! SPDX-License-Identifier: MIT
! Copyright (c) 2020-2022 Advanced Micro Devices, Inc. All rights reserved.
module types
  use iso_c_binding
  use gpufort_array

  ! interoperable types
  type,bind(c) :: node_t
    real(c_float) :: val
  end type

  type,bind(c) :: mesh_t
    real(c_float)        :: a
    type(gpufort_array1) :: x ! array of type `node_t`
    type(gpufort_array1) :: y ! array of type `real(c_float)`
  end type
end module

program main
  use types
  use hipfort
  use hipfort_check
  implicit none
  integer, parameter :: N = 40000
  !
  type(mesh_t)          :: mesh
  real(c_float),pointer :: mesh_t_y(:)
  !
  call init_mesh()
  call gpufort_array_hostptr(mesh%y,mesh_t_y)
  
  call launch_vecadd_kernel_auto(0,c_null_ptr,mesh)
  call hipCheck(gpufort_array_copy_to_host(mesh%y))
  
  write(*,*) 'Max error: ', maxval(abs(mesh_t_y-4.0))
  
  call destroy_mesh()
contains
  subroutine init_mesh()
    use gpufort_array
    use iso_c_binding
    implicit none
    integer i
    type(node_t)          :: node_t_dummy
    type(node_t),pointer  :: mesh_t_x(:)
    real(c_float),pointer :: mesh_t_y(:)

    ! Init scalar
    mesh%a = 2.0
  
    ! Init basic datatype array member
    call hipCheck(gpufort_array_init(mesh%y,&
      c_float,sizes=[N],lbounds=[1],&
      alloc_mode=gpufort_array_alloc_pinned_host_alloc_device)) 
    call gpufort_array_hostptr(mesh%y,mesh_t_y) ! Get Fortran pointer to host data (overloaded routine exists for basic datatypes.
    ! 
    mesh_t_y(:) = 2.0                            ! Also sets lower bounds.
    call hipCheck(gpufort_array_copy_to_device(mesh%y))
    
    ! Init struct member.  
    call hipCheck(gpufort_array_init(mesh%x,&
      int(c_sizeof(node_t_dummy),c_int),&
      sizes=[N],lbounds=[1],&
      alloc_mode=gpufort_array_alloc_pinned_host_alloc_device))
    !    
    ! Get Fortran pointer to host data. No overloaded routine exists (must be type-specific).
    ! In this case, you must/can set lower bounds manually if they are different from 1 and 
    ! the initial data is depending on the index.
    call c_f_pointer(mesh%x%data%data_host,mesh_t_x,shape=[N])
    !mesh_t_x(1:) => mesh_t_x ! Set lower bounds
    mesh_t_x(:)%val = 1
    call hipCheck(gpufort_array_copy_to_device(mesh%x))
  end subroutine
 
  ! (will be) autogenerated by GPUFORT
  subroutine destroy_mesh()
    use gpufort_array
    use iso_c_binding
    implicit none
    call hipCheck(gpufort_array_destroy(mesh%x))
    call hipCheck(gpufort_array_destroy(mesh%y))
  end subroutine
end program main