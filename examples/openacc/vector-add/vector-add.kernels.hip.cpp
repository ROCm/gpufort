// This file was generated by gpufort

#include "hip/hip_complex.h"
#include "hip/hip_runtime.h"
#include "hip/math_functions.h"
#include <algorithm>
#include <cstdio>
#include <iostream>

#define HIP_CHECK(condition)                                                                                                               \
  {                                                                                                                                        \
    hipError_t error = condition;                                                                                                          \
    if (error != hipSuccess) {                                                                                                             \
      std::cout << "HIP error: " << error << " line: " << __LINE__ << std::endl;                                                           \
      exit(error);                                                                                                                         \
    }                                                                                                                                      \
  }

// global thread indices for various dimensions
#define __gidx(idx) (threadIdx.idx + blockIdx.idx * blockDim.idx)
#define __gidx1 __gidx(x)
#define __gidx2 (__gidx(x) + gridDim.x * blockDim.x * __gidx(y))
#define __gidx3 (__gidx(x) + gridDim.x * blockDim.x * __gidx(y) + gridDim.x * blockDim.x * gridDim.y * blockDim.y * __gidx(z))
#define __total_threads(grid, block) ((grid).x * (grid).y * (grid).z * (block).x * (block).y * (block).z)

namespace {
template <typename I, typename E, typename S> __device__ __forceinline__ bool loop_cond(I idx, E end, S stride) {
  return (stride > 0) ? (idx <= end) : (-idx <= -end);
}

// make float
__device__ __forceinline__ float make_float(const short int &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const unsigned short int &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const unsigned int &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const int &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const long int &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const unsigned long int &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const long long int &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const unsigned long long int &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const signed char &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const unsigned char &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const float &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const double &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const long double &a) { return static_cast<float>(a); }
__device__ __forceinline__ float make_float(const hipFloatComplex &a) { return static_cast<float>(a.x); }
__device__ __forceinline__ float make_float(const hipDoubleComplex &a) { return static_cast<float>(a.x); }
// make double
__device__ __forceinline__ double make_double(const short int &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const unsigned short int &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const unsigned int &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const int &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const long int &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const unsigned long int &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const long long int &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const unsigned long long int &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const signed char &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const unsigned char &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const float &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const double &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const long double &a) { return static_cast<double>(a); }
__device__ __forceinline__ double make_double(const hipFloatComplex &a) { return static_cast<double>(a.x); }
__device__ __forceinline__ double make_double(const hipDoubleComplex &a) { return static_cast<double>(a.x); }
// conjugate complex type
__device__ __forceinline__ hipFloatComplex conj(const hipFloatComplex &c) { return hipConjf(c); }
__device__ __forceinline__ hipDoubleComplex conj(const hipDoubleComplex &z) { return hipConj(z); }

// TODO Add the following functions:
// - sign(x,y) = sign(y) * |x| - sign transfer function
// ...
} // namespace

// end of preamble
#define divideAndRoundUp(x, y) ((x) / (y) + ((x) % (y) != 0))

// BEGIN krnl_cecba2_14
/* Fortran original:
  ! parallel loop
  do i = 1, N
     x(i) = 1
     y(i) = 2
  end do

*/

__global__ void __launch_bounds__(128, 1)
    krnl_cecba2_14(int N, int x[], const int x_n1, const int x_lb1, int y[], const int y_n1, const int y_lb1) {
#undef _idx_x
#define _idx_x(a) ((a - (x_lb1)))
#undef _idx_y
#define _idx_y(a) ((a - (y_lb1)))

  int i = 1 + (1) * (threadIdx.x + blockIdx.x * blockDim.x);
  if (loop_cond(i, N, 1)) {
    x[_idx_x(i)] = 1;
    y[_idx_y(i)] = 2;
  }
}

extern "C" void launch_krnl_cecba2_14(dim3 *grid,
                                      dim3 *block,
                                      const int sharedMem,
                                      hipStream_t stream,
                                      int N,
                                      int x[],
                                      const int x_n1,
                                      const int x_lb1,
                                      int y[],
                                      const int y_n1,
                                      const int y_lb1) {

  // launch kernel
  hipLaunchKernelGGL((krnl_cecba2_14), *grid, *block, sharedMem, stream, N, x, x_n1, x_lb1, y, y_n1, y_lb1);
}
extern "C" void launch_krnl_cecba2_14_auto(const int sharedMem,
                                           hipStream_t stream,
                                           int N,
                                           int x[],
                                           const int x_n1,
                                           const int x_lb1,
                                           int y[],
                                           const int y_n1,
                                           const int y_lb1) {
  const int krnl_cecba2_14_blockX = 128;
  dim3 block(krnl_cecba2_14_blockX);
  const int krnl_cecba2_14_NX = (1 + ((N) - (1)));

  const int krnl_cecba2_14_gridX = divideAndRoundUp(krnl_cecba2_14_NX, krnl_cecba2_14_blockX);
  dim3 grid(krnl_cecba2_14_gridX);

  // launch kernel
  hipLaunchKernelGGL((krnl_cecba2_14), grid, block, sharedMem, stream, N, x, x_n1, x_lb1, y, y_n1, y_lb1);
}
// END krnl_cecba2_14

// BEGIN krnl_3207b9_20
/* Fortran original:
  ! parallel loop
  do i = 1, N
     y(i) = x(i) + y(i)
  end do

*/

__global__ void __launch_bounds__(128, 1)
    krnl_3207b9_20(int N, int y[], const int y_n1, const int y_lb1, int x[], const int x_n1, const int x_lb1) {
#undef _idx_y
#define _idx_y(a) ((a - (y_lb1)))
#undef _idx_x
#define _idx_x(a) ((a - (x_lb1)))

  int i = 1 + (1) * (threadIdx.x + blockIdx.x * blockDim.x);
  if (loop_cond(i, N, 1)) {
    y[_idx_y(i)] = (x[_idx_x(i)] + y[_idx_y(i)]);
  }
}

extern "C" void launch_krnl_3207b9_20(dim3 *grid,
                                      dim3 *block,
                                      const int sharedMem,
                                      hipStream_t stream,
                                      int N,
                                      int y[],
                                      const int y_n1,
                                      const int y_lb1,
                                      int x[],
                                      const int x_n1,
                                      const int x_lb1) {

  // launch kernel
  hipLaunchKernelGGL((krnl_3207b9_20), *grid, *block, sharedMem, stream, N, y, y_n1, y_lb1, x, x_n1, x_lb1);
}
extern "C" void launch_krnl_3207b9_20_auto(const int sharedMem,
                                           hipStream_t stream,
                                           int N,
                                           int y[],
                                           const int y_n1,
                                           const int y_lb1,
                                           int x[],
                                           const int x_n1,
                                           const int x_lb1) {
  const int krnl_3207b9_20_blockX = 128;
  dim3 block(krnl_3207b9_20_blockX);
  const int krnl_3207b9_20_NX = (1 + ((N) - (1)));

  const int krnl_3207b9_20_gridX = divideAndRoundUp(krnl_3207b9_20_NX, krnl_3207b9_20_blockX);
  dim3 grid(krnl_3207b9_20_gridX);

  // launch kernel
  hipLaunchKernelGGL((krnl_3207b9_20), grid, block, sharedMem, stream, N, y, y_n1, y_lb1, x, x_n1, x_lb1);
}
// END krnl_3207b9_20
