!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! ==============================================================================
! hipfort: FORTRAN Interfaces for GPU kernels
! ==============================================================================
! Copyright (c) 2020-2022 Advanced Micro Devices, Inc. All rights reserved.
! [MITx11 License]
! 
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
! 
! The above copyright notice and this permission notice shall be included in
! all copies or substantial portions of the Software.
! 
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
! THE SOFTWARE.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          
           
module hipfort_hipblas
  use hipfort_hipblas_enums
  use hipfort_hipblas_auxiliary
  implicit none

 
  
  interface hipblasCreate
#ifdef USE_CUDA_NAMES
    function hipblasCreate_(handle) bind(c, name="cublasCreate_v2")
#else
    function hipblasCreate_(handle) bind(c, name="hipblasCreate")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCreate_
      type(c_ptr) :: handle
    end function

  end interface
  
  interface hipblasDestroy
#ifdef USE_CUDA_NAMES
    function hipblasDestroy_(handle) bind(c, name="cublasDestroy_v2")
#else
    function hipblasDestroy_(handle) bind(c, name="hipblasDestroy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDestroy_
      type(c_ptr),value :: handle
    end function

  end interface
  
  interface hipblasSetStream
#ifdef USE_CUDA_NAMES
    function hipblasSetStream_(handle,streamId) bind(c, name="cublasSetStream_v2")
#else
    function hipblasSetStream_(handle,streamId) bind(c, name="hipblasSetStream")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSetStream_
      type(c_ptr),value :: handle
      type(c_ptr),value :: streamId
    end function

  end interface
  
  interface hipblasGetStream
#ifdef USE_CUDA_NAMES
    function hipblasGetStream_(handle,streamId) bind(c, name="cublasGetStream_v2")
#else
    function hipblasGetStream_(handle,streamId) bind(c, name="hipblasGetStream")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGetStream_
      type(c_ptr),value :: handle
      type(c_ptr) :: streamId
    end function

  end interface
  
  interface hipblasSetPointerMode
#ifdef USE_CUDA_NAMES
    function hipblasSetPointerMode_(handle,mode) bind(c, name="cublasSetPointerMode_v2")
#else
    function hipblasSetPointerMode_(handle,mode) bind(c, name="hipblasSetPointerMode")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSetPointerMode_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_POINTER_MODE_HOST)),value :: mode
    end function

  end interface
  
  interface hipblasGetPointerMode
#ifdef USE_CUDA_NAMES
    function hipblasGetPointerMode_(handle,mode) bind(c, name="cublasGetPointerMode_v2")
#else
    function hipblasGetPointerMode_(handle,mode) bind(c, name="hipblasGetPointerMode")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGetPointerMode_
      type(c_ptr),value :: handle
      type(c_ptr),value :: mode
    end function

  end interface
  
  interface hipblasSetAtomicsMode
#ifdef USE_CUDA_NAMES
    function hipblasSetAtomicsMode_(handle,atomics_mode) bind(c, name="cublasSetAtomicsMode")
#else
    function hipblasSetAtomicsMode_(handle,atomics_mode) bind(c, name="hipblasSetAtomicsMode")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSetAtomicsMode_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_ATOMICS_NOT_ALLOWED)),value :: atomics_mode
    end function

  end interface
  
  interface hipblasGetAtomicsMode
#ifdef USE_CUDA_NAMES
    function hipblasGetAtomicsMode_(handle,atomics_mode) bind(c, name="cublasGetAtomicsMode")
#else
    function hipblasGetAtomicsMode_(handle,atomics_mode) bind(c, name="hipblasGetAtomicsMode")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGetAtomicsMode_
      type(c_ptr),value :: handle
      type(c_ptr),value :: atomics_mode
    end function

  end interface
  
  interface hipblasIsamax
#ifdef USE_CUDA_NAMES
    function hipblasIsamax_(handle,n,x,incx,myResult) bind(c, name="cublasIsamax_v2")
#else
    function hipblasIsamax_(handle,n,x,incx,myResult) bind(c, name="hipblasIsamax")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamax_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIsamax_rank_0,&
      hipblasIsamax_rank_1
#endif
  end interface
  
  interface hipblasIdamax
#ifdef USE_CUDA_NAMES
    function hipblasIdamax_(handle,n,x,incx,myResult) bind(c, name="cublasIdamax_v2")
#else
    function hipblasIdamax_(handle,n,x,incx,myResult) bind(c, name="hipblasIdamax")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamax_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIdamax_rank_0,&
      hipblasIdamax_rank_1
#endif
  end interface
  
  interface hipblasIcamax
#ifdef USE_CUDA_NAMES
    function hipblasIcamax_(handle,n,x,incx,myResult) bind(c, name="cublasIcamax_v2")
#else
    function hipblasIcamax_(handle,n,x,incx,myResult) bind(c, name="hipblasIcamax")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamax_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIcamax_rank_0,&
      hipblasIcamax_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     amax finds the first index of the element of maximum magnitude of a vector x.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the amax index.
  !>               return is 0.0 if n, incx<=0.
  interface hipblasIzamax
#ifdef USE_CUDA_NAMES
    function hipblasIzamax_(handle,n,x,incx,myResult) bind(c, name="cublasIzamax_v2")
#else
    function hipblasIzamax_(handle,n,x,incx,myResult) bind(c, name="hipblasIzamax")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamax_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIzamax_rank_0,&
      hipblasIzamax_rank_1
#endif
  end interface
  
  interface hipblasIsamaxBatched
#ifdef USE_CUDA_NAMES
    function hipblasIsamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIsamaxBatched")
#else
    function hipblasIsamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIsamaxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIsamaxBatched_full_rank,&
      hipblasIsamaxBatched_rank_0,&
      hipblasIsamaxBatched_rank_1
#endif
  end interface
  
  interface hipblasIdamaxBatched
#ifdef USE_CUDA_NAMES
    function hipblasIdamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIdamaxBatched")
#else
    function hipblasIdamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIdamaxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIdamaxBatched_full_rank,&
      hipblasIdamaxBatched_rank_0,&
      hipblasIdamaxBatched_rank_1
#endif
  end interface
  
  interface hipblasIcamaxBatched
#ifdef USE_CUDA_NAMES
    function hipblasIcamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIcamaxBatched")
#else
    function hipblasIcamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIcamaxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIcamaxBatched_full_rank,&
      hipblasIcamaxBatched_rank_0,&
      hipblasIcamaxBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      amaxBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch, must be > 0.
  !>     @param[out]
  !>     result
  !>               device or host array of pointers of batchCount size for results.
  !>               return is 0 if n, incx<=0.
  interface hipblasIzamaxBatched
#ifdef USE_CUDA_NAMES
    function hipblasIzamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIzamaxBatched")
#else
    function hipblasIzamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIzamaxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIzamaxBatched_full_rank,&
      hipblasIzamaxBatched_rank_0,&
      hipblasIzamaxBatched_rank_1
#endif
  end interface
  
  interface hipblasIsamaxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIsamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIsamaxStridedBatched")
#else
    function hipblasIsamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIsamaxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIsamaxStridedBatched_rank_0,&
      hipblasIsamaxStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasIdamaxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIdamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIdamaxStridedBatched")
#else
    function hipblasIdamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIdamaxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIdamaxStridedBatched_rank_0,&
      hipblasIdamaxStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasIcamaxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIcamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIcamaxStridedBatched")
#else
    function hipblasIcamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIcamaxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIcamaxStridedBatched_rank_0,&
      hipblasIcamaxStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      amaxStridedBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               specifies the pointer increment between one x_i and the next x_(i + 1).
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device or host pointer for storing contiguous batchCount results.
  !>               return is 0 if n <= 0, incx<=0.
  !>
  interface hipblasIzamaxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIzamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIzamaxStridedBatched")
#else
    function hipblasIzamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIzamaxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIzamaxStridedBatched_rank_0,&
      hipblasIzamaxStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasIsamin
#ifdef USE_CUDA_NAMES
    function hipblasIsamin_(handle,n,x,incx,myResult) bind(c, name="cublasIsamin_v2")
#else
    function hipblasIsamin_(handle,n,x,incx,myResult) bind(c, name="hipblasIsamin")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamin_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIsamin_rank_0,&
      hipblasIsamin_rank_1
#endif
  end interface
  
  interface hipblasIdamin
#ifdef USE_CUDA_NAMES
    function hipblasIdamin_(handle,n,x,incx,myResult) bind(c, name="cublasIdamin_v2")
#else
    function hipblasIdamin_(handle,n,x,incx,myResult) bind(c, name="hipblasIdamin")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamin_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIdamin_rank_0,&
      hipblasIdamin_rank_1
#endif
  end interface
  
  interface hipblasIcamin
#ifdef USE_CUDA_NAMES
    function hipblasIcamin_(handle,n,x,incx,myResult) bind(c, name="cublasIcamin_v2")
#else
    function hipblasIcamin_(handle,n,x,incx,myResult) bind(c, name="hipblasIcamin")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamin_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIcamin_rank_0,&
      hipblasIcamin_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     amin finds the first index of the element of minimum magnitude of a vector x.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the amin index.
  !>               return is 0.0 if n, incx<=0.
  interface hipblasIzamin
#ifdef USE_CUDA_NAMES
    function hipblasIzamin_(handle,n,x,incx,myResult) bind(c, name="cublasIzamin_v2")
#else
    function hipblasIzamin_(handle,n,x,incx,myResult) bind(c, name="hipblasIzamin")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamin_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIzamin_rank_0,&
      hipblasIzamin_rank_1
#endif
  end interface
  
  interface hipblasIsaminBatched
#ifdef USE_CUDA_NAMES
    function hipblasIsaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIsaminBatched")
#else
    function hipblasIsaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIsaminBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIsaminBatched_full_rank,&
      hipblasIsaminBatched_rank_0,&
      hipblasIsaminBatched_rank_1
#endif
  end interface
  
  interface hipblasIdaminBatched
#ifdef USE_CUDA_NAMES
    function hipblasIdaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIdaminBatched")
#else
    function hipblasIdaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIdaminBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIdaminBatched_full_rank,&
      hipblasIdaminBatched_rank_0,&
      hipblasIdaminBatched_rank_1
#endif
  end interface
  
  interface hipblasIcaminBatched
#ifdef USE_CUDA_NAMES
    function hipblasIcaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIcaminBatched")
#else
    function hipblasIcaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIcaminBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIcaminBatched_full_rank,&
      hipblasIcaminBatched_rank_0,&
      hipblasIcaminBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     aminBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch, must be > 0.
  !>     @param[out]
  !>     result
  !>               device or host pointers to array of batchCount size for results.
  !>               return is 0 if n, incx<=0.
  interface hipblasIzaminBatched
#ifdef USE_CUDA_NAMES
    function hipblasIzaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIzaminBatched")
#else
    function hipblasIzaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIzaminBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIzaminBatched_full_rank,&
      hipblasIzaminBatched_rank_0,&
      hipblasIzaminBatched_rank_1
#endif
  end interface
  
  interface hipblasIsaminStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIsaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIsaminStridedBatched")
#else
    function hipblasIsaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIsaminStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIsaminStridedBatched_rank_0,&
      hipblasIsaminStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasIdaminStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIdaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIdaminStridedBatched")
#else
    function hipblasIdaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIdaminStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIdaminStridedBatched_rank_0,&
      hipblasIdaminStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasIcaminStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIcaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIcaminStridedBatched")
#else
    function hipblasIcaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIcaminStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIcaminStridedBatched_rank_0,&
      hipblasIcaminStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      aminStridedBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               specifies the pointer increment between one x_i and the next x_(i + 1)
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device or host pointer to array for storing contiguous batchCount results.
  !>               return is 0 if n <= 0, incx<=0.
  !>
  interface hipblasIzaminStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIzaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIzaminStridedBatched")
#else
    function hipblasIzaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIzaminStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasIzaminStridedBatched_rank_0,&
      hipblasIzaminStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSasum
#ifdef USE_CUDA_NAMES
    function hipblasSasum_(handle,n,x,incx,myResult) bind(c, name="cublasSasum_v2")
#else
    function hipblasSasum_(handle,n,x,incx,myResult) bind(c, name="hipblasSasum")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSasum_rank_0,&
      hipblasSasum_rank_1
#endif
  end interface
  
  interface hipblasDasum
#ifdef USE_CUDA_NAMES
    function hipblasDasum_(handle,n,x,incx,myResult) bind(c, name="cublasDasum_v2")
#else
    function hipblasDasum_(handle,n,x,incx,myResult) bind(c, name="hipblasDasum")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDasum_rank_0,&
      hipblasDasum_rank_1
#endif
  end interface
  
  interface hipblasScasum
#ifdef USE_CUDA_NAMES
    function hipblasScasum_(handle,n,x,incx,myResult) bind(c, name="cublasScasum_v2")
#else
    function hipblasScasum_(handle,n,x,incx,myResult) bind(c, name="hipblasScasum")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasScasum_rank_0,&
      hipblasScasum_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asum computes the sum of the magnitudes of elements of a real vector x,
  !>          or the sum of magnitudes of the real and imaginary parts of elements if x is a complex vector.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x. incx must be > 0.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the asum product.
  !>               return is 0.0 if n <= 0.
  !>
  interface hipblasDzasum
#ifdef USE_CUDA_NAMES
    function hipblasDzasum_(handle,n,x,incx,myResult) bind(c, name="cublasDzasum_v2")
#else
    function hipblasDzasum_(handle,n,x,incx,myResult) bind(c, name="hipblasDzasum")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDzasum_rank_0,&
      hipblasDzasum_rank_1
#endif
  end interface
  
  interface hipblasSasumBatched
#ifdef USE_CUDA_NAMES
    function hipblasSasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasSasumBatched")
#else
    function hipblasSasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasSasumBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSasumBatched_full_rank,&
      hipblasSasumBatched_rank_0,&
      hipblasSasumBatched_rank_1
#endif
  end interface
  
  interface hipblasDasumBatched
#ifdef USE_CUDA_NAMES
    function hipblasDasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasDasumBatched")
#else
    function hipblasDasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasDasumBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDasumBatched_full_rank,&
      hipblasDasumBatched_rank_0,&
      hipblasDasumBatched_rank_1
#endif
  end interface
  
  interface hipblasScasumBatched
#ifdef USE_CUDA_NAMES
    function hipblasScasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasScasumBatched")
#else
    function hipblasScasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasScasumBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasScasumBatched_full_rank,&
      hipblasScasumBatched_rank_0,&
      hipblasScasumBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asumBatched computes the sum of the magnitudes of the elements in a batch of real vectors x_i,
  !>         or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
  !>         vector, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch.
  !>     @param[out]
  !>     result
  !>               device array or host array of batchCount size for results.
  !>               return is 0.0 if n, incx<=0.
  interface hipblasDzasumBatched
#ifdef USE_CUDA_NAMES
    function hipblasDzasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasDzasumBatched")
#else
    function hipblasDzasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasDzasumBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDzasumBatched_full_rank,&
      hipblasDzasumBatched_rank_0,&
      hipblasDzasumBatched_rank_1
#endif
  end interface
  
  interface hipblasSasumStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasSasumStridedBatched")
#else
    function hipblasSasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasSasumStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSasumStridedBatched_rank_0,&
      hipblasSasumStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDasumStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasDasumStridedBatched")
#else
    function hipblasDasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasDasumStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDasumStridedBatched_rank_0,&
      hipblasDasumStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasScasumStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasScasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasScasumStridedBatched")
#else
    function hipblasScasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasScasumStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasScasumStridedBatched_rank_0,&
      hipblasScasumStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asumStridedBatched computes the sum of the magnitudes of elements of a real vectors x_i,
  !>         or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
  !>         vector, for i = 1, ..., batchCount
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n * incx.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device pointer or host pointer to array for storing contiguous batchCount results.
  !>               return is 0.0 if n, incx<=0.
  interface hipblasDzasumStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDzasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasDzasumStridedBatched")
#else
    function hipblasDzasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasDzasumStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDzasumStridedBatched_rank_0,&
      hipblasDzasumStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSaxpy
#ifdef USE_CUDA_NAMES
    function hipblasSaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="cublasSaxpy_v2")
#else
    function hipblasSaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="hipblasSaxpy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSaxpy_rank_0,&
      hipblasSaxpy_rank_1
#endif
  end interface
  
  interface hipblasDaxpy
#ifdef USE_CUDA_NAMES
    function hipblasDaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="cublasDaxpy_v2")
#else
    function hipblasDaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="hipblasDaxpy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDaxpy_rank_0,&
      hipblasDaxpy_rank_1
#endif
  end interface
  
  interface hipblasCaxpy
#ifdef USE_CUDA_NAMES
    function hipblasCaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="cublasCaxpy_v2")
#else
    function hipblasCaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="hipblasCaxpy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCaxpy_rank_0,&
      hipblasCaxpy_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     axpy   computes ant alpha multiplied by vector x, plus vector y
  !> 
  !>         y := alpha * x + y
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to specify the scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[out]
  !>     y         device pointer storing vector y.
  !>     @param[inout]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>
  interface hipblasZaxpy
#ifdef USE_CUDA_NAMES
    function hipblasZaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="cublasZaxpy_v2")
#else
    function hipblasZaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="hipblasZaxpy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZaxpy_rank_0,&
      hipblasZaxpy_rank_1
#endif
  end interface
  
  interface hipblasSaxpyBatched
#ifdef USE_CUDA_NAMES
    function hipblasSaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="cublasSaxpyBatched")
#else
    function hipblasSaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="hipblasSaxpyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSaxpyBatched_full_rank,&
      hipblasSaxpyBatched_rank_0,&
      hipblasSaxpyBatched_rank_1
#endif
  end interface
  
  interface hipblasDaxpyBatched
#ifdef USE_CUDA_NAMES
    function hipblasDaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="cublasDaxpyBatched")
#else
    function hipblasDaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="hipblasDaxpyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDaxpyBatched_full_rank,&
      hipblasDaxpyBatched_rank_0,&
      hipblasDaxpyBatched_rank_1
#endif
  end interface
  
  interface hipblasCaxpyBatched
#ifdef USE_CUDA_NAMES
    function hipblasCaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="cublasCaxpyBatched")
#else
    function hipblasCaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="hipblasCaxpyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCaxpyBatched_full_rank,&
      hipblasCaxpyBatched_rank_0,&
      hipblasCaxpyBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     axpyBatched   compute y := alpha * x + y over a set of batched vectors.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     alpha     specifies the scalar alpha.
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU.
  !>     @param[inout]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  interface hipblasZaxpyBatched
#ifdef USE_CUDA_NAMES
    function hipblasZaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="cublasZaxpyBatched")
#else
    function hipblasZaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="hipblasZaxpyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZaxpyBatched_full_rank,&
      hipblasZaxpyBatched_rank_0,&
      hipblasZaxpyBatched_rank_1
#endif
  end interface
  
  interface hipblasSaxpyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasSaxpyStridedBatched")
#else
    function hipblasSaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasSaxpyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSaxpyStridedBatched_rank_0,&
      hipblasSaxpyStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDaxpyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasDaxpyStridedBatched")
#else
    function hipblasDaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasDaxpyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDaxpyStridedBatched_rank_0,&
      hipblasDaxpyStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCaxpyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasCaxpyStridedBatched")
#else
    function hipblasCaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasCaxpyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCaxpyStridedBatched_rank_0,&
      hipblasCaxpyStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     axpyStridedBatched   compute y := alpha * x + y over a set of strided batched vectors.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     alpha     specifies the scalar alpha.
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               specifies the increment between vectors of x.
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU.
  !>     @param[inout]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey   [hipblasStride]
  !>               specifies the increment between vectors of y.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>
  interface hipblasZaxpyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasZaxpyStridedBatched")
#else
    function hipblasZaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasZaxpyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZaxpyStridedBatched_rank_0,&
      hipblasZaxpyStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasScopy
#ifdef USE_CUDA_NAMES
    function hipblasScopy_(handle,n,x,incx,y,incy) bind(c, name="cublasScopy_v2")
#else
    function hipblasScopy_(handle,n,x,incx,y,incy) bind(c, name="hipblasScopy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasScopy_rank_0,&
      hipblasScopy_rank_1
#endif
  end interface
  
  interface hipblasDcopy
#ifdef USE_CUDA_NAMES
    function hipblasDcopy_(handle,n,x,incx,y,incy) bind(c, name="cublasDcopy_v2")
#else
    function hipblasDcopy_(handle,n,x,incx,y,incy) bind(c, name="hipblasDcopy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDcopy_rank_0,&
      hipblasDcopy_rank_1
#endif
  end interface
  
  interface hipblasCcopy
#ifdef USE_CUDA_NAMES
    function hipblasCcopy_(handle,n,x,incx,y,incy) bind(c, name="cublasCcopy_v2")
#else
    function hipblasCcopy_(handle,n,x,incx,y,incy) bind(c, name="hipblasCcopy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCcopy_rank_0,&
      hipblasCcopy_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copy  copies each element x[i] into y[i], for  i = 1 , ... , n
  !> 
  !>         y := x,
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x to be copied to y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[out]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>
  interface hipblasZcopy
#ifdef USE_CUDA_NAMES
    function hipblasZcopy_(handle,n,x,incx,y,incy) bind(c, name="cublasZcopy_v2")
#else
    function hipblasZcopy_(handle,n,x,incx,y,incy) bind(c, name="hipblasZcopy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZcopy_rank_0,&
      hipblasZcopy_rank_1
#endif
  end interface
  
  interface hipblasScopyBatched
#ifdef USE_CUDA_NAMES
    function hipblasScopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasScopyBatched")
#else
    function hipblasScopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasScopyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasScopyBatched_full_rank,&
      hipblasScopyBatched_rank_0,&
      hipblasScopyBatched_rank_1
#endif
  end interface
  
  interface hipblasDcopyBatched
#ifdef USE_CUDA_NAMES
    function hipblasDcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasDcopyBatched")
#else
    function hipblasDcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasDcopyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDcopyBatched_full_rank,&
      hipblasDcopyBatched_rank_0,&
      hipblasDcopyBatched_rank_1
#endif
  end interface
  
  interface hipblasCcopyBatched
#ifdef USE_CUDA_NAMES
    function hipblasCcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasCcopyBatched")
#else
    function hipblasCcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasCcopyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCcopyBatched_full_rank,&
      hipblasCcopyBatched_rank_0,&
      hipblasCcopyBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copyBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount
  !> 
  !>         y_i := x_i,
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i to be copied to y_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i.
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZcopyBatched
#ifdef USE_CUDA_NAMES
    function hipblasZcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasZcopyBatched")
#else
    function hipblasZcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasZcopyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZcopyBatched_full_rank,&
      hipblasZcopyBatched_rank_0,&
      hipblasZcopyBatched_rank_1
#endif
  end interface
  
  interface hipblasScopyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasScopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasScopyStridedBatched")
#else
    function hipblasScopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasScopyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasScopyStridedBatched_rank_0,&
      hipblasScopyStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDcopyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasDcopyStridedBatched")
#else
    function hipblasDcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasDcopyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDcopyStridedBatched_rank_0,&
      hipblasDcopyStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCcopyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasCcopyStridedBatched")
#else
    function hipblasCcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasCcopyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCcopyStridedBatched_rank_0,&
      hipblasCcopyStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copyStridedBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount
  !> 
  !>         y_i := x_i,
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i to be copied to y_i.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increments for the elements of vectors x_i.
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stride_x is of appropriate size, for a typical
  !>                 case this means stride_x >= n * incx.
  !>     @param[out]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of vectors y_i.
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stride_y, however the user should
  !>                 take care to ensure that stride_y is of appropriate size, for a typical
  !>                 case this means stride_y >= n * incy. stridey should be non zero.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZcopyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasZcopyStridedBatched")
#else
    function hipblasZcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasZcopyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZcopyStridedBatched_rank_0,&
      hipblasZcopyStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSdot
#ifdef USE_CUDA_NAMES
    function hipblasSdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasSdot_v2")
#else
    function hipblasSdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasSdot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSdot_rank_0,&
      hipblasSdot_rank_1
#endif
  end interface
  
  interface hipblasDdot
#ifdef USE_CUDA_NAMES
    function hipblasDdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasDdot_v2")
#else
    function hipblasDdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasDdot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDdot_rank_0,&
      hipblasDdot_rank_1
#endif
  end interface
  
  interface hipblasCdotc
#ifdef USE_CUDA_NAMES
    function hipblasCdotc_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasCdotc_v2")
#else
    function hipblasCdotc_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasCdotc")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotc_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCdotc_rank_0,&
      hipblasCdotc_rank_1
#endif
  end interface
  
  interface hipblasCdotu
#ifdef USE_CUDA_NAMES
    function hipblasCdotu_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasCdotu_v2")
#else
    function hipblasCdotu_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasCdotu")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCdotu_rank_0,&
      hipblasCdotu_rank_1
#endif
  end interface
  
  interface hipblasZdotc
#ifdef USE_CUDA_NAMES
    function hipblasZdotc_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasZdotc_v2")
#else
    function hipblasZdotc_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasZdotc")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotc_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdotc_rank_0,&
      hipblasZdotc_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     dot(u)  performs the dot product of vectors x and y
  !> 
  !>         result = x * y;
  !> 
  !>     dotc  performs the dot product of the conjugate of complex vector x and complex vector y
  !> 
  !>         result = conjugate (x) * y;
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the dot product.
  !>               return is 0.0 if n <= 0.
  !>
  interface hipblasZdotu
#ifdef USE_CUDA_NAMES
    function hipblasZdotu_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasZdotu_v2")
#else
    function hipblasZdotu_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasZdotu")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdotu_rank_0,&
      hipblasZdotu_rank_1
#endif
  end interface
  
  interface hipblasSdotBatched
#ifdef USE_CUDA_NAMES
    function hipblasSdotBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasSdotBatched")
#else
    function hipblasSdotBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasSdotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSdotBatched_full_rank,&
      hipblasSdotBatched_rank_0,&
      hipblasSdotBatched_rank_1
#endif
  end interface
  
  interface hipblasDdotBatched
#ifdef USE_CUDA_NAMES
    function hipblasDdotBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasDdotBatched")
#else
    function hipblasDdotBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasDdotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDdotBatched_full_rank,&
      hipblasDdotBatched_rank_0,&
      hipblasDdotBatched_rank_1
#endif
  end interface
  
  interface hipblasCdotcBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdotcBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasCdotcBatched")
#else
    function hipblasCdotcBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasCdotcBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCdotcBatched_full_rank,&
      hipblasCdotcBatched_rank_0,&
      hipblasCdotcBatched_rank_1
#endif
  end interface
  
  interface hipblasCdotuBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdotuBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasCdotuBatched")
#else
    function hipblasCdotuBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasCdotuBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCdotuBatched_full_rank,&
      hipblasCdotuBatched_rank_0,&
      hipblasCdotuBatched_rank_1
#endif
  end interface
  
  interface hipblasZdotcBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdotcBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasZdotcBatched")
#else
    function hipblasZdotcBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasZdotcBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdotcBatched_full_rank,&
      hipblasZdotcBatched_rank_0,&
      hipblasZdotcBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     dotBatched(u) performs a batch of dot products of vectors x and y
  !> 
  !>         result_i = x_i * y_i;
  !> 
  !>     dotcBatched  performs a batch of dot products of the conjugate of complex vector x and complex vector y
  !> 
  !>         result_i = conjugate (x_i) * y_i;
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors, for i = 1, ..., batchCount
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>     @param[inout]
  !>     result
  !>               device array or host array of batchCount size to store the dot products of each batch.
  !>               return 0.0 for each element if n <= 0.
  !>
  interface hipblasZdotuBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdotuBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasZdotuBatched")
#else
    function hipblasZdotuBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasZdotuBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdotuBatched_full_rank,&
      hipblasZdotuBatched_rank_0,&
      hipblasZdotuBatched_rank_1
#endif
  end interface
  
  interface hipblasSdotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSdotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasSdotStridedBatched")
#else
    function hipblasSdotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasSdotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSdotStridedBatched_rank_0,&
      hipblasSdotStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDdotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDdotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasDdotStridedBatched")
#else
    function hipblasDdotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasDdotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDdotStridedBatched_rank_0,&
      hipblasDdotStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCdotcStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdotcStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasCdotcStridedBatched")
#else
    function hipblasCdotcStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasCdotcStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCdotcStridedBatched_rank_0,&
      hipblasCdotcStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCdotuStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdotuStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasCdotuStridedBatched")
#else
    function hipblasCdotuStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasCdotuStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCdotuStridedBatched_rank_0,&
      hipblasCdotuStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasZdotcStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdotcStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasZdotcStridedBatched")
#else
    function hipblasZdotcStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasZdotcStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdotcStridedBatched_rank_0,&
      hipblasZdotcStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     dotStridedBatched(u)  performs a batch of dot products of vectors x and y
  !> 
  !>         result_i = x_i * y_i;
  !> 
  !>     dotcStridedBatched  performs a batch of dot products of the conjugate of complex vector x and complex vector y
  !> 
  !>         result_i = conjugate (x_i) * y_i;
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors, for i = 1, ..., batchCount
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>     @param[inout]
  !>     result
  !>               device array or host array of batchCount size to store the dot products of each batch.
  !>               return 0.0 for each element if n <= 0.
  !>
  interface hipblasZdotuStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdotuStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasZdotuStridedBatched")
#else
    function hipblasZdotuStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasZdotuStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdotuStridedBatched_rank_0,&
      hipblasZdotuStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSnrm2
#ifdef USE_CUDA_NAMES
    function hipblasSnrm2_(handle,n,x,incx,myResult) bind(c, name="cublasSnrm2_v2")
#else
    function hipblasSnrm2_(handle,n,x,incx,myResult) bind(c, name="hipblasSnrm2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSnrm2_rank_0,&
      hipblasSnrm2_rank_1
#endif
  end interface
  
  interface hipblasDnrm2
#ifdef USE_CUDA_NAMES
    function hipblasDnrm2_(handle,n,x,incx,myResult) bind(c, name="cublasDnrm2_v2")
#else
    function hipblasDnrm2_(handle,n,x,incx,myResult) bind(c, name="hipblasDnrm2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDnrm2_rank_0,&
      hipblasDnrm2_rank_1
#endif
  end interface
  
  interface hipblasScnrm2
#ifdef USE_CUDA_NAMES
    function hipblasScnrm2_(handle,n,x,incx,myResult) bind(c, name="cublasScnrm2_v2")
#else
    function hipblasScnrm2_(handle,n,x,incx,myResult) bind(c, name="hipblasScnrm2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasScnrm2_rank_0,&
      hipblasScnrm2_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2 computes the euclidean norm of a real or complex vector
  !> 
  !>               result := sqrt( x'*x ) for real vectors
  !>               result := sqrt( x**H*x ) for complex vectors
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the nrm2 product.
  !>               return is 0.0 if n, incx<=0.
  interface hipblasDznrm2
#ifdef USE_CUDA_NAMES
    function hipblasDznrm2_(handle,n,x,incx,myResult) bind(c, name="cublasDznrm2_v2")
#else
    function hipblasDznrm2_(handle,n,x,incx,myResult) bind(c, name="hipblasDznrm2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDznrm2_rank_0,&
      hipblasDznrm2_rank_1
#endif
  end interface
  
  interface hipblasSnrm2Batched
#ifdef USE_CUDA_NAMES
    function hipblasSnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasSnrm2Batched")
#else
    function hipblasSnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasSnrm2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2Batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSnrm2Batched_full_rank,&
      hipblasSnrm2Batched_rank_0,&
      hipblasSnrm2Batched_rank_1
#endif
  end interface
  
  interface hipblasDnrm2Batched
#ifdef USE_CUDA_NAMES
    function hipblasDnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasDnrm2Batched")
#else
    function hipblasDnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasDnrm2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2Batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDnrm2Batched_full_rank,&
      hipblasDnrm2Batched_rank_0,&
      hipblasDnrm2Batched_rank_1
#endif
  end interface
  
  interface hipblasScnrm2Batched
#ifdef USE_CUDA_NAMES
    function hipblasScnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasScnrm2Batched")
#else
    function hipblasScnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasScnrm2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasScnrm2Batched_full_rank,&
      hipblasScnrm2Batched_rank_0,&
      hipblasScnrm2Batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2Batched computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount
  !>               result := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batchCount
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device pointer or host pointer to array of batchCount size for nrm2 results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !>
  interface hipblasDznrm2Batched
#ifdef USE_CUDA_NAMES
    function hipblasDznrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasDznrm2Batched")
#else
    function hipblasDznrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasDznrm2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDznrm2Batched_full_rank,&
      hipblasDznrm2Batched_rank_0,&
      hipblasDznrm2Batched_rank_1
#endif
  end interface
  
  interface hipblasSnrm2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasSnrm2StridedBatched")
#else
    function hipblasSnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasSnrm2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2StridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSnrm2StridedBatched_rank_0,&
      hipblasSnrm2StridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDnrm2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasDnrm2StridedBatched")
#else
    function hipblasDnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasDnrm2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2StridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDnrm2StridedBatched_rank_0,&
      hipblasDnrm2StridedBatched_rank_1
#endif
  end interface
  
  interface hipblasScnrm2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasScnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasScnrm2StridedBatched")
#else
    function hipblasScnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasScnrm2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2StridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasScnrm2StridedBatched_rank_0,&
      hipblasScnrm2StridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2StridedBatched computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount
  !>               := sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batchCount
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n * incx.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device pointer or host pointer to array for storing contiguous batch_count results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !>
  interface hipblasDznrm2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDznrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasDznrm2StridedBatched")
#else
    function hipblasDznrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasDznrm2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2StridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDznrm2StridedBatched_rank_0,&
      hipblasDznrm2StridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSrot
#ifdef USE_CUDA_NAMES
    function hipblasSrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasSrot_v2")
#else
    function hipblasSrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasSrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSrot_rank_0,&
      hipblasSrot_rank_1
#endif
  end interface
  
  interface hipblasDrot
#ifdef USE_CUDA_NAMES
    function hipblasDrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasDrot_v2")
#else
    function hipblasDrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasDrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDrot_rank_0,&
      hipblasDrot_rank_1
#endif
  end interface
  
  interface hipblasCrot
#ifdef USE_CUDA_NAMES
    function hipblasCrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasCrot_v2")
#else
    function hipblasCrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasCrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCrot_rank_0,&
      hipblasCrot_rank_1
#endif
  end interface
  
  interface hipblasCsrot
#ifdef USE_CUDA_NAMES
    function hipblasCsrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasCsrot_v2")
#else
    function hipblasCsrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasCsrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsrot_rank_0,&
      hipblasCsrot_rank_1
#endif
  end interface
  
  interface hipblasZrot
#ifdef USE_CUDA_NAMES
    function hipblasZrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasZrot_v2")
#else
    function hipblasZrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasZrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZrot_rank_0,&
      hipblasZrot_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rot applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer storing vector x.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of x.
  !>     @param[inout]
  !>     y       device pointer storing vector y.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of y.
  !>     @param[in]
  !>     c       device pointer or host pointer storing scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer storing scalar sine component of the rotation matrix.
  !>
  interface hipblasZdrot
#ifdef USE_CUDA_NAMES
    function hipblasZdrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasZdrot_v2")
#else
    function hipblasZdrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasZdrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdrot_rank_0,&
      hipblasZdrot_rank_1
#endif
  end interface
  
  interface hipblasSrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasSrotBatched")
#else
    function hipblasSrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasSrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSrotBatched_full_rank,&
      hipblasSrotBatched_rank_0,&
      hipblasSrotBatched_rank_1
#endif
  end interface
  
  interface hipblasDrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasDrotBatched")
#else
    function hipblasDrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasDrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDrotBatched_full_rank,&
      hipblasDrotBatched_rank_0,&
      hipblasDrotBatched_rank_1
#endif
  end interface
  
  interface hipblasCrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasCrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasCrotBatched")
#else
    function hipblasCrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasCrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCrotBatched_full_rank,&
      hipblasCrotBatched_rank_0,&
      hipblasCrotBatched_rank_1
#endif
  end interface
  
  interface hipblasCsrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasCsrotBatched")
#else
    function hipblasCsrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasCsrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsrotBatched_full_rank,&
      hipblasCsrotBatched_rank_0,&
      hipblasCsrotBatched_rank_1
#endif
  end interface
  
  interface hipblasZrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasZrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasZrotBatched")
#else
    function hipblasZrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasZrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZrotBatched_full_rank,&
      hipblasZrotBatched_rank_0,&
      hipblasZrotBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device array of deivce pointers storing each vector x_i.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[inout]
  !>     y       device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     batchCount [int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !>
  interface hipblasZdrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasZdrotBatched")
#else
    function hipblasZdrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasZdrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdrotBatched_full_rank,&
      hipblasZdrotBatched_rank_0,&
      hipblasZdrotBatched_rank_1
#endif
  end interface
  
  interface hipblasSrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasSrotStridedBatched")
#else
    function hipblasSrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasSrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSrotStridedBatched_rank_0,&
      hipblasSrotStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasDrotStridedBatched")
#else
    function hipblasDrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasDrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDrotStridedBatched_rank_0,&
      hipblasDrotStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasCrotStridedBatched")
#else
    function hipblasCrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasCrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCrotStridedBatched_rank_0,&
      hipblasCrotStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCsrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasCsrotStridedBatched")
#else
    function hipblasCsrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasCsrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsrotStridedBatched_rank_0,&
      hipblasCsrotStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasZrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasZrotStridedBatched")
#else
    function hipblasZrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasZrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZrotStridedBatched_rank_0,&
      hipblasZrotStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotStridedBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[in]
  !>     stride_x [hipblasStride]
  !>              specifies the increment from the beginning of x_i to the beginning of x_(i+1)
  !>     @param[inout]
  !>     y       device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>              specifies the increment from the beginning of y_i to the beginning of y_(i+1)
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     batchCount [int]
  !>             the number of x and y arrays, i.e. the number of batches.
  !>
  interface hipblasZdrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasZdrotStridedBatched")
#else
    function hipblasZdrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasZdrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdrotStridedBatched_rank_0,&
      hipblasZdrotStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSrotg
#ifdef USE_CUDA_NAMES
    function hipblasSrotg_(handle,a,b,c,s) bind(c, name="cublasSrotg_v2")
#else
    function hipblasSrotg_(handle,a,b,c,s) bind(c, name="hipblasSrotg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

  end interface
  
  interface hipblasDrotg
#ifdef USE_CUDA_NAMES
    function hipblasDrotg_(handle,a,b,c,s) bind(c, name="cublasDrotg_v2")
#else
    function hipblasDrotg_(handle,a,b,c,s) bind(c, name="hipblasDrotg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

  end interface
  
  interface hipblasCrotg
#ifdef USE_CUDA_NAMES
    function hipblasCrotg_(handle,a,b,c,s) bind(c, name="cublasCrotg_v2")
#else
    function hipblasCrotg_(handle,a,b,c,s) bind(c, name="hipblasCrotg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotg creates the Givens rotation matrix for the vector (a b).
  !>          Scalars c and s and arrays a and b may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     a       device pointer or host pointer to input vector element, overwritten with r.
  !>     @param[inout]
  !>     b       device pointer or host pointer to input vector element, overwritten with z.
  !>     @param[inout]
  !>     c       device pointer or host pointer to cosine element of Givens rotation.
  !>     @param[inout]
  !>     s       device pointer or host pointer sine element of Givens rotation.
  !>
  interface hipblasZrotg
#ifdef USE_CUDA_NAMES
    function hipblasZrotg_(handle,a,b,c,s) bind(c, name="cublasZrotg_v2")
#else
    function hipblasZrotg_(handle,a,b,c,s) bind(c, name="hipblasZrotg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

  end interface
  
  interface hipblasSrotgBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="cublasSrotgBatched")
#else
    function hipblasSrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="hipblasSrotgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batchCount
    end function

  end interface
  
  interface hipblasDrotgBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="cublasDrotgBatched")
#else
    function hipblasDrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="hipblasDrotgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batchCount
    end function

  end interface
  
  interface hipblasCrotgBatched
#ifdef USE_CUDA_NAMES
    function hipblasCrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="cublasCrotgBatched")
#else
    function hipblasCrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="hipblasCrotgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batchCount
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotgBatched creates the Givens rotation matrix for the batched vectors (a_i b_i), for i = 1, ..., batchCount.
  !>          a, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     a       device array of device pointers storing each single input vector element a_i, overwritten with r_i.
  !>     @param[inout]
  !>     b       device array of device pointers storing each single input vector element b_i, overwritten with z_i.
  !>     @param[inout]
  !>     c       device array of device pointers storing each cosine element of Givens rotation for the batch.
  !>     @param[inout]
  !>     s       device array of device pointers storing each sine element of Givens rotation for the batch.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of batches (length of arrays a, b, c, and s).
  !>
  interface hipblasZrotgBatched
#ifdef USE_CUDA_NAMES
    function hipblasZrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="cublasZrotgBatched")
#else
    function hipblasZrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="hipblasZrotgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batchCount
    end function

  end interface
  
  interface hipblasSrotgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotgStridedBatched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batchCount) bind(c, name="cublasSrotgStridedBatched")
#else
    function hipblasSrotgStridedBatched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batchCount) bind(c, name="hipblasSrotgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batchCount
    end function

  end interface
  
  interface hipblasDrotgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotgStridedBatched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batchCount) bind(c, name="cublasDrotgStridedBatched")
#else
    function hipblasDrotgStridedBatched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batchCount) bind(c, name="hipblasDrotgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batchCount
    end function

  end interface
  
  interface hipblasCrotgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCrotgStridedBatched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batchCount) bind(c, name="cublasCrotgStridedBatched")
#else
    function hipblasCrotgStridedBatched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batchCount) bind(c, name="hipblasCrotgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batchCount
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotgStridedBatched creates the Givens rotation matrix for the strided batched vectors (a_i b_i), for i = 1, ..., batchCount.
  !>          a, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     a       device strided_batched pointer or host strided_batched pointer to first single input vector element a_1, overwritten with r.
  !>     @param[in]
  !>     stride_a [hipblasStride]
  !>              distance between elements of a in batch (distance between a_i and a_(i + 1))
  !>     @param[inout]
  !>     b       device strided_batched pointer or host strided_batched pointer to first single input vector element b_1, overwritten with z.
  !>     @param[in]
  !>     stride_b [hipblasStride]
  !>              distance between elements of b in batch (distance between b_i and b_(i + 1))
  !>     @param[inout]
  !>     c       device strided_batched pointer or host strided_batched pointer to first cosine element of Givens rotations c_1.
  !>     @param[in]
  !>     stride_c [hipblasStride]
  !>              distance between elements of c in batch (distance between c_i and c_(i + 1))
  !>     @param[inout]
  !>     s       device strided_batched pointer or host strided_batched pointer to sine element of Givens rotations s_1.
  !>     @param[in]
  !>     stride_s [hipblasStride]
  !>              distance between elements of s in batch (distance between s_i and s_(i + 1))
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of batches (length of arrays a, b, c, and s).
  !>
  interface hipblasZrotgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZrotgStridedBatched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batchCount) bind(c, name="cublasZrotgStridedBatched")
#else
    function hipblasZrotgStridedBatched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batchCount) bind(c, name="hipblasZrotgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batchCount
    end function

  end interface
  
  interface hipblasSrotm
#ifdef USE_CUDA_NAMES
    function hipblasSrotm_(handle,n,x,incx,y,incy,param) bind(c, name="cublasSrotm_v2")
#else
    function hipblasSrotm_(handle,n,x,incx,y,incy,param) bind(c, name="hipblasSrotm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotm_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSrotm_rank_0,&
      hipblasSrotm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotm applies the modified Givens rotation matrix defined by param to vectors x and y.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer storing vector x.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of x.
  !>     @param[inout]
  !>     y       device pointer storing vector y.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of y.
  !>     @param[in]
  !>     param   device vector or host vector of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>
  interface hipblasDrotm
#ifdef USE_CUDA_NAMES
    function hipblasDrotm_(handle,n,x,incx,y,incy,param) bind(c, name="cublasDrotm_v2")
#else
    function hipblasDrotm_(handle,n,x,incx,y,incy,param) bind(c, name="hipblasDrotm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotm_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDrotm_rank_0,&
      hipblasDrotm_rank_1
#endif
  end interface
  
  interface hipblasSrotmBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotmBatched_(handle,n,x,incx,y,incy,param,batchCount) bind(c, name="cublasSrotmBatched")
#else
    function hipblasSrotmBatched_(handle,n,x,incx,y,incy,param,batchCount) bind(c, name="hipblasSrotmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSrotmBatched_full_rank,&
      hipblasSrotmBatched_rank_0,&
      hipblasSrotmBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmBatched applies the modified Givens rotation matrix defined by param_i to batched vectors x_i and y_i, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[inout]
  !>     y       device array of device pointers storing each vector y_1.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     param   device array of device vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may ONLY be stored on the device for the batched version of this function.
  !>     @param[in]
  !>     batchCount [int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !>
  interface hipblasDrotmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotmBatched_(handle,n,x,incx,y,incy,param,batchCount) bind(c, name="cublasDrotmBatched")
#else
    function hipblasDrotmBatched_(handle,n,x,incx,y,incy,param,batchCount) bind(c, name="hipblasDrotmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDrotmBatched_full_rank,&
      hipblasDrotmBatched_rank_0,&
      hipblasDrotmBatched_rank_1
#endif
  end interface
  
  interface hipblasSrotmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotmStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount) bind(c, name="cublasSrotmStridedBatched")
#else
    function hipblasSrotmStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount) bind(c, name="hipblasSrotmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: param
      integer(c_int64_t),value :: strideParam
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSrotmStridedBatched_rank_0,&
      hipblasSrotmStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmStridedBatched applies the modified Givens rotation matrix defined by param_i to strided batched vectors x_i and y_i, for i = 1, ..., batchCount
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer pointing to first strided batched vector x_1.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[in]
  !>     stride_x [hipblasStride]
  !>              specifies the increment between the beginning of x_i and x_(i + 1)
  !>     @param[inout]
  !>     y       device pointer pointing to first strided batched vector y_1.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>              specifies the increment between the beginning of y_i and y_(i + 1)
  !>     @param[in]
  !>     param   device pointer pointing to first array of 5 elements defining the rotation (param_1).
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may ONLY be stored on the device for the strided_batched version of this function.
  !>     @param[in]
  !>     strideParam [hipblasStride]
  !>                  specifies the increment between the beginning of param_i and param_(i + 1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !>
  interface hipblasDrotmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotmStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount) bind(c, name="cublasDrotmStridedBatched")
#else
    function hipblasDrotmStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount) bind(c, name="hipblasDrotmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: param
      integer(c_int64_t),value :: strideParam
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDrotmStridedBatched_rank_0,&
      hipblasDrotmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSrotmg
#ifdef USE_CUDA_NAMES
    function hipblasSrotmg_(handle,d1,d2,x1,y1,param) bind(c, name="cublasSrotmg_v2")
#else
    function hipblasSrotmg_(handle,d1,d2,x1,y1,param) bind(c, name="hipblasSrotmg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      type(c_ptr),value :: d2
      type(c_ptr),value :: x1
      type(c_ptr),value :: y1
      type(c_ptr),value :: param
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmg creates the modified Givens rotation matrix for the vector (d1 * x1, d2 * y1).
  !>           Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     d1      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[inout]
  !>     d2      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[inout]
  !>     x1      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[in]
  !>     y1      device pointer or host pointer to input scalar.
  !>     @param[out]
  !>     param   device vector or host vector of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>
  interface hipblasDrotmg
#ifdef USE_CUDA_NAMES
    function hipblasDrotmg_(handle,d1,d2,x1,y1,param) bind(c, name="cublasDrotmg_v2")
#else
    function hipblasDrotmg_(handle,d1,d2,x1,y1,param) bind(c, name="hipblasDrotmg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      type(c_ptr),value :: d2
      type(c_ptr),value :: x1
      type(c_ptr),value :: y1
      type(c_ptr),value :: param
    end function

  end interface
  
  interface hipblasSrotmgBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotmgBatched_(handle,d1,d2,x1,y1,param,batchCount) bind(c, name="cublasSrotmgBatched")
#else
    function hipblasSrotmgBatched_(handle,d1,d2,x1,y1,param,batchCount) bind(c, name="hipblasSrotmgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: d1
      type(c_ptr) :: d2
      type(c_ptr) :: x1
      type(c_ptr) :: y1
      type(c_ptr) :: param
      integer(c_int),value :: batchCount
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmgBatched creates the modified Givens rotation matrix for the batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batchCount.
  !>           Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     d1      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[inout]
  !>     d2      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[inout]
  !>     x1      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     y1      device batched array or host batched array of input scalars.
  !>     @param[out]
  !>     param   device batched array or host batched array of vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>     @param[in]
  !>     batchCount [int]
  !>                 the number of instances in the batch.
  !>
  interface hipblasDrotmgBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotmgBatched_(handle,d1,d2,x1,y1,param,batchCount) bind(c, name="cublasDrotmgBatched")
#else
    function hipblasDrotmgBatched_(handle,d1,d2,x1,y1,param,batchCount) bind(c, name="hipblasDrotmgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: d1
      type(c_ptr) :: d2
      type(c_ptr) :: x1
      type(c_ptr) :: y1
      type(c_ptr) :: param
      integer(c_int),value :: batchCount
    end function

  end interface
  
  interface hipblasSrotmgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotmgStridedBatched_(handle,d1,stride_d1,d2,stride_d2,x1,stride_x1,y1,stride_y1,param,strideParam,batchCount) bind(c, name="cublasSrotmgStridedBatched")
#else
    function hipblasSrotmgStridedBatched_(handle,d1,stride_d1,d2,stride_d2,x1,stride_x1,y1,stride_y1,param,strideParam,batchCount) bind(c, name="hipblasSrotmgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      integer(c_int64_t),value :: stride_d1
      type(c_ptr),value :: d2
      integer(c_int64_t),value :: stride_d2
      type(c_ptr),value :: x1
      integer(c_int64_t),value :: stride_x1
      type(c_ptr),value :: y1
      integer(c_int64_t),value :: stride_y1
      type(c_ptr),value :: param
      integer(c_int64_t),value :: strideParam
      integer(c_int),value :: batchCount
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmgStridedBatched creates the modified Givens rotation matrix for the strided batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batchCount.
  !>           Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     d1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     stride_d1 [hipblasStride]
  !>               specifies the increment between the beginning of d1_i and d1_(i+1)
  !>     @param[inout]
  !>     d2      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     stride_d2 [hipblasStride]
  !>               specifies the increment between the beginning of d2_i and d2_(i+1)
  !>     @param[inout]
  !>     x1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     stride_x1 [hipblasStride]
  !>               specifies the increment between the beginning of x1_i and x1_(i+1)
  !>     @param[in]
  !>     y1      device strided_batched array or host strided_batched array of input scalars.
  !>     @param[in]
  !>     stride_y1 [hipblasStride]
  !>               specifies the increment between the beginning of y1_i and y1_(i+1)
  !>     @param[out]
  !>     param   device stridedBatched array or host stridedBatched array of vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>     @param[in]
  !>     strideParam [hipblasStride]
  !>                  specifies the increment between the beginning of param_i and param_(i + 1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 the number of instances in the batch.
  !>
  interface hipblasDrotmgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotmgStridedBatched_(handle,d1,stride_d1,d2,stride_d2,x1,stride_x1,y1,stride_y1,param,strideParam,batchCount) bind(c, name="cublasDrotmgStridedBatched")
#else
    function hipblasDrotmgStridedBatched_(handle,d1,stride_d1,d2,stride_d2,x1,stride_x1,y1,stride_y1,param,strideParam,batchCount) bind(c, name="hipblasDrotmgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      integer(c_int64_t),value :: stride_d1
      type(c_ptr),value :: d2
      integer(c_int64_t),value :: stride_d2
      type(c_ptr),value :: x1
      integer(c_int64_t),value :: stride_x1
      type(c_ptr),value :: y1
      integer(c_int64_t),value :: stride_y1
      type(c_ptr),value :: param
      integer(c_int64_t),value :: strideParam
      integer(c_int),value :: batchCount
    end function

  end interface
  
  interface hipblasSscal
#ifdef USE_CUDA_NAMES
    function hipblasSscal_(handle,n,alpha,x,incx) bind(c, name="cublasSscal_v2")
#else
    function hipblasSscal_(handle,n,alpha,x,incx) bind(c, name="hipblasSscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSscal_rank_0,&
      hipblasSscal_rank_1
#endif
  end interface
  
  interface hipblasDscal
#ifdef USE_CUDA_NAMES
    function hipblasDscal_(handle,n,alpha,x,incx) bind(c, name="cublasDscal_v2")
#else
    function hipblasDscal_(handle,n,alpha,x,incx) bind(c, name="hipblasDscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDscal_rank_0,&
      hipblasDscal_rank_1
#endif
  end interface
  
  interface hipblasCscal
#ifdef USE_CUDA_NAMES
    function hipblasCscal_(handle,n,alpha,x,incx) bind(c, name="cublasCscal_v2")
#else
    function hipblasCscal_(handle,n,alpha,x,incx) bind(c, name="hipblasCscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCscal_rank_0,&
      hipblasCscal_rank_1
#endif
  end interface
  
  interface hipblasCsscal
#ifdef USE_CUDA_NAMES
    function hipblasCsscal_(handle,n,alpha,x,incx) bind(c, name="cublasCsscal_v2")
#else
    function hipblasCsscal_(handle,n,alpha,x,incx) bind(c, name="hipblasCsscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsscal_rank_0,&
      hipblasCsscal_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     scal  scales each element of vector x with scalar alpha.
  !> 
  !>         x := alpha * x
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     alpha     device pointer or host pointer for the scalar alpha.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !> 
  !>
  interface hipblasZscal
#ifdef USE_CUDA_NAMES
    function hipblasZscal_(handle,n,alpha,x,incx) bind(c, name="cublasZscal_v2")
#else
    function hipblasZscal_(handle,n,alpha,x,incx) bind(c, name="hipblasZscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZscal_rank_0,&
      hipblasZscal_rank_1
#endif
  end interface
  
  interface hipblasZdscal
#ifdef USE_CUDA_NAMES
    function hipblasZdscal_(handle,n,alpha,x,incx) bind(c, name="cublasZdscal_v2")
#else
    function hipblasZdscal_(handle,n,alpha,x,incx) bind(c, name="hipblasZdscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdscal_rank_0,&
      hipblasZdscal_rank_1
#endif
  end interface
  
  interface hipblasSscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasSscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasSscalBatched")
#else
    function hipblasSscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasSscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSscalBatched_full_rank,&
      hipblasSscalBatched_rank_0,&
      hipblasSscalBatched_rank_1
#endif
  end interface
  
  interface hipblasDscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasDscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasDscalBatched")
#else
    function hipblasDscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasDscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDscalBatched_full_rank,&
      hipblasDscalBatched_rank_0,&
      hipblasDscalBatched_rank_1
#endif
  end interface
  
  interface hipblasCscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasCscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasCscalBatched")
#else
    function hipblasCscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasCscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCscalBatched_full_rank,&
      hipblasCscalBatched_rank_0,&
      hipblasCscalBatched_rank_1
#endif
  end interface
  
  interface hipblasZscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasZscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasZscalBatched")
#else
    function hipblasZscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasZscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZscalBatched_full_rank,&
      hipblasZscalBatched_rank_0,&
      hipblasZscalBatched_rank_1
#endif
  end interface
  
  interface hipblasCsscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasCsscalBatched")
#else
    function hipblasCsscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasCsscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsscalBatched_full_rank,&
      hipblasCsscalBatched_rank_0,&
      hipblasCsscalBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !>      \details
  !>     scalBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.
  !> 
  !>          x_i := alpha * x_i
  !> 
  !>      where (x_i) is the i-th instance of the batch.
  !>     @param[in]
  !>     handle      [hipblasHandle_t]
  !>                 handle to the hipblas library context queue.
  !>     @param[in]
  !>     n           [int]
  !>                 the number of elements in each x_i.
  !>     @param[in]
  !>     alpha       host pointer or device pointer for the scalar alpha.
  !>     @param[inout]
  !>     x           device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx        [int]
  !>                 specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of batches in x.
  interface hipblasZdscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasZdscalBatched")
#else
    function hipblasZdscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasZdscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdscalBatched_full_rank,&
      hipblasZdscalBatched_rank_0,&
      hipblasZdscalBatched_rank_1
#endif
  end interface
  
  interface hipblasSscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasSscalStridedBatched")
#else
    function hipblasSscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasSscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSscalStridedBatched_rank_0,&
      hipblasSscalStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasDscalStridedBatched")
#else
    function hipblasDscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasDscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDscalStridedBatched_rank_0,&
      hipblasDscalStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasCscalStridedBatched")
#else
    function hipblasCscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasCscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCscalStridedBatched_rank_0,&
      hipblasCscalStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasZscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasZscalStridedBatched")
#else
    function hipblasZscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasZscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZscalStridedBatched_rank_0,&
      hipblasZscalStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCsscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasCsscalStridedBatched")
#else
    function hipblasCsscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasCsscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsscalStridedBatched_rank_0,&
      hipblasCsscalStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !>      \details
  !>     scalStridedBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.
  !> 
  !>          x_i := alpha * x_i ,
  !> 
  !>      where (x_i) is the i-th instance of the batch.
  !>      @param[in]
  !>     handle      [hipblasHandle_t]
  !>                 handle to the hipblas library context queue.
  !>     @param[in]
  !>     n           [int]
  !>                 the number of elements in each x_i.
  !>     @param[in]
  !>     alpha       host pointer or device pointer for the scalar alpha.
  !>     @param[inout]
  !>     x           device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx        [int]
  !>                 specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stride_x is of appropriate size, for a typical
  !>                 case this means stride_x >= n * incx.
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of batches in x.
  interface hipblasZdscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasZdscalStridedBatched")
#else
    function hipblasZdscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasZdscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdscalStridedBatched_rank_0,&
      hipblasZdscalStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSswap
#ifdef USE_CUDA_NAMES
    function hipblasSswap_(handle,n,x,incx,y,incy) bind(c, name="cublasSswap_v2")
#else
    function hipblasSswap_(handle,n,x,incx,y,incy) bind(c, name="hipblasSswap")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSswap_rank_0,&
      hipblasSswap_rank_1
#endif
  end interface
  
  interface hipblasDswap
#ifdef USE_CUDA_NAMES
    function hipblasDswap_(handle,n,x,incx,y,incy) bind(c, name="cublasDswap_v2")
#else
    function hipblasDswap_(handle,n,x,incx,y,incy) bind(c, name="hipblasDswap")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDswap_rank_0,&
      hipblasDswap_rank_1
#endif
  end interface
  
  interface hipblasCswap
#ifdef USE_CUDA_NAMES
    function hipblasCswap_(handle,n,x,incx,y,incy) bind(c, name="cublasCswap_v2")
#else
    function hipblasCswap_(handle,n,x,incx,y,incy) bind(c, name="hipblasCswap")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCswap_rank_0,&
      hipblasCswap_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swap  interchanges vectors x and y.
  !> 
  !>         y := x; x := y
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x and y.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>
  interface hipblasZswap
#ifdef USE_CUDA_NAMES
    function hipblasZswap_(handle,n,x,incx,y,incy) bind(c, name="cublasZswap_v2")
#else
    function hipblasZswap_(handle,n,x,incx,y,incy) bind(c, name="hipblasZswap")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZswap_rank_0,&
      hipblasZswap_rank_1
#endif
  end interface
  
  interface hipblasSswapBatched
#ifdef USE_CUDA_NAMES
    function hipblasSswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasSswapBatched")
#else
    function hipblasSswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasSswapBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSswapBatched_full_rank,&
      hipblasSswapBatched_rank_0,&
      hipblasSswapBatched_rank_1
#endif
  end interface
  
  interface hipblasDswapBatched
#ifdef USE_CUDA_NAMES
    function hipblasDswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasDswapBatched")
#else
    function hipblasDswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasDswapBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDswapBatched_full_rank,&
      hipblasDswapBatched_rank_0,&
      hipblasDswapBatched_rank_1
#endif
  end interface
  
  interface hipblasCswapBatched
#ifdef USE_CUDA_NAMES
    function hipblasCswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasCswapBatched")
#else
    function hipblasCswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasCswapBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCswapBatched_full_rank,&
      hipblasCswapBatched_rank_0,&
      hipblasCswapBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swapBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount
  !> 
  !>         y_i := x_i; x_i := y_i
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[inout]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZswapBatched
#ifdef USE_CUDA_NAMES
    function hipblasZswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasZswapBatched")
#else
    function hipblasZswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasZswapBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZswapBatched_full_rank,&
      hipblasZswapBatched_rank_0,&
      hipblasZswapBatched_rank_1
#endif
  end interface
  
  interface hipblasSswapStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasSswapStridedBatched")
#else
    function hipblasSswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasSswapStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSswapStridedBatched_rank_0,&
      hipblasSswapStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDswapStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasDswapStridedBatched")
#else
    function hipblasDswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasDswapStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDswapStridedBatched_rank_0,&
      hipblasDswapStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCswapStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasCswapStridedBatched")
#else
    function hipblasCswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasCswapStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCswapStridedBatched_rank_0,&
      hipblasCswapStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swapStridedBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount
  !> 
  !>         y_i := x_i; x_i := y_i
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[inout]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n * incx.
  !>     @param[inout]
  !>     y         device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey   [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_y is of appropriate size, for a typical
  !>               case this means stride_y >= n * incy. stridey should be non zero.
  !>      @param[in]
  !>      batchCount [int]
  !>                  number of instances in the batch.
  !>
  interface hipblasZswapStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasZswapStridedBatched")
#else
    function hipblasZswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasZswapStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZswapStridedBatched_rank_0,&
      hipblasZswapStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSgbmv
#ifdef USE_CUDA_NAMES
    function hipblasSgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasSgbmv_v2")
#else
    function hipblasSgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasSgbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgbmv_full_rank,&
      hipblasSgbmv_rank_0,&
      hipblasSgbmv_rank_1
#endif
  end interface
  
  interface hipblasDgbmv
#ifdef USE_CUDA_NAMES
    function hipblasDgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasDgbmv_v2")
#else
    function hipblasDgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasDgbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgbmv_full_rank,&
      hipblasDgbmv_rank_0,&
      hipblasDgbmv_rank_1
#endif
  end interface
  
  interface hipblasCgbmv
#ifdef USE_CUDA_NAMES
    function hipblasCgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasCgbmv_v2")
#else
    function hipblasCgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasCgbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgbmv_full_rank,&
      hipblasCgbmv_rank_0,&
      hipblasCgbmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gbmv performs one of the matrix-vector operations
  !> 
  !>         y := alpha*A*x    + beta*y,   or
  !>         y := alpha*A**T*x + beta*y,   or
  !>         y := alpha*A**H*x + beta*y,
  !> 
  !>     where alpha and beta are scalars, x and y are vectors and A is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     kl        [int]
  !>               number of sub-diagonals of A
  !>     @param[in]
  !>     ku        [int]
  !>               number of super-diagonals of A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         A     device pointer storing banded matrix A.
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propogates up and down across
  !>               sub/super-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>
  interface hipblasZgbmv
#ifdef USE_CUDA_NAMES
    function hipblasZgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasZgbmv_v2")
#else
    function hipblasZgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasZgbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgbmv_full_rank,&
      hipblasZgbmv_rank_0,&
      hipblasZgbmv_rank_1
#endif
  end interface
  
  interface hipblasSgbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgbmvBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasSgbmvBatched")
#else
    function hipblasSgbmvBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasSgbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgbmvBatched_full_rank,&
      hipblasSgbmvBatched_rank_0,&
      hipblasSgbmvBatched_rank_1
#endif
  end interface
  
  interface hipblasDgbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgbmvBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasDgbmvBatched")
#else
    function hipblasDgbmvBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasDgbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgbmvBatched_full_rank,&
      hipblasDgbmvBatched_rank_0,&
      hipblasDgbmvBatched_rank_1
#endif
  end interface
  
  interface hipblasCgbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgbmvBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasCgbmvBatched")
#else
    function hipblasCgbmvBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasCgbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgbmvBatched_full_rank,&
      hipblasCgbmvBatched_rank_0,&
      hipblasCgbmvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gbmvBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i    + beta*y_i,   or
  !>         y_i := alpha*A_i**T*x_i + beta*y_i,   or
  !>         y_i := alpha*A_i**H*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals,
  !>     for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [int]
  !>               number of rows of each matrix A_i
  !>     @param[in]
  !>     n         [int]
  !>               number of columns of each matrix A_i
  !>     @param[in]
  !>     kl        [int]
  !>               number of sub-diagonals of each A_i
  !>     @param[in]
  !>     ku        [int]
  !>               number of super-diagonals of each A_i
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         A     device array of device pointers storing each banded matrix A_i.
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propogates up and down across
  !>               sub/super-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of instances in the batch.
  !>
  interface hipblasZgbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgbmvBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZgbmvBatched")
#else
    function hipblasZgbmvBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZgbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgbmvBatched_full_rank,&
      hipblasZgbmvBatched_rank_0,&
      hipblasZgbmvBatched_rank_1
#endif
  end interface
  
  interface hipblasSgbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasSgbmvStridedBatched")
#else
    function hipblasSgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasSgbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgbmvStridedBatched_full_rank,&
      hipblasSgbmvStridedBatched_rank_0,&
      hipblasSgbmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDgbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasDgbmvStridedBatched")
#else
    function hipblasDgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasDgbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgbmvStridedBatched_full_rank,&
      hipblasDgbmvStridedBatched_rank_0,&
      hipblasDgbmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCgbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasCgbmvStridedBatched")
#else
    function hipblasCgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasCgbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgbmvStridedBatched_full_rank,&
      hipblasCgbmvStridedBatched_rank_0,&
      hipblasCgbmvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gbmvStridedBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i    + beta*y_i,   or
  !>         y_i := alpha*A_i**T*x_i + beta*y_i,   or
  !>         y_i := alpha*A_i**H*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals,
  !>     for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     kl        [int]
  !>               number of sub-diagonals of A
  !>     @param[in]
  !>     ku        [int]
  !>               number of super-diagonals of A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         A     device pointer to first banded matrix (A_1).
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propogates up and down across
  !>               sub/super-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         device pointer to first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer to first vector (y_1).
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (x_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of instances in the batch.
  !>
  interface hipblasZgbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZgbmvStridedBatched")
#else
    function hipblasZgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZgbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgbmvStridedBatched_full_rank,&
      hipblasZgbmvStridedBatched_rank_0,&
      hipblasZgbmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSgemv
#ifdef USE_CUDA_NAMES
    function hipblasSgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasSgemv_v2")
#else
    function hipblasSgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasSgemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgemv_full_rank,&
      hipblasSgemv_rank_0,&
      hipblasSgemv_rank_1
#endif
  end interface
  
  interface hipblasDgemv
#ifdef USE_CUDA_NAMES
    function hipblasDgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasDgemv_v2")
#else
    function hipblasDgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasDgemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgemv_full_rank,&
      hipblasDgemv_rank_0,&
      hipblasDgemv_rank_1
#endif
  end interface
  
  interface hipblasCgemv
#ifdef USE_CUDA_NAMES
    function hipblasCgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasCgemv_v2")
#else
    function hipblasCgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasCgemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgemv_full_rank,&
      hipblasCgemv_rank_0,&
      hipblasCgemv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gemv performs one of the matrix-vector operations
  !> 
  !>         y := alpha*A*x    + beta*y,   or
  !>         y := alpha*A**T*x + beta*y,   or
  !>         y := alpha*A**H*x + beta*y,
  !> 
  !>     where alpha and beta are scalars, x and y are vectors and A is an
  !>     m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>
  interface hipblasZgemv
#ifdef USE_CUDA_NAMES
    function hipblasZgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasZgemv_v2")
#else
    function hipblasZgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasZgemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgemv_full_rank,&
      hipblasZgemv_rank_0,&
      hipblasZgemv_rank_1
#endif
  end interface
  
  interface hipblasSgemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgemvBatched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasSgemvBatched")
#else
    function hipblasSgemvBatched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasSgemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgemvBatched_full_rank,&
      hipblasSgemvBatched_rank_0,&
      hipblasSgemvBatched_rank_1
#endif
  end interface
  
  interface hipblasDgemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgemvBatched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasDgemvBatched")
#else
    function hipblasDgemvBatched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasDgemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgemvBatched_full_rank,&
      hipblasDgemvBatched_rank_0,&
      hipblasDgemvBatched_rank_1
#endif
  end interface
  
  interface hipblasCgemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgemvBatched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasCgemvBatched")
#else
    function hipblasCgemvBatched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasCgemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgemvBatched_full_rank,&
      hipblasCgemvBatched_rank_0,&
      hipblasCgemvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gemvBatched performs a batch of matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i    + beta*y_i,   or
  !>         y_i := alpha*A_i**T*x_i + beta*y_i,   or
  !>         y_i := alpha*A_i**H*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle      [hipblasHandle_t]
  !>                 handle to the hipblas library context queue.
  !>     @param[in]
  !>     trans       [hipblasOperation_t]
  !>                 indicates whether matrices A_i are tranposed (conjugated) or not
  !>     @param[in]
  !>     m           [int]
  !>                 number of rows of each matrix A_i
  !>     @param[in]
  !>     n           [int]
  !>                 number of columns of each matrix A_i
  !>     @param[in]
  !>     alpha       device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A           device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda         [int]
  !>                 specifies the leading dimension of each matrix A_i.
  !>     @param[in]
  !>     x           device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx        [int]
  !>                 specifies the increment for the elements of each vector x_i.
  !>     @param[in]
  !>     beta        device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y           device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy        [int]
  !>                 specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZgemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgemvBatched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZgemvBatched")
#else
    function hipblasZgemvBatched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZgemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgemvBatched_full_rank,&
      hipblasZgemvBatched_rank_0,&
      hipblasZgemvBatched_rank_1
#endif
  end interface
  
  interface hipblasSgemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgemvStridedBatched_(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasSgemvStridedBatched")
#else
    function hipblasSgemvStridedBatched_(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasSgemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgemvStridedBatched_full_rank,&
      hipblasSgemvStridedBatched_rank_0,&
      hipblasSgemvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDgemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgemvStridedBatched_(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasDgemvStridedBatched")
#else
    function hipblasDgemvStridedBatched_(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasDgemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgemvStridedBatched_full_rank,&
      hipblasDgemvStridedBatched_rank_0,&
      hipblasDgemvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCgemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgemvStridedBatched_(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasCgemvStridedBatched")
#else
    function hipblasCgemvStridedBatched_(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasCgemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgemvStridedBatched_full_rank,&
      hipblasCgemvStridedBatched_rank_0,&
      hipblasCgemvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gemvStridedBatched performs a batch of matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i    + beta*y_i,   or
  !>         y_i := alpha*A_i**T*x_i + beta*y_i,   or
  !>         y_i := alpha*A_i**H*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle      [hipblasHandle_t]
  !>                 handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA      [hipblasOperation_t]
  !>                 indicates whether matrices A_i are tranposed (conjugated) or not
  !>     @param[in]
  !>     m           [int]
  !>                 number of rows of matrices A_i
  !>     @param[in]
  !>     n           [int]
  !>                 number of columns of matrices A_i
  !>     @param[in]
  !>     alpha       device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A           device pointer to the first matrix (A_1) in the batch.
  !>     @param[in]
  !>     lda         [int]
  !>                 specifies the leading dimension of matrices A_i.
  !>     @param[in]
  !>     strideA     [hipblasStride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x           device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx        [int]
  !>                 specifies the increment for the elements of vectors x_i.
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size. When trans equals HIPBLAS_OP_N
  !>                 this typically means stridex >= n * incx, otherwise stridex >= m * incx.
  !>     @param[in]
  !>     beta        device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y           device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy        [int]
  !>                 specifies the increment for the elements of vectors y_i.
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size. When trans equals HIPBLAS_OP_N
  !>                 this typically means stridey >= m * incy, otherwise stridey >= n * incy. stridey should be non zero.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZgemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgemvStridedBatched_(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZgemvStridedBatched")
#else
    function hipblasZgemvStridedBatched_(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZgemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgemvStridedBatched_full_rank,&
      hipblasZgemvStridedBatched_rank_0,&
      hipblasZgemvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSger
#ifdef USE_CUDA_NAMES
    function hipblasSger_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasSger_v2")
#else
    function hipblasSger_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasSger")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSger_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSger_full_rank,&
      hipblasSger_rank_0,&
      hipblasSger_rank_1
#endif
  end interface
  
  interface hipblasDger
#ifdef USE_CUDA_NAMES
    function hipblasDger_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasDger_v2")
#else
    function hipblasDger_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasDger")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDger_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDger_full_rank,&
      hipblasDger_rank_0,&
      hipblasDger_rank_1
#endif
  end interface
  
  interface hipblasCgeru
#ifdef USE_CUDA_NAMES
    function hipblasCgeru_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasCgeru_v2")
#else
    function hipblasCgeru_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasCgeru")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeru_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgeru_full_rank,&
      hipblasCgeru_rank_0,&
      hipblasCgeru_rank_1
#endif
  end interface
  
  interface hipblasCgerc
#ifdef USE_CUDA_NAMES
    function hipblasCgerc_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasCgerc_v2")
#else
    function hipblasCgerc_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasCgerc")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgerc_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgerc_full_rank,&
      hipblasCgerc_rank_0,&
      hipblasCgerc_rank_1
#endif
  end interface
  
  interface hipblasZgeru
#ifdef USE_CUDA_NAMES
    function hipblasZgeru_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasZgeru_v2")
#else
    function hipblasZgeru_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasZgeru")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeru_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgeru_full_rank,&
      hipblasZgeru_rank_0,&
      hipblasZgeru_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     ger,geru,gerc performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*y**T , OR
  !>         A := A + alpha*x*y**H for gerc
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     m         [int]
  !>               the number of rows of the matrix A.
  !>     @param[in]
  !>     n         [int]
  !>               the number of columns of the matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>
  interface hipblasZgerc
#ifdef USE_CUDA_NAMES
    function hipblasZgerc_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasZgerc_v2")
#else
    function hipblasZgerc_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasZgerc")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgerc_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgerc_full_rank,&
      hipblasZgerc_rank_0,&
      hipblasZgerc_rank_1
#endif
  end interface
  
  interface hipblasSgerBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgerBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasSgerBatched")
#else
    function hipblasSgerBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasSgerBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgerBatched_full_rank,&
      hipblasSgerBatched_rank_0,&
      hipblasSgerBatched_rank_1
#endif
  end interface
  
  interface hipblasDgerBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgerBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasDgerBatched")
#else
    function hipblasDgerBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasDgerBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgerBatched_full_rank,&
      hipblasDgerBatched_rank_0,&
      hipblasDgerBatched_rank_1
#endif
  end interface
  
  interface hipblasCgeruBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeruBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasCgeruBatched")
#else
    function hipblasCgeruBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasCgeruBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgeruBatched_full_rank,&
      hipblasCgeruBatched_rank_0,&
      hipblasCgeruBatched_rank_1
#endif
  end interface
  
  interface hipblasCgercBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgercBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasCgercBatched")
#else
    function hipblasCgercBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasCgercBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgercBatched_full_rank,&
      hipblasCgercBatched_rank_0,&
      hipblasCgercBatched_rank_1
#endif
  end interface
  
  interface hipblasZgeruBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeruBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasZgeruBatched")
#else
    function hipblasZgeruBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasZgeruBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgeruBatched_full_rank,&
      hipblasZgeruBatched_rank_0,&
      hipblasZgeruBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gerBatched,geruBatched,gercBatched performs a batch of the matrix-vector operations
  !> 
  !>         A := A + alpha*x*y**T , OR
  !>         A := A + alpha*x*y**H for gerc
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha is a scalar, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     m         [int]
  !>               the number of rows of each matrix A_i.
  !>     @param[in]
  !>     n         [int]
  !>               the number of columns of eaceh matrix A_i.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZgercBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgercBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasZgercBatched")
#else
    function hipblasZgercBatched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasZgercBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgercBatched_full_rank,&
      hipblasZgercBatched_rank_0,&
      hipblasZgercBatched_rank_1
#endif
  end interface
  
  interface hipblasSgerStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgerStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasSgerStridedBatched")
#else
    function hipblasSgerStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasSgerStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgerStridedBatched_full_rank,&
      hipblasSgerStridedBatched_rank_0,&
      hipblasSgerStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDgerStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgerStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasDgerStridedBatched")
#else
    function hipblasDgerStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasDgerStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgerStridedBatched_full_rank,&
      hipblasDgerStridedBatched_rank_0,&
      hipblasDgerStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCgeruStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeruStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasCgeruStridedBatched")
#else
    function hipblasCgeruStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasCgeruStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgeruStridedBatched_full_rank,&
      hipblasCgeruStridedBatched_rank_0,&
      hipblasCgeruStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCgercStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgercStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasCgercStridedBatched")
#else
    function hipblasCgercStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasCgercStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgercStridedBatched_full_rank,&
      hipblasCgercStridedBatched_rank_0,&
      hipblasCgercStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasZgeruStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeruStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasZgeruStridedBatched")
#else
    function hipblasZgeruStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasZgeruStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgeruStridedBatched_full_rank,&
      hipblasZgeruStridedBatched_rank_0,&
      hipblasZgeruStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gerStridedBatched,geruStridedBatched,gercStridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**T, OR
  !>         A_i := A_i + alpha*x_i*y_i**H  for gerc
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha is a scalar, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     m         [int]
  !>               the number of rows of each matrix A_i.
  !>     @param[in]
  !>     n         [int]
  !>               the number of columns of each matrix A_i.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increments for the elements of each vector x_i.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stridex, however the user should
  !>               take care to ensure that stridex is of appropriate size, for a typical
  !>               case this means stridex >= m * incx.
  !>     @param[inout]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     stridey   [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>               There are no restrictions placed on stridey, however the user should
  !>               take care to ensure that stridey is of appropriate size, for a typical
  !>               case this means stridey >= n * incy.
  !>     @param[inout]
  !>     A         device pointer to the first matrix (A_1) in the batch.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA     [hipblasStride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZgercStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgercStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasZgercStridedBatched")
#else
    function hipblasZgercStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasZgercStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgercStridedBatched_full_rank,&
      hipblasZgercStridedBatched_rank_0,&
      hipblasZgercStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasChbmv
#ifdef USE_CUDA_NAMES
    function hipblasChbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasChbmv_v2")
#else
    function hipblasChbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasChbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChbmv_full_rank,&
      hipblasChbmv_rank_0,&
      hipblasChbmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hbmv performs the matrix-vector operations
  !> 
  !>         y := alpha*A*x + beta*y
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian band matrix, with k super-diagonals.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is being supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is being supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of the matrix A.
  !>     @param[in]
  !>     k         [int]
  !>               the number of super-diagonals of the matrix A. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A. Of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The leading (k + 1) by n part of A must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of A will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The leading (k + 1) by n part of A must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of A will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of A will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. must be >= k + 1
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>
  interface hipblasZhbmv
#ifdef USE_CUDA_NAMES
    function hipblasZhbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasZhbmv_v2")
#else
    function hipblasZhbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasZhbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhbmv_full_rank,&
      hipblasZhbmv_rank_0,&
      hipblasZhbmv_rank_1
#endif
  end interface
  
  interface hipblasChbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasChbmvBatched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasChbmvBatched")
#else
    function hipblasChbmvBatched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasChbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChbmvBatched_full_rank,&
      hipblasChbmvBatched_rank_0,&
      hipblasChbmvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hbmvBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     k         [int]
  !>               the number of super-diagonals of each matrix A_i. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix_i A of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The leading (k + 1) by n part of each A_i must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of each A_i will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The leading (k + 1) by n part of each A_i must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of each A_i will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZhbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhbmvBatched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZhbmvBatched")
#else
    function hipblasZhbmvBatched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZhbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhbmvBatched_full_rank,&
      hipblasZhbmvBatched_rank_0,&
      hipblasZhbmvBatched_rank_1
#endif
  end interface
  
  interface hipblasChbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChbmvStridedBatched_(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasChbmvStridedBatched")
#else
    function hipblasChbmvStridedBatched_(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasChbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChbmvStridedBatched_full_rank,&
      hipblasChbmvStridedBatched_rank_0,&
      hipblasChbmvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hbmvStridedBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     k         [int]
  !>               the number of super-diagonals of each matrix A_i. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array pointing to the first matrix A_1. Each A_i is of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The leading (k + 1) by n part of each A_i must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of each A_i will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The leading (k + 1) by n part of each A_i must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of each A_i will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         device array pointing to the first vector y_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array pointing to the first vector y_1.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZhbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhbmvStridedBatched_(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZhbmvStridedBatched")
#else
    function hipblasZhbmvStridedBatched_(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZhbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhbmvStridedBatched_full_rank,&
      hipblasZhbmvStridedBatched_rank_0,&
      hipblasZhbmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasChemv
#ifdef USE_CUDA_NAMES
    function hipblasChemv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasChemv_v2")
#else
    function hipblasChemv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasChemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChemv_full_rank,&
      hipblasChemv_rank_0,&
      hipblasChemv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hemv performs one of the matrix-vector operations
  !> 
  !>         y := alpha*A*x + beta*y
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of the matrix A.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A. Of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular part of A must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of A will not be referenced.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular part of A must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of A will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of A will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. must be >= max(1, n)
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>
  interface hipblasZhemv
#ifdef USE_CUDA_NAMES
    function hipblasZhemv_(handle,uplo,n,alpha,A,da,x,incx,beta,y,incy) bind(c, name="cublasZhemv_v2")
#else
    function hipblasZhemv_(handle,uplo,n,alpha,A,da,x,incx,beta,y,incy) bind(c, name="hipblasZhemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: da
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhemv_full_rank,&
      hipblasZhemv_rank_0,&
      hipblasZhemv_rank_1
#endif
  end interface
  
  interface hipblasChemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasChemvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasChemvBatched")
#else
    function hipblasChemvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasChemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChemvBatched_full_rank,&
      hipblasChemvBatched_rank_0,&
      hipblasChemvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hemvBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, for each batch in i = [1, batchCount].
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular part of each A_i must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of each A_i will not be referenced.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular part of each A_i must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of each A_i will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZhemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhemvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZhemvBatched")
#else
    function hipblasZhemvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZhemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhemvBatched_full_rank,&
      hipblasZhemvBatched_rank_0,&
      hipblasZhemvBatched_rank_1
#endif
  end interface
  
  interface hipblasChemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChemvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasChemvStridedBatched")
#else
    function hipblasChemvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasChemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChemvStridedBatched_full_rank,&
      hipblasChemvStridedBatched_rank_0,&
      hipblasChemvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hemvStridedBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, for each batch in i = [1, batchCount].
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular part of each A_i must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of each A_i will not be referenced.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular part of each A_i must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of each A_i will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     strideA    [hipblasStride]
  !>                 stride from the start of one (A_i) to the next (A_i+1)
  !> 
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZhemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhemvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZhemvStridedBatched")
#else
    function hipblasZhemvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZhemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhemvStridedBatched_full_rank,&
      hipblasZhemvStridedBatched_rank_0,&
      hipblasZhemvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCher
#ifdef USE_CUDA_NAMES
    function hipblasCher_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="cublasCher_v2")
#else
    function hipblasCher_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="hipblasCher")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCher_full_rank,&
      hipblasCher_rank_0,&
      hipblasCher_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*x**H
  !> 
  !>     where alpha is a real scalar, x is a vector, and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in A.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in A.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     A         device pointer storing the specified triangular portion of
  !>               the Hermitian matrix A. Of size (lda * n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied. The lower
  !>                 triangluar portion will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied. The upper
  !>                 triangular portion will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. Must be at least max(1, n).
  interface hipblasZher
#ifdef USE_CUDA_NAMES
    function hipblasZher_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="cublasZher_v2")
#else
    function hipblasZher_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="hipblasZher")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZher_full_rank,&
      hipblasZher_rank_0,&
      hipblasZher_rank_1
#endif
  end interface
  
  interface hipblasCherBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="cublasCherBatched")
#else
    function hipblasCherBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="hipblasCherBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCherBatched_full_rank,&
      hipblasCherBatched_rank_0,&
      hipblasCherBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     herBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**H
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n * (n + 1)) 2). Array is of at least size batchCount.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular portion
  !>                 of each A_i will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular portion
  !>                 of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. Must be at least max(1, n).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasZherBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="cublasZherBatched")
#else
    function hipblasZherBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="hipblasZherBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZherBatched_full_rank,&
      hipblasZherBatched_rank_0,&
      hipblasZherBatched_rank_1
#endif
  end interface
  
  interface hipblasCherStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batchCount) bind(c, name="cublasCherStridedBatched")
#else
    function hipblasCherStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batchCount) bind(c, name="hipblasCherStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCherStridedBatched_full_rank,&
      hipblasCherStridedBatched_rank_0,&
      hipblasCherStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     herStridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**H
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n Hermitian matrix, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     A         device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA    [hipblasStride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasZherStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batchCount) bind(c, name="cublasZherStridedBatched")
#else
    function hipblasZherStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batchCount) bind(c, name="hipblasZherStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZherStridedBatched_full_rank,&
      hipblasZherStridedBatched_rank_0,&
      hipblasZherStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCher2
#ifdef USE_CUDA_NAMES
    function hipblasCher2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasCher2_v2")
#else
    function hipblasCher2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasCher2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCher2_full_rank,&
      hipblasCher2_rank_0,&
      hipblasCher2_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her2 performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*y**H + conj(alpha)*y*x**H
  !> 
  !>     where alpha is a complex scalar, x and y are vectors, and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     A         device pointer storing the specified triangular portion of
  !>               the Hermitian matrix A. Of size (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied. The lower triangular
  !>                 portion of A will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied. The upper triangular
  !>                 portion of A will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. Must be at least max(lda, 1).
  interface hipblasZher2
#ifdef USE_CUDA_NAMES
    function hipblasZher2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasZher2_v2")
#else
    function hipblasZher2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasZher2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZher2_full_rank,&
      hipblasZher2_rank_0,&
      hipblasZher2_rank_1
#endif
  end interface
  
  interface hipblasCher2Batched
#ifdef USE_CUDA_NAMES
    function hipblasCher2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasCher2Batched")
#else
    function hipblasCher2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasCher2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCher2Batched_full_rank,&
      hipblasCher2Batched_rank_0,&
      hipblasCher2Batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her2Batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n Hermitian matrix for each batch in i = [1, batchCount].
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i of size (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. Must be at least max(lda, 1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasZher2Batched
#ifdef USE_CUDA_NAMES
    function hipblasZher2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasZher2Batched")
#else
    function hipblasZher2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasZher2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZher2Batched_full_rank,&
      hipblasZher2Batched_rank_0,&
      hipblasZher2Batched_rank_1
#endif
  end interface
  
  interface hipblasCher2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCher2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasCher2StridedBatched")
#else
    function hipblasCher2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasCher2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCher2StridedBatched_full_rank,&
      hipblasCher2StridedBatched_rank_0,&
      hipblasCher2StridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her2StridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n Hermitian matrix for each batch in i = [1, batchCount].
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               specifies the stride between the beginning of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               specifies the stride between the beginning of one vector (y_i) and the next (y_i+1).
  !>     @param[inout]
  !>     A         device pointer pointing to the first matrix (A_1). Stores the specified triangular portion of
  !>               each Hermitian matrix A_i.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. Must be at least max(lda, 1).
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               specifies the stride between the beginning of one matrix (A_i) and the next (A_i+1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasZher2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZher2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasZher2StridedBatched")
#else
    function hipblasZher2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasZher2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZher2StridedBatched_full_rank,&
      hipblasZher2StridedBatched_rank_0,&
      hipblasZher2StridedBatched_rank_1
#endif
  end interface
  
  interface hipblasChpmv
#ifdef USE_CUDA_NAMES
    function hipblasChpmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="cublasChpmv_v2")
#else
    function hipblasChpmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="hipblasChpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChpmv_rank_0,&
      hipblasChpmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpmv performs the matrix-vector operation
  !> 
  !>         y := alpha*A*x + beta*y
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below).
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the order of the matrix A, must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n * (n + 1)) 2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>
  interface hipblasZhpmv
#ifdef USE_CUDA_NAMES
    function hipblasZhpmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="cublasZhpmv_v2")
#else
    function hipblasZhpmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="hipblasZhpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhpmv_rank_0,&
      hipblasZhpmv_rank_1
#endif
  end interface
  
  interface hipblasChpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasChpmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="cublasChpmvBatched")
#else
    function hipblasChpmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasChpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChpmvBatched_full_rank,&
      hipblasChpmvBatched_rank_0,&
      hipblasChpmvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpmvBatched performs the matrix-vector operation
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below),
  !>     for each batch in i = [1, batchCount].
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP      device pointer of device pointers storing the packed version of the specified triangular
  !>             portion of each Hermitian matrix A_i. Each A_i is of at least size ((n * (n + 1)) 2).
  !>             if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>             The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>             The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>             so that:
  !>             AP(0) = A(0,0)
  !>             AP(1) = A(0,1)
  !>             AP(2) = A(1,1), etc.
  !>                 Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                     (1, 0) (2, 1) (3, 2)
  !>                     (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                     (3,-2) (5, 1) (6, 0)
  !>         if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>             The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>             The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>             so that:
  !>             AP(0) = A(0,0)
  !>             AP(1) = A(1,0)
  !>             AP(2) = A(2,1), etc.
  !>                 Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                     (1, 0) (2, 1) (3, 2)
  !>                     (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                     (3,-2) (5, 1) (6, 0)
  !>         Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>         to be 0.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZhpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhpmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZhpmvBatched")
#else
    function hipblasZhpmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZhpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhpmvBatched_full_rank,&
      hipblasZhpmvBatched_rank_0,&
      hipblasZhpmvBatched_rank_1
#endif
  end interface
  
  interface hipblasChpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChpmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasChpmvStridedBatched")
#else
    function hipblasChpmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasChpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChpmvStridedBatched_rank_0,&
      hipblasChpmvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpmvStridedBatched performs the matrix-vector operation
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below),
  !>     for each batch in i = [1, batchCount].
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer pointing to the beginning of the first matrix (AP_1). Stores the packed
  !>               version of the specified triangular portion of each Hermitian matrix AP_i of size ((n * (n + 1)) 2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>         Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>         to be 0.
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (AP_i) and the next one (AP_i+1).
  !>     @param[in]
  !>     x         device array pointing to the beginning of the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array pointing to the beginning of the first vector (y_1).
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZhpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhpmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZhpmvStridedBatched")
#else
    function hipblasZhpmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZhpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhpmvStridedBatched_rank_0,&
      hipblasZhpmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasChpr
#ifdef USE_CUDA_NAMES
    function hipblasChpr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasChpr_v2")
#else
    function hipblasChpr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasChpr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChpr_rank_0,&
      hipblasChpr_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*x**H
  !> 
  !>     where alpha is a real scalar, x is a vector, and A is an
  !>     n by n Hermitian matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n * (n + 1)) 2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  interface hipblasZhpr
#ifdef USE_CUDA_NAMES
    function hipblasZhpr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasZhpr_v2")
#else
    function hipblasZhpr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasZhpr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhpr_rank_0,&
      hipblasZhpr_rank_1
#endif
  end interface
  
  interface hipblasChprBatched
#ifdef USE_CUDA_NAMES
    function hipblasChprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasChprBatched")
#else
    function hipblasChprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasChprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChprBatched_full_rank,&
      hipblasChprBatched_rank_0,&
      hipblasChprBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hprBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**H
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n * (n + 1)) 2). Array is of at least size batchCount.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasZhprBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasZhprBatched")
#else
    function hipblasZhprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasZhprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhprBatched_full_rank,&
      hipblasZhprBatched_rank_0,&
      hipblasZhprBatched_rank_1
#endif
  end interface
  
  interface hipblasChprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="cublasChprStridedBatched")
#else
    function hipblasChprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="hipblasChprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChprStridedBatched_rank_0,&
      hipblasChprStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hprStridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**H
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     strideAP   [hipblasStride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasZhprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="cublasZhprStridedBatched")
#else
    function hipblasZhprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="hipblasZhprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhprStridedBatched_rank_0,&
      hipblasZhprStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasChpr2
#ifdef USE_CUDA_NAMES
    function hipblasChpr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="cublasChpr2_v2")
#else
    function hipblasChpr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="hipblasChpr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChpr2_rank_0,&
      hipblasChpr2_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr2 performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*y**H + conj(alpha)*y*x**H
  !> 
  !>     where alpha is a complex scalar, x and y are vectors, and A is an
  !>     n by n Hermitian matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n * (n + 1)) 2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  interface hipblasZhpr2
#ifdef USE_CUDA_NAMES
    function hipblasZhpr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="cublasZhpr2_v2")
#else
    function hipblasZhpr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="hipblasZhpr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhpr2_rank_0,&
      hipblasZhpr2_rank_1
#endif
  end interface
  
  interface hipblasChpr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasChpr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="cublasChpr2Batched")
#else
    function hipblasChpr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="hipblasChpr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChpr2Batched_full_rank,&
      hipblasChpr2Batched_rank_0,&
      hipblasChpr2Batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr2Batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n * (n + 1)) 2). Array is of at least size batchCount.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasZhpr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasZhpr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="cublasZhpr2Batched")
#else
    function hipblasZhpr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="hipblasZhpr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhpr2Batched_full_rank,&
      hipblasZhpr2Batched_rank_0,&
      hipblasZhpr2Batched_rank_1
#endif
  end interface
  
  interface hipblasChpr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChpr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount) bind(c, name="cublasChpr2StridedBatched")
#else
    function hipblasChpr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount) bind(c, name="hipblasChpr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChpr2StridedBatched_rank_0,&
      hipblasChpr2StridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr2StridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector (y_1).
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     strideAP    [hipblasStride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasZhpr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhpr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount) bind(c, name="cublasZhpr2StridedBatched")
#else
    function hipblasZhpr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount) bind(c, name="hipblasZhpr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhpr2StridedBatched_rank_0,&
      hipblasZhpr2StridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSsbmv
#ifdef USE_CUDA_NAMES
    function hipblasSsbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasSsbmv_v2")
#else
    function hipblasSsbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasSsbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsbmv_full_rank,&
      hipblasSsbmv_rank_0,&
      hipblasSsbmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sbmv performs the matrix-vector operation:
  !> 
  !>         y := alpha*A*x + beta*y,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     k         [int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     A         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of matrix A
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y
  !>
  interface hipblasDsbmv
#ifdef USE_CUDA_NAMES
    function hipblasDsbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasDsbmv_v2")
#else
    function hipblasDsbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasDsbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsbmv_full_rank,&
      hipblasDsbmv_rank_0,&
      hipblasDsbmv_rank_1
#endif
  end interface
  
  interface hipblasSsbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsbmvBatched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasSsbmvBatched")
#else
    function hipblasSsbmvBatched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasSsbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsbmvBatched_full_rank,&
      hipblasSsbmvBatched_rank_0,&
      hipblasSsbmvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sbmvBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric banded matrix, for i = 1, ..., batchCount.
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     k         [int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasDsbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsbmvBatched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasDsbmvBatched")
#else
    function hipblasDsbmvBatched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasDsbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsbmvBatched_full_rank,&
      hipblasDsbmvBatched_rank_0,&
      hipblasDsbmvBatched_rank_1
#endif
  end interface
  
  interface hipblasSsbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsbmvStridedBatched_(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasSsbmvStridedBatched")
#else
    function hipblasSsbmvStridedBatched_(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasSsbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsbmvStridedBatched_full_rank,&
      hipblasSsbmvStridedBatched_rank_0,&
      hipblasSsbmvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sbmvStridedBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric banded matrix, for i = 1, ..., batchCount.
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     k         [int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     strideA     [hipblasStride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n * incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n * incy. stridey should be non zero.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasDsbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsbmvStridedBatched_(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasDsbmvStridedBatched")
#else
    function hipblasDsbmvStridedBatched_(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasDsbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsbmvStridedBatched_full_rank,&
      hipblasDsbmvStridedBatched_rank_0,&
      hipblasDsbmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSspmv
#ifdef USE_CUDA_NAMES
    function hipblasSspmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="cublasSspmv_v2")
#else
    function hipblasSspmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="hipblasSspmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSspmv_rank_0,&
      hipblasSspmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spmv performs the matrix-vector operation:
  !> 
  !>         y := alpha*A*x + beta*y,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     A         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y
  !>
  interface hipblasDspmv
#ifdef USE_CUDA_NAMES
    function hipblasDspmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="cublasDspmv_v2")
#else
    function hipblasDspmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="hipblasDspmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDspmv_rank_0,&
      hipblasDspmv_rank_1
#endif
  end interface
  
  interface hipblasSspmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasSspmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="cublasSspmvBatched")
#else
    function hipblasSspmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasSspmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSspmvBatched_full_rank,&
      hipblasSspmvBatched_rank_0,&
      hipblasSspmvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spmvBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batchCount.
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasDspmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDspmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="cublasDspmvBatched")
#else
    function hipblasDspmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasDspmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDspmvBatched_full_rank,&
      hipblasDspmvBatched_rank_0,&
      hipblasDspmvBatched_rank_1
#endif
  end interface
  
  interface hipblasSspmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSspmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasSspmvStridedBatched")
#else
    function hipblasSspmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasSspmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSspmvStridedBatched_rank_0,&
      hipblasSspmvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spmvStridedBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batchCount.
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     strideA     [hipblasStride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n * incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n * incy. stridey should be non zero.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasDspmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDspmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasDspmvStridedBatched")
#else
    function hipblasDspmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasDspmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDspmvStridedBatched_rank_0,&
      hipblasDspmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSspr
#ifdef USE_CUDA_NAMES
    function hipblasSspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasSspr_v2")
#else
    function hipblasSspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasSspr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSspr_rank_0,&
      hipblasSspr_rank_1
#endif
  end interface
  
  interface hipblasDspr
#ifdef USE_CUDA_NAMES
    function hipblasDspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasDspr_v2")
#else
    function hipblasDspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasDspr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDspr_rank_0,&
      hipblasDspr_rank_1
#endif
  end interface
  
  interface hipblasCspr
#ifdef USE_CUDA_NAMES
    function hipblasCspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasCspr")
#else
    function hipblasCspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasCspr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCspr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCspr_rank_0,&
      hipblasCspr_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*x**T
  !> 
  !>     where alpha is a scalar, x is a vector, and A is an
  !>     n by n symmetric matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the symmetric matrix A. Of at least size ((n * (n + 1)) 2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  interface hipblasZspr
#ifdef USE_CUDA_NAMES
    function hipblasZspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasZspr")
#else
    function hipblasZspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasZspr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZspr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZspr_rank_0,&
      hipblasZspr_rank_1
#endif
  end interface
  
  interface hipblasSsprBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasSsprBatched")
#else
    function hipblasSsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasSsprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsprBatched_full_rank,&
      hipblasSsprBatched_rank_0,&
      hipblasSsprBatched_rank_1
#endif
  end interface
  
  interface hipblasDsprBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasDsprBatched")
#else
    function hipblasDsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasDsprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsprBatched_full_rank,&
      hipblasDsprBatched_rank_0,&
      hipblasDsprBatched_rank_1
#endif
  end interface
  
  interface hipblasCsprBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasCsprBatched")
#else
    function hipblasCsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasCsprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsprBatched_full_rank,&
      hipblasCsprBatched_rank_0,&
      hipblasCsprBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sprBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**T
  !> 
  !>     where alpha is a scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i of at least size ((n * (n + 1)) 2). Array is of at least size batchCount.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasZsprBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasZsprBatched")
#else
    function hipblasZsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasZsprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsprBatched_full_rank,&
      hipblasZsprBatched_rank_0,&
      hipblasZsprBatched_rank_1
#endif
  end interface
  
  interface hipblasSsprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="cublasSsprStridedBatched")
#else
    function hipblasSsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="hipblasSsprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsprStridedBatched_rank_0,&
      hipblasSsprStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDsprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="cublasDsprStridedBatched")
#else
    function hipblasDsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="hipblasDsprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsprStridedBatched_rank_0,&
      hipblasDsprStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCsprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="cublasCsprStridedBatched")
#else
    function hipblasCsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="hipblasCsprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsprStridedBatched_rank_0,&
      hipblasCsprStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sprStridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**T
  !> 
  !>     where alpha is a scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i. Points to the first A_1.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     strideA    [hipblasStride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasZsprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="cublasZsprStridedBatched")
#else
    function hipblasZsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount) bind(c, name="hipblasZsprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsprStridedBatched_rank_0,&
      hipblasZsprStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSspr2
#ifdef USE_CUDA_NAMES
    function hipblasSspr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="cublasSspr2_v2")
#else
    function hipblasSspr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="hipblasSspr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSspr2_rank_0,&
      hipblasSspr2_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr2 performs the matrix-vector operation
  !> 
  !>         A := A + alpha*x*y**T + alpha*y*x**T
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     n by n symmetric matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the symmetric matrix A. Of at least size ((n * (n + 1)) 2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  interface hipblasDspr2
#ifdef USE_CUDA_NAMES
    function hipblasDspr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="cublasDspr2_v2")
#else
    function hipblasDspr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="hipblasDspr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDspr2_rank_0,&
      hipblasDspr2_rank_1
#endif
  end interface
  
  interface hipblasSspr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasSspr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="cublasSspr2Batched")
#else
    function hipblasSspr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="hipblasSspr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSspr2Batched_full_rank,&
      hipblasSspr2Batched_rank_0,&
      hipblasSspr2Batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr2Batched performs the matrix-vector operation
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T
  !> 
  !>     where alpha is a scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i of at least size ((n * (n + 1)) 2). Array is of at least size batchCount.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasDspr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasDspr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="cublasDspr2Batched")
#else
    function hipblasDspr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="hipblasDspr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDspr2Batched_full_rank,&
      hipblasDspr2Batched_rank_0,&
      hipblasDspr2Batched_rank_1
#endif
  end interface
  
  interface hipblasSspr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSspr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount) bind(c, name="cublasSspr2StridedBatched")
#else
    function hipblasSspr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount) bind(c, name="hipblasSspr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSspr2StridedBatched_rank_0,&
      hipblasSspr2StridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr2StridedBatched performs the matrix-vector operation
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T
  !> 
  !>     where alpha is a scalar, x_i amd y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector (y_1).
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i. Points to the first A_1.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     strideA    [hipblasStride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  interface hipblasDspr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDspr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount) bind(c, name="cublasDspr2StridedBatched")
#else
    function hipblasDspr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount) bind(c, name="hipblasDspr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDspr2StridedBatched_rank_0,&
      hipblasDspr2StridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSsymv
#ifdef USE_CUDA_NAMES
    function hipblasSsymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasSsymv_v2")
#else
    function hipblasSsymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasSsymv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsymv_full_rank,&
      hipblasSsymv_rank_0,&
      hipblasSsymv_rank_1
#endif
  end interface
  
  interface hipblasDsymv
#ifdef USE_CUDA_NAMES
    function hipblasDsymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasDsymv_v2")
#else
    function hipblasDsymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasDsymv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsymv_full_rank,&
      hipblasDsymv_rank_0,&
      hipblasDsymv_rank_1
#endif
  end interface
  
  interface hipblasCsymv
#ifdef USE_CUDA_NAMES
    function hipblasCsymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasCsymv_v2")
#else
    function hipblasCsymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasCsymv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsymv_full_rank,&
      hipblasCsymv_rank_0,&
      hipblasCsymv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     symv performs the matrix-vector operation:
  !> 
  !>         y := alpha*A*x + beta*y,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     A         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y
  !>
  interface hipblasZsymv
#ifdef USE_CUDA_NAMES
    function hipblasZsymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="cublasZsymv_v2")
#else
    function hipblasZsymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="hipblasZsymv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsymv_full_rank,&
      hipblasZsymv_rank_0,&
      hipblasZsymv_rank_1
#endif
  end interface
  
  interface hipblasSsymvBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsymvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasSsymvBatched")
#else
    function hipblasSsymvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasSsymvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsymvBatched_full_rank,&
      hipblasSsymvBatched_rank_0,&
      hipblasSsymvBatched_rank_1
#endif
  end interface
  
  interface hipblasDsymvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsymvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasDsymvBatched")
#else
    function hipblasDsymvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasDsymvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsymvBatched_full_rank,&
      hipblasDsymvBatched_rank_0,&
      hipblasDsymvBatched_rank_1
#endif
  end interface
  
  interface hipblasCsymvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsymvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasCsymvBatched")
#else
    function hipblasCsymvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasCsymvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsymvBatched_full_rank,&
      hipblasCsymvBatched_rank_0,&
      hipblasCsymvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     symvBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batchCount.
  !>     A a should contain an upper or lower triangular symmetric matrix
  !>     and the opposing triangular part of A is not referenced
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZsymvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsymvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZsymvBatched")
#else
    function hipblasZsymvBatched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZsymvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsymvBatched_full_rank,&
      hipblasZsymvBatched_rank_0,&
      hipblasZsymvBatched_rank_1
#endif
  end interface
  
  interface hipblasSsymvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsymvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasSsymvStridedBatched")
#else
    function hipblasSsymvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasSsymvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsymvStridedBatched_full_rank,&
      hipblasSsymvStridedBatched_rank_0,&
      hipblasSsymvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDsymvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsymvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasDsymvStridedBatched")
#else
    function hipblasDsymvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasDsymvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsymvStridedBatched_full_rank,&
      hipblasDsymvStridedBatched_rank_0,&
      hipblasDsymvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCsymvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsymvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasCsymvStridedBatched")
#else
    function hipblasCsymvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasCsymvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsymvStridedBatched_full_rank,&
      hipblasCsymvStridedBatched_rank_0,&
      hipblasCsymvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     symvStridedBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batchCount.
  !>     A a should contain an upper or lower triangular symmetric matrix
  !>     and the opposing triangular part of A is not referenced
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     strideA     [hipblasStride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n * incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n * incy. stridey should be non zero.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZsymvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsymvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZsymvStridedBatched")
#else
    function hipblasZsymvStridedBatched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZsymvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsymvStridedBatched_full_rank,&
      hipblasZsymvStridedBatched_rank_0,&
      hipblasZsymvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSsyr
#ifdef USE_CUDA_NAMES
    function hipblasSsyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="cublasSsyr_v2")
#else
    function hipblasSsyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="hipblasSsyr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyr_full_rank,&
      hipblasSsyr_rank_0,&
      hipblasSsyr_rank_1
#endif
  end interface
  
  interface hipblasDsyr
#ifdef USE_CUDA_NAMES
    function hipblasDsyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="cublasDsyr_v2")
#else
    function hipblasDsyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="hipblasDsyr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyr_full_rank,&
      hipblasDsyr_rank_0,&
      hipblasDsyr_rank_1
#endif
  end interface
  
  interface hipblasCsyr
#ifdef USE_CUDA_NAMES
    function hipblasCsyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="cublasCsyr_v2")
#else
    function hipblasCsyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="hipblasCsyr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyr_full_rank,&
      hipblasCsyr_rank_0,&
      hipblasCsyr_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*x**T
  !> 
  !>     where alpha is a scalar, x is a vector, and A is an
  !>     n by n symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>
  interface hipblasZsyr
#ifdef USE_CUDA_NAMES
    function hipblasZsyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="cublasZsyr_v2")
#else
    function hipblasZsyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="hipblasZsyr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyr_full_rank,&
      hipblasZsyr_rank_0,&
      hipblasZsyr_rank_1
#endif
  end interface
  
  interface hipblasSsyrBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="cublasSsyrBatched")
#else
    function hipblasSsyrBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="hipblasSsyrBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyrBatched_full_rank,&
      hipblasSsyrBatched_rank_0,&
      hipblasSsyrBatched_rank_1
#endif
  end interface
  
  interface hipblasDsyrBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="cublasDsyrBatched")
#else
    function hipblasDsyrBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="hipblasDsyrBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyrBatched_full_rank,&
      hipblasDsyrBatched_rank_0,&
      hipblasDsyrBatched_rank_1
#endif
  end interface
  
  interface hipblasCsyrBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="cublasCsyrBatched")
#else
    function hipblasCsyrBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="hipblasCsyrBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyrBatched_full_rank,&
      hipblasCsyrBatched_rank_0,&
      hipblasCsyrBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syrBatched performs a batch of matrix-vector operations
  !> 
  !>         A[i] := A[i] + alpha*x[i]*x[i]**T
  !> 
  !>     where alpha is a scalar, x is an array of vectors, and A is an array of
  !>     n by n symmetric matrices, for i = 1 , ... , batchCount
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZsyrBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="cublasZsyrBatched")
#else
    function hipblasZsyrBatched_(handle,uplo,n,alpha,x,incx,A,lda,batchCount) bind(c, name="hipblasZsyrBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyrBatched_full_rank,&
      hipblasZsyrBatched_rank_0,&
      hipblasZsyrBatched_rank_1
#endif
  end interface
  
  interface hipblasSsyrStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount) bind(c, name="cublasSsyrStridedBatched")
#else
    function hipblasSsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount) bind(c, name="hipblasSsyrStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyrStridedBatched_full_rank,&
      hipblasSsyrStridedBatched_rank_0,&
      hipblasSsyrStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDsyrStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount) bind(c, name="cublasDsyrStridedBatched")
#else
    function hipblasDsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount) bind(c, name="hipblasDsyrStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyrStridedBatched_full_rank,&
      hipblasDsyrStridedBatched_rank_0,&
      hipblasDsyrStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCsyrStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount) bind(c, name="cublasCsyrStridedBatched")
#else
    function hipblasCsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount) bind(c, name="hipblasCsyrStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyrStridedBatched_full_rank,&
      hipblasCsyrStridedBatched_rank_0,&
      hipblasCsyrStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syrStridedBatched performs the matrix-vector operations
  !> 
  !>         A[i] := A[i] + alpha*x[i]*x[i]**T
  !> 
  !>     where alpha is a scalar, vectors, and A is an array of
  !>     n by n symmetric matrices, for i = 1 , ... , batchCount
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               specifies the pointer increment between vectors (x_i) and (x_i+1).
  !>     @param[inout]
  !>     A         device pointer to the first matrix A_1.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA   [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>
  interface hipblasZsyrStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount) bind(c, name="cublasZsyrStridedBatched")
#else
    function hipblasZsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount) bind(c, name="hipblasZsyrStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyrStridedBatched_full_rank,&
      hipblasZsyrStridedBatched_rank_0,&
      hipblasZsyrStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSsyr2
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasSsyr2_v2")
#else
    function hipblasSsyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasSsyr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyr2_full_rank,&
      hipblasSsyr2_rank_0,&
      hipblasSsyr2_rank_1
#endif
  end interface
  
  interface hipblasDsyr2
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasDsyr2_v2")
#else
    function hipblasDsyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasDsyr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyr2_full_rank,&
      hipblasDsyr2_rank_0,&
      hipblasDsyr2_rank_1
#endif
  end interface
  
  interface hipblasCsyr2
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasCsyr2_v2")
#else
    function hipblasCsyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasCsyr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyr2_full_rank,&
      hipblasCsyr2_rank_0,&
      hipblasCsyr2_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr2 performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*y**T + alpha*y*x**T
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     n by n symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>
  interface hipblasZsyr2
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="cublasZsyr2_v2")
#else
    function hipblasZsyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="hipblasZsyr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyr2_full_rank,&
      hipblasZsyr2_rank_0,&
      hipblasZsyr2_rank_1
#endif
  end interface
  
  interface hipblasSsyr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasSsyr2Batched")
#else
    function hipblasSsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasSsyr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyr2Batched_full_rank,&
      hipblasSsyr2Batched_rank_0,&
      hipblasSsyr2Batched_rank_1
#endif
  end interface
  
  interface hipblasDsyr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasDsyr2Batched")
#else
    function hipblasDsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasDsyr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyr2Batched_full_rank,&
      hipblasDsyr2Batched_rank_0,&
      hipblasDsyr2Batched_rank_1
#endif
  end interface
  
  interface hipblasCsyr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasCsyr2Batched")
#else
    function hipblasCsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasCsyr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyr2Batched_full_rank,&
      hipblasCsyr2Batched_rank_0,&
      hipblasCsyr2Batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr2Batched performs a batch of matrix-vector operations
  !> 
  !>         A[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T
  !> 
  !>     where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
  !>     n by n symmetric matrix, for i = 1 , ... , batchCount
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZsyr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="cublasZsyr2Batched")
#else
    function hipblasZsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount) bind(c, name="hipblasZsyr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyr2Batched_full_rank,&
      hipblasZsyr2Batched_rank_0,&
      hipblasZsyr2Batched_rank_1
#endif
  end interface
  
  interface hipblasSsyr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasSsyr2StridedBatched")
#else
    function hipblasSsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasSsyr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyr2StridedBatched_full_rank,&
      hipblasSsyr2StridedBatched_rank_0,&
      hipblasSsyr2StridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDsyr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasDsyr2StridedBatched")
#else
    function hipblasDsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasDsyr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyr2StridedBatched_full_rank,&
      hipblasDsyr2StridedBatched_rank_0,&
      hipblasDsyr2StridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCsyr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasCsyr2StridedBatched")
#else
    function hipblasCsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasCsyr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyr2StridedBatched_full_rank,&
      hipblasCsyr2StridedBatched_rank_0,&
      hipblasCsyr2StridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr2StridedBatched the matrix-vector operations
  !> 
  !>         A[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T
  !> 
  !>     where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
  !>     n by n symmetric matrices, for i = 1 , ... , batchCount
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               specifies the pointer increment between vectors (x_i) and (x_i+1).
  !>     @param[in]
  !>     y         device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey   [hipblasStride]
  !>               specifies the pointer increment between vectors (y_i) and (y_i+1).
  !>     @param[inout]
  !>     A         device pointer to the first matrix A_1.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA   [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>
  interface hipblasZsyr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="cublasZsyr2StridedBatched")
#else
    function hipblasZsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount) bind(c, name="hipblasZsyr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyr2StridedBatched_full_rank,&
      hipblasZsyr2StridedBatched_rank_0,&
      hipblasZsyr2StridedBatched_rank_1
#endif
  end interface
  
  interface hipblasStbmv
#ifdef USE_CUDA_NAMES
    function hipblasStbmv_(handle,uplo,transA,diag,m,k,A,lda,x,incx) bind(c, name="cublasStbmv_v2")
#else
    function hipblasStbmv_(handle,uplo,transA,diag,m,k,A,lda,x,incx) bind(c, name="hipblasStbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStbmv_full_rank,&
      hipblasStbmv_rank_0,&
      hipblasStbmv_rank_1
#endif
  end interface
  
  interface hipblasDtbmv
#ifdef USE_CUDA_NAMES
    function hipblasDtbmv_(handle,uplo,transA,diag,m,k,A,lda,x,incx) bind(c, name="cublasDtbmv_v2")
#else
    function hipblasDtbmv_(handle,uplo,transA,diag,m,k,A,lda,x,incx) bind(c, name="hipblasDtbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtbmv_full_rank,&
      hipblasDtbmv_rank_0,&
      hipblasDtbmv_rank_1
#endif
  end interface
  
  interface hipblasCtbmv
#ifdef USE_CUDA_NAMES
    function hipblasCtbmv_(handle,uplo,transA,diag,m,k,A,lda,x,incx) bind(c, name="cublasCtbmv_v2")
#else
    function hipblasCtbmv_(handle,uplo,transA,diag,m,k,A,lda,x,incx) bind(c, name="hipblasCtbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtbmv_full_rank,&
      hipblasCtbmv_rank_0,&
      hipblasCtbmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbmv performs one of the matrix-vector operations
  !> 
  !>         x := A*x      or
  !>         x := A**T*x   or
  !>         x := A**H*x,
  !> 
  !>     x is a vectors and A is a banded m by m matrix (see description below).
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: A is an upper banded triangular matrix.
  !>               HIPBLAS_FILL_MODE_LOWER: A is a  lower banded triangular matrix.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether matrix A is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               HIPBLAS_DIAG_UNIT: The main diagonal of A is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               HIPBLAS_DIAG_NON_UNIT: No assumptions are made of A's main diagonal.
  !>     @param[in]
  !>     m         [int]
  !>               the number of rows and columns of the matrix represented by A.
  !>     @param[in]
  !>     k         [int]
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
  !>               of the matrix A.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
  !>               of the matrix A.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     A         device pointer storing banded triangular matrix A.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_UPPER; m = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_LOWER; m = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. lda must satisfy lda > k.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>
  interface hipblasZtbmv
#ifdef USE_CUDA_NAMES
    function hipblasZtbmv_(handle,uplo,transA,diag,m,k,A,lda,x,incx) bind(c, name="cublasZtbmv_v2")
#else
    function hipblasZtbmv_(handle,uplo,transA,diag,m,k,A,lda,x,incx) bind(c, name="hipblasZtbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtbmv_full_rank,&
      hipblasZtbmv_rank_0,&
      hipblasZtbmv_rank_1
#endif
  end interface
  
  interface hipblasStbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStbmvBatched_(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount) bind(c, name="cublasStbmvBatched")
#else
    function hipblasStbmvBatched_(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount) bind(c, name="hipblasStbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStbmvBatched_full_rank,&
      hipblasStbmvBatched_rank_0,&
      hipblasStbmvBatched_rank_1
#endif
  end interface
  
  interface hipblasDtbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtbmvBatched_(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount) bind(c, name="cublasDtbmvBatched")
#else
    function hipblasDtbmvBatched_(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount) bind(c, name="hipblasDtbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtbmvBatched_full_rank,&
      hipblasDtbmvBatched_rank_0,&
      hipblasDtbmvBatched_rank_1
#endif
  end interface
  
  interface hipblasCtbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtbmvBatched_(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount) bind(c, name="cublasCtbmvBatched")
#else
    function hipblasCtbmvBatched_(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount) bind(c, name="hipblasCtbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtbmvBatched_full_rank,&
      hipblasCtbmvBatched_rank_0,&
      hipblasCtbmvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbmvBatched performs one of the matrix-vector operations
  !> 
  !>         x_i := A_i*x_i      or
  !>         x_i := A_i**T*x_i   or
  !>         x_i := A_i**H*x_i,
  !> 
  !>     where (A_i, x_i) is the i-th instance of the batch.
  !>     x_i is a vector and A_i is an m by m matrix, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.
  !>               HIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether each matrix A_i is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               HIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               HIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.
  !>     @param[in]
  !>     m         [int]
  !>               the number of rows and columns of the matrix represented by each A_i.
  !>     @param[in]
  !>     k         [int]
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
  !>               of each matrix A_i.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
  !>               of each matrix A_i.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     A         device array of device pointers storing each banded triangular matrix A_i.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_UPPER; m = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_LOWER; m = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. lda must satisfy lda > k.
  !>     @param[inout]
  !>     x         device array of device pointer storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZtbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtbmvBatched_(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount) bind(c, name="cublasZtbmvBatched")
#else
    function hipblasZtbmvBatched_(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount) bind(c, name="hipblasZtbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtbmvBatched_full_rank,&
      hipblasZtbmvBatched_rank_0,&
      hipblasZtbmvBatched_rank_1
#endif
  end interface
  
  interface hipblasStbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStbmvStridedBatched_(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasStbmvStridedBatched")
#else
    function hipblasStbmvStridedBatched_(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasStbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStbmvStridedBatched_full_rank,&
      hipblasStbmvStridedBatched_rank_0,&
      hipblasStbmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDtbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtbmvStridedBatched_(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasDtbmvStridedBatched")
#else
    function hipblasDtbmvStridedBatched_(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasDtbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtbmvStridedBatched_full_rank,&
      hipblasDtbmvStridedBatched_rank_0,&
      hipblasDtbmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCtbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtbmvStridedBatched_(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtbmvStridedBatched")
#else
    function hipblasCtbmvStridedBatched_(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtbmvStridedBatched_full_rank,&
      hipblasCtbmvStridedBatched_rank_0,&
      hipblasCtbmvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbmvStridedBatched performs one of the matrix-vector operations
  !> 
  !>         x_i := A_i*x_i      or
  !>         x_i := A_i**T*x_i   or
  !>         x_i := A_i**H*x_i,
  !> 
  !>     where (A_i, x_i) is the i-th instance of the batch.
  !>     x_i is a vector and A_i is an m by m matrix, for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.
  !>               HIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether each matrix A_i is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               HIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               HIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.
  !>     @param[in]
  !>     m         [int]
  !>               the number of rows and columns of the matrix represented by each A_i.
  !>     @param[in]
  !>     k         [int]
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
  !>               of each matrix A_i.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
  !>               of each matrix A_i.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     A         device array to the first matrix A_i of the batch. Stores each banded triangular matrix A_i.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_UPPER; m = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_LOWER; m = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. lda must satisfy lda > k.
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[inout]
  !>     x         device array to the first vector x_i of the batch.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one x_i matrix to the next x_(i + 1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZtbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtbmvStridedBatched_(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtbmvStridedBatched")
#else
    function hipblasZtbmvStridedBatched_(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtbmvStridedBatched_full_rank,&
      hipblasZtbmvStridedBatched_rank_0,&
      hipblasZtbmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasStbsv
#ifdef USE_CUDA_NAMES
    function hipblasStbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="cublasStbsv_v2")
#else
    function hipblasStbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="hipblasStbsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStbsv_full_rank,&
      hipblasStbsv_rank_0,&
      hipblasStbsv_rank_1
#endif
  end interface
  
  interface hipblasDtbsv
#ifdef USE_CUDA_NAMES
    function hipblasDtbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="cublasDtbsv_v2")
#else
    function hipblasDtbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="hipblasDtbsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtbsv_full_rank,&
      hipblasDtbsv_rank_0,&
      hipblasDtbsv_rank_1
#endif
  end interface
  
  interface hipblasCtbsv
#ifdef USE_CUDA_NAMES
    function hipblasCtbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="cublasCtbsv_v2")
#else
    function hipblasCtbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="hipblasCtbsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtbsv_full_rank,&
      hipblasCtbsv_rank_0,&
      hipblasCtbsv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsv solves
  !> 
  !>          A*x = b or A**T*x = b or A**H*x = b,
  !> 
  !>     where x and b are vectors and A is a banded triangular matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !>                HIPBLAS_OP_N: Solves A*x = b
  !>                HIPBLAS_OP_T: Solves A**T*x = b
  !>                HIPBLAS_OP_C: Solves A**H*x = b
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of A are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of b. n >= 0.
  !>     @param[in]
  !>     k         [int]
  !>               if(uplo == HIPBLAS_FILL_MODE_UPPER)
  !>                 k specifies the number of super-diagonals of A.
  !>               if(uplo == HIPBLAS_FILL_MODE_LOWER)
  !>                 k specifies the number of sub-diagonals of A.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing the matrix A in banded format.
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>               lda >= (k + 1).
  !> 
  !>     @param[inout]
  !>     x         device pointer storing input vector b. Overwritten by the output vector x.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>
  interface hipblasZtbsv
#ifdef USE_CUDA_NAMES
    function hipblasZtbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="cublasZtbsv_v2")
#else
    function hipblasZtbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="hipblasZtbsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtbsv_full_rank,&
      hipblasZtbsv_rank_0,&
      hipblasZtbsv_rank_1
#endif
  end interface
  
  interface hipblasStbsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStbsvBatched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount) bind(c, name="cublasStbsvBatched")
#else
    function hipblasStbsvBatched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount) bind(c, name="hipblasStbsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStbsvBatched_full_rank,&
      hipblasStbsvBatched_rank_0,&
      hipblasStbsvBatched_rank_1
#endif
  end interface
  
  interface hipblasDtbsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtbsvBatched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount) bind(c, name="cublasDtbsvBatched")
#else
    function hipblasDtbsvBatched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount) bind(c, name="hipblasDtbsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtbsvBatched_full_rank,&
      hipblasDtbsvBatched_rank_0,&
      hipblasDtbsvBatched_rank_1
#endif
  end interface
  
  interface hipblasCtbsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtbsvBatched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount) bind(c, name="cublasCtbsvBatched")
#else
    function hipblasCtbsvBatched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount) bind(c, name="hipblasCtbsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtbsvBatched_full_rank,&
      hipblasCtbsvBatched_rank_0,&
      hipblasCtbsvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsvBatched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a banded triangular matrix,
  !>     for i = [1, batchCount].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !>                HIPBLAS_OP_N: Solves A_i*x_i = b_i
  !>                HIPBLAS_OP_T: Solves A_i**T*x_i = b_i
  !>                HIPBLAS_OP_C: Solves A_i**H*x_i = b_i
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !>     @param[in]
  !>     k         [int]
  !>               if(uplo == HIPBLAS_FILL_MODE_UPPER)
  !>                 k specifies the number of super-diagonals of each A_i.
  !>               if(uplo == HIPBLAS_FILL_MODE_LOWER)
  !>                 k specifies the number of sub-diagonals of each A_i.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     A         device vector of device pointers storing each matrix A_i in banded format.
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>               lda >= (k + 1).
  !> 
  !>     @param[inout]
  !>     x         device vector of device pointers storing each input vector b_i. Overwritten by each output
  !>               vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZtbsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtbsvBatched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount) bind(c, name="cublasZtbsvBatched")
#else
    function hipblasZtbsvBatched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount) bind(c, name="hipblasZtbsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtbsvBatched_full_rank,&
      hipblasZtbsvBatched_rank_0,&
      hipblasZtbsvBatched_rank_1
#endif
  end interface
  
  interface hipblasStbsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStbsvStridedBatched_(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasStbsvStridedBatched")
#else
    function hipblasStbsvStridedBatched_(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasStbsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStbsvStridedBatched_full_rank,&
      hipblasStbsvStridedBatched_rank_0,&
      hipblasStbsvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDtbsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtbsvStridedBatched_(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasDtbsvStridedBatched")
#else
    function hipblasDtbsvStridedBatched_(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasDtbsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtbsvStridedBatched_full_rank,&
      hipblasDtbsvStridedBatched_rank_0,&
      hipblasDtbsvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCtbsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtbsvStridedBatched_(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtbsvStridedBatched")
#else
    function hipblasCtbsvStridedBatched_(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtbsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtbsvStridedBatched_full_rank,&
      hipblasCtbsvStridedBatched_rank_0,&
      hipblasCtbsvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsvStridedBatched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a banded triangular matrix,
  !>     for i = [1, batchCount].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !>                HIPBLAS_OP_N: Solves A_i*x_i = b_i
  !>                HIPBLAS_OP_T: Solves A_i**T*x_i = b_i
  !>                HIPBLAS_OP_C: Solves A_i**H*x_i = b_i
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !>     @param[in]
  !>     k         [int]
  !>               if(uplo == HIPBLAS_FILL_MODE_UPPER)
  !>                 k specifies the number of super-diagonals of each A_i.
  !>               if(uplo == HIPBLAS_FILL_MODE_LOWER)
  !>                 k specifies the number of sub-diagonals of each A_i.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer pointing to the first banded matrix A_1.
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>               lda >= (k + 1).
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               specifies the distance between the start of one matrix (A_i) and the next (A_i+1).
  !> 
  !>     @param[inout]
  !>     x         device pointer pointing to the first input vector b_1. Overwritten by output vectors x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               specifies the distance between the start of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZtbsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtbsvStridedBatched_(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtbsvStridedBatched")
#else
    function hipblasZtbsvStridedBatched_(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtbsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtbsvStridedBatched_full_rank,&
      hipblasZtbsvStridedBatched_rank_0,&
      hipblasZtbsvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasStpmv
#ifdef USE_CUDA_NAMES
    function hipblasStpmv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="cublasStpmv_v2")
#else
    function hipblasStpmv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="hipblasStpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStpmv_rank_0,&
      hipblasStpmv_rank_1
#endif
  end interface
  
  interface hipblasDtpmv
#ifdef USE_CUDA_NAMES
    function hipblasDtpmv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="cublasDtpmv_v2")
#else
    function hipblasDtpmv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="hipblasDtpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtpmv_rank_0,&
      hipblasDtpmv_rank_1
#endif
  end interface
  
  interface hipblasCtpmv
#ifdef USE_CUDA_NAMES
    function hipblasCtpmv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="cublasCtpmv_v2")
#else
    function hipblasCtpmv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="hipblasCtpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtpmv_rank_0,&
      hipblasCtpmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpmv performs one of the matrix-vector operations
  !> 
  !>          x = A*x or x = A**T*x,
  !> 
  !>     where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix, supplied in the pack form.
  !> 
  !>     The vector x is overwritten.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of A. m >= 0.
  !> 
  !>     @param[in]
  !>     A       device pointer storing matrix A,
  !>             of dimension at leat ( m * ( m + 1 ) 2 ).
  !>           Before entry with uplo = HIPBLAS_FILL_MODE_UPPER, the array A
  !>           must contain the upper triangular matrix packed sequentially,
  !>           column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
  !>           a_{0,1} and a_{1, 1} respectively, and so on.
  !>           Before entry with uplo = HIPBLAS_FILL_MODE_LOWER, the array A
  !>           must contain the lower triangular matrix packed sequentially,
  !>           column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
  !>           a_{1,0} and a_{2,0} respectively, and so on.
  !>           Note that when DIAG = HIPBLAS_DIAG_UNIT, the diagonal elements of A are
  !>           not referenced, but are assumed to be unity.
  !> 
  !>     @param[in]
  !>     x       device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment for the elements of x. incx must not be zero.
  !>
  interface hipblasZtpmv
#ifdef USE_CUDA_NAMES
    function hipblasZtpmv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="cublasZtpmv_v2")
#else
    function hipblasZtpmv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="hipblasZtpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtpmv_rank_0,&
      hipblasZtpmv_rank_1
#endif
  end interface
  
  interface hipblasStpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStpmvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="cublasStpmvBatched")
#else
    function hipblasStpmvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="hipblasStpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStpmvBatched_full_rank,&
      hipblasStpmvBatched_rank_0,&
      hipblasStpmvBatched_rank_1
#endif
  end interface
  
  interface hipblasDtpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtpmvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="cublasDtpmvBatched")
#else
    function hipblasDtpmvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="hipblasDtpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtpmvBatched_full_rank,&
      hipblasDtpmvBatched_rank_0,&
      hipblasDtpmvBatched_rank_1
#endif
  end interface
  
  interface hipblasCtpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtpmvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="cublasCtpmvBatched")
#else
    function hipblasCtpmvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="hipblasCtpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtpmvBatched_full_rank,&
      hipblasCtpmvBatched_rank_0,&
      hipblasCtpmvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpmvBatched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [int]
  !>               m specifies the number of rows of matrices A_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing pointer of matrices A_i,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     x         device pointer storing vectors x_i.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of vectors x_i.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>               The number of batched matrices/vectors.
  !> 
  !>
  interface hipblasZtpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtpmvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="cublasZtpmvBatched")
#else
    function hipblasZtpmvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="hipblasZtpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtpmvBatched_full_rank,&
      hipblasZtpmvBatched_rank_0,&
      hipblasZtpmvBatched_rank_1
#endif
  end interface
  
  interface hipblasStpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount) bind(c, name="cublasStpmvStridedBatched")
#else
    function hipblasStpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount) bind(c, name="hipblasStpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStpmvStridedBatched_rank_0,&
      hipblasStpmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDtpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount) bind(c, name="cublasDtpmvStridedBatched")
#else
    function hipblasDtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount) bind(c, name="hipblasDtpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtpmvStridedBatched_rank_0,&
      hipblasDtpmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCtpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount) bind(c, name="cublasCtpmvStridedBatched")
#else
    function hipblasCtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount) bind(c, name="hipblasCtpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtpmvStridedBatched_rank_0,&
      hipblasCtpmvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpmvStridedBatched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !>     with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [int]
  !>               m specifies the number of rows of matrices A_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer of the matrix A_0,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one A_i matrix to the next A_{i + 1}
  !> 
  !>     @param[in]
  !>     x         device pointer storing the vector x_0.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of one vector x.
  !> 
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one x_i vector to the next x_{i + 1}
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>               The number of batched matrices/vectors.
  !> 
  !>
  interface hipblasZtpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount) bind(c, name="cublasZtpmvStridedBatched")
#else
    function hipblasZtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount) bind(c, name="hipblasZtpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtpmvStridedBatched_rank_0,&
      hipblasZtpmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasStpsv
#ifdef USE_CUDA_NAMES
    function hipblasStpsv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="cublasStpsv_v2")
#else
    function hipblasStpsv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="hipblasStpsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStpsv_rank_0,&
      hipblasStpsv_rank_1
#endif
  end interface
  
  interface hipblasDtpsv
#ifdef USE_CUDA_NAMES
    function hipblasDtpsv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="cublasDtpsv_v2")
#else
    function hipblasDtpsv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="hipblasDtpsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtpsv_rank_0,&
      hipblasDtpsv_rank_1
#endif
  end interface
  
  interface hipblasCtpsv
#ifdef USE_CUDA_NAMES
    function hipblasCtpsv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="cublasCtpsv_v2")
#else
    function hipblasCtpsv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="hipblasCtpsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtpsv_rank_0,&
      hipblasCtpsv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpsv solves
  !> 
  !>          A*x = b or A**T*x = b, or A**H*x = b,
  !> 
  !>     where x and b are vectors and A is a triangular matrix stored in the packed format.
  !> 
  !>     The input vector b is overwritten by the output vector x.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: Solves A*x = b
  !>             HIPBLAS_OP_T: Solves A**T*x = b
  !>             HIPBLAS_OP_C: Solves A**H*x = b
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of A are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of b. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer storing the packed version of matrix A,
  !>               of dimension >= (n * (n + 1) 2)
  !> 
  !>     @param[inout]
  !>     x         device pointer storing vector b on input, overwritten by x on output.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>
  interface hipblasZtpsv
#ifdef USE_CUDA_NAMES
    function hipblasZtpsv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="cublasZtpsv_v2")
#else
    function hipblasZtpsv_(handle,uplo,transA,diag,m,AP,x,incx) bind(c, name="hipblasZtpsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtpsv_rank_0,&
      hipblasZtpsv_rank_1
#endif
  end interface
  
  interface hipblasStpsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStpsvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="cublasStpsvBatched")
#else
    function hipblasStpsvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="hipblasStpsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStpsvBatched_full_rank,&
      hipblasStpsvBatched_rank_0,&
      hipblasStpsvBatched_rank_1
#endif
  end interface
  
  interface hipblasDtpsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtpsvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="cublasDtpsvBatched")
#else
    function hipblasDtpsvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="hipblasDtpsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtpsvBatched_full_rank,&
      hipblasDtpsvBatched_rank_0,&
      hipblasDtpsvBatched_rank_1
#endif
  end interface
  
  interface hipblasCtpsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtpsvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="cublasCtpsvBatched")
#else
    function hipblasCtpsvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="hipblasCtpsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtpsvBatched_full_rank,&
      hipblasCtpsvBatched_rank_0,&
      hipblasCtpsvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpsvBatched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
  !>     for i in [1, batchCount].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: Solves A*x = b
  !>             HIPBLAS_OP_T: Solves A**T*x = b
  !>             HIPBLAS_OP_C: Solves A**H*x = b
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device array of device pointers storing the packed versions of each matrix A_i,
  !>               of dimension >= (n * (n + 1) 2)
  !> 
  !>     @param[inout]
  !>     x         device array of device pointers storing each input vector b_i, overwritten by x_i on output.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of instances in the batch.
  !>
  interface hipblasZtpsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtpsvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="cublasZtpsvBatched")
#else
    function hipblasZtpsvBatched_(handle,uplo,transA,diag,m,AP,x,incx,batchCount) bind(c, name="hipblasZtpsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtpsvBatched_full_rank,&
      hipblasZtpsvBatched_rank_0,&
      hipblasZtpsvBatched_rank_1
#endif
  end interface
  
  interface hipblasStpsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount) bind(c, name="cublasStpsvStridedBatched")
#else
    function hipblasStpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount) bind(c, name="hipblasStpsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStpsvStridedBatched_rank_0,&
      hipblasStpsvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDtpsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount) bind(c, name="cublasDtpsvStridedBatched")
#else
    function hipblasDtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount) bind(c, name="hipblasDtpsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtpsvStridedBatched_rank_0,&
      hipblasDtpsvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCtpsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount) bind(c, name="cublasCtpsvStridedBatched")
#else
    function hipblasCtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount) bind(c, name="hipblasCtpsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtpsvStridedBatched_rank_0,&
      hipblasCtpsvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpsvStridedBatched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
  !>     for i in [1, batchCount].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: Solves A*x = b
  !>             HIPBLAS_OP_T: Solves A**T*x = b
  !>             HIPBLAS_OP_C: Solves A**H*x = b
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer pointing to the first packed matrix A_1,
  !>               of dimension >= (n * (n + 1) 2)
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the beginning of one packed matrix (AP_i) and the next (AP_i+1).
  !> 
  !>     @param[inout]
  !>     x         device pointer pointing to the first input vector b_1. Overwritten by each x_i on output.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the beginning of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of instances in the batch.
  !>
  interface hipblasZtpsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount) bind(c, name="cublasZtpsvStridedBatched")
#else
    function hipblasZtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount) bind(c, name="hipblasZtpsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideAP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtpsvStridedBatched_rank_0,&
      hipblasZtpsvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasStrmv
#ifdef USE_CUDA_NAMES
    function hipblasStrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="cublasStrmv_v2")
#else
    function hipblasStrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="hipblasStrmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrmv_full_rank,&
      hipblasStrmv_rank_0,&
      hipblasStrmv_rank_1
#endif
  end interface
  
  interface hipblasDtrmv
#ifdef USE_CUDA_NAMES
    function hipblasDtrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="cublasDtrmv_v2")
#else
    function hipblasDtrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="hipblasDtrmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrmv_full_rank,&
      hipblasDtrmv_rank_0,&
      hipblasDtrmv_rank_1
#endif
  end interface
  
  interface hipblasCtrmv
#ifdef USE_CUDA_NAMES
    function hipblasCtrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="cublasCtrmv_v2")
#else
    function hipblasCtrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="hipblasCtrmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrmv_full_rank,&
      hipblasCtrmv_rank_0,&
      hipblasCtrmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trmv performs one of the matrix-vector operations
  !> 
  !>          x = A*x or x = A**T*x,
  !> 
  !>     where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.
  !> 
  !>     The vector x is overwritten.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [int]
  !>               m specifies the number of rows of A. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing matrix A,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>               lda = max( 1, m ).
  !> 
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>
  interface hipblasZtrmv
#ifdef USE_CUDA_NAMES
    function hipblasZtrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="cublasZtrmv_v2")
#else
    function hipblasZtrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="hipblasZtrmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrmv_full_rank,&
      hipblasZtrmv_rank_0,&
      hipblasZtrmv_rank_1
#endif
  end interface
  
  interface hipblasStrmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrmvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="cublasStrmvBatched")
#else
    function hipblasStrmvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="hipblasStrmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrmvBatched_full_rank,&
      hipblasStrmvBatched_rank_0,&
      hipblasStrmvBatched_rank_1
#endif
  end interface
  
  interface hipblasDtrmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrmvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="cublasDtrmvBatched")
#else
    function hipblasDtrmvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="hipblasDtrmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrmvBatched_full_rank,&
      hipblasDtrmvBatched_rank_0,&
      hipblasDtrmvBatched_rank_1
#endif
  end interface
  
  interface hipblasCtrmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrmvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="cublasCtrmvBatched")
#else
    function hipblasCtrmvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="hipblasCtrmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrmvBatched_full_rank,&
      hipblasCtrmvBatched_rank_0,&
      hipblasCtrmvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trmvBatched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [int]
  !>               m specifies the number of rows of matrices A_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing pointer of matrices A_i,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A_i.
  !>               lda >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     x         device pointer storing vectors x_i.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of vectors x_i.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>               The number of batched matrices/vectors.
  !> 
  !>
  interface hipblasZtrmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrmvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="cublasZtrmvBatched")
#else
    function hipblasZtrmvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="hipblasZtrmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrmvBatched_full_rank,&
      hipblasZtrmvBatched_rank_0,&
      hipblasZtrmvBatched_rank_1
#endif
  end interface
  
  interface hipblasStrmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrmvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasStrmvStridedBatched")
#else
    function hipblasStrmvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasStrmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrmvStridedBatched_full_rank,&
      hipblasStrmvStridedBatched_rank_0,&
      hipblasStrmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDtrmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrmvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasDtrmvStridedBatched")
#else
    function hipblasDtrmvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasDtrmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrmvStridedBatched_full_rank,&
      hipblasDtrmvStridedBatched_rank_0,&
      hipblasDtrmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCtrmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrmvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtrmvStridedBatched")
#else
    function hipblasCtrmvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtrmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrmvStridedBatched_full_rank,&
      hipblasCtrmvStridedBatched_rank_0,&
      hipblasCtrmvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trmvStridedBatched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !>     with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [int]
  !>               m specifies the number of rows of matrices A_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer of the matrix A_0,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A_i.
  !>               lda >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one A_i matrix to the next A_{i + 1}
  !> 
  !>     @param[in]
  !>     x         device pointer storing the vector x_0.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of one vector x.
  !> 
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one x_i vector to the next x_{i + 1}
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>               The number of batched matrices/vectors.
  !> 
  !>
  interface hipblasZtrmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrmvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtrmvStridedBatched")
#else
    function hipblasZtrmvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtrmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrmvStridedBatched_full_rank,&
      hipblasZtrmvStridedBatched_rank_0,&
      hipblasZtrmvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasStrsv
#ifdef USE_CUDA_NAMES
    function hipblasStrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="cublasStrsv_v2")
#else
    function hipblasStrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="hipblasStrsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrsv_full_rank,&
      hipblasStrsv_rank_0,&
      hipblasStrsv_rank_1
#endif
  end interface
  
  interface hipblasDtrsv
#ifdef USE_CUDA_NAMES
    function hipblasDtrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="cublasDtrsv_v2")
#else
    function hipblasDtrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="hipblasDtrsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrsv_full_rank,&
      hipblasDtrsv_rank_0,&
      hipblasDtrsv_rank_1
#endif
  end interface
  
  interface hipblasCtrsv
#ifdef USE_CUDA_NAMES
    function hipblasCtrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="cublasCtrsv_v2")
#else
    function hipblasCtrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="hipblasCtrsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrsv_full_rank,&
      hipblasCtrsv_rank_0,&
      hipblasCtrsv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsv solves
  !> 
  !>          A*x = b or A**T*x = b,
  !> 
  !>     where x and b are vectors and A is a triangular matrix.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [int]
  !>               m specifies the number of rows of b. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing matrix A,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>               lda = max( 1, m ).
  !> 
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>
  interface hipblasZtrsv
#ifdef USE_CUDA_NAMES
    function hipblasZtrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="cublasZtrsv_v2")
#else
    function hipblasZtrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="hipblasZtrsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrsv_full_rank,&
      hipblasZtrsv_rank_0,&
      hipblasZtrsv_rank_1
#endif
  end interface
  
  interface hipblasStrsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrsvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="cublasStrsvBatched")
#else
    function hipblasStrsvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="hipblasStrsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrsvBatched_full_rank,&
      hipblasStrsvBatched_rank_0,&
      hipblasStrsvBatched_rank_1
#endif
  end interface
  
  interface hipblasDtrsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrsvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="cublasDtrsvBatched")
#else
    function hipblasDtrsvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="hipblasDtrsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrsvBatched_full_rank,&
      hipblasDtrsvBatched_rank_0,&
      hipblasDtrsvBatched_rank_1
#endif
  end interface
  
  interface hipblasCtrsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrsvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="cublasCtrsvBatched")
#else
    function hipblasCtrsvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="hipblasCtrsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrsvBatched_full_rank,&
      hipblasCtrsvBatched_rank_0,&
      hipblasCtrsvBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsvBatched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i,
  !> 
  !>     where (A_i, x_i, b_i) is the i-th instance of the batch.
  !>     x_i and b_i are vectors and A_i is an
  !>     m by m triangular matrix.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [int]
  !>               m specifies the number of rows of b. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i.
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>               lda = max(1, m)
  !> 
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZtrsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrsvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="cublasZtrsvBatched")
#else
    function hipblasZtrsvBatched_(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount) bind(c, name="hipblasZtrsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrsvBatched_full_rank,&
      hipblasZtrsvBatched_rank_0,&
      hipblasZtrsvBatched_rank_1
#endif
  end interface
  
  interface hipblasStrsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrsvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasStrsvStridedBatched")
#else
    function hipblasStrsvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasStrsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrsvStridedBatched_full_rank,&
      hipblasStrsvStridedBatched_rank_0,&
      hipblasStrsvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDtrsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrsvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasDtrsvStridedBatched")
#else
    function hipblasDtrsvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasDtrsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrsvStridedBatched_full_rank,&
      hipblasDtrsvStridedBatched_rank_0,&
      hipblasDtrsvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCtrsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrsvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtrsvStridedBatched")
#else
    function hipblasCtrsvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtrsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrsvStridedBatched_full_rank,&
      hipblasCtrsvStridedBatched_rank_0,&
      hipblasCtrsvStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsvStridedBatched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i,
  !> 
  !>     where (A_i, x_i, b_i) is the i-th instance of the batch.
  !>     x_i and b_i are vectors and A_i is an m by m triangular matrix, for i = 1, ..., batchCount.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [int]
  !>               m specifies the number of rows of each b_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer to the first matrix (A_1) in the batch, of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1)
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>               lda = max( 1, m ).
  !> 
  !>     @param[in, out]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !> 
  !>     @param[in]
  !>     stridex [hipblasStride]
  !>              stride from the start of one x_i vector to the next x_(i + 1)
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZtrsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrsvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtrsvStridedBatched")
#else
    function hipblasZtrsvStridedBatched_(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtrsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrsvStridedBatched_full_rank,&
      hipblasZtrsvStridedBatched_rank_0,&
      hipblasZtrsvStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSgemm
#ifdef USE_CUDA_NAMES
    function hipblasSgemm_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasSgemm_v2")
#else
    function hipblasSgemm_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasSgemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgemm_full_rank,&
      hipblasSgemm_rank_0,&
      hipblasSgemm_rank_1
#endif
  end interface
  
  interface hipblasDgemm
#ifdef USE_CUDA_NAMES
    function hipblasDgemm_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasDgemm_v2")
#else
    function hipblasDgemm_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasDgemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgemm_full_rank,&
      hipblasDgemm_rank_0,&
      hipblasDgemm_rank_1
#endif
  end interface
  
  interface hipblasCgemm
#ifdef USE_CUDA_NAMES
    function hipblasCgemm_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasCgemm_v2")
#else
    function hipblasCgemm_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasCgemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgemm_full_rank,&
      hipblasCgemm_rank_0,&
      hipblasCgemm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     gemm performs one of the matrix-matrix operations
  !> 
  !>         C = alpha*op( A )*op( B ) + beta*C,
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !> 
  !>     alpha and beta are scalars, and A, B and C are matrices, with
  !>     op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [int]
  !>               number or rows of matrices op( A ) and C
  !>     @param[in]
  !>     n         [int]
  !>               number of columns of matrices op( B ) and C
  !>     @param[in]
  !>     k         [int]
  !>               number of columns of matrix op( A ) and number of rows of matrix op( B )
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     B         device pointer storing matrix B.
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of B.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in, out]
  !>     C         device pointer storing matrix C on the GPU.
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !>
  interface hipblasZgemm
#ifdef USE_CUDA_NAMES
    function hipblasZgemm_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasZgemm_v2")
#else
    function hipblasZgemm_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasZgemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgemm_full_rank,&
      hipblasZgemm_rank_0,&
      hipblasZgemm_rank_1
#endif
  end interface
  
  interface hipblasSgemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgemmBatched_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasSgemmBatched")
#else
    function hipblasSgemmBatched_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasSgemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgemmBatched_full_rank,&
      hipblasSgemmBatched_rank_0,&
      hipblasSgemmBatched_rank_1
#endif
  end interface
  
  interface hipblasDgemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgemmBatched_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasDgemmBatched")
#else
    function hipblasDgemmBatched_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasDgemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgemmBatched_full_rank,&
      hipblasDgemmBatched_rank_0,&
      hipblasDgemmBatched_rank_1
#endif
  end interface
  
  interface hipblasCgemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgemmBatched_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasCgemmBatched")
#else
    function hipblasCgemmBatched_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasCgemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgemmBatched_full_rank,&
      hipblasCgemmBatched_rank_0,&
      hipblasCgemmBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !>      \details
  !>     gemmBatched performs one of the batched matrix-matrix operations
  !>          C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batchCount.
  !>      where op( X ) is one of
  !>          op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !>      alpha and beta are scalars, and A, B and C are strided batched matrices, with
  !>     op( A ) an m by k by batchCount strided_batched matrix,
  !>     op( B ) an k by n by batchCount strided_batched matrix and
  !>     C an m by n by batchCount strided_batched matrix.
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimention m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimention n.
  !>     @param[in]
  !>     k         [int]
  !>               matrix dimention k.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     B         device array of device pointers storing each matrix B_i.
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of each B_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in, out]
  !>     C         device array of device pointers storing each matrix C_i.
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of each C_i.
  !>     @param[in]
  !>     batchCount
  !>               [int]
  !>               number of gemm operations in the batch
  interface hipblasZgemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgemmBatched_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasZgemmBatched")
#else
    function hipblasZgemmBatched_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasZgemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgemmBatched_full_rank,&
      hipblasZgemmBatched_rank_0,&
      hipblasZgemmBatched_rank_1
#endif
  end interface
  
  interface hipblasSgemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasSgemmStridedBatched")
#else
    function hipblasSgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasSgemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_long_long),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_long_long),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_long_long),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgemmStridedBatched_full_rank,&
      hipblasSgemmStridedBatched_rank_0,&
      hipblasSgemmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDgemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasDgemmStridedBatched")
#else
    function hipblasDgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasDgemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_long_long),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_long_long),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_long_long),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgemmStridedBatched_full_rank,&
      hipblasDgemmStridedBatched_rank_0,&
      hipblasDgemmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCgemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasCgemmStridedBatched")
#else
    function hipblasCgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasCgemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_long_long),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_long_long),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_long_long),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgemmStridedBatched_full_rank,&
      hipblasCgemmStridedBatched_rank_0,&
      hipblasCgemmStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     gemmStridedBatched performs one of the strided batched matrix-matrix operations
  !> 
  !>         C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batchCount.
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !> 
  !>     alpha and beta are scalars, and A, B and C are strided batched matrices, with
  !>     op( A ) an m by k by batchCount strided_batched matrix,
  !>     op( B ) an k by n by batchCount strided_batched matrix and
  !>     C an m by n by batchCount strided_batched matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimention m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimention n.
  !>     @param[in]
  !>     k         [int]
  !>               matrix dimention k.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device pointer pointing to the first matrix A_1.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[in]
  !>     B         device pointer pointing to the first matrix B_1.
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of each B_i.
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one B_i matrix to the next B_(i + 1).
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in, out]
  !>     C         device pointer pointing to the first matrix C_1.
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of each C_i.
  !>     @param[in]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one C_i matrix to the next C_(i + 1).
  !>     @param[in]
  !>     batchCount
  !>               [int]
  !>               number of gemm operatons in the batch
  !>
  interface hipblasZgemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasZgemmStridedBatched")
#else
    function hipblasZgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasZgemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_long_long),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_long_long),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_long_long),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgemmStridedBatched_full_rank,&
      hipblasZgemmStridedBatched_rank_0,&
      hipblasZgemmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCherk
#ifdef USE_CUDA_NAMES
    function hipblasCherk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="cublasCherk_v2")
#else
    function hipblasCherk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="hipblasCherk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCherk_full_rank,&
      hipblasCherk_rank_0,&
      hipblasCherk_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herk performs one of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C := alpha*op( A )*op( A )^H + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A,  and A is n by k if transA == HIPBLAS_OP_N
  !>         op( A ) = A^H and A is k by n if transA == HIPBLAS_OP_C
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C:  op(A) = A^H
  !>             HIPBLAS_ON_N:  op(A) = A
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface hipblasZherk
#ifdef USE_CUDA_NAMES
    function hipblasZherk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="cublasZherk_v2")
#else
    function hipblasZherk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="hipblasZherk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZherk_full_rank,&
      hipblasZherk_rank_0,&
      hipblasZherk_rank_1
#endif
  end interface
  
  interface hipblasCherkBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="cublasCherkBatched")
#else
    function hipblasCherkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="hipblasCherkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCherkBatched_full_rank,&
      hipblasCherkBatched_rank_0,&
      hipblasCherkBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( A_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op(A) = A^H
  !>             HIPBLAS_OP_N: op(A) = A
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZherkBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="cublasZherkBatched")
#else
    function hipblasZherkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="hipblasZherkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZherkBatched_full_rank,&
      hipblasZherkBatched_rank_0,&
      hipblasZherkBatched_rank_1
#endif
  end interface
  
  interface hipblasCherkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="cublasCherkStridedBatched")
#else
    function hipblasCherkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasCherkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCherkStridedBatched_full_rank,&
      hipblasCherkStridedBatched_rank_0,&
      hipblasCherkStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( A_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C
  !> 
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op(A) = A^H
  !>             HIPBLAS_OP_N: op(A) = A
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZherkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="cublasZherkStridedBatched")
#else
    function hipblasZherkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasZherkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZherkStridedBatched_full_rank,&
      hipblasZherkStridedBatched_rank_0,&
      hipblasZherkStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCherkx
#ifdef USE_CUDA_NAMES
    function hipblasCherkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasCherkx")
#else
    function hipblasCherkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasCherkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCherkx_full_rank,&
      hipblasCherkx_rank_0,&
      hipblasCherkx_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkx performs one of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C := alpha*op( A )*op( B )^H + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.
  !> 
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
  !>         op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H
  !>             HIPBLAS_OP_N:  op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface hipblasZherkx
#ifdef USE_CUDA_NAMES
    function hipblasZherkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasZherkx")
#else
    function hipblasZherkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasZherkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZherkx_full_rank,&
      hipblasZherkx_rank_0,&
      hipblasZherkx_rank_1
#endif
  end interface
  
  interface hipblasCherkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasCherkxBatched")
#else
    function hipblasCherkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasCherkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCherkxBatched_full_rank,&
      hipblasCherkxBatched_rank_0,&
      hipblasCherkxBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkxBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op(A) = A^H
  !>             HIPBLAS_OP_N: op(A) = A
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZherkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasZherkxBatched")
#else
    function hipblasZherkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasZherkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZherkxBatched_full_rank,&
      hipblasZherkxBatched_rank_0,&
      hipblasZherkxBatched_rank_1
#endif
  end interface
  
  interface hipblasCherkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasCherkxStridedBatched")
#else
    function hipblasCherkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasCherkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCherkxStridedBatched_full_rank,&
      hipblasCherkxStridedBatched_rank_0,&
      hipblasCherkxStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkxStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H
  !>             HIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZherkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasZherkxStridedBatched")
#else
    function hipblasZherkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasZherkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZherkxStridedBatched_full_rank,&
      hipblasZherkxStridedBatched_rank_0,&
      hipblasZherkxStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCher2k
#ifdef USE_CUDA_NAMES
    function hipblasCher2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasCher2k_v2")
#else
    function hipblasCher2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasCher2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCher2k_full_rank,&
      hipblasCher2k_rank_0,&
      hipblasCher2k_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2k performs one of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C := alpha*op( A )*op( B )^H + conj(alpha)*op( B )*op( A )^H + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
  !>         op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H
  !>             HIPBLAS_OP_N:  op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface hipblasZher2k
#ifdef USE_CUDA_NAMES
    function hipblasZher2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasZher2k_v2")
#else
    function hipblasZher2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasZher2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZher2k_full_rank,&
      hipblasZher2k_rank_0,&
      hipblasZher2k_rank_1
#endif
  end interface
  
  interface hipblasCher2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasCher2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasCher2kBatched")
#else
    function hipblasCher2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasCher2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCher2kBatched_full_rank,&
      hipblasCher2kBatched_rank_0,&
      hipblasCher2kBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2kBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op(A) = A^H
  !>             HIPBLAS_OP_N: op(A) = A
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZher2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasZher2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasZher2kBatched")
#else
    function hipblasZher2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasZher2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZher2kBatched_full_rank,&
      hipblasZher2kBatched_rank_0,&
      hipblasZher2kBatched_rank_1
#endif
  end interface
  
  interface hipblasCher2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCher2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasCher2kStridedBatched")
#else
    function hipblasCher2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasCher2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCher2kStridedBatched_full_rank,&
      hipblasCher2kStridedBatched_rank_0,&
      hipblasCher2kStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2kStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H
  !>             HIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZher2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZher2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasZher2kStridedBatched")
#else
    function hipblasZher2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasZher2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZher2kStridedBatched_full_rank,&
      hipblasZher2kStridedBatched_rank_0,&
      hipblasZher2kStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSsymm
#ifdef USE_CUDA_NAMES
    function hipblasSsymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasSsymm_v2")
#else
    function hipblasSsymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasSsymm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsymm_full_rank,&
      hipblasSsymm_rank_0,&
      hipblasSsymm_rank_1
#endif
  end interface
  
  interface hipblasDsymm
#ifdef USE_CUDA_NAMES
    function hipblasDsymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasDsymm_v2")
#else
    function hipblasDsymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasDsymm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsymm_full_rank,&
      hipblasDsymm_rank_0,&
      hipblasDsymm_rank_1
#endif
  end interface
  
  interface hipblasCsymm
#ifdef USE_CUDA_NAMES
    function hipblasCsymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasCsymm_v2")
#else
    function hipblasCsymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasCsymm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsymm_full_rank,&
      hipblasCsymm_rank_0,&
      hipblasCsymm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symm performs one of the matrix-matrix operations:
  !> 
  !>     C := alpha*A*B + beta*C if side == HIPBLAS_SIDE_LEFT,
  !>     C := alpha*B*A + beta*C if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B and C are m by n matrices, and
  !>     A is a symmetric matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C := alpha*A*B + beta*C
  !>             HIPBLAS_SIDE_RIGHT:     C := alpha*B*A + beta*C
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B and C. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B and C. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A and B are not referenced.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             A is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !>
  interface hipblasZsymm
#ifdef USE_CUDA_NAMES
    function hipblasZsymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasZsymm_v2")
#else
    function hipblasZsymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasZsymm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsymm_full_rank,&
      hipblasZsymm_rank_0,&
      hipblasZsymm_rank_1
#endif
  end interface
  
  interface hipblasSsymmBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsymmBatched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasSsymmBatched")
#else
    function hipblasSsymmBatched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasSsymmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsymmBatched_full_rank,&
      hipblasSsymmBatched_rank_0,&
      hipblasSsymmBatched_rank_1
#endif
  end interface
  
  interface hipblasDsymmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsymmBatched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasDsymmBatched")
#else
    function hipblasDsymmBatched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasDsymmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsymmBatched_full_rank,&
      hipblasDsymmBatched_rank_0,&
      hipblasDsymmBatched_rank_1
#endif
  end interface
  
  interface hipblasCsymmBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsymmBatched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasCsymmBatched")
#else
    function hipblasCsymmBatched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasCsymmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsymmBatched_full_rank,&
      hipblasCsymmBatched_rank_0,&
      hipblasCsymmBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symmBatched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
  !>     C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a symmetric matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
  !>             HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix A_i on the GPU.
  !>             A_i is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A_i is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C_i need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C_i. ldc >= max( 1, m )
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZsymmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsymmBatched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasZsymmBatched")
#else
    function hipblasZsymmBatched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasZsymmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsymmBatched_full_rank,&
      hipblasZsymmBatched_rank_0,&
      hipblasZsymmBatched_rank_1
#endif
  end interface
  
  interface hipblasSsymmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsymmStridedBatched_(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasSsymmStridedBatched")
#else
    function hipblasSsymmStridedBatched_(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasSsymmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsymmStridedBatched_full_rank,&
      hipblasSsymmStridedBatched_rank_0,&
      hipblasSsymmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDsymmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsymmStridedBatched_(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasDsymmStridedBatched")
#else
    function hipblasDsymmStridedBatched_(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasDsymmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsymmStridedBatched_full_rank,&
      hipblasDsymmStridedBatched_rank_0,&
      hipblasDsymmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCsymmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsymmStridedBatched_(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasCsymmStridedBatched")
#else
    function hipblasCsymmStridedBatched_(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasCsymmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsymmStridedBatched_full_rank,&
      hipblasCsymmStridedBatched_rank_0,&
      hipblasCsymmStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symmStridedBatched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
  !>     C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a symmetric matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
  !>             HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device pointer to first matrix A_1
  !>             A_i is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A_i is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZsymmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsymmStridedBatched_(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasZsymmStridedBatched")
#else
    function hipblasZsymmStridedBatched_(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasZsymmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsymmStridedBatched_full_rank,&
      hipblasZsymmStridedBatched_rank_0,&
      hipblasZsymmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSsyrk
#ifdef USE_CUDA_NAMES
    function hipblasSsyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="cublasSsyrk_v2")
#else
    function hipblasSsyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="hipblasSsyrk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyrk_full_rank,&
      hipblasSsyrk_rank_0,&
      hipblasSsyrk_rank_1
#endif
  end interface
  
  interface hipblasDsyrk
#ifdef USE_CUDA_NAMES
    function hipblasDsyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="cublasDsyrk_v2")
#else
    function hipblasDsyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="hipblasDsyrk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyrk_full_rank,&
      hipblasDsyrk_rank_0,&
      hipblasDsyrk_rank_1
#endif
  end interface
  
  interface hipblasCsyrk
#ifdef USE_CUDA_NAMES
    function hipblasCsyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="cublasCsyrk_v2")
#else
    function hipblasCsyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="hipblasCsyrk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyrk_full_rank,&
      hipblasCsyrk_rank_0,&
      hipblasCsyrk_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrk performs one of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C := alpha*op( A )*op( A )^T + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, and A is n by k if transA == HIPBLAS_OP_N
  !>         op( A ) = A^T and A is k by n if transA == HIPBLAS_OP_T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T: op(A) = A^T
  !>             HIPBLAS_OP_N: op(A) = A
  !>             HIPBLAS_OP_C: op(A) = A^T
  !> 
  !>             HIPBLAS_OP_C is not supported for complex types, see cherk
  !>             and zherk.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface hipblasZsyrk
#ifdef USE_CUDA_NAMES
    function hipblasZsyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="cublasZsyrk_v2")
#else
    function hipblasZsyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="hipblasZsyrk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyrk_full_rank,&
      hipblasZsyrk_rank_0,&
      hipblasZsyrk_rank_1
#endif
  end interface
  
  interface hipblasSsyrkBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="cublasSsyrkBatched")
#else
    function hipblasSsyrkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="hipblasSsyrkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyrkBatched_full_rank,&
      hipblasSsyrkBatched_rank_0,&
      hipblasSsyrkBatched_rank_1
#endif
  end interface
  
  interface hipblasDsyrkBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="cublasDsyrkBatched")
#else
    function hipblasDsyrkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="hipblasDsyrkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyrkBatched_full_rank,&
      hipblasDsyrkBatched_rank_0,&
      hipblasDsyrkBatched_rank_1
#endif
  end interface
  
  interface hipblasCsyrkBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="cublasCsyrkBatched")
#else
    function hipblasCsyrkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="hipblasCsyrkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyrkBatched_full_rank,&
      hipblasCsyrkBatched_rank_0,&
      hipblasCsyrkBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( A_i )^T + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T: op(A) = A^T
  !>             HIPBLAS_OP_N: op(A) = A
  !>             HIPBLAS_OP_C: op(A) = A^T
  !> 
  !>             HIPBLAS_OP_C is not supported for complex types, see cherk
  !>             and zherk.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZsyrkBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="cublasZsyrkBatched")
#else
    function hipblasZsyrkBatched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount) bind(c, name="hipblasZsyrkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyrkBatched_full_rank,&
      hipblasZsyrkBatched_rank_0,&
      hipblasZsyrkBatched_rank_1
#endif
  end interface
  
  interface hipblasSsyrkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="cublasSsyrkStridedBatched")
#else
    function hipblasSsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasSsyrkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyrkStridedBatched_full_rank,&
      hipblasSsyrkStridedBatched_rank_0,&
      hipblasSsyrkStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDsyrkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="cublasDsyrkStridedBatched")
#else
    function hipblasDsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasDsyrkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyrkStridedBatched_full_rank,&
      hipblasDsyrkStridedBatched_rank_0,&
      hipblasDsyrkStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCsyrkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="cublasCsyrkStridedBatched")
#else
    function hipblasCsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasCsyrkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyrkStridedBatched_full_rank,&
      hipblasCsyrkStridedBatched_rank_0,&
      hipblasCsyrkStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( A_i )^T + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T: op(A) = A^T
  !>             HIPBLAS_OP_N: op(A) = A
  !>             HIPBLAS_OP_C: op(A) = A^T
  !> 
  !>             HIPBLAS_OP_C is not supported for complex types, see cherk
  !>             and zherk.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU. on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZsyrkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="cublasZsyrkStridedBatched")
#else
    function hipblasZsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasZsyrkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyrkStridedBatched_full_rank,&
      hipblasZsyrkStridedBatched_rank_0,&
      hipblasZsyrkStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSsyr2k
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasSsyr2k_v2")
#else
    function hipblasSsyr2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasSsyr2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyr2k_full_rank,&
      hipblasSsyr2k_rank_0,&
      hipblasSsyr2k_rank_1
#endif
  end interface
  
  interface hipblasDsyr2k
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasDsyr2k_v2")
#else
    function hipblasDsyr2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasDsyr2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyr2k_full_rank,&
      hipblasDsyr2k_rank_0,&
      hipblasDsyr2k_rank_1
#endif
  end interface
  
  interface hipblasCsyr2k
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasCsyr2k_v2")
#else
    function hipblasCsyr2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasCsyr2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyr2k_full_rank,&
      hipblasCsyr2k_rank_0,&
      hipblasCsyr2k_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2k performs one of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C := alpha*(op( A )*op( B )^T + op( B )*op( A )^T) + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
  !>         op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T
  !>             HIPBLAS_OP_N:           op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A) and op(B). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface hipblasZsyr2k
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasZsyr2k_v2")
#else
    function hipblasZsyr2k_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasZsyr2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyr2k_full_rank,&
      hipblasZsyr2k_rank_0,&
      hipblasZsyr2k_rank_1
#endif
  end interface
  
  interface hipblasSsyr2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasSsyr2kBatched")
#else
    function hipblasSsyr2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasSsyr2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyr2kBatched_full_rank,&
      hipblasSsyr2kBatched_rank_0,&
      hipblasSsyr2kBatched_rank_1
#endif
  end interface
  
  interface hipblasDsyr2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasDsyr2kBatched")
#else
    function hipblasDsyr2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasDsyr2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyr2kBatched_full_rank,&
      hipblasDsyr2kBatched_rank_0,&
      hipblasDsyr2kBatched_rank_1
#endif
  end interface
  
  interface hipblasCsyr2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasCsyr2kBatched")
#else
    function hipblasCsyr2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasCsyr2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyr2kBatched_full_rank,&
      hipblasCsyr2kBatched_rank_0,&
      hipblasCsyr2kBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2kBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZsyr2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasZsyr2kBatched")
#else
    function hipblasZsyr2kBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasZsyr2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyr2kBatched_full_rank,&
      hipblasZsyr2kBatched_rank_0,&
      hipblasZsyr2kBatched_rank_1
#endif
  end interface
  
  interface hipblasSsyr2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasSsyr2kStridedBatched")
#else
    function hipblasSsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasSsyr2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyr2kStridedBatched_full_rank,&
      hipblasSsyr2kStridedBatched_rank_0,&
      hipblasSsyr2kStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDsyr2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasDsyr2kStridedBatched")
#else
    function hipblasDsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasDsyr2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyr2kStridedBatched_full_rank,&
      hipblasDsyr2kStridedBatched_rank_0,&
      hipblasDsyr2kStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCsyr2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasCsyr2kStridedBatched")
#else
    function hipblasCsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasCsyr2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyr2kStridedBatched_full_rank,&
      hipblasCsyr2kStridedBatched_rank_0,&
      hipblasCsyr2kStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2kStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_B  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZsyr2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasZsyr2kStridedBatched")
#else
    function hipblasZsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasZsyr2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyr2kStridedBatched_full_rank,&
      hipblasZsyr2kStridedBatched_rank_0,&
      hipblasZsyr2kStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSsyrkx
#ifdef USE_CUDA_NAMES
    function hipblasSsyrkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasSsyrkx")
#else
    function hipblasSsyrkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasSsyrkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyrkx_full_rank,&
      hipblasSsyrkx_rank_0,&
      hipblasSsyrkx_rank_1
#endif
  end interface
  
  interface hipblasDsyrkx
#ifdef USE_CUDA_NAMES
    function hipblasDsyrkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasDsyrkx")
#else
    function hipblasDsyrkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasDsyrkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyrkx_full_rank,&
      hipblasDsyrkx_rank_0,&
      hipblasDsyrkx_rank_1
#endif
  end interface
  
  interface hipblasCsyrkx
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasCsyrkx")
#else
    function hipblasCsyrkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasCsyrkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyrkx_full_rank,&
      hipblasCsyrkx_rank_0,&
      hipblasCsyrkx_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkx performs one of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C := alpha*op( A )*op( B )^T + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be symmetric.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
  !>         op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T
  !>             HIPBLAS_OP_N:           op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A) and op(B). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface hipblasZsyrkx
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasZsyrkx")
#else
    function hipblasZsyrkx_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasZsyrkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyrkx_full_rank,&
      hipblasZsyrkx_rank_0,&
      hipblasZsyrkx_rank_1
#endif
  end interface
  
  interface hipblasSsyrkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasSsyrkxBatched")
#else
    function hipblasSsyrkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasSsyrkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyrkxBatched_full_rank,&
      hipblasSsyrkxBatched_rank_0,&
      hipblasSsyrkxBatched_rank_1
#endif
  end interface
  
  interface hipblasDsyrkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasDsyrkxBatched")
#else
    function hipblasDsyrkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasDsyrkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyrkxBatched_full_rank,&
      hipblasDsyrkxBatched_rank_0,&
      hipblasDsyrkxBatched_rank_1
#endif
  end interface
  
  interface hipblasCsyrkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasCsyrkxBatched")
#else
    function hipblasCsyrkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasCsyrkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyrkxBatched_full_rank,&
      hipblasCsyrkxBatched_rank_0,&
      hipblasCsyrkxBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkxBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^T + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>             number of instances in the batch.
  !>
  interface hipblasZsyrkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasZsyrkxBatched")
#else
    function hipblasZsyrkxBatched_(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasZsyrkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyrkxBatched_full_rank,&
      hipblasZsyrkxBatched_rank_0,&
      hipblasZsyrkxBatched_rank_1
#endif
  end interface
  
  interface hipblasSsyrkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount) bind(c, name="cublasSsyrkxStridedBatched")
#else
    function hipblasSsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount) bind(c, name="hipblasSsyrkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stridec
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSsyrkxStridedBatched_full_rank,&
      hipblasSsyrkxStridedBatched_rank_0,&
      hipblasSsyrkxStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDsyrkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount) bind(c, name="cublasDsyrkxStridedBatched")
#else
    function hipblasDsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount) bind(c, name="hipblasDsyrkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stridec
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDsyrkxStridedBatched_full_rank,&
      hipblasDsyrkxStridedBatched_rank_0,&
      hipblasDsyrkxStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCsyrkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount) bind(c, name="cublasCsyrkxStridedBatched")
#else
    function hipblasCsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount) bind(c, name="hipblasCsyrkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stridec
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCsyrkxStridedBatched_full_rank,&
      hipblasCsyrkxStridedBatched_rank_0,&
      hipblasCsyrkxStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkxStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^T + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZsyrkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount) bind(c, name="cublasZsyrkxStridedBatched")
#else
    function hipblasZsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount) bind(c, name="hipblasZsyrkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stridec
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZsyrkxStridedBatched_full_rank,&
      hipblasZsyrkxStridedBatched_rank_0,&
      hipblasZsyrkxStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSgeam
#ifdef USE_CUDA_NAMES
    function hipblasSgeam_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="cublasSgeam")
#else
    function hipblasSgeam_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="hipblasSgeam")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeam_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgeam_full_rank,&
      hipblasSgeam_rank_0,&
      hipblasSgeam_rank_1
#endif
  end interface
  
  interface hipblasDgeam
#ifdef USE_CUDA_NAMES
    function hipblasDgeam_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="cublasDgeam")
#else
    function hipblasDgeam_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="hipblasDgeam")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeam_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgeam_full_rank,&
      hipblasDgeam_rank_0,&
      hipblasDgeam_rank_1
#endif
  end interface
  
  interface hipblasCgeam
#ifdef USE_CUDA_NAMES
    function hipblasCgeam_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="cublasCgeam")
#else
    function hipblasCgeam_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="hipblasCgeam")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeam_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgeam_full_rank,&
      hipblasCgeam_rank_0,&
      hipblasCgeam_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     geam performs one of the matrix-matrix operations
  !> 
  !>         C = alpha*op( A ) + beta*op( B ),
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !> 
  !>     alpha and beta are scalars, and A, B and C are matrices, with
  !>     op( A ) an m by n matrix, op( B ) an m by n matrix, and C an m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in]
  !>     B         device pointer storing matrix B.
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of B.
  !>     @param[in, out]
  !>     C         device pointer storing matrix C.
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !>
  interface hipblasZgeam
#ifdef USE_CUDA_NAMES
    function hipblasZgeam_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="cublasZgeam")
#else
    function hipblasZgeam_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="hipblasZgeam")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeam_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgeam_full_rank,&
      hipblasZgeam_rank_0,&
      hipblasZgeam_rank_1
#endif
  end interface
  
  interface hipblasSgeamBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgeamBatched_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount) bind(c, name="cublasSgeamBatched")
#else
    function hipblasSgeamBatched_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount) bind(c, name="hipblasSgeamBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeamBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgeamBatched_full_rank,&
      hipblasSgeamBatched_rank_0,&
      hipblasSgeamBatched_rank_1
#endif
  end interface
  
  interface hipblasDgeamBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgeamBatched_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount) bind(c, name="cublasDgeamBatched")
#else
    function hipblasDgeamBatched_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount) bind(c, name="hipblasDgeamBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeamBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgeamBatched_full_rank,&
      hipblasDgeamBatched_rank_0,&
      hipblasDgeamBatched_rank_1
#endif
  end interface
  
  interface hipblasCgeamBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeamBatched_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount) bind(c, name="cublasCgeamBatched")
#else
    function hipblasCgeamBatched_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount) bind(c, name="hipblasCgeamBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgeamBatched_full_rank,&
      hipblasCgeamBatched_rank_0,&
      hipblasCgeamBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     geamBatched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batchCount - 1
  !> 
  !>     where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
  !>     and op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i on the GPU.
  !>               Each A_i is of dimension ( lda, k ), where k is m
  !>               when  transA == HIPBLAS_OP_N and
  !>               is  n  when  transA == HIPBLAS_OP_T.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in]
  !>     B         device array of device pointers storing each matrix B_i on the GPU.
  !>               Each B_i is of dimension ( ldb, k ), where k is m
  !>               when  transB == HIPBLAS_OP_N and
  !>               is  n  when  transB == HIPBLAS_OP_T.
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of B.
  !>     @param[in, out]
  !>     C         device array of device pointers storing each matrix C_i on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances i in the batch.
  !>
  interface hipblasZgeamBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeamBatched_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount) bind(c, name="cublasZgeamBatched")
#else
    function hipblasZgeamBatched_(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount) bind(c, name="hipblasZgeamBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgeamBatched_full_rank,&
      hipblasZgeamBatched_rank_0,&
      hipblasZgeamBatched_rank_1
#endif
  end interface
  
  interface hipblasSgeamStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgeamStridedBatched_(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="cublasSgeamStridedBatched")
#else
    function hipblasSgeamStridedBatched_(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="hipblasSgeamStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeamStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgeamStridedBatched_full_rank,&
      hipblasSgeamStridedBatched_rank_0,&
      hipblasSgeamStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDgeamStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgeamStridedBatched_(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="cublasDgeamStridedBatched")
#else
    function hipblasDgeamStridedBatched_(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="hipblasDgeamStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeamStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgeamStridedBatched_full_rank,&
      hipblasDgeamStridedBatched_rank_0,&
      hipblasDgeamStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCgeamStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeamStridedBatched_(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="cublasCgeamStridedBatched")
#else
    function hipblasCgeamStridedBatched_(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="hipblasCgeamStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgeamStridedBatched_full_rank,&
      hipblasCgeamStridedBatched_rank_0,&
      hipblasCgeamStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     geamStridedBatched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batchCount - 1
  !> 
  !>     where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
  !>     and op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A )
  !> 
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B )
  !> 
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !> 
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !> 
  !>     @param[in]
  !>     A         device pointer to the first matrix A_0 on the GPU.
  !>               Each A_i is of dimension ( lda, k ), where k is m
  !>               when  transA == HIPBLAS_OP_N and
  !>               is  n  when  transA == HIPBLAS_OP_T.
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !> 
  !>     @param[in]
  !>     B         pointer to the first matrix B_0 on the GPU.
  !>               Each B_i is of dimension ( ldb, k ), where k is m
  !>               when  transB == HIPBLAS_OP_N and
  !>               is  n  when  transB == HIPBLAS_OP_T.
  !> 
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of B.
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in, out]
  !>     C         pointer to the first matrix C_0 on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !> 
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !> 
  !>     @param[in]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances i in the batch.
  !>
  interface hipblasZgeamStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeamStridedBatched_(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="cublasZgeamStridedBatched")
#else
    function hipblasZgeamStridedBatched_(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="hipblasZgeamStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transa
      integer(kind(HIPBLAS_OP_N)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgeamStridedBatched_full_rank,&
      hipblasZgeamStridedBatched_rank_0,&
      hipblasZgeamStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasChemm
#ifdef USE_CUDA_NAMES
    function hipblasChemm_(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasChemm_v2")
#else
    function hipblasChemm_(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasChemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChemm_full_rank,&
      hipblasChemm_rank_0,&
      hipblasChemm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemm performs one of the matrix-matrix operations:
  !> 
  !>     C := alpha*A*B + beta*C if side == HIPBLAS_SIDE_LEFT,
  !>     C := alpha*B*A + beta*C if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B and C are m by n matrices, and
  !>     A is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C := alpha*A*B + beta*C
  !>             HIPBLAS_SIDE_RIGHT:     C := alpha*B*A + beta*C
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B and C. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B and C. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A and B are not referenced.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             A is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             Only the upper/lower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !>
  interface hipblasZhemm
#ifdef USE_CUDA_NAMES
    function hipblasZhemm_(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="cublasZhemm_v2")
#else
    function hipblasZhemm_(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="hipblasZhemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhemm_full_rank,&
      hipblasZhemm_rank_0,&
      hipblasZhemm_rank_1
#endif
  end interface
  
  interface hipblasChemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasChemmBatched_(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasChemmBatched")
#else
    function hipblasChemmBatched_(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasChemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChemmBatched_full_rank,&
      hipblasChemmBatched_rank_0,&
      hipblasChemmBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemmBatched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
  !>     C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
  !>             HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix A_i on the GPU.
  !>             A_i is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A_i is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             Only the upper/lower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C_i need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C_i. ldc >= max( 1, m )
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZhemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhemmBatched_(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="cublasZhemmBatched")
#else
    function hipblasZhemmBatched_(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount) bind(c, name="hipblasZhemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhemmBatched_full_rank,&
      hipblasZhemmBatched_rank_0,&
      hipblasZhemmBatched_rank_1
#endif
  end interface
  
  interface hipblasChemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChemmStridedBatched_(handle,side,uplo,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasChemmStridedBatched")
#else
    function hipblasChemmStridedBatched_(handle,side,uplo,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasChemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasChemmStridedBatched_full_rank,&
      hipblasChemmStridedBatched_rank_0,&
      hipblasChemmStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemmStridedBatched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
  !>     C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
  !>             HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device pointer to first matrix A_1
  !>             A_i is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A_i is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             Only the upper/lower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if side = HIPBLAS_OP_N,  ldb >= max( 1, m ),
  !>             otherwise ldb >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !>
  interface hipblasZhemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhemmStridedBatched_(handle,side,uplo,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="cublasZhemmStridedBatched")
#else
    function hipblasZhemmStridedBatched_(handle,side,uplo,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount) bind(c, name="hipblasZhemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZhemmStridedBatched_full_rank,&
      hipblasZhemmStridedBatched_rank_0,&
      hipblasZhemmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasStrmm
#ifdef USE_CUDA_NAMES
    function hipblasStrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="cublasStrmm_v2")
#else
    function hipblasStrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="hipblasStrmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrmm_full_rank,&
      hipblasStrmm_rank_0,&
      hipblasStrmm_rank_1
#endif
  end interface
  
  interface hipblasDtrmm
#ifdef USE_CUDA_NAMES
    function hipblasDtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="cublasDtrmm_v2")
#else
    function hipblasDtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="hipblasDtrmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrmm_full_rank,&
      hipblasDtrmm_rank_0,&
      hipblasDtrmm_rank_1
#endif
  end interface
  
  interface hipblasCtrmm
#ifdef USE_CUDA_NAMES
    function hipblasCtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="cublasCtrmm_v2")
#else
    function hipblasCtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="hipblasCtrmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrmm_full_rank,&
      hipblasCtrmm_rank_0,&
      hipblasCtrmm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm performs one of the matrix-matrix operations
  !> 
  !>     B := alpha*op( A )*B,   or   B := alpha*B*op( A )
  !> 
  !>     where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             Specifies whether op(A) multiplies B from the left or right as follows:
  !>             HIPBLAS_SIDE_LEFT:       B := alpha*op( A )*B.
  !>             HIPBLAS_SIDE_RIGHT:      B := alpha*B*op( A ).
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             Specifies the form of op(A) to be used in the matrix multiplication as follows:
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_OP_C:  op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             Specifies whether or not A is unit triangular as follows:
  !>             HIPBLAS_DIAG_UNIT:      A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to matrix A on the GPU.
  !>             A has dimension ( lda, k ), where k is m
  !>             when  side == HIPBLAS_SIDE_LEFT  and
  !>             is  n  when  side == HIPBLAS_SIDE_RIGHT.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
  !>         A  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     B       Device pointer to the first matrix B_0 on the GPU.
  !>             On entry,  the leading  m by n part of the array  B must
  !>            contain the matrix  B,  and  on exit  is overwritten  by the
  !>            transformed matrix.
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !>
  interface hipblasZtrmm
#ifdef USE_CUDA_NAMES
    function hipblasZtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="cublasZtrmm_v2")
#else
    function hipblasZtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="hipblasZtrmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrmm_full_rank,&
      hipblasZtrmm_rank_0,&
      hipblasZtrmm_rank_1
#endif
  end interface
  
  interface hipblasStrmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="cublasStrmmBatched")
#else
    function hipblasStrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="hipblasStrmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrmmBatched_full_rank,&
      hipblasStrmmBatched_rank_0,&
      hipblasStrmmBatched_rank_1
#endif
  end interface
  
  interface hipblasDtrmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="cublasDtrmmBatched")
#else
    function hipblasDtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="hipblasDtrmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrmmBatched_full_rank,&
      hipblasDtrmmBatched_rank_0,&
      hipblasDtrmmBatched_rank_1
#endif
  end interface
  
  interface hipblasCtrmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="cublasCtrmmBatched")
#else
    function hipblasCtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="hipblasCtrmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrmmBatched_full_rank,&
      hipblasCtrmmBatched_rank_0,&
      hipblasCtrmmBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmmBatched performs one of the batched matrix-matrix operations
  !> 
  !>     B_i := alpha*op( A_i )*B_i,   or   B_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batchCount -1
  !> 
  !>     where  alpha  is a scalar,  B_i  is an m by n matrix,  A_i  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             Specifies whether op(A_i) multiplies B_i from the left or right as follows:
  !>             HIPBLAS_SIDE_LEFT:       B_i := alpha*op( A_i )*B_i.
  !>             HIPBLAS_SIDE_RIGHT:      B_i := alpha*B_i*op( A_i ).
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
  !>             HIPBLAS_OP_N:    op(A_i) = A_i.
  !>             HIPBLAS_OP_T:      op(A_i) = A_i^T.
  !>             HIPBLAS_OP_C:  op(A_i) = A_i^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             Specifies whether or not A_i is unit triangular as follows:
  !>             HIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i is not referenced and B_i need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device array of device pointers storing each matrix A_i on the GPU.
  !>             Each A_i is of dimension ( lda, k ), where k is m
  !>             when  side == HIPBLAS_SIDE_LEFT  and
  !>             is  n  when  side == HIPBLAS_SIDE_RIGHT.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
  !>         A_i  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>             On entry,  the leading  m by n part of the array  B_i must
  !>            contain the matrix  B_i,  and  on exit  is overwritten  by the
  !>            transformed matrix.
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances i in the batch.
  interface hipblasZtrmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="cublasZtrmmBatched")
#else
    function hipblasZtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="hipblasZtrmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrmmBatched_full_rank,&
      hipblasZtrmmBatched_rank_0,&
      hipblasZtrmmBatched_rank_1
#endif
  end interface
  
  interface hipblasStrmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="cublasStrmmStridedBatched")
#else
    function hipblasStrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="hipblasStrmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrmmStridedBatched_full_rank,&
      hipblasStrmmStridedBatched_rank_0,&
      hipblasStrmmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDtrmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="cublasDtrmmStridedBatched")
#else
    function hipblasDtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="hipblasDtrmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrmmStridedBatched_full_rank,&
      hipblasDtrmmStridedBatched_rank_0,&
      hipblasDtrmmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCtrmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="cublasCtrmmStridedBatched")
#else
    function hipblasCtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="hipblasCtrmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrmmStridedBatched_full_rank,&
      hipblasCtrmmStridedBatched_rank_0,&
      hipblasCtrmmStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmmStridedBatched performs one of the strided_batched matrix-matrix operations
  !> 
  !>     B_i := alpha*op( A_i )*B_i,   or   B_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batchCount -1
  !> 
  !>     where  alpha  is a scalar,  B_i  is an m by n matrix,  A_i  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             Specifies whether op(A_i) multiplies B_i from the left or right as follows:
  !>             HIPBLAS_SIDE_LEFT:       B_i := alpha*op( A_i )*B_i.
  !>             HIPBLAS_SIDE_RIGHT:      B_i := alpha*B_i*op( A_i ).
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
  !>             HIPBLAS_OP_N:    op(A_i) = A_i.
  !>             HIPBLAS_OP_T:      op(A_i) = A_i^T.
  !>             HIPBLAS_OP_C:  op(A_i) = A_i^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             Specifies whether or not A_i is unit triangular as follows:
  !>             HIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i is not referenced and B_i need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_0 on the GPU.
  !>             Each A_i is of dimension ( lda, k ), where k is m
  !>             when  side == HIPBLAS_SIDE_LEFT  and
  !>             is  n  when  side == HIPBLAS_SIDE_RIGHT.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
  !>         A_i  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[inout]
  !>     B       Device pointer to the first matrix B_0 on the GPU.
  !>             On entry,  the leading  m by n part of the array  B_i must
  !>            contain the matrix  B_i,  and  on exit  is overwritten  by the
  !>            transformed matrix.
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).
  !> 
  !>            @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances i in the batch.
  interface hipblasZtrmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="cublasZtrmmStridedBatched")
#else
    function hipblasZtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="hipblasZtrmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrmmStridedBatched_full_rank,&
      hipblasZtrmmStridedBatched_rank_0,&
      hipblasZtrmmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasStrsm
#ifdef USE_CUDA_NAMES
    function hipblasStrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="cublasStrsm_v2")
#else
    function hipblasStrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="hipblasStrsm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrsm_full_rank,&
      hipblasStrsm_rank_0,&
      hipblasStrsm_rank_1
#endif
  end interface
  
  interface hipblasDtrsm
#ifdef USE_CUDA_NAMES
    function hipblasDtrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="cublasDtrsm_v2")
#else
    function hipblasDtrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="hipblasDtrsm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrsm_full_rank,&
      hipblasDtrsm_rank_0,&
      hipblasDtrsm_rank_1
#endif
  end interface
  
  interface hipblasCtrsm
#ifdef USE_CUDA_NAMES
    function hipblasCtrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="cublasCtrsm_v2")
#else
    function hipblasCtrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="hipblasCtrsm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrsm_full_rank,&
      hipblasCtrsm_rank_0,&
      hipblasCtrsm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trsm solves
  !> 
  !>         op(A)*X = alpha*B or  X*op(A) = alpha*B,
  !> 
  !>     where alpha is a scalar, X and B are m by n matrices,
  !>     A is triangular matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     The matrix X is overwritten on B.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !> 
  !>     (where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
  !>             HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_OP_C: op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device pointer storing matrix A.
  !>             of dimension ( lda, k ), where k is m
  !>             when  HIPBLAS_SIDE_LEFT  and
  !>             is  n  when  HIPBLAS_SIDE_RIGHT
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[in,out]
  !>     B       device pointer storing matrix B.
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !>
  interface hipblasZtrsm
#ifdef USE_CUDA_NAMES
    function hipblasZtrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="cublasZtrsm_v2")
#else
    function hipblasZtrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="hipblasZtrsm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrsm_full_rank,&
      hipblasZtrsm_rank_0,&
      hipblasZtrsm_rank_1
#endif
  end interface
  
  interface hipblasStrsmBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="cublasStrsmBatched")
#else
    function hipblasStrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="hipblasStrsmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrsmBatched_full_rank,&
      hipblasStrsmBatched_rank_0,&
      hipblasStrsmBatched_rank_1
#endif
  end interface
  
  interface hipblasDtrsmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="cublasDtrsmBatched")
#else
    function hipblasDtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="hipblasDtrsmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrsmBatched_full_rank,&
      hipblasDtrsmBatched_rank_0,&
      hipblasDtrsmBatched_rank_1
#endif
  end interface
  
  interface hipblasCtrsmBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="cublasCtrsmBatched")
#else
    function hipblasCtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="hipblasCtrsmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrsmBatched_full_rank,&
      hipblasCtrsmBatched_rank_0,&
      hipblasCtrsmBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !>     \details
  !>     trsmBatched performs the following batched operation:
  !> 
  !>         op(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batchCount.
  !> 
  !>     where alpha is a scalar, X and B are batched m by n matrices,
  !>     A is triangular batched matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i for i = 1, ..., batchCount.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !>     (where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
  !>             HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_OP_C: op(A) = A^H.
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix A_i on the GPU.
  !>             Matricies are of dimension ( lda, k ), where k is m
  !>             when  HIPBLAS_SIDE_LEFT  and is  n  when  HIPBLAS_SIDE_RIGHT
  !>             only the upper/lower triangular part is accessed.
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of each A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !>     @param[in,out]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of trsm operatons in the batch.
  interface hipblasZtrsmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="cublasZtrsmBatched")
#else
    function hipblasZtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount) bind(c, name="hipblasZtrsmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrsmBatched_full_rank,&
      hipblasZtrsmBatched_rank_0,&
      hipblasZtrsmBatched_rank_1
#endif
  end interface
  
  interface hipblasStrsmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="cublasStrsmStridedBatched")
#else
    function hipblasStrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="hipblasStrsmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrsmStridedBatched_full_rank,&
      hipblasStrsmStridedBatched_rank_0,&
      hipblasStrsmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDtrsmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="cublasDtrsmStridedBatched")
#else
    function hipblasDtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="hipblasDtrsmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrsmStridedBatched_full_rank,&
      hipblasDtrsmStridedBatched_rank_0,&
      hipblasDtrsmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCtrsmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="cublasCtrsmStridedBatched")
#else
    function hipblasCtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="hipblasCtrsmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrsmStridedBatched_full_rank,&
      hipblasCtrsmStridedBatched_rank_0,&
      hipblasCtrsmStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !>     \details
  !>     trsmSridedBatched performs the following strided batched operation:
  !> 
  !>         op(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batchCount.
  !> 
  !>     where alpha is a scalar, X and B are strided batched m by n matrices,
  !>     A is triangular strided batched matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i for i = 1, ..., batchCount.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !>     (where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
  !>             HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_OP_C: op(A) = A^H.
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !>     @param[in]
  !>     A       device pointer pointing to the first matrix A_1.
  !>             of dimension ( lda, k ), where k is m
  !>             when  HIPBLAS_SIDE_LEFT  and
  !>             is  n  when  HIPBLAS_SIDE_RIGHT
  !>             only the upper/lower triangular part is accessed.
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of each A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !>     @param[in]
  !>     strideA [hipblasStride]
  !>              stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[in,out]
  !>     B       device pointer pointing to the first matrix B_1.
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !>     @param[in]
  !>     strideB [hipblasStride]
  !>              stride from the start of one B_i matrix to the next B_(i + 1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of trsm operatons in the batch.
  interface hipblasZtrsmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="cublasZtrsmStridedBatched")
#else
    function hipblasZtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount) bind(c, name="hipblasZtrsmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrsmStridedBatched_full_rank,&
      hipblasZtrsmStridedBatched_rank_0,&
      hipblasZtrsmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasStrtri
#ifdef USE_CUDA_NAMES
    function hipblasStrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="cublasStrtri")
#else
    function hipblasStrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="hipblasStrtri")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtri_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrtri_full_rank,&
      hipblasStrtri_rank_0,&
      hipblasStrtri_rank_1
#endif
  end interface
  
  interface hipblasDtrtri
#ifdef USE_CUDA_NAMES
    function hipblasDtrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="cublasDtrtri")
#else
    function hipblasDtrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="hipblasDtrtri")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtri_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrtri_full_rank,&
      hipblasDtrtri_rank_0,&
      hipblasDtrtri_rank_1
#endif
  end interface
  
  interface hipblasCtrtri
#ifdef USE_CUDA_NAMES
    function hipblasCtrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="cublasCtrtri")
#else
    function hipblasCtrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="hipblasCtrtri")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrtri_full_rank,&
      hipblasCtrtri_rank_0,&
      hipblasCtrtri_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtri  compute the inverse of a matrix A, namely, invA
  !> 
  !>         and write the result into invA;
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               = 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
  !>               = 'HIPBLAS_DIAG_UNIT', A is unit triangular;
  !>     @param[in]
  !>     n         [int]
  !>               size of matrix A and invA
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[out]
  !>     invA      device pointer storing matrix invA.
  !>     @param[in]
  !>     ldinvA    [int]
  !>               specifies the leading dimension of invA.
  !>
  interface hipblasZtrtri
#ifdef USE_CUDA_NAMES
    function hipblasZtrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="cublasZtrtri")
#else
    function hipblasZtrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="hipblasZtrtri")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrtri_full_rank,&
      hipblasZtrtri_rank_0,&
      hipblasZtrtri_rank_1
#endif
  end interface
  
  interface hipblasStrtriBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrtriBatched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount) bind(c, name="cublasStrtriBatched")
#else
    function hipblasStrtriBatched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount) bind(c, name="hipblasStrtriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrtriBatched_full_rank,&
      hipblasStrtriBatched_rank_0,&
      hipblasStrtriBatched_rank_1
#endif
  end interface
  
  interface hipblasDtrtriBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrtriBatched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount) bind(c, name="cublasDtrtriBatched")
#else
    function hipblasDtrtriBatched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount) bind(c, name="hipblasDtrtriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrtriBatched_full_rank,&
      hipblasDtrtriBatched_rank_0,&
      hipblasDtrtriBatched_rank_1
#endif
  end interface
  
  interface hipblasCtrtriBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrtriBatched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount) bind(c, name="cublasCtrtriBatched")
#else
    function hipblasCtrtriBatched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount) bind(c, name="hipblasCtrtriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrtriBatched_full_rank,&
      hipblasCtrtriBatched_rank_0,&
      hipblasCtrtriBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtriBatched  compute the inverse of A_i and write into invA_i where
  !>                    A_i and invA_i are the i-th matrices in the batch,
  !>                    for i = 1, ..., batchCount.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               = 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
  !>               = 'HIPBLAS_DIAG_UNIT', A is unit triangular;
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[out]
  !>     invA      device array of device pointers storing the inverse of each matrix A_i.
  !>               Partial inplace operation is supported, see below.
  !>               If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
  !>               the inverse of the upper triangular matrix, and the strictly lower
  !>               triangular part of invA is cleared.
  !>               If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
  !>               the inverse of the lower triangular matrix, and the strictly upper
  !>               triangular part of invA is cleared.
  !>     @param[in]
  !>     ldinvA    [int]
  !>               specifies the leading dimension of each invA_i.
  !>     @param[in]
  !>     batchCount [int]
  !>               numbers of matrices in the batch
  interface hipblasZtrtriBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrtriBatched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount) bind(c, name="cublasZtrtriBatched")
#else
    function hipblasZtrtriBatched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount) bind(c, name="hipblasZtrtriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrtriBatched_full_rank,&
      hipblasZtrtriBatched_rank_0,&
      hipblasZtrtriBatched_rank_1
#endif
  end interface
  
  interface hipblasStrtriStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrtriStridedBatched_(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="cublasStrtriStridedBatched")
#else
    function hipblasStrtriStridedBatched_(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="hipblasStrtriStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasStrtriStridedBatched_full_rank,&
      hipblasStrtriStridedBatched_rank_0,&
      hipblasStrtriStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDtrtriStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrtriStridedBatched_(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="cublasDtrtriStridedBatched")
#else
    function hipblasDtrtriStridedBatched_(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="hipblasDtrtriStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDtrtriStridedBatched_full_rank,&
      hipblasDtrtriStridedBatched_rank_0,&
      hipblasDtrtriStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCtrtriStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrtriStridedBatched_(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="cublasCtrtriStridedBatched")
#else
    function hipblasCtrtriStridedBatched_(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="hipblasCtrtriStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCtrtriStridedBatched_full_rank,&
      hipblasCtrtriStridedBatched_rank_0,&
      hipblasCtrtriStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtriStridedBatched compute the inverse of A_i and write into invA_i where
  !>                    A_i and invA_i are the i-th matrices in the batch,
  !>                    for i = 1, ..., batchCount
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               = 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
  !>               = 'HIPBLAS_DIAG_UNIT', A is unit triangular;
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     A         device pointer pointing to address of first matrix A_1.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A.
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>              "batch stride a": stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[out]
  !>     invA      device pointer storing the inverses of each matrix A_i.
  !>               Partial inplace operation is supported, see below.
  !>               If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
  !>               the inverse of the upper triangular matrix, and the strictly lower
  !>               triangular part of invA is cleared.
  !>               If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
  !>               the inverse of the lower triangular matrix, and the strictly upper
  !>               triangular part of invA is cleared.
  !>     @param[in]
  !>     ldinvA    [int]
  !>               specifies the leading dimension of each invA_i.
  !>     @param[in]
  !>     stride_invA  [hipblasStride]
  !>                  "batch stride invA": stride from the start of one invA_i matrix to the next invA_(i + 1).
  !>     @param[in]
  !>     batchCount  [int]
  !>                  numbers of matrices in the batch
  interface hipblasZtrtriStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrtriStridedBatched_(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="cublasZtrtriStridedBatched")
#else
    function hipblasZtrtriStridedBatched_(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="hipblasZtrtriStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZtrtriStridedBatched_full_rank,&
      hipblasZtrtriStridedBatched_rank_0,&
      hipblasZtrtriStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSdgmm
#ifdef USE_CUDA_NAMES
    function hipblasSdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="cublasSdgmm")
#else
    function hipblasSdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="hipblasSdgmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSdgmm_full_rank,&
      hipblasSdgmm_rank_0,&
      hipblasSdgmm_rank_1
#endif
  end interface
  
  interface hipblasDdgmm
#ifdef USE_CUDA_NAMES
    function hipblasDdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="cublasDdgmm")
#else
    function hipblasDdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="hipblasDdgmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDdgmm_full_rank,&
      hipblasDdgmm_rank_0,&
      hipblasDdgmm_rank_1
#endif
  end interface
  
  interface hipblasCdgmm
#ifdef USE_CUDA_NAMES
    function hipblasCdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="cublasCdgmm")
#else
    function hipblasCdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="hipblasCdgmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCdgmm_full_rank,&
      hipblasCdgmm_rank_0,&
      hipblasCdgmm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     dgmm performs one of the matrix-matrix operations
  !> 
  !>         C = A * diag(x) if side == HIPBLAS_SIDE_RIGHT
  !>         C = diag(x) * A if side == HIPBLAS_SIDE_LEFT
  !> 
  !>     where C and A are m by n dimensional matrices. diag( x ) is a diagonal matrix
  !>     and x is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
  !>     if side == HIPBLAS_SIDE_LEFT.
  !> 
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     side      [hipblasSideMode_t]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment between values of x
  !>     @param[in, out]
  !>     C         device pointer storing matrix C.
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !>
  interface hipblasZdgmm
#ifdef USE_CUDA_NAMES
    function hipblasZdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="cublasZdgmm")
#else
    function hipblasZdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="hipblasZdgmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdgmm_full_rank,&
      hipblasZdgmm_rank_0,&
      hipblasZdgmm_rank_1
#endif
  end interface
  
  interface hipblasSdgmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasSdgmmBatched_(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount) bind(c, name="cublasSdgmmBatched")
#else
    function hipblasSdgmmBatched_(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount) bind(c, name="hipblasSdgmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSdgmmBatched_full_rank,&
      hipblasSdgmmBatched_rank_0,&
      hipblasSdgmmBatched_rank_1
#endif
  end interface
  
  interface hipblasDdgmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDdgmmBatched_(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount) bind(c, name="cublasDdgmmBatched")
#else
    function hipblasDdgmmBatched_(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount) bind(c, name="hipblasDdgmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDdgmmBatched_full_rank,&
      hipblasDdgmmBatched_rank_0,&
      hipblasDdgmmBatched_rank_1
#endif
  end interface
  
  interface hipblasCdgmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdgmmBatched_(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount) bind(c, name="cublasCdgmmBatched")
#else
    function hipblasCdgmmBatched_(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount) bind(c, name="hipblasCdgmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCdgmmBatched_full_rank,&
      hipblasCdgmmBatched_rank_0,&
      hipblasCdgmmBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     dgmmBatched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = A_i * diag(x_i) for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_RIGHT
  !>         C_i = diag(x_i) * A_i for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_LEFT
  !> 
  !>     where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
  !>     and x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
  !>     if side == HIPBLAS_SIDE_LEFT.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     side      [hipblasSideMode_t]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i on the GPU.
  !>               Each A_i is of dimension ( lda, n )
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i on the GPU.
  !>               Each x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension
  !>               m if side == HIPBLAS_SIDE_LEFT
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment between values of x_i
  !>     @param[in, out]
  !>     C         device array of device pointers storing each matrix C_i on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>
  interface hipblasZdgmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdgmmBatched_(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount) bind(c, name="cublasZdgmmBatched")
#else
    function hipblasZdgmmBatched_(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount) bind(c, name="hipblasZdgmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdgmmBatched_full_rank,&
      hipblasZdgmmBatched_rank_0,&
      hipblasZdgmmBatched_rank_1
#endif
  end interface
  
  interface hipblasSdgmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSdgmmStridedBatched_(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount) bind(c, name="cublasSdgmmStridedBatched")
#else
    function hipblasSdgmmStridedBatched_(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount) bind(c, name="hipblasSdgmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSdgmmStridedBatched_full_rank,&
      hipblasSdgmmStridedBatched_rank_0,&
      hipblasSdgmmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDdgmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDdgmmStridedBatched_(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount) bind(c, name="cublasDdgmmStridedBatched")
#else
    function hipblasDdgmmStridedBatched_(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount) bind(c, name="hipblasDdgmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDdgmmStridedBatched_full_rank,&
      hipblasDdgmmStridedBatched_rank_0,&
      hipblasDdgmmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCdgmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdgmmStridedBatched_(handle,side,m,n,A,lda,stride_A,x,incx,stride_x,C,ldc,stride_C,batchCount) bind(c, name="cublasCdgmmStridedBatched")
#else
    function hipblasCdgmmStridedBatched_(handle,side,m,n,A,lda,stride_A,x,incx,stride_x,C,ldc,stride_C,batchCount) bind(c, name="hipblasCdgmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCdgmmStridedBatched_full_rank,&
      hipblasCdgmmStridedBatched_rank_0,&
      hipblasCdgmmStridedBatched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     dgmmStridedBatched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = A_i * diag(x_i)   if side == HIPBLAS_SIDE_RIGHT   for i = 0, 1, ... batchCount-1
  !>         C_i = diag(x_i) * A_i   if side == HIPBLAS_SIDE_LEFT    for i = 0, 1, ... batchCount-1
  !> 
  !>     where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
  !>     and x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
  !>     if side == HIPBLAS_SIDE_LEFT.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     side      [hipblasSideMode_t]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     A         device pointer to the first matrix A_0 on the GPU.
  !>               Each A_i is of dimension ( lda, n )
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         pointer to the first vector x_0 on the GPU.
  !>               Each x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension
  !>               m if side == HIPBLAS_SIDE_LEFT
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment between values of x
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector(x_i) and the next one (x_i+1)
  !>     @param[in, out]
  !>     C         device pointer to the first matrix C_0 on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !>     @param[in]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances i in the batch.
  !>
  interface hipblasZdgmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdgmmStridedBatched_(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount) bind(c, name="cublasZdgmmStridedBatched")
#else
    function hipblasZdgmmStridedBatched_(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount) bind(c, name="hipblasZdgmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZdgmmStridedBatched_full_rank,&
      hipblasZdgmmStridedBatched_rank_0,&
      hipblasZdgmmStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSgetrf
#ifdef USE_CUDA_NAMES
    function hipblasSgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="cublasSgetrf")
#else
    function hipblasSgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="hipblasSgetrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgetrf_full_rank,&
      hipblasSgetrf_rank_0,&
      hipblasSgetrf_rank_1
#endif
  end interface
  
  interface hipblasDgetrf
#ifdef USE_CUDA_NAMES
    function hipblasDgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="cublasDgetrf")
#else
    function hipblasDgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="hipblasDgetrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgetrf_full_rank,&
      hipblasDgetrf_rank_0,&
      hipblasDgetrf_rank_1
#endif
  end interface
  
  interface hipblasCgetrf
#ifdef USE_CUDA_NAMES
    function hipblasCgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="cublasCgetrf")
#else
    function hipblasCgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="hipblasCgetrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgetrf_full_rank,&
      hipblasCgetrf_rank_0,&
      hipblasCgetrf_rank_1
#endif
  end interface
  !>  \brief SOLVER API
  !> 
  !>     \details
  !>     getrf computes the LU factorization of a general n-by-n matrix A
  !>     using partial pivoting with row interchanges. The LU factorization can
  !>     be done without pivoting if ipiv is passed as a nullptr.
  !> 
  !>     In the case that ipiv is not null, the factorization has the form:
  !> 
  !>     \f[
  !>         A = PLU
  !>     \f]
  !> 
  !>     where P is a permutation matrix, L is lower triangular with unit
  !>     diagonal elements, and U is upper triangular.
  !> 
  !>     In the case that ipiv is null, the factorization is done without pivoting:
  !> 
  !>     \f[
  !>         A = LU
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns and rows of the matrix A.
  !>     @param[inout]
  !>     A         pointer to type. Array on the GPU of dimension lda*n.\n
  !>               On entry, the n-by-n matrix A to be factored.
  !>               On exit, the factors L and U from the factorization.
  !>               The unit diagonal elements of L are not stored.
  !>     @param[in]
  !>     lda       int. lda >= n.\n
  !>               Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv      pointer to int. Array on the GPU of dimension n.\n
  !>               The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>               For 1 <= i <= n, the row i of the
  !>               matrix was interchanged with row ipiv[i].
  !>               Matrix P of the factorization can be derived from ipiv.
  !>               The factorization here can be done without pivoting if ipiv is passed
  !>               in as a nullptr.
  !>     @param[out]
  !>     info      pointer to a int on the GPU.\n
  !>               If info = 0, successful exit.
  !>               If info = j > 0, U is singular. U[j,j] is the first zero pivot.
  interface hipblasZgetrf
#ifdef USE_CUDA_NAMES
    function hipblasZgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="cublasZgetrf")
#else
    function hipblasZgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="hipblasZgetrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgetrf_full_rank,&
      hipblasZgetrf_rank_0,&
      hipblasZgetrf_rank_1
#endif
  end interface
  
  interface hipblasSgetrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasSgetrfBatched")
#else
    function hipblasSgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasSgetrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgetrfBatched_full_rank,&
      hipblasSgetrfBatched_rank_0,&
      hipblasSgetrfBatched_rank_1
#endif
  end interface
  
  interface hipblasDgetrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasDgetrfBatched")
#else
    function hipblasDgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasDgetrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgetrfBatched_full_rank,&
      hipblasDgetrfBatched_rank_0,&
      hipblasDgetrfBatched_rank_1
#endif
  end interface
  
  interface hipblasCgetrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasCgetrfBatched")
#else
    function hipblasCgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasCgetrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgetrfBatched_full_rank,&
      hipblasCgetrfBatched_rank_0,&
      hipblasCgetrfBatched_rank_1
#endif
  end interface
  !>  \brief SOLVER API
  !> 
  !>     \details
  !>     getrfBatched computes the LU factorization of a batch of general
  !>     n-by-n matrices using partial pivoting with row interchanges. The LU factorization can
  !>     be done without pivoting if ipiv is passed as a nullptr.
  !> 
  !>     In the case that ipiv is not null, the factorization of matrix \f$A_i\f$ in the batch has the form:
  !> 
  !>     \f[
  !>         A_i = P_iL_iU_i
  !>     \f]
  !> 
  !>     where \f$P_i\f$ is a permutation matrix, \f$L_i\f$ is lower triangular with unit
  !>     diagonal elements, and \f$U_i\f$ is upper triangular.
  !> 
  !>     In the case that ipiv is null, the factorization is done without pivoting:
  !> 
  !>     \f[
  !>         A_i = L_iU_i
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns and rows of all matrices A_i in the batch.
  !>     @param[inout]
  !>     A         array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\n
  !>               On entry, the n-by-n matrices A_i to be factored.
  !>               On exit, the factors L_i and U_i from the factorizations.
  !>               The unit diagonal elements of L_i are not stored.
  !>     @param[in]
  !>     lda       int. lda >= n.\n
  !>               Specifies the leading dimension of matrices A_i.
  !>     @param[out]
  !>     ipiv      pointer to int. Array on the GPU.\n
  !>               Contains the vectors of pivot indices ipiv_i (corresponding to A_i).
  !>               Dimension of ipiv_i is n.
  !>               Elements of ipiv_i are 1-based indices.
  !>               For each instance A_i in the batch and for 1 <= j <= n, the row j of the
  !>               matrix A_i was interchanged with row ipiv_i[j].
  !>               Matrix P_i of the factorization can be derived from ipiv_i.
  !>               The factorization here can be done without pivoting if ipiv is passed
  !>               in as a nullptr.
  !>     @param[out]
  !>     info      pointer to int. Array of batchCount integers on the GPU.\n
  !>               If info[i] = 0, successful exit for factorization of A_i.
  !>               If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.
  !>     @param[in]
  !>     batchCount int. batchCount >= 0.\n
  !>                 Number of matrices in the batch.
  interface hipblasZgetrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasZgetrfBatched")
#else
    function hipblasZgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasZgetrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgetrfBatched_full_rank,&
      hipblasZgetrfBatched_rank_0,&
      hipblasZgetrfBatched_rank_1
#endif
  end interface
  
  interface hipblasSgetrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasSgetrfStridedBatched")
#else
    function hipblasSgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasSgetrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgetrfStridedBatched_full_rank,&
      hipblasSgetrfStridedBatched_rank_0,&
      hipblasSgetrfStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDgetrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasDgetrfStridedBatched")
#else
    function hipblasDgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasDgetrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgetrfStridedBatched_full_rank,&
      hipblasDgetrfStridedBatched_rank_0,&
      hipblasDgetrfStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCgetrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasCgetrfStridedBatched")
#else
    function hipblasCgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasCgetrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgetrfStridedBatched_full_rank,&
      hipblasCgetrfStridedBatched_rank_0,&
      hipblasCgetrfStridedBatched_rank_1
#endif
  end interface
  !>  \brief SOLVER API
  !> 
  !>     \details
  !>     getrfStridedBatched computes the LU factorization of a batch of
  !>     general n-by-n matrices using partial pivoting with row interchanges. The LU factorization can
  !>     be done without pivoting if ipiv is passed as a nullptr.
  !> 
  !>     In the case that ipiv is not null, the factorization of matrix \f$A_i\f$ in the batch has the form:
  !> 
  !>     \f[
  !>         A_i = P_iL_iU_i
  !>     \f]
  !> 
  !>     where \f$P_i\f$ is a permutation matrix, \f$L_i\f$ is lower triangular with unit
  !>     diagonal elements, and \f$U_i\f$ is upper triangular.
  !> 
  !>     In the case that ipiv is null, the factorization is done without pivoting:
  !> 
  !>     \f[
  !>         A_i = L_iU_i
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns and rows of all matrices A_i in the batch.
  !>     @param[inout]
  !>     A         pointer to type. Array on the GPU (the size depends on the value of strideA).\n
  !>               On entry, the n-by-n matrices A_i to be factored.
  !>               On exit, the factors L_i and U_i from the factorization.
  !>               The unit diagonal elements of L_i are not stored.
  !>     @param[in]
  !>     lda       int. lda >= n.\n
  !>               Specifies the leading dimension of matrices A_i.
  !>     @param[in]
  !>     strideA   hipblasStride.\n
  !>               Stride from the start of one matrix A_i to the next one A_(i+1).
  !>               There is no restriction for the value of strideA. Normal use case is strideA >= lda*n
  !>     @param[out]
  !>     ipiv      pointer to int. Array on the GPU (the size depends on the value of strideP).\n
  !>               Contains the vectors of pivots indices ipiv_i (corresponding to A_i).
  !>               Dimension of ipiv_i is n.
  !>               Elements of ipiv_i are 1-based indices.
  !>               For each instance A_i in the batch and for 1 <= j <= n, the row j of the
  !>               matrix A_i was interchanged with row ipiv_i[j].
  !>               Matrix P_i of the factorization can be derived from ipiv_i.
  !>               The factorization here can be done without pivoting if ipiv is passed
  !>               in as a nullptr.
  !>     @param[in]
  !>     strideP   hipblasStride.\n
  !>               Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
  !>               There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[out]
  !>     info      pointer to int. Array of batchCount integers on the GPU.\n
  !>               If info[i] = 0, successful exit for factorization of A_i.
  !>               If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.
  !>     @param[in]
  !>     batchCount int. batchCount >= 0.\n
  !>                 Number of matrices in the batch.
  interface hipblasZgetrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasZgetrfStridedBatched")
#else
    function hipblasZgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasZgetrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgetrfStridedBatched_full_rank,&
      hipblasZgetrfStridedBatched_rank_0,&
      hipblasZgetrfStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSgetrs
#ifdef USE_CUDA_NAMES
    function hipblasSgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="cublasSgetrs")
#else
    function hipblasSgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="hipblasSgetrs")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrs_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgetrs_full_rank,&
      hipblasSgetrs_rank_0,&
      hipblasSgetrs_rank_1
#endif
  end interface
  
  interface hipblasDgetrs
#ifdef USE_CUDA_NAMES
    function hipblasDgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="cublasDgetrs")
#else
    function hipblasDgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="hipblasDgetrs")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrs_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgetrs_full_rank,&
      hipblasDgetrs_rank_0,&
      hipblasDgetrs_rank_1
#endif
  end interface
  
  interface hipblasCgetrs
#ifdef USE_CUDA_NAMES
    function hipblasCgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="cublasCgetrs")
#else
    function hipblasCgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="hipblasCgetrs")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgetrs_full_rank,&
      hipblasCgetrs_rank_0,&
      hipblasCgetrs_rank_1
#endif
  end interface
  !>  \brief SOLVER API
  !> 
  !>     \details
  !>     getrs solves a system of n linear equations on n variables in its factorized form.
  !> 
  !>     It solves one of the following systems, depending on the value of trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = B & \: \text{not transposed,}\\
  !>         A^T X = B & \: \text{transposed, or}\\
  !>         A^H X = B & \: \text{conjugate transposed.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Matrix A is defined by its triangular factors as returned by \ref hipblasSgetrf "getrf".
  !> 
  !>     @param[in]
  !>     handle      hipblasHandle_t.
  !>     @param[in]
  !>     trans       hipblasOperation_t.\n
  !>                 Specifies the form of the system of equations.
  !>     @param[in]
  !>     n           int. n >= 0.\n
  !>                 The order of the system, i.e. the number of columns and rows of A.
  !>     @param[in]
  !>     nrhs        int. nrhs >= 0.\n
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of the matrix B.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of dimension lda*n.\n
  !>                 The factors L and U of the factorization A = P*L*U returned by \ref hipblasSgetrf "getrf".
  !>     @param[in]
  !>     lda         int. lda >= n.\n
  !>                 The leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to int. Array on the GPU of dimension n.\n
  !>                 The pivot indices returned by \ref hipblasSgetrf "getrf".
  !>     @param[in,out]
  !>     B           pointer to type. Array on the GPU of dimension ldb*nrhs.\n
  !>                 On entry, the right hand side matrix B.
  !>                 On exit, the solution matrix X.
  !>     @param[in]
  !>     ldb         int. ldb >= n.\n
  !>                 The leading dimension of B.
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = j < 0, the j-th argument is invalid.
  interface hipblasZgetrs
#ifdef USE_CUDA_NAMES
    function hipblasZgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="cublasZgetrs")
#else
    function hipblasZgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="hipblasZgetrs")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgetrs_full_rank,&
      hipblasZgetrs_rank_0,&
      hipblasZgetrs_rank_1
#endif
  end interface
  
  interface hipblasSgetrsBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="cublasSgetrsBatched")
#else
    function hipblasSgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="hipblasSgetrsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgetrsBatched_full_rank,&
      hipblasSgetrsBatched_rank_0,&
      hipblasSgetrsBatched_rank_1
#endif
  end interface
  
  interface hipblasDgetrsBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="cublasDgetrsBatched")
#else
    function hipblasDgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="hipblasDgetrsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgetrsBatched_full_rank,&
      hipblasDgetrsBatched_rank_0,&
      hipblasDgetrsBatched_rank_1
#endif
  end interface
  
  interface hipblasCgetrsBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="cublasCgetrsBatched")
#else
    function hipblasCgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="hipblasCgetrsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgetrsBatched_full_rank,&
      hipblasCgetrsBatched_rank_0,&
      hipblasCgetrsBatched_rank_1
#endif
  end interface
  !>  \brief SOLVER API
  !> 
  !>     \details getrsBatched solves a batch of systems of n linear equations on n
  !>     variables in its factorized forms.
  !> 
  !>     For each instance i in the batch, it solves one of the following systems, depending on the value of trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_i X_i = B_i & \: \text{not transposed,}\\
  !>         A_i^T X_i = B_i & \: \text{transposed, or}\\
  !>         A_i^H X_i = B_i & \: \text{conjugate transposed.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Matrix \f$A_i\f$ is defined by its triangular factors as returned by \ref hipblasSgetrfBatched "getrfBatched".
  !> 
  !>     @param[in]
  !>     handle      hipblasHandle_t.
  !>     @param[in]
  !>     trans       hipblasOperation_t.\n
  !>                 Specifies the form of the system of equations of each instance in the batch.
  !>     @param[in]
  !>     n           int. n >= 0.\n
  !>                 The order of the system, i.e. the number of columns and rows of all A_i matrices.
  !>     @param[in]
  !>     nrhs        int. nrhs >= 0.\n
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_i.
  !>     @param[in]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\n
  !>                 The factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \ref hipblasSgetrfBatched "getrfBatched".
  !>     @param[in]
  !>     lda         int. lda >= n.\n
  !>                 The leading dimension of matrices A_i.
  !>     @param[in]
  !>     ipiv        pointer to int. Array on the GPU.\n
  !>                 Contains the vectors ipiv_i of pivot indices returned by \ref hipblasSgetrfBatched "getrfBatched".
  !>     @param[in,out]
  !>     B           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\n
  !>                 On entry, the right hand side matrices B_i.
  !>                 On exit, the solution matrix X_i of each system in the batch.
  !>     @param[in]
  !>     ldb         int. ldb >= n.\n
  !>                 The leading dimension of matrices B_i.
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = j < 0, the j-th argument is invalid.
  !>     @param[in]
  !>     batchCount int. batchCount >= 0.\n
  !>                 Number of instances (systems) in the batch.
  !>
  interface hipblasZgetrsBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="cublasZgetrsBatched")
#else
    function hipblasZgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="hipblasZgetrsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgetrsBatched_full_rank,&
      hipblasZgetrsBatched_rank_0,&
      hipblasZgetrsBatched_rank_1
#endif
  end interface
  
  interface hipblasSgetrsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="cublasSgetrsStridedBatched")
#else
    function hipblasSgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="hipblasSgetrsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgetrsStridedBatched_full_rank,&
      hipblasSgetrsStridedBatched_rank_0,&
      hipblasSgetrsStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDgetrsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="cublasDgetrsStridedBatched")
#else
    function hipblasDgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="hipblasDgetrsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgetrsStridedBatched_full_rank,&
      hipblasDgetrsStridedBatched_rank_0,&
      hipblasDgetrsStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCgetrsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="cublasCgetrsStridedBatched")
#else
    function hipblasCgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="hipblasCgetrsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgetrsStridedBatched_full_rank,&
      hipblasCgetrsStridedBatched_rank_0,&
      hipblasCgetrsStridedBatched_rank_1
#endif
  end interface
  !>  \brief SOLVER API
  !> 
  !>     \details
  !>     getrsStridedBatched solves a batch of systems of n linear equations
  !>     on n variables in its factorized forms.
  !> 
  !>     For each instance i in the batch, it solves one of the following systems, depending on the value of trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_i X_i = B_i & \: \text{not transposed,}\\
  !>         A_i^T X_i = B_i & \: \text{transposed, or}\\
  !>         A_i^H X_i = B_i & \: \text{conjugate transposed.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Matrix \f$A_i\f$ is defined by its triangular factors as returned by \ref hipblasSgetrfStridedBatched "getrfStridedBatched".
  !> 
  !>     @param[in]
  !>     handle      hipblasHandle_t.
  !>     @param[in]
  !>     trans       hipblasOperation_t.\n
  !>                 Specifies the form of the system of equations of each instance in the batch.
  !>     @param[in]
  !>     n           int. n >= 0.\n
  !>                 The order of the system, i.e. the number of columns and rows of all A_i matrices.
  !>     @param[in]
  !>     nrhs        int. nrhs >= 0.\n
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_i.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).\n
  !>                 The factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \ref hipblasSgetrfStridedBatched "getrfStridedBatched".
  !>     @param[in]
  !>     lda         int. lda >= n.\n
  !>                 The leading dimension of matrices A_i.
  !>     @param[in]
  !>     strideA     hipblasStride.\n
  !>                 Stride from the start of one matrix A_i to the next one A_(i+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= lda*n.
  !>     @param[in]
  !>     ipiv        pointer to int. Array on the GPU (the size depends on the value of strideP).\n
  !>                 Contains the vectors ipiv_i of pivot indices returned by \ref hipblasSgetrfStridedBatched "getrfStridedBatched".
  !>     @param[in]
  !>     strideP     hipblasStride.\n
  !>                 Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[in,out]
  !>     B           pointer to type. Array on the GPU (size depends on the value of strideB).\n
  !>                 On entry, the right hand side matrices B_i.
  !>                 On exit, the solution matrix X_i of each system in the batch.
  !>     @param[in]
  !>     ldb         int. ldb >= n.\n
  !>                 The leading dimension of matrices B_i.
  !>     @param[in]
  !>     strideB     hipblasStride.\n
  !>                 Stride from the start of one matrix B_i to the next one B_(i+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = j < 0, the j-th argument is invalid.
  !>     @param[in]
  !>     batchCount int. batchCount >= 0.\n
  !>                 Number of instances (systems) in the batch.
  !>
  interface hipblasZgetrsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="cublasZgetrsStridedBatched")
#else
    function hipblasZgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="hipblasZgetrsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgetrsStridedBatched_full_rank,&
      hipblasZgetrsStridedBatched_rank_0,&
      hipblasZgetrsStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasSgetriBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="cublasSgetriBatched")
#else
    function hipblasSgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="hipblasSgetriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetriBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgetriBatched_full_rank,&
      hipblasSgetriBatched_rank_0,&
      hipblasSgetriBatched_rank_1
#endif
  end interface
  
  interface hipblasDgetriBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="cublasDgetriBatched")
#else
    function hipblasDgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="hipblasDgetriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetriBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgetriBatched_full_rank,&
      hipblasDgetriBatched_rank_0,&
      hipblasDgetriBatched_rank_1
#endif
  end interface
  
  interface hipblasCgetriBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="cublasCgetriBatched")
#else
    function hipblasCgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="hipblasCgetriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgetriBatched_full_rank,&
      hipblasCgetriBatched_rank_0,&
      hipblasCgetriBatched_rank_1
#endif
  end interface
  !>  \brief SOLVER API
  !> 
  !>     \details
  !>     getriBatched computes the inverse \f$C_i = A_i^{-1}\f$ of a batch of general n-by-n matrices \f$A_i\f$.
  !> 
  !>     The inverse is computed by solving the linear system
  !> 
  !>     \f[
  !>         A_i C_i = I
  !>     \f]
  !> 
  !>     where I is the identity matrix, and \f$A_i\f$ is factorized as \f$A_i = P_i  L_i  U_i\f$ as given by \ref hipblasSgetrfBatched "getrfBatched".
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of rows and columns of all matrices A_i in the batch.
  !>     @param[in]
  !>     A         array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\n
  !>               The factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \ref hipblasSgetrfBatched "getrfBatched".
  !>     @param[in]
  !>     lda       int. lda >= n.\n
  !>               Specifies the leading dimension of matrices A_i.
  !>     @param[in]
  !>     ipiv      pointer to int. Array on the GPU (the size depends on the value of strideP).\n
  !>               The pivot indices returned by \ref hipblasSgetrfBatched "getrfBatched".
  !>               ipiv can be passed in as a nullptr, this will assume that getrfBatched was called without partial pivoting.
  !>     @param[out]
  !>     C         array of pointers to type. Each pointer points to an array on the GPU of dimension ldc*n.\n
  !>               If info[i] = 0, the inverse of matrices A_i. Otherwise, undefined.
  !>     @param[in]
  !>     ldc       int. ldc >= n.\n
  !>               Specifies the leading dimension of C_i.
  !>     @param[out]
  !>     info      pointer to int. Array of batchCount integers on the GPU.\n
  !>               If info[i] = 0, successful exit for inversion of A_i.
  !>               If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.
  !>     @param[in]
  !>     batchCount int. batchCount >= 0.\n
  !>                 Number of matrices in the batch.
  !>
  interface hipblasZgetriBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="cublasZgetriBatched")
#else
    function hipblasZgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="hipblasZgetriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgetriBatched_full_rank,&
      hipblasZgetriBatched_rank_0,&
      hipblasZgetriBatched_rank_1
#endif
  end interface
  
  interface hipblasSgeqrf
#ifdef USE_CUDA_NAMES
    function hipblasSgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="cublasSgeqrf")
#else
    function hipblasSgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="hipblasSgeqrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgeqrf_full_rank,&
      hipblasSgeqrf_rank_0,&
      hipblasSgeqrf_rank_1
#endif
  end interface
  
  interface hipblasDgeqrf
#ifdef USE_CUDA_NAMES
    function hipblasDgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="cublasDgeqrf")
#else
    function hipblasDgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="hipblasDgeqrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgeqrf_full_rank,&
      hipblasDgeqrf_rank_0,&
      hipblasDgeqrf_rank_1
#endif
  end interface
  
  interface hipblasCgeqrf
#ifdef USE_CUDA_NAMES
    function hipblasCgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="cublasCgeqrf")
#else
    function hipblasCgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="hipblasCgeqrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgeqrf_full_rank,&
      hipblasCgeqrf_rank_0,&
      hipblasCgeqrf_rank_1
#endif
  end interface
  !>  \brief SOLVER API
  !> 
  !>     \details
  !>     geqrf computes a QR factorization of a general m-by-n matrix A.
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = Q\left[\begin{array}{c}
  !>         R\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where R is upper triangular (upper trapezoidal if m < n), and Q is
  !>     a m-by-m orthogonal/unitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q = H_1H_2\cdots H_k, \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_i\f$ is given by
  !> 
  !>     \f[
  !>         H_i = I - \text{ipiv}[i] \cdot v_i v_i'
  !>     \f]
  !> 
  !>     where the first i-1 elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     m         int. m >= 0.\n
  !>               The number of rows of the matrix A.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns of the matrix A.
  !>     @param[inout]
  !>     A         pointer to type. Array on the GPU of dimension lda*n.\n
  !>               On entry, the m-by-n matrix to be factored.
  !>               On exit, the elements on and above the diagonal contain the
  !>               factor R; the elements below the diagonal are the last m - i elements
  !>               of Householder vector v_i.
  !>     @param[in]
  !>     lda       int. lda >= m.\n
  !>               Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv      pointer to type. Array on the GPU of dimension min(m,n).\n
  !>               The Householder scalars.
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = j < 0, the j-th argument is invalid.
  !>
  interface hipblasZgeqrf
#ifdef USE_CUDA_NAMES
    function hipblasZgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="cublasZgeqrf")
#else
    function hipblasZgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="hipblasZgeqrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgeqrf_full_rank,&
      hipblasZgeqrf_rank_0,&
      hipblasZgeqrf_rank_1
#endif
  end interface
  
  interface hipblasSgeqrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasSgeqrfBatched")
#else
    function hipblasSgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasSgeqrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgeqrfBatched_full_rank,&
      hipblasSgeqrfBatched_rank_0,&
      hipblasSgeqrfBatched_rank_1
#endif
  end interface
  
  interface hipblasDgeqrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasDgeqrfBatched")
#else
    function hipblasDgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasDgeqrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgeqrfBatched_full_rank,&
      hipblasDgeqrfBatched_rank_0,&
      hipblasDgeqrfBatched_rank_1
#endif
  end interface
  
  interface hipblasCgeqrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasCgeqrfBatched")
#else
    function hipblasCgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasCgeqrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgeqrfBatched_full_rank,&
      hipblasCgeqrfBatched_rank_0,&
      hipblasCgeqrfBatched_rank_1
#endif
  end interface
  !>  \brief SOLVER API
  !> 
  !>     \details
  !>     geqrfBatched computes the QR factorization of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     The factorization of matrix \f$A_i\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_i = Q_i\left[\begin{array}{c}
  !>         R_i\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$R_i\f$ is upper triangular (upper trapezoidal if m < n), and \f$Q_i\f$ is
  !>     a m-by-m orthogonal/unitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_i = H_{i_1}H_{i_2}\cdots H_{i_k}, \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_{i_j}\f$ is given by
  !> 
  !>     \f[
  !>         H_{i_j} = I - \text{ipiv}_i[j] \cdot v_{i_j} v_{i_j}'
  !>     \f]
  !> 
  !>     where the first j-1 elements of Householder vector \f$v_{i_j}\f$ are zero, and \f$v_{i_j}[j] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     m         int. m >= 0.\n
  !>               The number of rows of all the matrices A_i in the batch.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns of all the matrices A_i in the batch.
  !>     @param[inout]
  !>     A         Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\n
  !>               On entry, the m-by-n matrices A_i to be factored.
  !>               On exit, the elements on and above the diagonal contain the
  !>               factor R_i. The elements below the diagonal are the last m - j elements
  !>               of Householder vector v_(i_j).
  !>     @param[in]
  !>     lda       int. lda >= m.\n
  !>               Specifies the leading dimension of matrices A_i.
  !>     @param[out]
  !>     ipiv      array of pointers to type. Each pointer points to an array on the GPU
  !>               of dimension min(m, n).\n
  !>               Contains the vectors ipiv_i of corresponding Householder scalars.
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = k < 0, the k-th argument is invalid.
  !>     @param[in]
  !>     batchCount  int. batchCount >= 0.\n
  !>                  Number of matrices in the batch.
  interface hipblasZgeqrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasZgeqrfBatched")
#else
    function hipblasZgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasZgeqrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgeqrfBatched_full_rank,&
      hipblasZgeqrfBatched_rank_0,&
      hipblasZgeqrfBatched_rank_1
#endif
  end interface
  
  interface hipblasSgeqrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasSgeqrfStridedBatched")
#else
    function hipblasSgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasSgeqrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasSgeqrfStridedBatched_full_rank,&
      hipblasSgeqrfStridedBatched_rank_0,&
      hipblasSgeqrfStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasDgeqrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasDgeqrfStridedBatched")
#else
    function hipblasDgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasDgeqrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasDgeqrfStridedBatched_full_rank,&
      hipblasDgeqrfStridedBatched_rank_0,&
      hipblasDgeqrfStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasCgeqrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasCgeqrfStridedBatched")
#else
    function hipblasCgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasCgeqrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasCgeqrfStridedBatched_full_rank,&
      hipblasCgeqrfStridedBatched_rank_0,&
      hipblasCgeqrfStridedBatched_rank_1
#endif
  end interface
  !>  \brief SOLVER API
  !> 
  !>     \details
  !>     geqrfStridedBatched computes the QR factorization of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     The factorization of matrix \f$A_i\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_i = Q_i\left[\begin{array}{c}
  !>         R_i\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$R_i\f$ is upper triangular (upper trapezoidal if m < n), and \f$Q_i\f$ is
  !>     a m-by-m orthogonal/unitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_i = H_{i_1}H_{i_2}\cdots H_{i_k}, \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_{i_j}\f$ is given by
  !> 
  !>     \f[
  !>         H_{i_j} = I - \text{ipiv}_j[j] \cdot v_{i_j} v_{i_j}'
  !>     \f]
  !> 
  !>     where the first j-1 elements of Householder vector \f$v_{i_j}\f$ are zero, and \f$v_{i_j}[j] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     m         int. m >= 0.\n
  !>               The number of rows of all the matrices A_i in the batch.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns of all the matrices A_i in the batch.
  !>     @param[inout]
  !>     A         pointer to type. Array on the GPU (the size depends on the value of strideA).\n
  !>               On entry, the m-by-n matrices A_i to be factored.
  !>               On exit, the elements on and above the diagonal contain the
  !>               factor R_i. The elements below the diagonal are the last m - j elements
  !>               of Householder vector v_(i_j).
  !>     @param[in]
  !>     lda       int. lda >= m.\n
  !>               Specifies the leading dimension of matrices A_i.
  !>     @param[in]
  !>     strideA   hipblasStride.\n
  !>               Stride from the start of one matrix A_i to the next one A_(i+1).
  !>               There is no restriction for the value of strideA. Normal use case is strideA >= lda*n.
  !>     @param[out]
  !>     ipiv      pointer to type. Array on the GPU (the size depends on the value of strideP).\n
  !>               Contains the vectors ipiv_i of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP   hipblasStride.\n
  !>               Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
  !>               There is no restriction for the value
  !>               of strideP. Normal use is strideP >= min(m,n).
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = k < 0, the k-th argument is invalid.
  !>     @param[in]
  !>     batchCount  int. batchCount >= 0.\n
  !>                  Number of matrices in the batch.
  interface hipblasZgeqrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasZgeqrfStridedBatched")
#else
    function hipblasZgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasZgeqrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      hipblasZgeqrfStridedBatched_full_rank,&
      hipblasZgeqrfStridedBatched_rank_0,&
      hipblasZgeqrfStridedBatched_rank_1
#endif
  end interface
  
  interface hipblasGemmEx
#ifdef USE_CUDA_NAMES
    function hipblasGemmEx_(handle,trans_a,trans_b,m,n,k,alpha,a,a_type,lda,b,b_type,ldb,beta,c,c_type,ldc,compute_type,algo) bind(c, name="cublasGemmEx")
#else
    function hipblasGemmEx_(handle,trans_a,trans_b,m,n,k,alpha,a,a_type,lda,b,b_type,ldb,beta,c,c_type,ldc,compute_type,algo) bind(c, name="hipblasGemmEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans_a
      integer(kind(HIPBLAS_OP_N)),value :: trans_b
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: a
      integer(kind(HIPBLAS_R_16F)),value :: a_type
      integer(c_int),value :: lda
      type(c_ptr),value :: b
      integer(kind(HIPBLAS_R_16F)),value :: b_type
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr),value :: c
      integer(kind(HIPBLAS_R_16F)),value :: c_type
      integer(c_int),value :: ldc
      integer(kind(HIPBLAS_R_16F)),value :: compute_type
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
    end function

  end interface
  
  interface hipblasGemmBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasGemmBatchedEx_(handle,trans_a,trans_b,m,n,k,alpha,a,a_type,lda,b,b_type,ldb,beta,c,c_type,ldc,batch_count,compute_type,algo) bind(c, name="cublasGemmBatchedEx")
#else
    function hipblasGemmBatchedEx_(handle,trans_a,trans_b,m,n,k,alpha,a,a_type,lda,b,b_type,ldb,beta,c,c_type,ldc,batch_count,compute_type,algo) bind(c, name="hipblasGemmBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmBatchedEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans_a
      integer(kind(HIPBLAS_OP_N)),value :: trans_b
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr) :: a
      integer(kind(HIPBLAS_R_16F)),value :: a_type
      integer(c_int),value :: lda
      type(c_ptr) :: b
      integer(kind(HIPBLAS_R_16F)),value :: b_type
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr) :: c
      integer(kind(HIPBLAS_R_16F)),value :: c_type
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
      integer(kind(HIPBLAS_R_16F)),value :: compute_type
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
    end function

  end interface
  
  interface hipblasGemmStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasGemmStridedBatchedEx_(handle,trans_a,trans_b,m,n,k,alpha,a,a_type,lda,stride_A,b,b_type,ldb,stride_B,beta,c,c_type,ldc,stride_C,batch_count,compute_type,algo) bind(c, name="cublasGemmStridedBatchedEx")
#else
    function hipblasGemmStridedBatchedEx_(handle,trans_a,trans_b,m,n,k,alpha,a,a_type,lda,stride_A,b,b_type,ldb,stride_B,beta,c,c_type,ldc,stride_C,batch_count,compute_type,algo) bind(c, name="hipblasGemmStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans_a
      integer(kind(HIPBLAS_OP_N)),value :: trans_b
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: a
      integer(kind(HIPBLAS_R_16F)),value :: a_type
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: b
      integer(kind(HIPBLAS_R_16F)),value :: b_type
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      type(c_ptr),value :: beta
      type(c_ptr),value :: c
      integer(kind(HIPBLAS_R_16F)),value :: c_type
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
      integer(kind(HIPBLAS_R_16F)),value :: compute_type
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
    end function

  end interface
  
  interface hipblasTrsmEx
#ifdef USE_CUDA_NAMES
    function hipblasTrsmEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,invA,invA_size,compute_type) bind(c, name="cublasTrsmEx")
#else
    function hipblasTrsmEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,invA,invA_size,compute_type) bind(c, name="hipblasTrsmEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasTrsmEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: invA
      integer(c_int),value :: invA_size
      integer(kind(HIPBLAS_R_16F)),value :: compute_type
    end function

  end interface
  
  interface hipblasTrsmBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasTrsmBatchedEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count,invA,invA_size,compute_type) bind(c, name="cublasTrsmBatchedEx")
#else
    function hipblasTrsmBatchedEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count,invA,invA_size,compute_type) bind(c, name="hipblasTrsmBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasTrsmBatchedEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      type(c_ptr),value :: invA
      integer(c_int),value :: invA_size
      integer(kind(HIPBLAS_R_16F)),value :: compute_type
    end function

  end interface
  
  interface hipblasTrsmStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasTrsmStridedBatchedEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,batch_count,invA,invA_size,stride_invA,compute_type) bind(c, name="cublasTrsmStridedBatchedEx")
#else
    function hipblasTrsmStridedBatchedEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,batch_count,invA,invA_size,stride_invA,compute_type) bind(c, name="hipblasTrsmStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasTrsmStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      integer(c_int),value :: batch_count
      type(c_ptr),value :: invA
      integer(c_int),value :: invA_size
      integer(c_int64_t),value :: stride_invA
      integer(kind(HIPBLAS_R_16F)),value :: compute_type
    end function

  end interface
  
  interface hipblasAxpyEx
#ifdef USE_CUDA_NAMES
    function hipblasAxpyEx_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,executionType) bind(c, name="cublasAxpyEx")
#else
    function hipblasAxpyEx_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,executionType) bind(c, name="hipblasAxpyEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasAxpyEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIPBLAS_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasAxpyBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasAxpyBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,batch_count,executionType) bind(c, name="cublasAxpyBatchedEx")
#else
    function hipblasAxpyBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,batch_count,executionType) bind(c, name="hipblasAxpyBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasAxpyBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIPBLAS_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasAxpyStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasAxpyStridedBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,stridex,y,yType,incy,stridey,batch_count,executionType) bind(c, name="cublasAxpyStridedBatchedEx")
#else
    function hipblasAxpyStridedBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,stridex,y,yType,incy,stridey,batch_count,executionType) bind(c, name="hipblasAxpyStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasAxpyStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIPBLAS_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasDotEx
#ifdef USE_CUDA_NAMES
    function hipblasDotEx_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="cublasDotEx")
#else
    function hipblasDotEx_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="hipblasDotEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      integer(kind(HIPBLAS_R_16F)),value :: resultType
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasDotcEx
#ifdef USE_CUDA_NAMES
    function hipblasDotcEx_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="cublasDotcEx")
#else
    function hipblasDotcEx_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="hipblasDotcEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotcEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      integer(kind(HIPBLAS_R_16F)),value :: resultType
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasDotBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasDotBatchedEx_(handle,n,x,xType,incx,y,yType,incy,batch_count,myResult,resultType,executionType) bind(c, name="cublasDotBatchedEx")
#else
    function hipblasDotBatchedEx_(handle,n,x,xType,incx,y,yType,incy,batch_count,myResult,resultType,executionType) bind(c, name="hipblasDotBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      integer(kind(HIPBLAS_R_16F)),value :: resultType
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasDotcBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasDotcBatchedEx_(handle,n,x,xType,incx,y,yType,incy,batch_count,myResult,resultType,executionType) bind(c, name="cublasDotcBatchedEx")
#else
    function hipblasDotcBatchedEx_(handle,n,x,xType,incx,y,yType,incy,batch_count,myResult,resultType,executionType) bind(c, name="hipblasDotcBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotcBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      integer(kind(HIPBLAS_R_16F)),value :: resultType
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasDotStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasDotStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batch_count,myResult,resultType,executionType) bind(c, name="cublasDotStridedBatchedEx")
#else
    function hipblasDotStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batch_count,myResult,resultType,executionType) bind(c, name="hipblasDotStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      integer(kind(HIPBLAS_R_16F)),value :: resultType
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasDotcStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasDotcStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batch_count,myResult,resultType,executionType) bind(c, name="cublasDotcStridedBatchedEx")
#else
    function hipblasDotcStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batch_count,myResult,resultType,executionType) bind(c, name="hipblasDotcStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotcStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      integer(kind(HIPBLAS_R_16F)),value :: resultType
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasNrm2Ex
#ifdef USE_CUDA_NAMES
    function hipblasNrm2Ex_(handle,n,x,xType,incx,myResult,resultType,executionType) bind(c, name="cublasNrm2Ex")
#else
    function hipblasNrm2Ex_(handle,n,x,xType,incx,myResult,resultType,executionType) bind(c, name="hipblasNrm2Ex")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasNrm2Ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      integer(kind(HIPBLAS_R_16F)),value :: resultType
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasNrm2BatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasNrm2BatchedEx_(handle,n,x,xType,incx,batch_count,myResult,resultType,executionType) bind(c, name="cublasNrm2BatchedEx")
#else
    function hipblasNrm2BatchedEx_(handle,n,x,xType,incx,batch_count,myResult,resultType,executionType) bind(c, name="hipblasNrm2BatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasNrm2BatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      integer(kind(HIPBLAS_R_16F)),value :: resultType
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasNrm2StridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasNrm2StridedBatchedEx_(handle,n,x,xType,incx,stridex,batch_count,myResult,resultType,executionType) bind(c, name="cublasNrm2StridedBatchedEx")
#else
    function hipblasNrm2StridedBatchedEx_(handle,n,x,xType,incx,stridex,batch_count,myResult,resultType,executionType) bind(c, name="hipblasNrm2StridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasNrm2StridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      integer(kind(HIPBLAS_R_16F)),value :: resultType
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasRotEx
#ifdef USE_CUDA_NAMES
    function hipblasRotEx_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,executionType) bind(c, name="cublasRotEx")
#else
    function hipblasRotEx_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,executionType) bind(c, name="hipblasRotEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasRotEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(HIPBLAS_R_16F)),value :: csType
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasRotBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasRotBatchedEx_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,batch_count,executionType) bind(c, name="cublasRotBatchedEx")
#else
    function hipblasRotBatchedEx_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,batch_count,executionType) bind(c, name="hipblasRotBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasRotBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(HIPBLAS_R_16F)),value :: csType
      integer(c_int),value :: batch_count
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasRotStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasRotStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,c,s,csType,batch_count,executionType) bind(c, name="cublasRotStridedBatchedEx")
#else
    function hipblasRotStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,c,s,csType,batch_count,executionType) bind(c, name="hipblasRotStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasRotStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIPBLAS_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(HIPBLAS_R_16F)),value :: csType
      integer(c_int),value :: batch_count
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasScalEx
#ifdef USE_CUDA_NAMES
    function hipblasScalEx_(handle,n,alpha,alphaType,x,xType,incx,executionType) bind(c, name="cublasScalEx")
#else
    function hipblasScalEx_(handle,n,alpha,alphaType,x,xType,incx,executionType) bind(c, name="hipblasScalEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScalEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIPBLAS_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasScalBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasScalBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,batch_count,executionType) bind(c, name="cublasScalBatchedEx")
#else
    function hipblasScalBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,batch_count,executionType) bind(c, name="hipblasScalBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScalBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIPBLAS_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface
  
  interface hipblasScalStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasScalStridedBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,stridex,batch_count,executionType) bind(c, name="cublasScalStridedBatchedEx")
#else
    function hipblasScalStridedBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,stridex,batch_count,executionType) bind(c, name="hipblasScalStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScalStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIPBLAS_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIPBLAS_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      integer(kind(HIPBLAS_R_16F)),value :: executionType
    end function

  end interface

#ifdef USE_FPOINTER_INTERFACES
  contains
    function hipblasIsamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamax_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIsamax_rank_0 = hipblasIsamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIsamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamax_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIsamax_rank_1 = hipblasIsamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIdamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamax_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIdamax_rank_0 = hipblasIdamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIdamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamax_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIdamax_rank_1 = hipblasIdamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamax_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamax_rank_0 = hipblasIcamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamax_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamax_rank_1 = hipblasIcamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamax_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamax_rank_0 = hipblasIzamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamax_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamax_rank_1 = hipblasIzamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIsamaxBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsamaxBatched_full_rank = hipblasIsamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsamaxBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsamaxBatched_rank_0 = hipblasIsamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsamaxBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsamaxBatched_rank_1 = hipblasIsamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdamaxBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdamaxBatched_full_rank = hipblasIdamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdamaxBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdamaxBatched_rank_0 = hipblasIdamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdamaxBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdamaxBatched_rank_1 = hipblasIdamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcamaxBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxBatched_full_rank = hipblasIcamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcamaxBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxBatched_rank_0 = hipblasIcamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcamaxBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxBatched_rank_1 = hipblasIcamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzamaxBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxBatched_full_rank = hipblasIzamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzamaxBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxBatched_rank_0 = hipblasIzamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzamaxBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxBatched_rank_1 = hipblasIzamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsamaxStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsamaxStridedBatched_rank_0 = hipblasIsamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIsamaxStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsamaxStridedBatched_rank_1 = hipblasIsamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIdamaxStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdamaxStridedBatched_rank_0 = hipblasIdamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIdamaxStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdamaxStridedBatched_rank_1 = hipblasIdamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcamaxStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxStridedBatched_rank_0 = hipblasIcamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcamaxStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxStridedBatched_rank_1 = hipblasIcamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzamaxStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxStridedBatched_rank_0 = hipblasIzamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzamaxStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxStridedBatched_rank_1 = hipblasIzamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIsamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamin_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIsamin_rank_0 = hipblasIsamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIsamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamin_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIsamin_rank_1 = hipblasIsamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIdamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamin_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIdamin_rank_0 = hipblasIdamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIdamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamin_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIdamin_rank_1 = hipblasIdamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamin_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamin_rank_0 = hipblasIcamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamin_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamin_rank_1 = hipblasIcamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamin_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamin_rank_0 = hipblasIzamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamin_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamin_rank_1 = hipblasIzamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIsaminBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsaminBatched_full_rank = hipblasIsaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsaminBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsaminBatched_rank_0 = hipblasIsaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsaminBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsaminBatched_rank_1 = hipblasIsaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdaminBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdaminBatched_full_rank = hipblasIdaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdaminBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdaminBatched_rank_0 = hipblasIdaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdaminBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdaminBatched_rank_1 = hipblasIdaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcaminBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminBatched_full_rank = hipblasIcaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcaminBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminBatched_rank_0 = hipblasIcaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcaminBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminBatched_rank_1 = hipblasIcaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzaminBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminBatched_full_rank = hipblasIzaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzaminBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminBatched_rank_0 = hipblasIzaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzaminBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminBatched_rank_1 = hipblasIzaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsaminStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsaminStridedBatched_rank_0 = hipblasIsaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIsaminStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsaminStridedBatched_rank_1 = hipblasIsaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIdaminStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdaminStridedBatched_rank_0 = hipblasIdaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIdaminStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdaminStridedBatched_rank_1 = hipblasIdaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcaminStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminStridedBatched_rank_0 = hipblasIcaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcaminStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminStridedBatched_rank_1 = hipblasIcaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzaminStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminStridedBatched_rank_0 = hipblasIzaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzaminStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminStridedBatched_rank_1 = hipblasIzaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasSasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasum_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasSasum_rank_0 = hipblasSasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasSasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasum_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasSasum_rank_1 = hipblasSasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasum_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDasum_rank_0 = hipblasDasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasum_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDasum_rank_1 = hipblasDasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasum_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScasum_rank_0 = hipblasScasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasum_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScasum_rank_1 = hipblasScasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDzasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasum_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDzasum_rank_0 = hipblasDzasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDzasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasum_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDzasum_rank_1 = hipblasDzasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasSasumBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSasumBatched_full_rank = hipblasSasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSasumBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSasumBatched_rank_0 = hipblasSasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSasumBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSasumBatched_rank_1 = hipblasSasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDasumBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDasumBatched_full_rank = hipblasDasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDasumBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDasumBatched_rank_0 = hipblasDasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDasumBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDasumBatched_rank_1 = hipblasDasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScasumBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumBatched_full_rank = hipblasScasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScasumBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumBatched_rank_0 = hipblasScasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScasumBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumBatched_rank_1 = hipblasScasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDzasumBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumBatched_full_rank = hipblasDzasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDzasumBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumBatched_rank_0 = hipblasDzasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDzasumBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumBatched_rank_1 = hipblasDzasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSasumStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSasumStridedBatched_rank_0 = hipblasSasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasSasumStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSasumStridedBatched_rank_1 = hipblasSasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDasumStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDasumStridedBatched_rank_0 = hipblasDasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDasumStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDasumStridedBatched_rank_1 = hipblasDasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScasumStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumStridedBatched_rank_0 = hipblasScasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScasumStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumStridedBatched_rank_1 = hipblasScasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDzasumStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumStridedBatched_rank_0 = hipblasDzasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDzasumStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumStridedBatched_rank_1 = hipblasDzasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasSaxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSaxpy_rank_0 = hipblasSaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasSaxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSaxpy_rank_1 = hipblasSaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDaxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDaxpy_rank_0 = hipblasDaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDaxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDaxpy_rank_1 = hipblasDaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCaxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCaxpy_rank_0 = hipblasCaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCaxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCaxpy_rank_1 = hipblasCaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZaxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZaxpy_rank_0 = hipblasZaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZaxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZaxpy_rank_1 = hipblasZaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasSaxpyBatched_full_rank(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSaxpyBatched_full_rank = hipblasSaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSaxpyBatched_rank_0(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSaxpyBatched_rank_0 = hipblasSaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSaxpyBatched_rank_1(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSaxpyBatched_rank_1 = hipblasSaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDaxpyBatched_full_rank(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDaxpyBatched_full_rank = hipblasDaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDaxpyBatched_rank_0(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDaxpyBatched_rank_0 = hipblasDaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDaxpyBatched_rank_1(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDaxpyBatched_rank_1 = hipblasDaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCaxpyBatched_full_rank(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCaxpyBatched_full_rank = hipblasCaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCaxpyBatched_rank_0(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCaxpyBatched_rank_0 = hipblasCaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCaxpyBatched_rank_1(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCaxpyBatched_rank_1 = hipblasCaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZaxpyBatched_full_rank(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZaxpyBatched_full_rank = hipblasZaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZaxpyBatched_rank_0(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZaxpyBatched_rank_0 = hipblasZaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZaxpyBatched_rank_1(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZaxpyBatched_rank_1 = hipblasZaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSaxpyStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSaxpyStridedBatched_rank_0 = hipblasSaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSaxpyStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSaxpyStridedBatched_rank_1 = hipblasSaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDaxpyStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDaxpyStridedBatched_rank_0 = hipblasDaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDaxpyStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDaxpyStridedBatched_rank_1 = hipblasDaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCaxpyStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCaxpyStridedBatched_rank_0 = hipblasCaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCaxpyStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCaxpyStridedBatched_rank_1 = hipblasCaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZaxpyStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZaxpyStridedBatched_rank_0 = hipblasZaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZaxpyStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZaxpyStridedBatched_rank_1 = hipblasZaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasScopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasScopy_rank_0 = hipblasScopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasScopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasScopy_rank_1 = hipblasScopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDcopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDcopy_rank_0 = hipblasDcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDcopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDcopy_rank_1 = hipblasDcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCcopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCcopy_rank_0 = hipblasCcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCcopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCcopy_rank_1 = hipblasCcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZcopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZcopy_rank_0 = hipblasZcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZcopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZcopy_rank_1 = hipblasZcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasScopyBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasScopyBatched_full_rank = hipblasScopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasScopyBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasScopyBatched_rank_0 = hipblasScopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasScopyBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasScopyBatched_rank_1 = hipblasScopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDcopyBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDcopyBatched_full_rank = hipblasDcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDcopyBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDcopyBatched_rank_0 = hipblasDcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDcopyBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDcopyBatched_rank_1 = hipblasDcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCcopyBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCcopyBatched_full_rank = hipblasCcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCcopyBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCcopyBatched_rank_0 = hipblasCcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCcopyBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCcopyBatched_rank_1 = hipblasCcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZcopyBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZcopyBatched_full_rank = hipblasZcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZcopyBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZcopyBatched_rank_0 = hipblasZcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZcopyBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZcopyBatched_rank_1 = hipblasZcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasScopyStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasScopyStridedBatched_rank_0 = hipblasScopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasScopyStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasScopyStridedBatched_rank_1 = hipblasScopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDcopyStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDcopyStridedBatched_rank_0 = hipblasDcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDcopyStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDcopyStridedBatched_rank_1 = hipblasDcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCcopyStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCcopyStridedBatched_rank_0 = hipblasCcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCcopyStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCcopyStridedBatched_rank_1 = hipblasCcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZcopyStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZcopyStridedBatched_rank_0 = hipblasZcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZcopyStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZcopyStridedBatched_rank_1 = hipblasZcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSdot_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasSdot_rank_0 = hipblasSdot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasSdot_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasSdot_rank_1 = hipblasSdot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasDdot_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasDdot_rank_0 = hipblasDdot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasDdot_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasDdot_rank_1 = hipblasDdot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotc_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotc_rank_0 = hipblasCdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotc_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotc_rank_1 = hipblasCdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotu_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotu_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotu_rank_0 = hipblasCdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotu_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotu_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotu_rank_1 = hipblasCdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotc_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotc_rank_0 = hipblasZdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotc_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotc_rank_1 = hipblasZdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotu_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotu_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotu_rank_0 = hipblasZdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotu_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotu_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotu_rank_1 = hipblasZdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasSdotBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSdotBatched_full_rank = hipblasSdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasSdotBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSdotBatched_rank_0 = hipblasSdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasSdotBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSdotBatched_rank_1 = hipblasSdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasDdotBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDdotBatched_full_rank = hipblasDdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasDdotBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDdotBatched_rank_0 = hipblasDdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasDdotBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDdotBatched_rank_1 = hipblasDdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotcBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcBatched_full_rank = hipblasCdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotcBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcBatched_rank_0 = hipblasCdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotcBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcBatched_rank_1 = hipblasCdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotuBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuBatched_full_rank = hipblasCdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotuBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuBatched_rank_0 = hipblasCdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotuBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuBatched_rank_1 = hipblasCdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotcBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcBatched_full_rank = hipblasZdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotcBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcBatched_rank_0 = hipblasZdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotcBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcBatched_rank_1 = hipblasZdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotuBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuBatched_full_rank = hipblasZdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotuBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuBatched_rank_0 = hipblasZdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotuBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuBatched_rank_1 = hipblasZdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasSdotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSdotStridedBatched_rank_0 = hipblasSdotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasSdotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSdotStridedBatched_rank_1 = hipblasSdotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasDdotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDdotStridedBatched_rank_0 = hipblasDdotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasDdotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDdotStridedBatched_rank_1 = hipblasDdotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotcStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcStridedBatched_rank_0 = hipblasCdotcStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotcStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcStridedBatched_rank_1 = hipblasCdotcStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotuStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuStridedBatched_rank_0 = hipblasCdotuStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotuStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuStridedBatched_rank_1 = hipblasCdotuStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotcStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcStridedBatched_rank_0 = hipblasZdotcStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotcStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcStridedBatched_rank_1 = hipblasZdotcStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotuStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuStridedBatched_rank_0 = hipblasZdotuStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotuStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuStridedBatched_rank_1 = hipblasZdotuStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasSnrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasSnrm2_rank_0 = hipblasSnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasSnrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasSnrm2_rank_1 = hipblasSnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDnrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDnrm2_rank_0 = hipblasDnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDnrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDnrm2_rank_1 = hipblasDnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScnrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScnrm2_rank_0 = hipblasScnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScnrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScnrm2_rank_1 = hipblasScnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDznrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDznrm2_rank_0 = hipblasDznrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDznrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDznrm2_rank_1 = hipblasDznrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasSnrm2Batched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2Batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSnrm2Batched_full_rank = hipblasSnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSnrm2Batched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2Batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSnrm2Batched_rank_0 = hipblasSnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSnrm2Batched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2Batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSnrm2Batched_rank_1 = hipblasSnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDnrm2Batched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2Batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDnrm2Batched_full_rank = hipblasDnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDnrm2Batched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2Batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDnrm2Batched_rank_0 = hipblasDnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDnrm2Batched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2Batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDnrm2Batched_rank_1 = hipblasDnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScnrm2Batched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2Batched_full_rank = hipblasScnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScnrm2Batched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2Batched_rank_0 = hipblasScnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScnrm2Batched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2Batched_rank_1 = hipblasScnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDznrm2Batched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2Batched_full_rank = hipblasDznrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDznrm2Batched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2Batched_rank_0 = hipblasDznrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDznrm2Batched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2Batched_rank_1 = hipblasDznrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSnrm2StridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSnrm2StridedBatched_rank_0 = hipblasSnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasSnrm2StridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSnrm2StridedBatched_rank_1 = hipblasSnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDnrm2StridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDnrm2StridedBatched_rank_0 = hipblasDnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDnrm2StridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDnrm2StridedBatched_rank_1 = hipblasDnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScnrm2StridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2StridedBatched_rank_0 = hipblasScnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScnrm2StridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2StridedBatched_rank_1 = hipblasScnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDznrm2StridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2StridedBatched_rank_0 = hipblasDznrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDznrm2StridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2StridedBatched_rank_1 = hipblasDznrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasSrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasSrot_rank_0 = hipblasSrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasSrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasSrot_rank_1 = hipblasSrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasDrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasDrot_rank_0 = hipblasDrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasDrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasDrot_rank_1 = hipblasDrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCrot_rank_0 = hipblasCrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCrot_rank_1 = hipblasCrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCsrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCsrot_rank_0 = hipblasCsrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCsrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCsrot_rank_1 = hipblasCsrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZrot_rank_0 = hipblasZrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZrot_rank_1 = hipblasZrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZdrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZdrot_rank_0 = hipblasZdrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZdrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZdrot_rank_1 = hipblasZdrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasSrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasSrotBatched_full_rank = hipblasSrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasSrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasSrotBatched_rank_0 = hipblasSrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasSrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasSrotBatched_rank_1 = hipblasSrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasDrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasDrotBatched_full_rank = hipblasDrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasDrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasDrotBatched_rank_0 = hipblasDrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasDrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasDrotBatched_rank_1 = hipblasDrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotBatched_full_rank = hipblasCrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotBatched_rank_0 = hipblasCrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotBatched_rank_1 = hipblasCrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCsrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotBatched_full_rank = hipblasCsrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCsrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotBatched_rank_0 = hipblasCsrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCsrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotBatched_rank_1 = hipblasCsrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotBatched_full_rank = hipblasZrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotBatched_rank_0 = hipblasZrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotBatched_rank_1 = hipblasZrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZdrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotBatched_full_rank = hipblasZdrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZdrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotBatched_rank_0 = hipblasZdrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZdrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotBatched_rank_1 = hipblasZdrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasSrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasSrotStridedBatched_rank_0 = hipblasSrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasSrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasSrotStridedBatched_rank_1 = hipblasSrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasDrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasDrotStridedBatched_rank_0 = hipblasDrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasDrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasDrotStridedBatched_rank_1 = hipblasDrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotStridedBatched_rank_0 = hipblasCrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotStridedBatched_rank_1 = hipblasCrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCsrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotStridedBatched_rank_0 = hipblasCsrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCsrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotStridedBatched_rank_1 = hipblasCsrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotStridedBatched_rank_0 = hipblasZrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotStridedBatched_rank_1 = hipblasZrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZdrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotStridedBatched_rank_0 = hipblasZdrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZdrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotStridedBatched_rank_1 = hipblasZdrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasSrotm_rank_0(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotm_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      hipblasSrotm_rank_0 = hipblasSrotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function hipblasSrotm_rank_1(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotm_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      hipblasSrotm_rank_1 = hipblasSrotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function hipblasDrotm_rank_0(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotm_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      hipblasDrotm_rank_0 = hipblasDrotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function hipblasDrotm_rank_1(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotm_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      hipblasDrotm_rank_1 = hipblasDrotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function hipblasSrotmBatched_full_rank(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasSrotmBatched_full_rank = hipblasSrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasSrotmBatched_rank_0(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasSrotmBatched_rank_0 = hipblasSrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasSrotmBatched_rank_1(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasSrotmBatched_rank_1 = hipblasSrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasDrotmBatched_full_rank(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasDrotmBatched_full_rank = hipblasDrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasDrotmBatched_rank_0(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasDrotmBatched_rank_0 = hipblasDrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasDrotmBatched_rank_1(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasDrotmBatched_rank_1 = hipblasDrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasSrotmStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: param
      integer(c_int64_t) :: strideParam
      integer(c_int) :: batchCount
      !
      hipblasSrotmStridedBatched_rank_0 = hipblasSrotmStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,param,strideParam,batchCount)
    end function

    function hipblasSrotmStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: param
      integer(c_int64_t) :: strideParam
      integer(c_int) :: batchCount
      !
      hipblasSrotmStridedBatched_rank_1 = hipblasSrotmStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,param,strideParam,batchCount)
    end function

    function hipblasDrotmStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: param
      integer(c_int64_t) :: strideParam
      integer(c_int) :: batchCount
      !
      hipblasDrotmStridedBatched_rank_0 = hipblasDrotmStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,param,strideParam,batchCount)
    end function

    function hipblasDrotmStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: param
      integer(c_int64_t) :: strideParam
      integer(c_int) :: batchCount
      !
      hipblasDrotmStridedBatched_rank_1 = hipblasDrotmStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,param,strideParam,batchCount)
    end function

    function hipblasSscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasSscal_rank_0 = hipblasSscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasSscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasSscal_rank_1 = hipblasSscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasDscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDscal_rank_0 = hipblasDscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasDscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDscal_rank_1 = hipblasDscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCscal_rank_0 = hipblasCscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCscal_rank_1 = hipblasCscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCsscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCsscal_rank_0 = hipblasCsscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCsscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCsscal_rank_1 = hipblasCsscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZscal_rank_0 = hipblasZscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZscal_rank_1 = hipblasZscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZdscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZdscal_rank_0 = hipblasZdscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZdscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZdscal_rank_1 = hipblasZdscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasSscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasSscalBatched_full_rank = hipblasSscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasSscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasSscalBatched_rank_0 = hipblasSscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasSscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasSscalBatched_rank_1 = hipblasSscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasDscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDscalBatched_full_rank = hipblasDscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasDscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDscalBatched_rank_0 = hipblasDscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasDscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDscalBatched_rank_1 = hipblasDscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCscalBatched_full_rank = hipblasCscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCscalBatched_rank_0 = hipblasCscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCscalBatched_rank_1 = hipblasCscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZscalBatched_full_rank = hipblasZscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZscalBatched_rank_0 = hipblasZscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZscalBatched_rank_1 = hipblasZscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCsscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCsscalBatched_full_rank = hipblasCsscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCsscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCsscalBatched_rank_0 = hipblasCsscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCsscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCsscalBatched_rank_1 = hipblasCsscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZdscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZdscalBatched_full_rank = hipblasZdscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZdscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZdscalBatched_rank_0 = hipblasZdscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZdscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZdscalBatched_rank_1 = hipblasZdscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasSscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasSscalStridedBatched_rank_0 = hipblasSscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasSscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasSscalStridedBatched_rank_1 = hipblasSscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDscalStridedBatched_rank_0 = hipblasDscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDscalStridedBatched_rank_1 = hipblasDscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCscalStridedBatched_rank_0 = hipblasCscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCscalStridedBatched_rank_1 = hipblasCscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZscalStridedBatched_rank_0 = hipblasZscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZscalStridedBatched_rank_1 = hipblasZscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCsscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCsscalStridedBatched_rank_0 = hipblasCsscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCsscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCsscalStridedBatched_rank_1 = hipblasCsscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZdscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZdscalStridedBatched_rank_0 = hipblasZdscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZdscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZdscalStridedBatched_rank_1 = hipblasZdscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasSswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswap_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSswap_rank_0 = hipblasSswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasSswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswap_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSswap_rank_1 = hipblasSswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswap_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDswap_rank_0 = hipblasDswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswap_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDswap_rank_1 = hipblasDswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswap_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCswap_rank_0 = hipblasCswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswap_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCswap_rank_1 = hipblasCswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswap_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZswap_rank_0 = hipblasZswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswap_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZswap_rank_1 = hipblasZswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasSswapBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSswapBatched_full_rank = hipblasSswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSswapBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSswapBatched_rank_0 = hipblasSswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSswapBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSswapBatched_rank_1 = hipblasSswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDswapBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDswapBatched_full_rank = hipblasDswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDswapBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDswapBatched_rank_0 = hipblasDswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDswapBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDswapBatched_rank_1 = hipblasDswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCswapBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCswapBatched_full_rank = hipblasCswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCswapBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCswapBatched_rank_0 = hipblasCswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCswapBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCswapBatched_rank_1 = hipblasCswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZswapBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZswapBatched_full_rank = hipblasZswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZswapBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZswapBatched_rank_0 = hipblasZswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZswapBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZswapBatched_rank_1 = hipblasZswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSswapStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSswapStridedBatched_rank_0 = hipblasSswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSswapStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSswapStridedBatched_rank_1 = hipblasSswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDswapStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDswapStridedBatched_rank_0 = hipblasDswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDswapStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDswapStridedBatched_rank_1 = hipblasDswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCswapStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCswapStridedBatched_rank_0 = hipblasCswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCswapStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCswapStridedBatched_rank_1 = hipblasCswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZswapStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZswapStridedBatched_rank_0 = hipblasZswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZswapStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZswapStridedBatched_rank_1 = hipblasZswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSgbmv_full_rank = hipblasSgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSgbmv_rank_0 = hipblasSgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSgbmv_rank_1 = hipblasSgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDgbmv_full_rank = hipblasDgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDgbmv_rank_0 = hipblasDgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDgbmv_rank_1 = hipblasDgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCgbmv_full_rank = hipblasCgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCgbmv_rank_0 = hipblasCgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCgbmv_rank_1 = hipblasCgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZgbmv_full_rank = hipblasZgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZgbmv_rank_0 = hipblasZgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZgbmv_rank_1 = hipblasZgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSgbmvBatched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgbmvBatched_full_rank = hipblasSgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgbmvBatched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgbmvBatched_rank_0 = hipblasSgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgbmvBatched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgbmvBatched_rank_1 = hipblasSgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgbmvBatched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgbmvBatched_full_rank = hipblasDgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgbmvBatched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgbmvBatched_rank_0 = hipblasDgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgbmvBatched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgbmvBatched_rank_1 = hipblasDgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgbmvBatched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgbmvBatched_full_rank = hipblasCgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgbmvBatched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgbmvBatched_rank_0 = hipblasCgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgbmvBatched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgbmvBatched_rank_1 = hipblasCgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgbmvBatched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgbmvBatched_full_rank = hipblasZgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgbmvBatched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgbmvBatched_rank_0 = hipblasZgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgbmvBatched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgbmvBatched_rank_1 = hipblasZgbmvBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgbmvStridedBatched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSgbmvStridedBatched_full_rank = hipblasSgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSgbmvStridedBatched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSgbmvStridedBatched_rank_0 = hipblasSgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSgbmvStridedBatched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSgbmvStridedBatched_rank_1 = hipblasSgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDgbmvStridedBatched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDgbmvStridedBatched_full_rank = hipblasDgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDgbmvStridedBatched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDgbmvStridedBatched_rank_0 = hipblasDgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDgbmvStridedBatched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDgbmvStridedBatched_rank_1 = hipblasDgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgbmvStridedBatched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgbmvStridedBatched_full_rank = hipblasCgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgbmvStridedBatched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgbmvStridedBatched_rank_0 = hipblasCgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgbmvStridedBatched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgbmvStridedBatched_rank_1 = hipblasCgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgbmvStridedBatched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgbmvStridedBatched_full_rank = hipblasZgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgbmvStridedBatched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgbmvStridedBatched_rank_0 = hipblasZgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgbmvStridedBatched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgbmvStridedBatched_rank_1 = hipblasZgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSgemv_full_rank = hipblasSgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSgemv_rank_0 = hipblasSgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSgemv_rank_1 = hipblasSgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDgemv_full_rank = hipblasDgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDgemv_rank_0 = hipblasDgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDgemv_rank_1 = hipblasDgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCgemv_full_rank = hipblasCgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCgemv_rank_0 = hipblasCgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCgemv_rank_1 = hipblasCgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZgemv_full_rank = hipblasZgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZgemv_rank_0 = hipblasZgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZgemv_rank_1 = hipblasZgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSgemvBatched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgemvBatched_full_rank = hipblasSgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgemvBatched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgemvBatched_rank_0 = hipblasSgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgemvBatched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgemvBatched_rank_1 = hipblasSgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgemvBatched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgemvBatched_full_rank = hipblasDgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgemvBatched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgemvBatched_rank_0 = hipblasDgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgemvBatched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgemvBatched_rank_1 = hipblasDgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgemvBatched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgemvBatched_full_rank = hipblasCgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgemvBatched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgemvBatched_rank_0 = hipblasCgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgemvBatched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgemvBatched_rank_1 = hipblasCgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgemvBatched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgemvBatched_full_rank = hipblasZgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgemvBatched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgemvBatched_rank_0 = hipblasZgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgemvBatched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgemvBatched_rank_1 = hipblasZgemvBatched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgemvStridedBatched_full_rank(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSgemvStridedBatched_full_rank = hipblasSgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSgemvStridedBatched_rank_0(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSgemvStridedBatched_rank_0 = hipblasSgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSgemvStridedBatched_rank_1(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSgemvStridedBatched_rank_1 = hipblasSgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDgemvStridedBatched_full_rank(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDgemvStridedBatched_full_rank = hipblasDgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDgemvStridedBatched_rank_0(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDgemvStridedBatched_rank_0 = hipblasDgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDgemvStridedBatched_rank_1(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDgemvStridedBatched_rank_1 = hipblasDgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgemvStridedBatched_full_rank(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgemvStridedBatched_full_rank = hipblasCgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgemvStridedBatched_rank_0(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgemvStridedBatched_rank_0 = hipblasCgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgemvStridedBatched_rank_1(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgemvStridedBatched_rank_1 = hipblasCgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgemvStridedBatched_full_rank(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgemvStridedBatched_full_rank = hipblasZgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgemvStridedBatched_rank_0(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgemvStridedBatched_rank_0 = hipblasZgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgemvStridedBatched_rank_1(handle,trans,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgemvStridedBatched_rank_1 = hipblasZgemvStridedBatched_(handle,trans,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSger_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSger_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasSger_full_rank = hipblasSger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasSger_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSger_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      real(c_float),target :: A
      integer(c_int) :: lda
      !
      hipblasSger_rank_0 = hipblasSger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasSger_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSger_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasSger_rank_1 = hipblasSger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasDger_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDger_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasDger_full_rank = hipblasDger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasDger_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDger_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      real(c_double),target :: A
      integer(c_int) :: lda
      !
      hipblasDger_rank_0 = hipblasDger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasDger_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDger_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasDger_rank_1 = hipblasDger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCgeru_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeru_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasCgeru_full_rank = hipblasCgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCgeru_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeru_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasCgeru_rank_0 = hipblasCgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCgeru_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeru_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasCgeru_rank_1 = hipblasCgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCgerc_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgerc_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasCgerc_full_rank = hipblasCgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCgerc_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgerc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasCgerc_rank_0 = hipblasCgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCgerc_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgerc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasCgerc_rank_1 = hipblasCgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZgeru_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeru_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasZgeru_full_rank = hipblasZgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZgeru_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeru_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasZgeru_rank_0 = hipblasZgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZgeru_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeru_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasZgeru_rank_1 = hipblasZgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZgerc_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgerc_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasZgerc_full_rank = hipblasZgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZgerc_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgerc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasZgerc_rank_0 = hipblasZgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZgerc_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgerc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasZgerc_rank_1 = hipblasZgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasSgerBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSgerBatched_full_rank = hipblasSgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasSgerBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSgerBatched_rank_0 = hipblasSgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasSgerBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSgerBatched_rank_1 = hipblasSgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasDgerBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDgerBatched_full_rank = hipblasDgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasDgerBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDgerBatched_rank_0 = hipblasDgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasDgerBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDgerBatched_rank_1 = hipblasDgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCgeruBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgeruBatched_full_rank = hipblasCgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCgeruBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgeruBatched_rank_0 = hipblasCgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCgeruBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgeruBatched_rank_1 = hipblasCgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCgercBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgercBatched_full_rank = hipblasCgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCgercBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgercBatched_rank_0 = hipblasCgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCgercBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgercBatched_rank_1 = hipblasCgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZgeruBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgeruBatched_full_rank = hipblasZgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZgeruBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgeruBatched_rank_0 = hipblasZgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZgeruBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgeruBatched_rank_1 = hipblasZgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZgercBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgercBatched_full_rank = hipblasZgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZgercBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgercBatched_rank_0 = hipblasZgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZgercBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgercBatched_rank_1 = hipblasZgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasSgerStridedBatched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSgerStridedBatched_full_rank = hipblasSgerStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasSgerStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSgerStridedBatched_rank_0 = hipblasSgerStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasSgerStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSgerStridedBatched_rank_1 = hipblasSgerStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasDgerStridedBatched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDgerStridedBatched_full_rank = hipblasDgerStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasDgerStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDgerStridedBatched_rank_0 = hipblasDgerStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasDgerStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDgerStridedBatched_rank_1 = hipblasDgerStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCgeruStridedBatched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgeruStridedBatched_full_rank = hipblasCgeruStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCgeruStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgeruStridedBatched_rank_0 = hipblasCgeruStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCgeruStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgeruStridedBatched_rank_1 = hipblasCgeruStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCgercStridedBatched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgercStridedBatched_full_rank = hipblasCgercStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCgercStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgercStridedBatched_rank_0 = hipblasCgercStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCgercStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgercStridedBatched_rank_1 = hipblasCgercStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZgeruStridedBatched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgeruStridedBatched_full_rank = hipblasZgeruStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZgeruStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgeruStridedBatched_rank_0 = hipblasZgeruStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZgeruStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgeruStridedBatched_rank_1 = hipblasZgeruStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZgercStridedBatched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgercStridedBatched_full_rank = hipblasZgercStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZgercStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgercStridedBatched_rank_0 = hipblasZgercStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZgercStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgercStridedBatched_rank_1 = hipblasZgercStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasChbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChbmv_full_rank = hipblasChbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasChbmv_rank_0 = hipblasChbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChbmv_rank_1 = hipblasChbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhbmv_full_rank = hipblasZhbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZhbmv_rank_0 = hipblasZhbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhbmv_rank_1 = hipblasZhbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChbmvBatched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChbmvBatched_full_rank = hipblasChbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChbmvBatched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChbmvBatched_rank_0 = hipblasChbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChbmvBatched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChbmvBatched_rank_1 = hipblasChbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhbmvBatched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhbmvBatched_full_rank = hipblasZhbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhbmvBatched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhbmvBatched_rank_0 = hipblasZhbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhbmvBatched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhbmvBatched_rank_1 = hipblasZhbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChbmvStridedBatched_full_rank(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChbmvStridedBatched_full_rank = hipblasChbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChbmvStridedBatched_rank_0(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChbmvStridedBatched_rank_0 = hipblasChbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChbmvStridedBatched_rank_1(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChbmvStridedBatched_rank_1 = hipblasChbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhbmvStridedBatched_full_rank(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhbmvStridedBatched_full_rank = hipblasZhbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhbmvStridedBatched_rank_0(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhbmvStridedBatched_rank_0 = hipblasZhbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhbmvStridedBatched_rank_1(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhbmvStridedBatched_rank_1 = hipblasZhbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChemv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChemv_full_rank = hipblasChemv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChemv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasChemv_rank_0 = hipblasChemv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChemv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChemv_rank_1 = hipblasChemv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhemv_full_rank(handle,uplo,n,alpha,A,da,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: da
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhemv_full_rank = hipblasZhemv_(handle,uplo,n,alpha,c_loc(A),da,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhemv_rank_0(handle,uplo,n,alpha,A,da,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: da
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZhemv_rank_0 = hipblasZhemv_(handle,uplo,n,alpha,c_loc(A),da,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhemv_rank_1(handle,uplo,n,alpha,A,da,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: da
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhemv_rank_1 = hipblasZhemv_(handle,uplo,n,alpha,c_loc(A),da,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChemvBatched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChemvBatched_full_rank = hipblasChemvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChemvBatched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChemvBatched_rank_0 = hipblasChemvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChemvBatched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChemvBatched_rank_1 = hipblasChemvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhemvBatched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhemvBatched_full_rank = hipblasZhemvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhemvBatched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhemvBatched_rank_0 = hipblasZhemvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhemvBatched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhemvBatched_rank_1 = hipblasZhemvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChemvStridedBatched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChemvStridedBatched_full_rank = hipblasChemvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChemvStridedBatched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChemvStridedBatched_rank_0 = hipblasChemvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChemvStridedBatched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChemvStridedBatched_rank_1 = hipblasChemvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhemvStridedBatched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhemvStridedBatched_full_rank = hipblasZhemvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhemvStridedBatched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhemvStridedBatched_rank_0 = hipblasZhemvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhemvStridedBatched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhemvStridedBatched_rank_1 = hipblasZhemvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCher_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasCher_full_rank = hipblasCher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasCher_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasCher_rank_0 = hipblasCher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasCher_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasCher_rank_1 = hipblasCher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasZher_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasZher_full_rank = hipblasZher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasZher_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasZher_rank_0 = hipblasZher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasZher_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasZher_rank_1 = hipblasZher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasCherBatched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCherBatched_full_rank = hipblasCherBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasCherBatched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCherBatched_rank_0 = hipblasCherBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasCherBatched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCherBatched_rank_1 = hipblasCherBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasZherBatched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZherBatched_full_rank = hipblasZherBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasZherBatched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZherBatched_rank_0 = hipblasZherBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasZherBatched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZherBatched_rank_1 = hipblasZherBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasCherStridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCherStridedBatched_full_rank = hipblasCherStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCherStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCherStridedBatched_rank_0 = hipblasCherStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCherStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCherStridedBatched_rank_1 = hipblasCherStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZherStridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZherStridedBatched_full_rank = hipblasZherStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZherStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZherStridedBatched_rank_0 = hipblasZherStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZherStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZherStridedBatched_rank_1 = hipblasZherStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCher2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasCher2_full_rank = hipblasCher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCher2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasCher2_rank_0 = hipblasCher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCher2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasCher2_rank_1 = hipblasCher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZher2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasZher2_full_rank = hipblasZher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZher2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasZher2_rank_0 = hipblasZher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZher2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasZher2_rank_1 = hipblasZher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCher2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCher2Batched_full_rank = hipblasCher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCher2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCher2Batched_rank_0 = hipblasCher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCher2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCher2Batched_rank_1 = hipblasCher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZher2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZher2Batched_full_rank = hipblasZher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZher2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZher2Batched_rank_0 = hipblasZher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZher2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZher2Batched_rank_1 = hipblasZher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCher2StridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2StridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCher2StridedBatched_full_rank = hipblasCher2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCher2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCher2StridedBatched_rank_0 = hipblasCher2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCher2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCher2StridedBatched_rank_1 = hipblasCher2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZher2StridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2StridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZher2StridedBatched_full_rank = hipblasZher2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZher2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZher2StridedBatched_rank_0 = hipblasZher2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZher2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZher2StridedBatched_rank_1 = hipblasZher2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasChpmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasChpmv_rank_0 = hipblasChpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChpmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChpmv_rank_1 = hipblasChpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhpmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZhpmv_rank_0 = hipblasZhpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhpmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhpmv_rank_1 = hipblasZhpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChpmvBatched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChpmvBatched_full_rank = hipblasChpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChpmvBatched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChpmvBatched_rank_0 = hipblasChpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChpmvBatched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChpmvBatched_rank_1 = hipblasChpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhpmvBatched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhpmvBatched_full_rank = hipblasZhpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhpmvBatched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhpmvBatched_rank_0 = hipblasZhpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhpmvBatched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhpmvBatched_rank_1 = hipblasZhpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChpmvStridedBatched_rank_0(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChpmvStridedBatched_rank_0 = hipblasChpmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChpmvStridedBatched_rank_1(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChpmvStridedBatched_rank_1 = hipblasChpmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhpmvStridedBatched_rank_0(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhpmvStridedBatched_rank_0 = hipblasZhpmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhpmvStridedBatched_rank_1(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhpmvStridedBatched_rank_1 = hipblasZhpmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChpr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasChpr_rank_0 = hipblasChpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasChpr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasChpr_rank_1 = hipblasChpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZhpr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZhpr_rank_0 = hipblasZhpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZhpr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZhpr_rank_1 = hipblasZhpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasChprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChprBatched_full_rank = hipblasChprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasChprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChprBatched_rank_0 = hipblasChprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasChprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChprBatched_rank_1 = hipblasChprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZhprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhprBatched_full_rank = hipblasZhprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZhprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhprBatched_rank_0 = hipblasZhprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZhprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhprBatched_rank_1 = hipblasZhprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasChprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasChprStridedBatched_rank_0 = hipblasChprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasChprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasChprStridedBatched_rank_1 = hipblasChprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasZhprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasZhprStridedBatched_rank_0 = hipblasZhprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasZhprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasZhprStridedBatched_rank_1 = hipblasZhprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasChpr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasChpr2_rank_0 = hipblasChpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasChpr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasChpr2_rank_1 = hipblasChpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasZhpr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasZhpr2_rank_0 = hipblasZhpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasZhpr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasZhpr2_rank_1 = hipblasZhpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasChpr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChpr2Batched_full_rank = hipblasChpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasChpr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChpr2Batched_rank_0 = hipblasChpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasChpr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChpr2Batched_rank_1 = hipblasChpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasZhpr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2Batched_full_rank = hipblasZhpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasZhpr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2Batched_rank_0 = hipblasZhpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasZhpr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2Batched_rank_1 = hipblasZhpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasChpr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasChpr2StridedBatched_rank_0 = hipblasChpr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideAP,batchCount)
    end function

    function hipblasChpr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasChpr2StridedBatched_rank_1 = hipblasChpr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideAP,batchCount)
    end function

    function hipblasZhpr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2StridedBatched_rank_0 = hipblasZhpr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideAP,batchCount)
    end function

    function hipblasZhpr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2StridedBatched_rank_1 = hipblasZhpr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideAP,batchCount)
    end function

    function hipblasSsbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSsbmv_full_rank = hipblasSsbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSsbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSsbmv_rank_0 = hipblasSsbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSsbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSsbmv_rank_1 = hipblasSsbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDsbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDsbmv_full_rank = hipblasDsbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDsbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDsbmv_rank_0 = hipblasDsbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDsbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDsbmv_rank_1 = hipblasDsbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSsbmvBatched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsbmvBatched_full_rank = hipblasSsbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsbmvBatched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsbmvBatched_rank_0 = hipblasSsbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsbmvBatched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsbmvBatched_rank_1 = hipblasSsbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsbmvBatched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsbmvBatched_full_rank = hipblasDsbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsbmvBatched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsbmvBatched_rank_0 = hipblasDsbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsbmvBatched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsbmvBatched_rank_1 = hipblasDsbmvBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsbmvStridedBatched_full_rank(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsbmvStridedBatched_full_rank = hipblasSsbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSsbmvStridedBatched_rank_0(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsbmvStridedBatched_rank_0 = hipblasSsbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSsbmvStridedBatched_rank_1(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsbmvStridedBatched_rank_1 = hipblasSsbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDsbmvStridedBatched_full_rank(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsbmvStridedBatched_full_rank = hipblasDsbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDsbmvStridedBatched_rank_0(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsbmvStridedBatched_rank_0 = hipblasDsbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDsbmvStridedBatched_rank_1(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsbmvStridedBatched_rank_1 = hipblasDsbmvStridedBatched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSspmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSspmv_rank_0 = hipblasSspmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSspmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSspmv_rank_1 = hipblasSspmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDspmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDspmv_rank_0 = hipblasDspmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDspmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDspmv_rank_1 = hipblasDspmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSspmvBatched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSspmvBatched_full_rank = hipblasSspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSspmvBatched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSspmvBatched_rank_0 = hipblasSspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSspmvBatched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSspmvBatched_rank_1 = hipblasSspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDspmvBatched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDspmvBatched_full_rank = hipblasDspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDspmvBatched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDspmvBatched_rank_0 = hipblasDspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDspmvBatched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDspmvBatched_rank_1 = hipblasDspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSspmvStridedBatched_rank_0(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSspmvStridedBatched_rank_0 = hipblasSspmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSspmvStridedBatched_rank_1(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSspmvStridedBatched_rank_1 = hipblasSspmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDspmvStridedBatched_rank_0(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDspmvStridedBatched_rank_0 = hipblasDspmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDspmvStridedBatched_rank_1(handle,uplo,n,alpha,AP,strideAP,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDspmvStridedBatched_rank_1 = hipblasDspmvStridedBatched_(handle,uplo,n,alpha,AP,strideAP,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasSspr_rank_0 = hipblasSspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasSspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasSspr_rank_1 = hipblasSspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasDspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasDspr_rank_0 = hipblasDspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasDspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasDspr_rank_1 = hipblasDspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasCspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCspr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasCspr_rank_0 = hipblasCspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasCspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCspr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasCspr_rank_1 = hipblasCspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZspr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZspr_rank_0 = hipblasZspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZspr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZspr_rank_1 = hipblasZspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasSsprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSsprBatched_full_rank = hipblasSsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasSsprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSsprBatched_rank_0 = hipblasSsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasSsprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSsprBatched_rank_1 = hipblasSsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasDsprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDsprBatched_full_rank = hipblasDsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasDsprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDsprBatched_rank_0 = hipblasDsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasDsprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDsprBatched_rank_1 = hipblasDsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasCsprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasCsprBatched_full_rank = hipblasCsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasCsprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasCsprBatched_rank_0 = hipblasCsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasCsprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasCsprBatched_rank_1 = hipblasCsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZsprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZsprBatched_full_rank = hipblasZsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZsprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZsprBatched_rank_0 = hipblasZsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZsprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZsprBatched_rank_1 = hipblasZsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasSsprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasSsprStridedBatched_rank_0 = hipblasSsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasSsprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasSsprStridedBatched_rank_1 = hipblasSsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasDsprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasDsprStridedBatched_rank_0 = hipblasDsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasDsprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasDsprStridedBatched_rank_1 = hipblasDsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasCsprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasCsprStridedBatched_rank_0 = hipblasCsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasCsprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasCsprStridedBatched_rank_1 = hipblasCsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasZsprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasZsprStridedBatched_rank_0 = hipblasZsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasZsprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasZsprStridedBatched_rank_1 = hipblasZsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideAP,batchCount)
    end function

    function hipblasSspr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasSspr2_rank_0 = hipblasSspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasSspr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasSspr2_rank_1 = hipblasSspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasDspr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasDspr2_rank_0 = hipblasDspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasDspr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasDspr2_rank_1 = hipblasDspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasSspr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSspr2Batched_full_rank = hipblasSspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasSspr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSspr2Batched_rank_0 = hipblasSspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasSspr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSspr2Batched_rank_1 = hipblasSspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasDspr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDspr2Batched_full_rank = hipblasDspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasDspr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDspr2Batched_rank_0 = hipblasDspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasDspr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDspr2Batched_rank_1 = hipblasDspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasSspr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasSspr2StridedBatched_rank_0 = hipblasSspr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideAP,batchCount)
    end function

    function hipblasSspr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasSspr2StridedBatched_rank_1 = hipblasSspr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideAP,batchCount)
    end function

    function hipblasDspr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasDspr2StridedBatched_rank_0 = hipblasDspr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideAP,batchCount)
    end function

    function hipblasDspr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideAP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      integer(c_int) :: batchCount
      !
      hipblasDspr2StridedBatched_rank_1 = hipblasDspr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideAP,batchCount)
    end function

    function hipblasSsymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSsymv_full_rank = hipblasSsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSsymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSsymv_rank_0 = hipblasSsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSsymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSsymv_rank_1 = hipblasSsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDsymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDsymv_full_rank = hipblasDsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDsymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDsymv_rank_0 = hipblasDsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDsymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDsymv_rank_1 = hipblasDsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCsymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCsymv_full_rank = hipblasCsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCsymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCsymv_rank_0 = hipblasCsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCsymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCsymv_rank_1 = hipblasCsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZsymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZsymv_full_rank = hipblasZsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZsymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZsymv_rank_0 = hipblasZsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZsymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZsymv_rank_1 = hipblasZsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSsymvBatched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsymvBatched_full_rank = hipblasSsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsymvBatched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsymvBatched_rank_0 = hipblasSsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsymvBatched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsymvBatched_rank_1 = hipblasSsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsymvBatched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsymvBatched_full_rank = hipblasDsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsymvBatched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsymvBatched_rank_0 = hipblasDsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsymvBatched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsymvBatched_rank_1 = hipblasDsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCsymvBatched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCsymvBatched_full_rank = hipblasCsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCsymvBatched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCsymvBatched_rank_0 = hipblasCsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCsymvBatched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCsymvBatched_rank_1 = hipblasCsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZsymvBatched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZsymvBatched_full_rank = hipblasZsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZsymvBatched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZsymvBatched_rank_0 = hipblasZsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZsymvBatched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZsymvBatched_rank_1 = hipblasZsymvBatched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsymvStridedBatched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsymvStridedBatched_full_rank = hipblasSsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSsymvStridedBatched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsymvStridedBatched_rank_0 = hipblasSsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSsymvStridedBatched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsymvStridedBatched_rank_1 = hipblasSsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDsymvStridedBatched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsymvStridedBatched_full_rank = hipblasDsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDsymvStridedBatched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsymvStridedBatched_rank_0 = hipblasDsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDsymvStridedBatched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsymvStridedBatched_rank_1 = hipblasDsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCsymvStridedBatched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCsymvStridedBatched_full_rank = hipblasCsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCsymvStridedBatched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCsymvStridedBatched_rank_0 = hipblasCsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCsymvStridedBatched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCsymvStridedBatched_rank_1 = hipblasCsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZsymvStridedBatched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZsymvStridedBatched_full_rank = hipblasZsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZsymvStridedBatched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZsymvStridedBatched_rank_0 = hipblasZsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZsymvStridedBatched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZsymvStridedBatched_rank_1 = hipblasZsymvStridedBatched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSsyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasSsyr_full_rank = hipblasSsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasSsyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: A
      integer(c_int) :: lda
      !
      hipblasSsyr_rank_0 = hipblasSsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasSsyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasSsyr_rank_1 = hipblasSsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasDsyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasDsyr_full_rank = hipblasDsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasDsyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: A
      integer(c_int) :: lda
      !
      hipblasDsyr_rank_0 = hipblasDsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasDsyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasDsyr_rank_1 = hipblasDsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasCsyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasCsyr_full_rank = hipblasCsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasCsyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasCsyr_rank_0 = hipblasCsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasCsyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasCsyr_rank_1 = hipblasCsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasZsyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasZsyr_full_rank = hipblasZsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasZsyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasZsyr_rank_0 = hipblasZsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasZsyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasZsyr_rank_1 = hipblasZsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function hipblasSsyrBatched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyrBatched_full_rank = hipblasSsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasSsyrBatched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyrBatched_rank_0 = hipblasSsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasSsyrBatched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyrBatched_rank_1 = hipblasSsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasDsyrBatched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyrBatched_full_rank = hipblasDsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasDsyrBatched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyrBatched_rank_0 = hipblasDsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasDsyrBatched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyrBatched_rank_1 = hipblasDsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasCsyrBatched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyrBatched_full_rank = hipblasCsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasCsyrBatched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyrBatched_rank_0 = hipblasCsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasCsyrBatched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyrBatched_rank_1 = hipblasCsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasZsyrBatched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyrBatched_full_rank = hipblasZsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasZsyrBatched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyrBatched_rank_0 = hipblasZsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasZsyrBatched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyrBatched_rank_1 = hipblasZsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batchCount)
    end function

    function hipblasSsyrStridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsyrStridedBatched_full_rank = hipblasSsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasSsyrStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsyrStridedBatched_rank_0 = hipblasSsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasSsyrStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsyrStridedBatched_rank_1 = hipblasSsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasDsyrStridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsyrStridedBatched_full_rank = hipblasDsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasDsyrStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsyrStridedBatched_rank_0 = hipblasDsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasDsyrStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsyrStridedBatched_rank_1 = hipblasDsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasCsyrStridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCsyrStridedBatched_full_rank = hipblasCsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasCsyrStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCsyrStridedBatched_rank_0 = hipblasCsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasCsyrStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCsyrStridedBatched_rank_1 = hipblasCsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasZsyrStridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZsyrStridedBatched_full_rank = hipblasZsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasZsyrStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZsyrStridedBatched_rank_0 = hipblasZsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasZsyrStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZsyrStridedBatched_rank_1 = hipblasZsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,stridey,batchCount)
    end function

    function hipblasSsyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasSsyr2_full_rank = hipblasSsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasSsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      real(c_float),target :: A
      integer(c_int) :: lda
      !
      hipblasSsyr2_rank_0 = hipblasSsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasSsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasSsyr2_rank_1 = hipblasSsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasDsyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasDsyr2_full_rank = hipblasDsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasDsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      real(c_double),target :: A
      integer(c_int) :: lda
      !
      hipblasDsyr2_rank_0 = hipblasDsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasDsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasDsyr2_rank_1 = hipblasDsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCsyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasCsyr2_full_rank = hipblasCsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasCsyr2_rank_0 = hipblasCsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasCsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasCsyr2_rank_1 = hipblasCsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZsyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      hipblasZsyr2_full_rank = hipblasZsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      hipblasZsyr2_rank_0 = hipblasZsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasZsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      hipblasZsyr2_rank_1 = hipblasZsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function hipblasSsyr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyr2Batched_full_rank = hipblasSsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasSsyr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyr2Batched_rank_0 = hipblasSsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasSsyr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyr2Batched_rank_1 = hipblasSsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasDsyr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyr2Batched_full_rank = hipblasDsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasDsyr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyr2Batched_rank_0 = hipblasDsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasDsyr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyr2Batched_rank_1 = hipblasDsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCsyr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyr2Batched_full_rank = hipblasCsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCsyr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyr2Batched_rank_0 = hipblasCsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasCsyr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyr2Batched_rank_1 = hipblasCsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZsyr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyr2Batched_full_rank = hipblasZsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZsyr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyr2Batched_rank_0 = hipblasZsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasZsyr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyr2Batched_rank_1 = hipblasZsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batchCount)
    end function

    function hipblasSsyr2StridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2StridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSsyr2StridedBatched_full_rank = hipblasSsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasSsyr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSsyr2StridedBatched_rank_0 = hipblasSsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasSsyr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSsyr2StridedBatched_rank_1 = hipblasSsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasDsyr2StridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2StridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDsyr2StridedBatched_full_rank = hipblasDsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasDsyr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDsyr2StridedBatched_rank_0 = hipblasDsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasDsyr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDsyr2StridedBatched_rank_1 = hipblasDsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCsyr2StridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2StridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyr2StridedBatched_full_rank = hipblasCsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCsyr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyr2StridedBatched_rank_0 = hipblasCsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasCsyr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyr2StridedBatched_rank_1 = hipblasCsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZsyr2StridedBatched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2StridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyr2StridedBatched_full_rank = hipblasZsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZsyr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyr2StridedBatched_rank_0 = hipblasZsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasZsyr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyr2StridedBatched_rank_1 = hipblasZsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batchCount)
    end function

    function hipblasStbmv_full_rank(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStbmv_full_rank = hipblasStbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStbmv_rank_0(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStbmv_rank_0 = hipblasStbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStbmv_rank_1(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStbmv_rank_1 = hipblasStbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtbmv_full_rank(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtbmv_full_rank = hipblasDtbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtbmv_rank_0(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtbmv_rank_0 = hipblasDtbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtbmv_rank_1(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtbmv_rank_1 = hipblasDtbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtbmv_full_rank(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtbmv_full_rank = hipblasCtbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtbmv_rank_0(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtbmv_rank_0 = hipblasCtbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtbmv_rank_1(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtbmv_rank_1 = hipblasCtbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtbmv_full_rank(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtbmv_full_rank = hipblasZtbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtbmv_rank_0(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtbmv_rank_0 = hipblasZtbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtbmv_rank_1(handle,uplo,transA,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtbmv_rank_1 = hipblasZtbmv_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStbmvBatched_full_rank(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbmvBatched_full_rank = hipblasStbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbmvBatched_rank_0(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbmvBatched_rank_0 = hipblasStbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbmvBatched_rank_1(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbmvBatched_rank_1 = hipblasStbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbmvBatched_full_rank(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbmvBatched_full_rank = hipblasDtbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbmvBatched_rank_0(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbmvBatched_rank_0 = hipblasDtbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbmvBatched_rank_1(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbmvBatched_rank_1 = hipblasDtbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbmvBatched_full_rank(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbmvBatched_full_rank = hipblasCtbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbmvBatched_rank_0(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbmvBatched_rank_0 = hipblasCtbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbmvBatched_rank_1(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbmvBatched_rank_1 = hipblasCtbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbmvBatched_full_rank(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbmvBatched_full_rank = hipblasZtbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbmvBatched_rank_0(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbmvBatched_rank_0 = hipblasZtbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbmvBatched_rank_1(handle,uplo,transA,diag,m,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbmvBatched_rank_1 = hipblasZtbmvBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbmvStridedBatched_full_rank(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStbmvStridedBatched_full_rank = hipblasStbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStbmvStridedBatched_rank_0(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStbmvStridedBatched_rank_0 = hipblasStbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStbmvStridedBatched_rank_1(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStbmvStridedBatched_rank_1 = hipblasStbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtbmvStridedBatched_full_rank(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtbmvStridedBatched_full_rank = hipblasDtbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtbmvStridedBatched_rank_0(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtbmvStridedBatched_rank_0 = hipblasDtbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtbmvStridedBatched_rank_1(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtbmvStridedBatched_rank_1 = hipblasDtbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbmvStridedBatched_full_rank(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbmvStridedBatched_full_rank = hipblasCtbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbmvStridedBatched_rank_0(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbmvStridedBatched_rank_0 = hipblasCtbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbmvStridedBatched_rank_1(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbmvStridedBatched_rank_1 = hipblasCtbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbmvStridedBatched_full_rank(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbmvStridedBatched_full_rank = hipblasZtbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbmvStridedBatched_rank_0(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbmvStridedBatched_rank_0 = hipblasZtbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbmvStridedBatched_rank_1(handle,uplo,transA,diag,m,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbmvStridedBatched_rank_1 = hipblasZtbmvStridedBatched_(handle,uplo,transA,diag,m,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStbsv_full_rank = hipblasStbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStbsv_rank_0 = hipblasStbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStbsv_rank_1 = hipblasStbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtbsv_full_rank = hipblasDtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtbsv_rank_0 = hipblasDtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtbsv_rank_1 = hipblasDtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtbsv_full_rank = hipblasCtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtbsv_rank_0 = hipblasCtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtbsv_rank_1 = hipblasCtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtbsv_full_rank = hipblasZtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtbsv_rank_0 = hipblasZtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtbsv_rank_1 = hipblasZtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStbsvBatched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbsvBatched_full_rank = hipblasStbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbsvBatched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbsvBatched_rank_0 = hipblasStbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbsvBatched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbsvBatched_rank_1 = hipblasStbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbsvBatched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbsvBatched_full_rank = hipblasDtbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbsvBatched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbsvBatched_rank_0 = hipblasDtbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbsvBatched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbsvBatched_rank_1 = hipblasDtbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbsvBatched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbsvBatched_full_rank = hipblasCtbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbsvBatched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbsvBatched_rank_0 = hipblasCtbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbsvBatched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbsvBatched_rank_1 = hipblasCtbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbsvBatched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbsvBatched_full_rank = hipblasZtbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbsvBatched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbsvBatched_rank_0 = hipblasZtbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbsvBatched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbsvBatched_rank_1 = hipblasZtbsvBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbsvStridedBatched_full_rank(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStbsvStridedBatched_full_rank = hipblasStbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStbsvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStbsvStridedBatched_rank_0 = hipblasStbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStbsvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStbsvStridedBatched_rank_1 = hipblasStbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtbsvStridedBatched_full_rank(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtbsvStridedBatched_full_rank = hipblasDtbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtbsvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtbsvStridedBatched_rank_0 = hipblasDtbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtbsvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtbsvStridedBatched_rank_1 = hipblasDtbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbsvStridedBatched_full_rank(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbsvStridedBatched_full_rank = hipblasCtbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbsvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbsvStridedBatched_rank_0 = hipblasCtbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbsvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbsvStridedBatched_rank_1 = hipblasCtbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbsvStridedBatched_full_rank(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbsvStridedBatched_full_rank = hipblasZtbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbsvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbsvStridedBatched_rank_0 = hipblasZtbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbsvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbsvStridedBatched_rank_1 = hipblasZtbsvStridedBatched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStpmv_rank_0(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStpmv_rank_0 = hipblasStpmv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasStpmv_rank_1(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStpmv_rank_1 = hipblasStpmv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasDtpmv_rank_0(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtpmv_rank_0 = hipblasDtpmv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasDtpmv_rank_1(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtpmv_rank_1 = hipblasDtpmv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasCtpmv_rank_0(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtpmv_rank_0 = hipblasCtpmv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasCtpmv_rank_1(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtpmv_rank_1 = hipblasCtpmv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasZtpmv_rank_0(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtpmv_rank_0 = hipblasZtpmv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasZtpmv_rank_1(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtpmv_rank_1 = hipblasZtpmv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasStpmvBatched_full_rank(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpmvBatched_full_rank = hipblasStpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpmvBatched_rank_0(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpmvBatched_rank_0 = hipblasStpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpmvBatched_rank_1(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpmvBatched_rank_1 = hipblasStpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpmvBatched_full_rank(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpmvBatched_full_rank = hipblasDtpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpmvBatched_rank_0(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpmvBatched_rank_0 = hipblasDtpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpmvBatched_rank_1(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpmvBatched_rank_1 = hipblasDtpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpmvBatched_full_rank(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpmvBatched_full_rank = hipblasCtpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpmvBatched_rank_0(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpmvBatched_rank_0 = hipblasCtpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpmvBatched_rank_1(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpmvBatched_rank_1 = hipblasCtpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpmvBatched_full_rank(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpmvBatched_full_rank = hipblasZtpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpmvBatched_rank_0(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpmvBatched_rank_0 = hipblasZtpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpmvBatched_rank_1(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpmvBatched_rank_1 = hipblasZtpmvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpmvStridedBatched_rank_0(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride
      integer(c_int) :: batchCount
      !
      hipblasStpmvStridedBatched_rank_0 = hipblasStpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stride,batchCount)
    end function

    function hipblasStpmvStridedBatched_rank_1(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride
      integer(c_int) :: batchCount
      !
      hipblasStpmvStridedBatched_rank_1 = hipblasStpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stride,batchCount)
    end function

    function hipblasDtpmvStridedBatched_rank_0(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride
      integer(c_int) :: batchCount
      !
      hipblasDtpmvStridedBatched_rank_0 = hipblasDtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stride,batchCount)
    end function

    function hipblasDtpmvStridedBatched_rank_1(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride
      integer(c_int) :: batchCount
      !
      hipblasDtpmvStridedBatched_rank_1 = hipblasDtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stride,batchCount)
    end function

    function hipblasCtpmvStridedBatched_rank_0(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride
      integer(c_int) :: batchCount
      !
      hipblasCtpmvStridedBatched_rank_0 = hipblasCtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stride,batchCount)
    end function

    function hipblasCtpmvStridedBatched_rank_1(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride
      integer(c_int) :: batchCount
      !
      hipblasCtpmvStridedBatched_rank_1 = hipblasCtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stride,batchCount)
    end function

    function hipblasZtpmvStridedBatched_rank_0(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride
      integer(c_int) :: batchCount
      !
      hipblasZtpmvStridedBatched_rank_0 = hipblasZtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stride,batchCount)
    end function

    function hipblasZtpmvStridedBatched_rank_1(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stride,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride
      integer(c_int) :: batchCount
      !
      hipblasZtpmvStridedBatched_rank_1 = hipblasZtpmvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stride,batchCount)
    end function

    function hipblasStpsv_rank_0(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStpsv_rank_0 = hipblasStpsv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasStpsv_rank_1(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStpsv_rank_1 = hipblasStpsv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasDtpsv_rank_0(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtpsv_rank_0 = hipblasDtpsv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasDtpsv_rank_1(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtpsv_rank_1 = hipblasDtpsv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasCtpsv_rank_0(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtpsv_rank_0 = hipblasCtpsv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasCtpsv_rank_1(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtpsv_rank_1 = hipblasCtpsv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasZtpsv_rank_0(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtpsv_rank_0 = hipblasZtpsv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasZtpsv_rank_1(handle,uplo,transA,diag,m,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtpsv_rank_1 = hipblasZtpsv_(handle,uplo,transA,diag,m,AP,c_loc(x),incx)
    end function

    function hipblasStpsvBatched_full_rank(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpsvBatched_full_rank = hipblasStpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpsvBatched_rank_0(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpsvBatched_rank_0 = hipblasStpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpsvBatched_rank_1(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpsvBatched_rank_1 = hipblasStpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpsvBatched_full_rank(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpsvBatched_full_rank = hipblasDtpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpsvBatched_rank_0(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpsvBatched_rank_0 = hipblasDtpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpsvBatched_rank_1(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpsvBatched_rank_1 = hipblasDtpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpsvBatched_full_rank(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpsvBatched_full_rank = hipblasCtpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpsvBatched_rank_0(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpsvBatched_rank_0 = hipblasCtpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpsvBatched_rank_1(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpsvBatched_rank_1 = hipblasCtpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpsvBatched_full_rank(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpsvBatched_full_rank = hipblasZtpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpsvBatched_rank_0(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpsvBatched_rank_0 = hipblasZtpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpsvBatched_rank_1(handle,uplo,transA,diag,m,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpsvBatched_rank_1 = hipblasZtpsvBatched_(handle,uplo,transA,diag,m,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpsvStridedBatched_rank_0(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStpsvStridedBatched_rank_0 = hipblasStpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStpsvStridedBatched_rank_1(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStpsvStridedBatched_rank_1 = hipblasStpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtpsvStridedBatched_rank_0(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtpsvStridedBatched_rank_0 = hipblasDtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtpsvStridedBatched_rank_1(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtpsvStridedBatched_rank_1 = hipblasDtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtpsvStridedBatched_rank_0(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtpsvStridedBatched_rank_0 = hipblasCtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtpsvStridedBatched_rank_1(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtpsvStridedBatched_rank_1 = hipblasCtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtpsvStridedBatched_rank_0(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtpsvStridedBatched_rank_0 = hipblasZtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtpsvStridedBatched_rank_1(handle,uplo,transA,diag,m,AP,strideAP,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideAP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtpsvStridedBatched_rank_1 = hipblasZtpsvStridedBatched_(handle,uplo,transA,diag,m,AP,strideAP,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStrmv_full_rank = hipblasStrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStrmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStrmv_rank_0 = hipblasStrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStrmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStrmv_rank_1 = hipblasStrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtrmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtrmv_full_rank = hipblasDtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtrmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtrmv_rank_0 = hipblasDtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtrmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtrmv_rank_1 = hipblasDtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtrmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtrmv_full_rank = hipblasCtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtrmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtrmv_rank_0 = hipblasCtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtrmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtrmv_rank_1 = hipblasCtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtrmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtrmv_full_rank = hipblasZtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtrmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtrmv_rank_0 = hipblasZtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtrmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtrmv_rank_1 = hipblasZtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStrmvBatched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrmvBatched_full_rank = hipblasStrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrmvBatched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrmvBatched_rank_0 = hipblasStrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrmvBatched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrmvBatched_rank_1 = hipblasStrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrmvBatched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrmvBatched_full_rank = hipblasDtrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrmvBatched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrmvBatched_rank_0 = hipblasDtrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrmvBatched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrmvBatched_rank_1 = hipblasDtrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrmvBatched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrmvBatched_full_rank = hipblasCtrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrmvBatched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrmvBatched_rank_0 = hipblasCtrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrmvBatched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrmvBatched_rank_1 = hipblasCtrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrmvBatched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrmvBatched_full_rank = hipblasZtrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrmvBatched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrmvBatched_rank_0 = hipblasZtrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrmvBatched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrmvBatched_rank_1 = hipblasZtrmvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrmvStridedBatched_full_rank(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStrmvStridedBatched_full_rank = hipblasStrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrmvStridedBatched_rank_0(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStrmvStridedBatched_rank_0 = hipblasStrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrmvStridedBatched_rank_1(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStrmvStridedBatched_rank_1 = hipblasStrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtrmvStridedBatched_full_rank(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtrmvStridedBatched_full_rank = hipblasDtrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtrmvStridedBatched_rank_0(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtrmvStridedBatched_rank_0 = hipblasDtrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtrmvStridedBatched_rank_1(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtrmvStridedBatched_rank_1 = hipblasDtrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrmvStridedBatched_full_rank(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrmvStridedBatched_full_rank = hipblasCtrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrmvStridedBatched_rank_0(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrmvStridedBatched_rank_0 = hipblasCtrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrmvStridedBatched_rank_1(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrmvStridedBatched_rank_1 = hipblasCtrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrmvStridedBatched_full_rank(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrmvStridedBatched_full_rank = hipblasZtrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrmvStridedBatched_rank_0(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrmvStridedBatched_rank_0 = hipblasZtrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrmvStridedBatched_rank_1(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrmvStridedBatched_rank_1 = hipblasZtrmvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStrsv_full_rank = hipblasStrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStrsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStrsv_rank_0 = hipblasStrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStrsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStrsv_rank_1 = hipblasStrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtrsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtrsv_full_rank = hipblasDtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtrsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtrsv_rank_0 = hipblasDtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasDtrsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtrsv_rank_1 = hipblasDtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtrsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtrsv_full_rank = hipblasCtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtrsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtrsv_rank_0 = hipblasCtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasCtrsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtrsv_rank_1 = hipblasCtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtrsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsv_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtrsv_full_rank = hipblasZtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtrsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtrsv_rank_0 = hipblasZtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasZtrsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtrsv_rank_1 = hipblasZtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function hipblasStrsvBatched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrsvBatched_full_rank = hipblasStrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrsvBatched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrsvBatched_rank_0 = hipblasStrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrsvBatched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrsvBatched_rank_1 = hipblasStrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrsvBatched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrsvBatched_full_rank = hipblasDtrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrsvBatched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrsvBatched_rank_0 = hipblasDtrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrsvBatched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrsvBatched_rank_1 = hipblasDtrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrsvBatched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrsvBatched_full_rank = hipblasCtrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrsvBatched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrsvBatched_rank_0 = hipblasCtrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrsvBatched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrsvBatched_rank_1 = hipblasCtrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrsvBatched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrsvBatched_full_rank = hipblasZtrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrsvBatched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrsvBatched_rank_0 = hipblasZtrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrsvBatched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrsvBatched_rank_1 = hipblasZtrsvBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrsvStridedBatched_full_rank(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStrsvStridedBatched_full_rank = hipblasStrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrsvStridedBatched_rank_0(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStrsvStridedBatched_rank_0 = hipblasStrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrsvStridedBatched_rank_1(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStrsvStridedBatched_rank_1 = hipblasStrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtrsvStridedBatched_full_rank(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtrsvStridedBatched_full_rank = hipblasDtrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtrsvStridedBatched_rank_0(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtrsvStridedBatched_rank_0 = hipblasDtrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtrsvStridedBatched_rank_1(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtrsvStridedBatched_rank_1 = hipblasDtrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrsvStridedBatched_full_rank(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrsvStridedBatched_full_rank = hipblasCtrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrsvStridedBatched_rank_0(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrsvStridedBatched_rank_0 = hipblasCtrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrsvStridedBatched_rank_1(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrsvStridedBatched_rank_1 = hipblasCtrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrsvStridedBatched_full_rank(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrsvStridedBatched_full_rank = hipblasZtrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrsvStridedBatched_rank_0(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrsvStridedBatched_rank_0 = hipblasZtrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrsvStridedBatched_rank_1(handle,uplo,transA,diag,m,A,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrsvStridedBatched_rank_1 = hipblasZtrsvStridedBatched_(handle,uplo,transA,diag,m,c_loc(A),lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasSgemm_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasSgemm_full_rank = hipblasSgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSgemm_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      hipblasSgemm_rank_0 = hipblasSgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSgemm_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasSgemm_rank_1 = hipblasSgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDgemm_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasDgemm_full_rank = hipblasDgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDgemm_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      hipblasDgemm_rank_0 = hipblasDgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDgemm_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasDgemm_rank_1 = hipblasDgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCgemm_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCgemm_full_rank = hipblasCgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCgemm_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCgemm_rank_0 = hipblasCgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCgemm_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCgemm_rank_1 = hipblasCgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZgemm_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZgemm_full_rank = hipblasZgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZgemm_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZgemm_rank_0 = hipblasZgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZgemm_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZgemm_rank_1 = hipblasZgemm_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSgemmBatched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSgemmBatched_full_rank = hipblasSgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSgemmBatched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSgemmBatched_rank_0 = hipblasSgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSgemmBatched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSgemmBatched_rank_1 = hipblasSgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDgemmBatched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDgemmBatched_full_rank = hipblasDgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDgemmBatched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDgemmBatched_rank_0 = hipblasDgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDgemmBatched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDgemmBatched_rank_1 = hipblasDgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCgemmBatched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCgemmBatched_full_rank = hipblasCgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCgemmBatched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCgemmBatched_rank_0 = hipblasCgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCgemmBatched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCgemmBatched_rank_1 = hipblasCgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZgemmBatched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZgemmBatched_full_rank = hipblasZgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZgemmBatched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZgemmBatched_rank_0 = hipblasZgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZgemmBatched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZgemmBatched_rank_1 = hipblasZgemmBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSgemmStridedBatched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSgemmStridedBatched_full_rank = hipblasSgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSgemmStridedBatched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSgemmStridedBatched_rank_0 = hipblasSgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSgemmStridedBatched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSgemmStridedBatched_rank_1 = hipblasSgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDgemmStridedBatched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDgemmStridedBatched_full_rank = hipblasDgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDgemmStridedBatched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDgemmStridedBatched_rank_0 = hipblasDgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDgemmStridedBatched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDgemmStridedBatched_rank_1 = hipblasDgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCgemmStridedBatched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCgemmStridedBatched_full_rank = hipblasCgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCgemmStridedBatched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCgemmStridedBatched_rank_0 = hipblasCgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCgemmStridedBatched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCgemmStridedBatched_rank_1 = hipblasCgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZgemmStridedBatched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZgemmStridedBatched_full_rank = hipblasZgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZgemmStridedBatched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZgemmStridedBatched_rank_0 = hipblasZgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZgemmStridedBatched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_long_long) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_long_long) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_long_long) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZgemmStridedBatched_rank_1 = hipblasZgemmStridedBatched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCherk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherk_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCherk_full_rank = hipblasCherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasCherk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherk_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCherk_rank_0 = hipblasCherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasCherk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherk_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCherk_rank_1 = hipblasCherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasZherk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherk_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZherk_full_rank = hipblasZherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasZherk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherk_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZherk_rank_0 = hipblasZherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasZherk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherk_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZherk_rank_1 = hipblasZherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasCherkBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCherkBatched_full_rank = hipblasCherkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCherkBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCherkBatched_rank_0 = hipblasCherkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCherkBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCherkBatched_rank_1 = hipblasCherkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZherkBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZherkBatched_full_rank = hipblasZherkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZherkBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZherkBatched_rank_0 = hipblasZherkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZherkBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZherkBatched_rank_1 = hipblasZherkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCherkStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCherkStridedBatched_full_rank = hipblasCherkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCherkStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCherkStridedBatched_rank_0 = hipblasCherkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCherkStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCherkStridedBatched_rank_1 = hipblasCherkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZherkStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZherkStridedBatched_full_rank = hipblasZherkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZherkStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZherkStridedBatched_rank_0 = hipblasZherkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZherkStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZherkStridedBatched_rank_1 = hipblasZherkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCherkx_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkx_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCherkx_full_rank = hipblasCherkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCherkx_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkx_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCherkx_rank_0 = hipblasCherkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCherkx_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkx_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCherkx_rank_1 = hipblasCherkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZherkx_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkx_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZherkx_full_rank = hipblasZherkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZherkx_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkx_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZherkx_rank_0 = hipblasZherkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZherkx_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkx_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZherkx_rank_1 = hipblasZherkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCherkxBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCherkxBatched_full_rank = hipblasCherkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCherkxBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCherkxBatched_rank_0 = hipblasCherkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCherkxBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCherkxBatched_rank_1 = hipblasCherkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZherkxBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZherkxBatched_full_rank = hipblasZherkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZherkxBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZherkxBatched_rank_0 = hipblasZherkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZherkxBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZherkxBatched_rank_1 = hipblasZherkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCherkxStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCherkxStridedBatched_full_rank = hipblasCherkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCherkxStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCherkxStridedBatched_rank_0 = hipblasCherkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCherkxStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCherkxStridedBatched_rank_1 = hipblasCherkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZherkxStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZherkxStridedBatched_full_rank = hipblasZherkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZherkxStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZherkxStridedBatched_rank_0 = hipblasZherkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZherkxStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZherkxStridedBatched_rank_1 = hipblasZherkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCher2k_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2k_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCher2k_full_rank = hipblasCher2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCher2k_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2k_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCher2k_rank_0 = hipblasCher2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCher2k_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2k_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCher2k_rank_1 = hipblasCher2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZher2k_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2k_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZher2k_full_rank = hipblasZher2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZher2k_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2k_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZher2k_rank_0 = hipblasZher2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZher2k_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2k_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZher2k_rank_1 = hipblasZher2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCher2kBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCher2kBatched_full_rank = hipblasCher2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCher2kBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCher2kBatched_rank_0 = hipblasCher2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCher2kBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCher2kBatched_rank_1 = hipblasCher2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZher2kBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZher2kBatched_full_rank = hipblasZher2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZher2kBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZher2kBatched_rank_0 = hipblasZher2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZher2kBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZher2kBatched_rank_1 = hipblasZher2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCher2kStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCher2kStridedBatched_full_rank = hipblasCher2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCher2kStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCher2kStridedBatched_rank_0 = hipblasCher2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCher2kStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCher2kStridedBatched_rank_1 = hipblasCher2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZher2kStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZher2kStridedBatched_full_rank = hipblasZher2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZher2kStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZher2kStridedBatched_rank_0 = hipblasZher2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZher2kStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZher2kStridedBatched_rank_1 = hipblasZher2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSsymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasSsymm_full_rank = hipblasSsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSsymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      hipblasSsymm_rank_0 = hipblasSsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSsymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasSsymm_rank_1 = hipblasSsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDsymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasDsymm_full_rank = hipblasDsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDsymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      hipblasDsymm_rank_0 = hipblasDsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDsymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasDsymm_rank_1 = hipblasDsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCsymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCsymm_full_rank = hipblasCsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCsymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCsymm_rank_0 = hipblasCsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCsymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCsymm_rank_1 = hipblasCsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZsymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZsymm_full_rank = hipblasZsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZsymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZsymm_rank_0 = hipblasZsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZsymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZsymm_rank_1 = hipblasZsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSsymmBatched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsymmBatched_full_rank = hipblasSsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsymmBatched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsymmBatched_rank_0 = hipblasSsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsymmBatched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsymmBatched_rank_1 = hipblasSsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsymmBatched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsymmBatched_full_rank = hipblasDsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsymmBatched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsymmBatched_rank_0 = hipblasDsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsymmBatched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsymmBatched_rank_1 = hipblasDsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsymmBatched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsymmBatched_full_rank = hipblasCsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsymmBatched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsymmBatched_rank_0 = hipblasCsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsymmBatched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsymmBatched_rank_1 = hipblasCsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsymmBatched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsymmBatched_full_rank = hipblasZsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsymmBatched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsymmBatched_rank_0 = hipblasZsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsymmBatched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsymmBatched_rank_1 = hipblasZsymmBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsymmStridedBatched_full_rank(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSsymmStridedBatched_full_rank = hipblasSsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSsymmStridedBatched_rank_0(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSsymmStridedBatched_rank_0 = hipblasSsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSsymmStridedBatched_rank_1(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSsymmStridedBatched_rank_1 = hipblasSsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDsymmStridedBatched_full_rank(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDsymmStridedBatched_full_rank = hipblasDsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDsymmStridedBatched_rank_0(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDsymmStridedBatched_rank_0 = hipblasDsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDsymmStridedBatched_rank_1(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDsymmStridedBatched_rank_1 = hipblasDsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCsymmStridedBatched_full_rank(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCsymmStridedBatched_full_rank = hipblasCsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCsymmStridedBatched_rank_0(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCsymmStridedBatched_rank_0 = hipblasCsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCsymmStridedBatched_rank_1(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCsymmStridedBatched_rank_1 = hipblasCsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZsymmStridedBatched_full_rank(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZsymmStridedBatched_full_rank = hipblasZsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZsymmStridedBatched_rank_0(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZsymmStridedBatched_rank_0 = hipblasZsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZsymmStridedBatched_rank_1(handle,side,uplo,m,n,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZsymmStridedBatched_rank_1 = hipblasZsymmStridedBatched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSsyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrk_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasSsyrk_full_rank = hipblasSsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasSsyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrk_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      hipblasSsyrk_rank_0 = hipblasSsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasSsyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrk_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasSsyrk_rank_1 = hipblasSsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasDsyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrk_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasDsyrk_full_rank = hipblasDsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasDsyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrk_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      hipblasDsyrk_rank_0 = hipblasDsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasDsyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrk_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasDsyrk_rank_1 = hipblasDsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasCsyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrk_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCsyrk_full_rank = hipblasCsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasCsyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrk_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCsyrk_rank_0 = hipblasCsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasCsyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrk_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCsyrk_rank_1 = hipblasCsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasZsyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrk_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZsyrk_full_rank = hipblasZsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasZsyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrk_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZsyrk_rank_0 = hipblasZsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasZsyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrk_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZsyrk_rank_1 = hipblasZsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function hipblasSsyrkBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsyrkBatched_full_rank = hipblasSsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsyrkBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsyrkBatched_rank_0 = hipblasSsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsyrkBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsyrkBatched_rank_1 = hipblasSsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsyrkBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsyrkBatched_full_rank = hipblasDsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsyrkBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsyrkBatched_rank_0 = hipblasDsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsyrkBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsyrkBatched_rank_1 = hipblasDsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsyrkBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsyrkBatched_full_rank = hipblasCsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsyrkBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsyrkBatched_rank_0 = hipblasCsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsyrkBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsyrkBatched_rank_1 = hipblasCsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsyrkBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsyrkBatched_full_rank = hipblasZsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsyrkBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsyrkBatched_rank_0 = hipblasZsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsyrkBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsyrkBatched_rank_1 = hipblasZsyrkBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsyrkStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSsyrkStridedBatched_full_rank = hipblasSsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSsyrkStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSsyrkStridedBatched_rank_0 = hipblasSsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSsyrkStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSsyrkStridedBatched_rank_1 = hipblasSsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDsyrkStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDsyrkStridedBatched_full_rank = hipblasDsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDsyrkStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDsyrkStridedBatched_rank_0 = hipblasDsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDsyrkStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDsyrkStridedBatched_rank_1 = hipblasDsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCsyrkStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCsyrkStridedBatched_full_rank = hipblasCsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCsyrkStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCsyrkStridedBatched_rank_0 = hipblasCsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCsyrkStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCsyrkStridedBatched_rank_1 = hipblasCsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZsyrkStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZsyrkStridedBatched_full_rank = hipblasZsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZsyrkStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZsyrkStridedBatched_rank_0 = hipblasZsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZsyrkStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZsyrkStridedBatched_rank_1 = hipblasZsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSsyr2k_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2k_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasSsyr2k_full_rank = hipblasSsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSsyr2k_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2k_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      hipblasSsyr2k_rank_0 = hipblasSsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSsyr2k_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2k_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasSsyr2k_rank_1 = hipblasSsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDsyr2k_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2k_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasDsyr2k_full_rank = hipblasDsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDsyr2k_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2k_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      hipblasDsyr2k_rank_0 = hipblasDsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDsyr2k_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2k_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasDsyr2k_rank_1 = hipblasDsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCsyr2k_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2k_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCsyr2k_full_rank = hipblasCsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCsyr2k_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2k_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCsyr2k_rank_0 = hipblasCsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCsyr2k_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2k_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCsyr2k_rank_1 = hipblasCsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZsyr2k_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2k_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZsyr2k_full_rank = hipblasZsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZsyr2k_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2k_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZsyr2k_rank_0 = hipblasZsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZsyr2k_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2k_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZsyr2k_rank_1 = hipblasZsyr2k_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSsyr2kBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2kBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsyr2kBatched_full_rank = hipblasSsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsyr2kBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2kBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsyr2kBatched_rank_0 = hipblasSsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsyr2kBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2kBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsyr2kBatched_rank_1 = hipblasSsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsyr2kBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2kBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsyr2kBatched_full_rank = hipblasDsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsyr2kBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2kBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsyr2kBatched_rank_0 = hipblasDsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsyr2kBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2kBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsyr2kBatched_rank_1 = hipblasDsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsyr2kBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsyr2kBatched_full_rank = hipblasCsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsyr2kBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsyr2kBatched_rank_0 = hipblasCsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsyr2kBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsyr2kBatched_rank_1 = hipblasCsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsyr2kBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsyr2kBatched_full_rank = hipblasZsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsyr2kBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsyr2kBatched_rank_0 = hipblasZsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsyr2kBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsyr2kBatched_rank_1 = hipblasZsyr2kBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsyr2kStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2kStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSsyr2kStridedBatched_full_rank = hipblasSsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSsyr2kStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2kStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSsyr2kStridedBatched_rank_0 = hipblasSsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSsyr2kStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2kStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSsyr2kStridedBatched_rank_1 = hipblasSsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDsyr2kStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2kStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDsyr2kStridedBatched_full_rank = hipblasDsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDsyr2kStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2kStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDsyr2kStridedBatched_rank_0 = hipblasDsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDsyr2kStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2kStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDsyr2kStridedBatched_rank_1 = hipblasDsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCsyr2kStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCsyr2kStridedBatched_full_rank = hipblasCsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCsyr2kStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCsyr2kStridedBatched_rank_0 = hipblasCsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCsyr2kStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCsyr2kStridedBatched_rank_1 = hipblasCsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZsyr2kStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZsyr2kStridedBatched_full_rank = hipblasZsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZsyr2kStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZsyr2kStridedBatched_rank_0 = hipblasZsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZsyr2kStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZsyr2kStridedBatched_rank_1 = hipblasZsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSsyrkx_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkx_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasSsyrkx_full_rank = hipblasSsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSsyrkx_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkx_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      hipblasSsyrkx_rank_0 = hipblasSsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSsyrkx_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkx_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasSsyrkx_rank_1 = hipblasSsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDsyrkx_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkx_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasDsyrkx_full_rank = hipblasDsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDsyrkx_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkx_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      hipblasDsyrkx_rank_0 = hipblasDsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasDsyrkx_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkx_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasDsyrkx_rank_1 = hipblasDsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCsyrkx_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkx_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCsyrkx_full_rank = hipblasCsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCsyrkx_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkx_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCsyrkx_rank_0 = hipblasCsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasCsyrkx_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkx_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCsyrkx_rank_1 = hipblasCsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZsyrkx_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkx_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZsyrkx_full_rank = hipblasZsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZsyrkx_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkx_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZsyrkx_rank_0 = hipblasZsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZsyrkx_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkx_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZsyrkx_rank_1 = hipblasZsyrkx_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasSsyrkxBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkxBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsyrkxBatched_full_rank = hipblasSsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsyrkxBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkxBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsyrkxBatched_rank_0 = hipblasSsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsyrkxBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkxBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSsyrkxBatched_rank_1 = hipblasSsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsyrkxBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkxBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsyrkxBatched_full_rank = hipblasDsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsyrkxBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkxBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsyrkxBatched_rank_0 = hipblasDsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasDsyrkxBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkxBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDsyrkxBatched_rank_1 = hipblasDsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsyrkxBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsyrkxBatched_full_rank = hipblasCsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsyrkxBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsyrkxBatched_rank_0 = hipblasCsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasCsyrkxBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCsyrkxBatched_rank_1 = hipblasCsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsyrkxBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsyrkxBatched_full_rank = hipblasZsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsyrkxBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsyrkxBatched_rank_0 = hipblasZsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZsyrkxBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZsyrkxBatched_rank_1 = hipblasZsyrkxBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasSsyrkxStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkxStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasSsyrkxStridedBatched_full_rank = hipblasSsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasSsyrkxStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasSsyrkxStridedBatched_rank_0 = hipblasSsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasSsyrkxStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasSsyrkxStridedBatched_rank_1 = hipblasSsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasDsyrkxStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkxStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasDsyrkxStridedBatched_full_rank = hipblasDsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasDsyrkxStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasDsyrkxStridedBatched_rank_0 = hipblasDsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasDsyrkxStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasDsyrkxStridedBatched_rank_1 = hipblasDsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasCsyrkxStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasCsyrkxStridedBatched_full_rank = hipblasCsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasCsyrkxStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasCsyrkxStridedBatched_rank_0 = hipblasCsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasCsyrkxStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasCsyrkxStridedBatched_rank_1 = hipblasCsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasZsyrkxStridedBatched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasZsyrkxStridedBatched_full_rank = hipblasZsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasZsyrkxStridedBatched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasZsyrkxStridedBatched_rank_0 = hipblasZsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasZsyrkxStridedBatched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,stridec,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stridec
      integer(c_int) :: batchCount
      !
      hipblasZsyrkxStridedBatched_rank_1 = hipblasZsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,stridec,batchCount)
    end function

    function hipblasSgeam_full_rank(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeam_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasSgeam_full_rank = hipblasSgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasSgeam_rank_0(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeam_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      hipblasSgeam_rank_0 = hipblasSgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasSgeam_rank_1(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeam_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasSgeam_rank_1 = hipblasSgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasDgeam_full_rank(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeam_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasDgeam_full_rank = hipblasDgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasDgeam_rank_0(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeam_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      hipblasDgeam_rank_0 = hipblasDgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasDgeam_rank_1(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeam_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasDgeam_rank_1 = hipblasDgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasCgeam_full_rank(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeam_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCgeam_full_rank = hipblasCgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasCgeam_rank_0(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeam_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCgeam_rank_0 = hipblasCgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasCgeam_rank_1(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeam_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCgeam_rank_1 = hipblasCgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasZgeam_full_rank(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeam_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZgeam_full_rank = hipblasZgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasZgeam_rank_0(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeam_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZgeam_rank_0 = hipblasZgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasZgeam_rank_1(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeam_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZgeam_rank_1 = hipblasZgeam_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasSgeamBatched_full_rank(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeamBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSgeamBatched_full_rank = hipblasSgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasSgeamBatched_rank_0(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeamBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSgeamBatched_rank_0 = hipblasSgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasSgeamBatched_rank_1(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeamBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSgeamBatched_rank_1 = hipblasSgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasDgeamBatched_full_rank(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeamBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDgeamBatched_full_rank = hipblasDgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasDgeamBatched_rank_0(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeamBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDgeamBatched_rank_0 = hipblasDgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasDgeamBatched_rank_1(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeamBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDgeamBatched_rank_1 = hipblasDgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasCgeamBatched_full_rank(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCgeamBatched_full_rank = hipblasCgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasCgeamBatched_rank_0(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCgeamBatched_rank_0 = hipblasCgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasCgeamBatched_rank_1(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCgeamBatched_rank_1 = hipblasCgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasZgeamBatched_full_rank(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZgeamBatched_full_rank = hipblasZgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasZgeamBatched_rank_0(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZgeamBatched_rank_0 = hipblasZgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasZgeamBatched_rank_1(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZgeamBatched_rank_1 = hipblasZgeamBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasSgeamStridedBatched_full_rank(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeamStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSgeamStridedBatched_full_rank = hipblasSgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSgeamStridedBatched_rank_0(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeamStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: beta
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSgeamStridedBatched_rank_0 = hipblasSgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSgeamStridedBatched_rank_1(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeamStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSgeamStridedBatched_rank_1 = hipblasSgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDgeamStridedBatched_full_rank(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeamStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDgeamStridedBatched_full_rank = hipblasDgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDgeamStridedBatched_rank_0(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeamStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: beta
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDgeamStridedBatched_rank_0 = hipblasDgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDgeamStridedBatched_rank_1(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeamStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDgeamStridedBatched_rank_1 = hipblasDgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCgeamStridedBatched_full_rank(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCgeamStridedBatched_full_rank = hipblasCgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCgeamStridedBatched_rank_0(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCgeamStridedBatched_rank_0 = hipblasCgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCgeamStridedBatched_rank_1(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCgeamStridedBatched_rank_1 = hipblasCgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZgeamStridedBatched_full_rank(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZgeamStridedBatched_full_rank = hipblasZgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZgeamStridedBatched_rank_0(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZgeamStridedBatched_rank_0 = hipblasZgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZgeamStridedBatched_rank_1(handle,transa,transb,m,n,alpha,A,lda,strideA,beta,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transa
      integer(kind(HIPBLAS_OP_N)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZgeamStridedBatched_rank_1 = hipblasZgeamStridedBatched_(handle,transa,transb,m,n,alpha,c_loc(A),lda,strideA,beta,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasChemm_full_rank(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasChemm_full_rank = hipblasChemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasChemm_rank_0(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasChemm_rank_0 = hipblasChemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasChemm_rank_1(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasChemm_rank_1 = hipblasChemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZhemm_full_rank(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZhemm_full_rank = hipblasZhemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZhemm_rank_0(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZhemm_rank_0 = hipblasZhemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasZhemm_rank_1(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZhemm_rank_1 = hipblasZhemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function hipblasChemmBatched_full_rank(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasChemmBatched_full_rank = hipblasChemmBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasChemmBatched_rank_0(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasChemmBatched_rank_0 = hipblasChemmBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasChemmBatched_rank_1(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasChemmBatched_rank_1 = hipblasChemmBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZhemmBatched_full_rank(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZhemmBatched_full_rank = hipblasZhemmBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZhemmBatched_rank_0(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZhemmBatched_rank_0 = hipblasZhemmBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasZhemmBatched_rank_1(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZhemmBatched_rank_1 = hipblasZhemmBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batchCount)
    end function

    function hipblasChemmStridedBatched_full_rank(handle,side,uplo,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasChemmStridedBatched_full_rank = hipblasChemmStridedBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasChemmStridedBatched_rank_0(handle,side,uplo,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasChemmStridedBatched_rank_0 = hipblasChemmStridedBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasChemmStridedBatched_rank_1(handle,side,uplo,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasChemmStridedBatched_rank_1 = hipblasChemmStridedBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZhemmStridedBatched_full_rank(handle,side,uplo,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZhemmStridedBatched_full_rank = hipblasZhemmStridedBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZhemmStridedBatched_rank_0(handle,side,uplo,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZhemmStridedBatched_rank_0 = hipblasZhemmStridedBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZhemmStridedBatched_rank_1(handle,side,uplo,n,k,alpha,A,lda,strideA,B,ldb,strideB,beta,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZhemmStridedBatched_rank_1 = hipblasZhemmStridedBatched_(handle,side,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,beta,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasStrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      hipblasStrmm_full_rank = hipblasStrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasStrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      !
      hipblasStrmm_rank_0 = hipblasStrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasStrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      hipblasStrmm_rank_1 = hipblasStrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasDtrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      hipblasDtrmm_full_rank = hipblasDtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasDtrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      !
      hipblasDtrmm_rank_0 = hipblasDtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasDtrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      hipblasDtrmm_rank_1 = hipblasDtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasCtrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      hipblasCtrmm_full_rank = hipblasCtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasCtrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      !
      hipblasCtrmm_rank_0 = hipblasCtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasCtrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      hipblasCtrmm_rank_1 = hipblasCtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasZtrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      hipblasZtrmm_full_rank = hipblasZtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasZtrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      !
      hipblasZtrmm_rank_0 = hipblasZtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasZtrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      hipblasZtrmm_rank_1 = hipblasZtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasStrmmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasStrmmBatched_full_rank = hipblasStrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasStrmmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasStrmmBatched_rank_0 = hipblasStrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasStrmmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasStrmmBatched_rank_1 = hipblasStrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasDtrmmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasDtrmmBatched_full_rank = hipblasDtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasDtrmmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasDtrmmBatched_rank_0 = hipblasDtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasDtrmmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasDtrmmBatched_rank_1 = hipblasDtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasCtrmmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasCtrmmBatched_full_rank = hipblasCtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasCtrmmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasCtrmmBatched_rank_0 = hipblasCtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasCtrmmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasCtrmmBatched_rank_1 = hipblasCtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasZtrmmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasZtrmmBatched_full_rank = hipblasZtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasZtrmmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasZtrmmBatched_rank_0 = hipblasZtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasZtrmmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasZtrmmBatched_rank_1 = hipblasZtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasStrmmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasStrmmStridedBatched_full_rank = hipblasStrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasStrmmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasStrmmStridedBatched_rank_0 = hipblasStrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasStrmmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasStrmmStridedBatched_rank_1 = hipblasStrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasDtrmmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasDtrmmStridedBatched_full_rank = hipblasDtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasDtrmmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasDtrmmStridedBatched_rank_0 = hipblasDtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasDtrmmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasDtrmmStridedBatched_rank_1 = hipblasDtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasCtrmmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasCtrmmStridedBatched_full_rank = hipblasCtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasCtrmmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasCtrmmStridedBatched_rank_0 = hipblasCtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasCtrmmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasCtrmmStridedBatched_rank_1 = hipblasCtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasZtrmmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasZtrmmStridedBatched_full_rank = hipblasZtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasZtrmmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasZtrmmStridedBatched_rank_0 = hipblasZtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasZtrmmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasZtrmmStridedBatched_rank_1 = hipblasZtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasStrsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      hipblasStrsm_full_rank = hipblasStrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasStrsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      !
      hipblasStrsm_rank_0 = hipblasStrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasStrsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      hipblasStrsm_rank_1 = hipblasStrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasDtrsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      hipblasDtrsm_full_rank = hipblasDtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasDtrsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      !
      hipblasDtrsm_rank_0 = hipblasDtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasDtrsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      hipblasDtrsm_rank_1 = hipblasDtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasCtrsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      hipblasCtrsm_full_rank = hipblasCtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasCtrsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      !
      hipblasCtrsm_rank_0 = hipblasCtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasCtrsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      hipblasCtrsm_rank_1 = hipblasCtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasZtrsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      hipblasZtrsm_full_rank = hipblasZtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasZtrsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      !
      hipblasZtrsm_rank_0 = hipblasZtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasZtrsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      hipblasZtrsm_rank_1 = hipblasZtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function hipblasStrsmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasStrsmBatched_full_rank = hipblasStrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasStrsmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasStrsmBatched_rank_0 = hipblasStrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasStrsmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasStrsmBatched_rank_1 = hipblasStrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasDtrsmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasDtrsmBatched_full_rank = hipblasDtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasDtrsmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasDtrsmBatched_rank_0 = hipblasDtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasDtrsmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasDtrsmBatched_rank_1 = hipblasDtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasCtrsmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasCtrsmBatched_full_rank = hipblasCtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasCtrsmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasCtrsmBatched_rank_0 = hipblasCtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasCtrsmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasCtrsmBatched_rank_1 = hipblasCtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasZtrsmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasZtrsmBatched_full_rank = hipblasZtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasZtrsmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasZtrsmBatched_rank_0 = hipblasZtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasZtrsmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batchCount
      !
      hipblasZtrsmBatched_rank_1 = hipblasZtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batchCount)
    end function

    function hipblasStrsmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasStrsmStridedBatched_full_rank = hipblasStrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasStrsmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasStrsmStridedBatched_rank_0 = hipblasStrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasStrsmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasStrsmStridedBatched_rank_1 = hipblasStrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasDtrsmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasDtrsmStridedBatched_full_rank = hipblasDtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasDtrsmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasDtrsmStridedBatched_rank_0 = hipblasDtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasDtrsmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasDtrsmStridedBatched_rank_1 = hipblasDtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasCtrsmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasCtrsmStridedBatched_full_rank = hipblasCtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasCtrsmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasCtrsmStridedBatched_rank_0 = hipblasCtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasCtrsmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasCtrsmStridedBatched_rank_1 = hipblasCtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasZtrsmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasZtrsmStridedBatched_full_rank = hipblasZtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasZtrsmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasZtrsmStridedBatched_rank_0 = hipblasZtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasZtrsmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batchCount
      !
      hipblasZtrsmStridedBatched_rank_1 = hipblasZtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batchCount)
    end function

    function hipblasStrtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasStrtri_full_rank = hipblasStrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasStrtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: invA
      integer(c_int) :: ldinvA
      !
      hipblasStrtri_rank_0 = hipblasStrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasStrtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasStrtri_rank_1 = hipblasStrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasDtrtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasDtrtri_full_rank = hipblasDtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasDtrtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: invA
      integer(c_int) :: ldinvA
      !
      hipblasDtrtri_rank_0 = hipblasDtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasDtrtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasDtrtri_rank_1 = hipblasDtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasCtrtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasCtrtri_full_rank = hipblasCtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasCtrtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      !
      hipblasCtrtri_rank_0 = hipblasCtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasCtrtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasCtrtri_rank_1 = hipblasCtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasZtrtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasZtrtri_full_rank = hipblasZtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasZtrtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      !
      hipblasZtrtri_rank_0 = hipblasZtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasZtrtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasZtrtri_rank_1 = hipblasZtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function hipblasStrtriBatched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasStrtriBatched_full_rank = hipblasStrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasStrtriBatched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasStrtriBatched_rank_0 = hipblasStrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasStrtriBatched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasStrtriBatched_rank_1 = hipblasStrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasDtrtriBatched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriBatched_full_rank = hipblasDtrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasDtrtriBatched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriBatched_rank_0 = hipblasDtrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasDtrtriBatched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriBatched_rank_1 = hipblasDtrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasCtrtriBatched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriBatched_full_rank = hipblasCtrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasCtrtriBatched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriBatched_rank_0 = hipblasCtrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasCtrtriBatched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriBatched_rank_1 = hipblasCtrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasZtrtriBatched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriBatched_full_rank = hipblasZtrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasZtrtriBatched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriBatched_rank_0 = hipblasZtrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasZtrtriBatched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriBatched_rank_1 = hipblasZtrtriBatched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasStrtriStridedBatched_full_rank(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasStrtriStridedBatched_full_rank = hipblasStrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasStrtriStridedBatched_rank_0(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasStrtriStridedBatched_rank_0 = hipblasStrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasStrtriStridedBatched_rank_1(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasStrtriStridedBatched_rank_1 = hipblasStrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasDtrtriStridedBatched_full_rank(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriStridedBatched_full_rank = hipblasDtrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasDtrtriStridedBatched_rank_0(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriStridedBatched_rank_0 = hipblasDtrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasDtrtriStridedBatched_rank_1(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriStridedBatched_rank_1 = hipblasDtrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasCtrtriStridedBatched_full_rank(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriStridedBatched_full_rank = hipblasCtrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasCtrtriStridedBatched_rank_0(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriStridedBatched_rank_0 = hipblasCtrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasCtrtriStridedBatched_rank_1(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriStridedBatched_rank_1 = hipblasCtrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasZtrtriStridedBatched_full_rank(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriStridedBatched_full_rank = hipblasZtrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasZtrtriStridedBatched_rank_0(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriStridedBatched_rank_0 = hipblasZtrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasZtrtriStridedBatched_rank_1(handle,uplo,diag,n,A,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriStridedBatched_rank_1 = hipblasZtrtriStridedBatched_(handle,uplo,diag,n,c_loc(A),lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasSdgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasSdgmm_full_rank = hipblasSdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasSdgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      hipblasSdgmm_rank_0 = hipblasSdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasSdgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasSdgmm_rank_1 = hipblasSdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasDdgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasDdgmm_full_rank = hipblasDdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasDdgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      hipblasDdgmm_rank_0 = hipblasDdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasDdgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasDdgmm_rank_1 = hipblasDdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasCdgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCdgmm_full_rank = hipblasCdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasCdgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCdgmm_rank_0 = hipblasCdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasCdgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCdgmm_rank_1 = hipblasCdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasZdgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZdgmm_full_rank = hipblasZdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasZdgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZdgmm_rank_0 = hipblasZdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasZdgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZdgmm_rank_1 = hipblasZdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function hipblasSdgmmBatched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSdgmmBatched_full_rank = hipblasSdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasSdgmmBatched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSdgmmBatched_rank_0 = hipblasSdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasSdgmmBatched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSdgmmBatched_rank_1 = hipblasSdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasDdgmmBatched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDdgmmBatched_full_rank = hipblasDdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasDdgmmBatched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDdgmmBatched_rank_0 = hipblasDdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasDdgmmBatched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDdgmmBatched_rank_1 = hipblasDdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasCdgmmBatched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCdgmmBatched_full_rank = hipblasCdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasCdgmmBatched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCdgmmBatched_rank_0 = hipblasCdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasCdgmmBatched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCdgmmBatched_rank_1 = hipblasCdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasZdgmmBatched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZdgmmBatched_full_rank = hipblasZdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasZdgmmBatched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZdgmmBatched_rank_0 = hipblasZdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasZdgmmBatched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZdgmmBatched_rank_1 = hipblasZdgmmBatched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batchCount)
    end function

    function hipblasSdgmmStridedBatched_full_rank(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSdgmmStridedBatched_full_rank = hipblasSdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,strideA,c_loc(x),incx,stridex,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSdgmmStridedBatched_rank_0(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSdgmmStridedBatched_rank_0 = hipblasSdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,strideA,c_loc(x),incx,stridex,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSdgmmStridedBatched_rank_1(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSdgmmStridedBatched_rank_1 = hipblasSdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,strideA,c_loc(x),incx,stridex,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDdgmmStridedBatched_full_rank(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDdgmmStridedBatched_full_rank = hipblasDdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,strideA,c_loc(x),incx,stridex,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDdgmmStridedBatched_rank_0(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDdgmmStridedBatched_rank_0 = hipblasDdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,strideA,c_loc(x),incx,stridex,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDdgmmStridedBatched_rank_1(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDdgmmStridedBatched_rank_1 = hipblasDdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,strideA,c_loc(x),incx,stridex,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCdgmmStridedBatched_full_rank(handle,side,m,n,A,lda,stride_A,x,incx,stride_x,C,ldc,stride_C,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batchCount
      !
      hipblasCdgmmStridedBatched_full_rank = hipblasCdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_C,batchCount)
    end function

    function hipblasCdgmmStridedBatched_rank_0(handle,side,m,n,A,lda,stride_A,x,incx,stride_x,C,ldc,stride_C,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batchCount
      !
      hipblasCdgmmStridedBatched_rank_0 = hipblasCdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_C,batchCount)
    end function

    function hipblasCdgmmStridedBatched_rank_1(handle,side,m,n,A,lda,stride_A,x,incx,stride_x,C,ldc,stride_C,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batchCount
      !
      hipblasCdgmmStridedBatched_rank_1 = hipblasCdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_C,batchCount)
    end function

    function hipblasZdgmmStridedBatched_full_rank(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZdgmmStridedBatched_full_rank = hipblasZdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,strideA,c_loc(x),incx,stridex,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZdgmmStridedBatched_rank_0(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZdgmmStridedBatched_rank_0 = hipblasZdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,strideA,c_loc(x),incx,stridex,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZdgmmStridedBatched_rank_1(handle,side,m,n,A,lda,strideA,x,incx,stridex,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZdgmmStridedBatched_rank_1 = hipblasZdgmmStridedBatched_(handle,side,m,n,c_loc(A),lda,strideA,c_loc(x),incx,stridex,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasSgetrf_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgetrf_full_rank = hipblasSgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgetrf_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgetrf_rank_0 = hipblasSgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgetrf_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgetrf_rank_1 = hipblasSgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgetrf_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgetrf_full_rank = hipblasDgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgetrf_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgetrf_rank_0 = hipblasDgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgetrf_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgetrf_rank_1 = hipblasDgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgetrf_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgetrf_full_rank = hipblasCgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgetrf_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgetrf_rank_0 = hipblasCgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgetrf_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgetrf_rank_1 = hipblasCgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgetrf_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgetrf_full_rank = hipblasZgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgetrf_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgetrf_rank_0 = hipblasZgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgetrf_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgetrf_rank_1 = hipblasZgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgetrfBatched_full_rank(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfBatched_full_rank = hipblasSgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgetrfBatched_rank_0(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfBatched_rank_0 = hipblasSgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgetrfBatched_rank_1(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfBatched_rank_1 = hipblasSgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgetrfBatched_full_rank(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfBatched_full_rank = hipblasDgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgetrfBatched_rank_0(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfBatched_rank_0 = hipblasDgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgetrfBatched_rank_1(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfBatched_rank_1 = hipblasDgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgetrfBatched_full_rank(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfBatched_full_rank = hipblasCgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgetrfBatched_rank_0(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfBatched_rank_0 = hipblasCgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgetrfBatched_rank_1(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfBatched_rank_1 = hipblasCgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgetrfBatched_full_rank(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfBatched_full_rank = hipblasZgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgetrfBatched_rank_0(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfBatched_rank_0 = hipblasZgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgetrfBatched_rank_1(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfBatched_rank_1 = hipblasZgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgetrfStridedBatched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfStridedBatched_full_rank = hipblasSgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasSgetrfStridedBatched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfStridedBatched_rank_0 = hipblasSgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasSgetrfStridedBatched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfStridedBatched_rank_1 = hipblasSgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgetrfStridedBatched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfStridedBatched_full_rank = hipblasDgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgetrfStridedBatched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfStridedBatched_rank_0 = hipblasDgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgetrfStridedBatched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfStridedBatched_rank_1 = hipblasDgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgetrfStridedBatched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfStridedBatched_full_rank = hipblasCgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgetrfStridedBatched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfStridedBatched_rank_0 = hipblasCgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgetrfStridedBatched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfStridedBatched_rank_1 = hipblasCgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgetrfStridedBatched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfStridedBatched_full_rank = hipblasZgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgetrfStridedBatched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfStridedBatched_rank_0 = hipblasZgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgetrfStridedBatched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfStridedBatched_rank_1 = hipblasZgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasSgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasSgetrs_full_rank = hipblasSgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasSgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasSgetrs_rank_0 = hipblasSgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasSgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasSgetrs_rank_1 = hipblasSgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasDgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasDgetrs_full_rank = hipblasDgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasDgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasDgetrs_rank_0 = hipblasDgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasDgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasDgetrs_rank_1 = hipblasDgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasCgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasCgetrs_full_rank = hipblasCgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasCgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasCgetrs_rank_0 = hipblasCgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasCgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasCgetrs_rank_1 = hipblasCgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasZgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasZgetrs_full_rank = hipblasZgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasZgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasZgetrs_rank_0 = hipblasZgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasZgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasZgetrs_rank_1 = hipblasZgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasSgetrsBatched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsBatched_full_rank = hipblasSgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasSgetrsBatched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsBatched_rank_0 = hipblasSgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasSgetrsBatched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsBatched_rank_1 = hipblasSgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasDgetrsBatched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsBatched_full_rank = hipblasDgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasDgetrsBatched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsBatched_rank_0 = hipblasDgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasDgetrsBatched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsBatched_rank_1 = hipblasDgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasCgetrsBatched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsBatched_full_rank = hipblasCgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasCgetrsBatched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsBatched_rank_0 = hipblasCgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasCgetrsBatched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsBatched_rank_1 = hipblasCgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasZgetrsBatched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsBatched_full_rank = hipblasZgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasZgetrsBatched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsBatched_rank_0 = hipblasZgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasZgetrsBatched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsBatched_rank_1 = hipblasZgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasSgetrsStridedBatched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsStridedBatched_full_rank = hipblasSgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasSgetrsStridedBatched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsStridedBatched_rank_0 = hipblasSgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasSgetrsStridedBatched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsStridedBatched_rank_1 = hipblasSgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasDgetrsStridedBatched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsStridedBatched_full_rank = hipblasDgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasDgetrsStridedBatched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsStridedBatched_rank_0 = hipblasDgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasDgetrsStridedBatched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsStridedBatched_rank_1 = hipblasDgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasCgetrsStridedBatched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsStridedBatched_full_rank = hipblasCgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasCgetrsStridedBatched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsStridedBatched_rank_0 = hipblasCgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasCgetrsStridedBatched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsStridedBatched_rank_1 = hipblasCgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasZgetrsStridedBatched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsStridedBatched_full_rank = hipblasZgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasZgetrsStridedBatched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsStridedBatched_rank_0 = hipblasZgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasZgetrsStridedBatched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsStridedBatched_rank_1 = hipblasZgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasSgetriBatched_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetriBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetriBatched_full_rank = hipblasSgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasSgetriBatched_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetriBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetriBatched_rank_0 = hipblasSgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasSgetriBatched_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetriBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetriBatched_rank_1 = hipblasSgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasDgetriBatched_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetriBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetriBatched_full_rank = hipblasDgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasDgetriBatched_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetriBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetriBatched_rank_0 = hipblasDgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasDgetriBatched_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetriBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetriBatched_rank_1 = hipblasDgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasCgetriBatched_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetriBatched_full_rank = hipblasCgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasCgetriBatched_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetriBatched_rank_0 = hipblasCgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasCgetriBatched_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetriBatched_rank_1 = hipblasCgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasZgetriBatched_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetriBatched_full_rank = hipblasZgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasZgetriBatched_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetriBatched_rank_0 = hipblasZgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasZgetriBatched_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetriBatched_rank_1 = hipblasZgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasSgeqrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgeqrf_full_rank = hipblasSgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgeqrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgeqrf_rank_0 = hipblasSgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgeqrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgeqrf_rank_1 = hipblasSgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgeqrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgeqrf_full_rank = hipblasDgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgeqrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgeqrf_rank_0 = hipblasDgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgeqrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgeqrf_rank_1 = hipblasDgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgeqrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgeqrf_full_rank = hipblasCgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgeqrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgeqrf_rank_0 = hipblasCgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgeqrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgeqrf_rank_1 = hipblasCgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgeqrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgeqrf_full_rank = hipblasZgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgeqrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgeqrf_rank_0 = hipblasZgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgeqrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgeqrf_rank_1 = hipblasZgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgeqrfBatched_full_rank(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfBatched_full_rank = hipblasSgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgeqrfBatched_rank_0(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfBatched_rank_0 = hipblasSgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgeqrfBatched_rank_1(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfBatched_rank_1 = hipblasSgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgeqrfBatched_full_rank(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfBatched_full_rank = hipblasDgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgeqrfBatched_rank_0(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfBatched_rank_0 = hipblasDgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgeqrfBatched_rank_1(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfBatched_rank_1 = hipblasDgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgeqrfBatched_full_rank(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfBatched_full_rank = hipblasCgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgeqrfBatched_rank_0(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfBatched_rank_0 = hipblasCgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgeqrfBatched_rank_1(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfBatched_rank_1 = hipblasCgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgeqrfBatched_full_rank(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfBatched_full_rank = hipblasZgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgeqrfBatched_rank_0(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfBatched_rank_0 = hipblasZgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgeqrfBatched_rank_1(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfBatched_rank_1 = hipblasZgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgeqrfStridedBatched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfStridedBatched_full_rank = hipblasSgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasSgeqrfStridedBatched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfStridedBatched_rank_0 = hipblasSgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasSgeqrfStridedBatched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfStridedBatched_rank_1 = hipblasSgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgeqrfStridedBatched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfStridedBatched_full_rank = hipblasDgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgeqrfStridedBatched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfStridedBatched_rank_0 = hipblasDgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgeqrfStridedBatched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfStridedBatched_rank_1 = hipblasDgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgeqrfStridedBatched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfStridedBatched_full_rank = hipblasCgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgeqrfStridedBatched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfStridedBatched_rank_0 = hipblasCgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgeqrfStridedBatched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfStridedBatched_rank_1 = hipblasCgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgeqrfStridedBatched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfStridedBatched_full_rank = hipblasZgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgeqrfStridedBatched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfStridedBatched_rank_0 = hipblasZgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgeqrfStridedBatched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfStridedBatched_rank_1 = hipblasZgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

  
#endif
end module hipfort_hipblas