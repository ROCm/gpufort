!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! ==============================================================================
! hipfort: FORTRAN Interfaces for GPU kernels
! ==============================================================================
! Copyright (c) 2020-2022 Advanced Micro Devices, Inc. All rights reserved.
! [MITx11 License]
! 
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
! 
! The above copyright notice and this permission notice shall be included in
! all copies or substantial portions of the Software.
! 
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
! THE SOFTWARE.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          
           
module hipfort_rocblas
  use hipfort_rocblas_enums
  use hipfort_rocblas_auxiliary
  implicit none

 
  !>  ===========================================================================
  !>     level 1 BLAS
  !>  ===========================================================================
  interface rocblas_sscal
    function rocblas_sscal_(handle,incx) bind(c, name="rocblas_sscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
    end function

  end interface
  
  interface rocblas_dscal
    function rocblas_dscal_(handle,incx) bind(c, name="rocblas_dscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
    end function

  end interface
  
  interface rocblas_cscal
    function rocblas_cscal_(handle,n,alpha,x,incx) bind(c, name="rocblas_cscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cscal_rank_0,&
      rocblas_cscal_rank_1
#endif
  end interface
  
  interface rocblas_zscal
    function rocblas_zscal_(handle,n,alpha,x,incx) bind(c, name="rocblas_zscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zscal_rank_0,&
      rocblas_zscal_rank_1
#endif
  end interface
  
  interface rocblas_csscal
    function rocblas_csscal_(handle,n,alpha,x,incx) bind(c, name="rocblas_csscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csscal_rank_0,&
      rocblas_csscal_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     scal  scales each element of vector x with scalar alpha.
  !> 
  !>         x := alpha * x
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     alpha     device pointer or host pointer for the scalar alpha.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !> 
  !>
  interface rocblas_zdscal
    function rocblas_zdscal_(handle,n,alpha,x,incx) bind(c, name="rocblas_zdscal")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdscal_rank_0,&
      rocblas_zdscal_rank_1
#endif
  end interface
  
  interface rocblas_sscal_batched
    function rocblas_sscal_batched_(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_sscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sscal_batched_full_rank,&
      rocblas_sscal_batched_rank_0,&
      rocblas_sscal_batched_rank_1
#endif
  end interface
  
  interface rocblas_dscal_batched
    function rocblas_dscal_batched_(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_dscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dscal_batched_full_rank,&
      rocblas_dscal_batched_rank_0,&
      rocblas_dscal_batched_rank_1
#endif
  end interface
  
  interface rocblas_cscal_batched
    function rocblas_cscal_batched_(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_cscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cscal_batched_full_rank,&
      rocblas_cscal_batched_rank_0,&
      rocblas_cscal_batched_rank_1
#endif
  end interface
  
  interface rocblas_zscal_batched
    function rocblas_zscal_batched_(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_zscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zscal_batched_full_rank,&
      rocblas_zscal_batched_rank_0,&
      rocblas_zscal_batched_rank_1
#endif
  end interface
  
  interface rocblas_csscal_batched
    function rocblas_csscal_batched_(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_csscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csscal_batched_full_rank,&
      rocblas_csscal_batched_rank_0,&
      rocblas_csscal_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !>      \details
  !>     scal_batched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batch_count.
  !> 
  !>          x_i := alpha * x_i
  !> 
  !>      where (x_i) is the i-th instance of the batch.
  !>     @param[in]
  !>     handle      [rocblas_handle]
  !>                 handle to the rocblas library context queue.
  !>     @param[in]
  !>     n           [rocblas_int]
  !>                 the number of elements in each x_i.
  !>     @param[in]
  !>     alpha       host pointer or device pointer for the scalar alpha.
  !>     @param[inout]
  !>     x           device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx        [rocblas_int]
  !>                 specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of batches in x.
  interface rocblas_zdscal_batched
    function rocblas_zdscal_batched_(handle,n,alpha,x,incx,batch_count) bind(c, name="rocblas_zdscal_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdscal_batched_full_rank,&
      rocblas_zdscal_batched_rank_0,&
      rocblas_zdscal_batched_rank_1
#endif
  end interface
  
  interface rocblas_sscal_strided_batched
    function rocblas_sscal_strided_batched_(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_sscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sscal_strided_batched_rank_0,&
      rocblas_sscal_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dscal_strided_batched
    function rocblas_dscal_strided_batched_(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_dscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dscal_strided_batched_rank_0,&
      rocblas_dscal_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cscal_strided_batched
    function rocblas_cscal_strided_batched_(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_cscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cscal_strided_batched_rank_0,&
      rocblas_cscal_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_zscal_strided_batched
    function rocblas_zscal_strided_batched_(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_zscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zscal_strided_batched_rank_0,&
      rocblas_zscal_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_csscal_strided_batched
    function rocblas_csscal_strided_batched_(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_csscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csscal_strided_batched_rank_0,&
      rocblas_csscal_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !>      \details
  !>     scal_strided_batched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batch_count.
  !> 
  !>          x_i := alpha * x_i ,
  !> 
  !>      where (x_i) is the i-th instance of the batch.
  !>      @param[in]
  !>     handle      [rocblas_handle]
  !>                 handle to the rocblas library context queue.
  !>     @param[in]
  !>     n           [rocblas_int]
  !>                 the number of elements in each x_i.
  !>     @param[in]
  !>     alpha       host pointer or device pointer for the scalar alpha.
  !>     @param[inout]
  !>     x           device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx        [rocblas_int]
  !>                 specifies the increment for the elements of x.
  !>     @param[in]
  !>     stride_x    [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stride_x is of appropriate size, for a typical
  !>                 case this means stride_x >= n * incx.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of batches in x.
  interface rocblas_zdscal_strided_batched
    function rocblas_zdscal_strided_batched_(handle,n,alpha,x,incx,stride_x,batch_count) bind(c, name="rocblas_zdscal_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdscal_strided_batched_rank_0,&
      rocblas_zdscal_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_scopy
    function rocblas_scopy_(handle,n,x,incx,y,incy) bind(c, name="rocblas_scopy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_scopy_rank_0,&
      rocblas_scopy_rank_1
#endif
  end interface
  
  interface rocblas_dcopy
    function rocblas_dcopy_(handle,n,x,incx,y,incy) bind(c, name="rocblas_dcopy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dcopy_rank_0,&
      rocblas_dcopy_rank_1
#endif
  end interface
  
  interface rocblas_ccopy
    function rocblas_ccopy_(handle,n,x,incx,y,incy) bind(c, name="rocblas_ccopy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ccopy_rank_0,&
      rocblas_ccopy_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copy  copies each element x[i] into y[i], for  i = 1 , ... , n
  !> 
  !>         y := x,
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x to be copied to y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[out]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>
  interface rocblas_zcopy
    function rocblas_zcopy_(handle,n,x,incx,y,incy) bind(c, name="rocblas_zcopy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zcopy_rank_0,&
      rocblas_zcopy_rank_1
#endif
  end interface
  
  interface rocblas_scopy_batched
    function rocblas_scopy_batched_(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_scopy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_scopy_batched_full_rank,&
      rocblas_scopy_batched_rank_0,&
      rocblas_scopy_batched_rank_1
#endif
  end interface
  
  interface rocblas_dcopy_batched
    function rocblas_dcopy_batched_(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_dcopy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dcopy_batched_full_rank,&
      rocblas_dcopy_batched_rank_0,&
      rocblas_dcopy_batched_rank_1
#endif
  end interface
  
  interface rocblas_ccopy_batched
    function rocblas_ccopy_batched_(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_ccopy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ccopy_batched_full_rank,&
      rocblas_ccopy_batched_rank_0,&
      rocblas_ccopy_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copy_batched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batch_count
  !> 
  !>         y_i := x_i,
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i to be copied to y_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i.
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zcopy_batched
    function rocblas_zcopy_batched_(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_zcopy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zcopy_batched_full_rank,&
      rocblas_zcopy_batched_rank_0,&
      rocblas_zcopy_batched_rank_1
#endif
  end interface
  
  interface rocblas_scopy_strided_batched
    function rocblas_scopy_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_scopy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_scopy_strided_batched_rank_0,&
      rocblas_scopy_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dcopy_strided_batched
    function rocblas_dcopy_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_dcopy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dcopy_strided_batched_rank_0,&
      rocblas_dcopy_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ccopy_strided_batched
    function rocblas_ccopy_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_ccopy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ccopy_strided_batched_rank_0,&
      rocblas_ccopy_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copy_strided_batched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batch_count
  !> 
  !>         y_i := x_i,
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i to be copied to y_i.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increments for the elements of vectors x_i.
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stride_x is of appropriate size, for a typical
  !>                 case this means stride_x >= n * incx.
  !>     @param[out]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of vectors y_i.
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stride_y, however the user should
  !>                 take care to ensure that stride_y is of appropriate size, for a typical
  !>                 case this means stride_y >= n * incy. stridey should be non zero.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zcopy_strided_batched
    function rocblas_zcopy_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_zcopy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zcopy_strided_batched_rank_0,&
      rocblas_zcopy_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sdot
    function rocblas_sdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_sdot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sdot_rank_0,&
      rocblas_sdot_rank_1
#endif
  end interface
  
  interface rocblas_ddot
    function rocblas_ddot_(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_ddot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ddot_rank_0,&
      rocblas_ddot_rank_1
#endif
  end interface
  
  interface rocblas_hdot
    function rocblas_hdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_hdot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_hdot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: myResult
    end function

  end interface
  
  interface rocblas_bfdot
    function rocblas_bfdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_bfdot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_bfdot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_cdotu
    function rocblas_cdotu_(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_cdotu")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cdotu_rank_0,&
      rocblas_cdotu_rank_1
#endif
  end interface
  
  interface rocblas_zdotu
    function rocblas_zdotu_(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_zdotu")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdotu_rank_0,&
      rocblas_zdotu_rank_1
#endif
  end interface
  
  interface rocblas_cdotc
    function rocblas_cdotc_(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_cdotc")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cdotc_rank_0,&
      rocblas_cdotc_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     dot(u)  performs the dot product of vectors x and y
  !> 
  !>         result = x * y;
  !> 
  !>     dotc  performs the dot product of the conjugate of complex vector x and complex vector y
  !> 
  !>         result = conjugate (x) * y;
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the dot product.
  !>               return is 0.0 if n <= 0.
  !>
  interface rocblas_zdotc
    function rocblas_zdotc_(handle,n,x,incx,y,incy,myResult) bind(c, name="rocblas_zdotc")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdotc_rank_0,&
      rocblas_zdotc_rank_1
#endif
  end interface
  
  interface rocblas_sdot_batched
    function rocblas_sdot_batched_(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_sdot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sdot_batched_full_rank,&
      rocblas_sdot_batched_rank_0,&
      rocblas_sdot_batched_rank_1
#endif
  end interface
  
  interface rocblas_ddot_batched
    function rocblas_ddot_batched_(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_ddot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ddot_batched_full_rank,&
      rocblas_ddot_batched_rank_0,&
      rocblas_ddot_batched_rank_1
#endif
  end interface
  
  interface rocblas_hdot_batched
    function rocblas_hdot_batched_(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_hdot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_hdot_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr) :: myResult
    end function

  end interface
  
  interface rocblas_bfdot_batched
    function rocblas_bfdot_batched_(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_bfdot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_bfdot_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_cdotu_batched
    function rocblas_cdotu_batched_(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_cdotu_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cdotu_batched_full_rank,&
      rocblas_cdotu_batched_rank_0,&
      rocblas_cdotu_batched_rank_1
#endif
  end interface
  
  interface rocblas_zdotu_batched
    function rocblas_zdotu_batched_(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_zdotu_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdotu_batched_full_rank,&
      rocblas_zdotu_batched_rank_0,&
      rocblas_zdotu_batched_rank_1
#endif
  end interface
  
  interface rocblas_cdotc_batched
    function rocblas_cdotc_batched_(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_cdotc_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cdotc_batched_full_rank,&
      rocblas_cdotc_batched_rank_0,&
      rocblas_cdotc_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     dot_batched(u) performs a batch of dot products of vectors x and y
  !> 
  !>         result_i = x_i * y_i;
  !> 
  !>     dotc_batched  performs a batch of dot products of the conjugate of complex vector x and complex vector y
  !> 
  !>         result_i = conjugate (x_i) * y_i;
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>     @param[inout]
  !>     result
  !>               device array or host array of batch_count size to store the dot products of each batch.
  !>               return 0.0 for each element if n <= 0.
  !>
  interface rocblas_zdotc_batched
    function rocblas_zdotc_batched_(handle,n,x,incx,y,incy,batch_count,myResult) bind(c, name="rocblas_zdotc_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdotc_batched_full_rank,&
      rocblas_zdotc_batched_rank_0,&
      rocblas_zdotc_batched_rank_1
#endif
  end interface
  
  interface rocblas_sdot_strided_batched
    function rocblas_sdot_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_sdot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sdot_strided_batched_rank_0,&
      rocblas_sdot_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ddot_strided_batched
    function rocblas_ddot_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_ddot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ddot_strided_batched_rank_0,&
      rocblas_ddot_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_hdot_strided_batched
    function rocblas_hdot_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_hdot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_hdot_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr) :: myResult
    end function

  end interface
  
  interface rocblas_bfdot_strided_batched
    function rocblas_bfdot_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_bfdot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_bfdot_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_cdotu_strided_batched
    function rocblas_cdotu_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_cdotu_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cdotu_strided_batched_rank_0,&
      rocblas_cdotu_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_zdotu_strided_batched
    function rocblas_zdotu_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_zdotu_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdotu_strided_batched_rank_0,&
      rocblas_zdotu_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cdotc_strided_batched
    function rocblas_cdotc_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_cdotc_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cdotc_strided_batched_rank_0,&
      rocblas_cdotc_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     dot_strided_batched(u)  performs a batch of dot products of vectors x and y
  !> 
  !>         result_i = x_i * y_i;
  !> 
  !>     dotc_strided_batched  performs a batch of dot products of the conjugate of complex vector x and complex vector y
  !> 
  !>         result_i = conjugate (x_i) * y_i;
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>     @param[inout]
  !>     result
  !>               device array or host array of batch_count size to store the dot products of each batch.
  !>               return 0.0 for each element if n <= 0.
  !>
  interface rocblas_zdotc_strided_batched
    function rocblas_zdotc_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult) bind(c, name="rocblas_zdotc_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdotc_strided_batched_rank_0,&
      rocblas_zdotc_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sswap
    function rocblas_sswap_(handle,incy) bind(c, name="rocblas_sswap")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: incy
    end function

  end interface
  
  interface rocblas_dswap
    function rocblas_dswap_(handle,incy) bind(c, name="rocblas_dswap")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: incy
    end function

  end interface
  
  interface rocblas_cswap
    function rocblas_cswap_(handle,n,x,incx,y,incy) bind(c, name="rocblas_cswap")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cswap_rank_0,&
      rocblas_cswap_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swap  interchanges vectors x and y.
  !> 
  !>         y := x; x := y
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x and y.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>
  interface rocblas_zswap
    function rocblas_zswap_(handle,n,x,incx,y,incy) bind(c, name="rocblas_zswap")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zswap_rank_0,&
      rocblas_zswap_rank_1
#endif
  end interface
  
  interface rocblas_sswap_batched
    function rocblas_sswap_batched_(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_sswap_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sswap_batched_full_rank,&
      rocblas_sswap_batched_rank_0,&
      rocblas_sswap_batched_rank_1
#endif
  end interface
  
  interface rocblas_dswap_batched
    function rocblas_dswap_batched_(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_dswap_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dswap_batched_full_rank,&
      rocblas_dswap_batched_rank_0,&
      rocblas_dswap_batched_rank_1
#endif
  end interface
  
  interface rocblas_cswap_batched
    function rocblas_cswap_batched_(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_cswap_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cswap_batched_full_rank,&
      rocblas_cswap_batched_rank_0,&
      rocblas_cswap_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swap_batched interchanges vectors x_i and y_i, for i = 1 , ... , batch_count
  !> 
  !>         y_i := x_i; x_i := y_i
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[inout]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zswap_batched
    function rocblas_zswap_batched_(handle,n,x,incx,y,incy,batch_count) bind(c, name="rocblas_zswap_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zswap_batched_full_rank,&
      rocblas_zswap_batched_rank_0,&
      rocblas_zswap_batched_rank_1
#endif
  end interface
  
  interface rocblas_sswap_strided_batched
    function rocblas_sswap_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_sswap_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sswap_strided_batched_rank_0,&
      rocblas_sswap_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dswap_strided_batched
    function rocblas_dswap_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_dswap_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dswap_strided_batched_rank_0,&
      rocblas_dswap_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cswap_strided_batched
    function rocblas_cswap_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_cswap_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cswap_strided_batched_rank_0,&
      rocblas_cswap_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swap_strided_batched interchanges vectors x_i and y_i, for i = 1 , ... , batch_count
  !> 
  !>         y_i := x_i; x_i := y_i
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[inout]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n * incx.
  !>     @param[inout]
  !>     y         device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey   [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_y is of appropriate size, for a typical
  !>               case this means stride_y >= n * incy. stridey should be non zero.
  !>      @param[in]
  !>      batch_count [rocblas_int]
  !>                  number of instances in the batch.
  !>
  interface rocblas_zswap_strided_batched
    function rocblas_zswap_strided_batched_(handle,n,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_zswap_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zswap_strided_batched_rank_0,&
      rocblas_zswap_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_saxpy
    function rocblas_saxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="rocblas_saxpy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_saxpy_rank_0,&
      rocblas_saxpy_rank_1
#endif
  end interface
  
  interface rocblas_daxpy
    function rocblas_daxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="rocblas_daxpy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_daxpy_rank_0,&
      rocblas_daxpy_rank_1
#endif
  end interface
  
  interface rocblas_haxpy
    function rocblas_haxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="rocblas_haxpy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_haxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
    end function

  end interface
  
  interface rocblas_caxpy
    function rocblas_caxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="rocblas_caxpy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_caxpy_rank_0,&
      rocblas_caxpy_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     axpy   computes ant alpha multiplied by vector x, plus vector y
  !> 
  !>         y := alpha * x + y
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to specify the scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[out]
  !>     y         device pointer storing vector y.
  !>     @param[inout]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>
  interface rocblas_zaxpy
    function rocblas_zaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="rocblas_zaxpy")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zaxpy_rank_0,&
      rocblas_zaxpy_rank_1
#endif
  end interface
  
  interface rocblas_haxpy_batched
    function rocblas_haxpy_batched_(handle,n,alpha,x,incx,y,incy,batch_count) bind(c, name="rocblas_haxpy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_haxpy_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_saxpy_batched
    function rocblas_saxpy_batched_(handle,n,alpha,x,incx,y,incy,batch_count) bind(c, name="rocblas_saxpy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_saxpy_batched_full_rank,&
      rocblas_saxpy_batched_rank_0,&
      rocblas_saxpy_batched_rank_1
#endif
  end interface
  
  interface rocblas_daxpy_batched
    function rocblas_daxpy_batched_(handle,n,alpha,x,incx,y,incy,batch_count) bind(c, name="rocblas_daxpy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_daxpy_batched_full_rank,&
      rocblas_daxpy_batched_rank_0,&
      rocblas_daxpy_batched_rank_1
#endif
  end interface
  
  interface rocblas_caxpy_batched
    function rocblas_caxpy_batched_(handle,n,alpha,x,incx,y,incy,batch_count) bind(c, name="rocblas_caxpy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_caxpy_batched_full_rank,&
      rocblas_caxpy_batched_rank_0,&
      rocblas_caxpy_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     axpy_batched   compute y := alpha * x + y over a set of batched vectors.
  !> 
  !>     @param[in]
  !>     handle    rocblas_handle
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         rocblas_int
  !>     @param[in]
  !>     alpha     specifies the scalar alpha.
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU.
  !>     @param[in]
  !>     incx      rocblas_int
  !>               specifies the increment for the elements of x.
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU.
  !>     @param[inout]
  !>     incy      rocblas_int
  !>               specifies the increment for the elements of y.
  !> 
  !>     @param[in]
  !>     batch_count rocblas_int
  !>               number of instances in the batch
  !>
  interface rocblas_zaxpy_batched
    function rocblas_zaxpy_batched_(handle,n,alpha,x,incx,y,incy,batch_count) bind(c, name="rocblas_zaxpy_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zaxpy_batched_full_rank,&
      rocblas_zaxpy_batched_rank_0,&
      rocblas_zaxpy_batched_rank_1
#endif
  end interface
  
  interface rocblas_haxpy_strided_batched
    function rocblas_haxpy_strided_batched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_haxpy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_haxpy_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_saxpy_strided_batched
    function rocblas_saxpy_strided_batched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_saxpy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_saxpy_strided_batched_rank_0,&
      rocblas_saxpy_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_daxpy_strided_batched
    function rocblas_daxpy_strided_batched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_daxpy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_daxpy_strided_batched_rank_0,&
      rocblas_daxpy_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_caxpy_strided_batched
    function rocblas_caxpy_strided_batched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_caxpy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_caxpy_strided_batched_rank_0,&
      rocblas_caxpy_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     axpy_strided_batched   compute y := alpha * x + y over a set of strided batched vectors.
  !> 
  !>     @param[in]
  !>     handle    rocblas_handle
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         rocblas_int
  !>     @param[in]
  !>     alpha     specifies the scalar alpha.
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU.
  !>     @param[in]
  !>     incx      rocblas_int
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex   rocblas_stride
  !>               specifies the increment between vectors of x.
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU.
  !>     @param[inout]
  !>     incy      rocblas_int
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey   rocblas_stride
  !>               specifies the increment between vectors of y.
  !> 
  !>     @param[in]
  !>     batch_count rocblas_int
  !>               number of instances in the batch
  !>
  interface rocblas_zaxpy_strided_batched
    function rocblas_zaxpy_strided_batched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count) bind(c, name="rocblas_zaxpy_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zaxpy_strided_batched_rank_0,&
      rocblas_zaxpy_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sasum
    function rocblas_sasum_(handle,incx,myResult) bind(c, name="rocblas_sasum")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_dasum
    function rocblas_dasum_(handle,incx,myResult) bind(c, name="rocblas_dasum")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_scasum
    function rocblas_scasum_(handle,n,x,incx,myResult) bind(c, name="rocblas_scasum")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_scasum_rank_0,&
      rocblas_scasum_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asum computes the sum of the magnitudes of elements of a real vector x,
  !>          or the sum of magnitudes of the real and imaginary parts of elements if x is a complex
  !>    vector
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x. incx must be > 0.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the asum product.
  !>               return is 0.0 if n <= 0.
  !>
  interface rocblas_dzasum
    function rocblas_dzasum_(handle,n,x,incx,myResult) bind(c, name="rocblas_dzasum")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dzasum_rank_0,&
      rocblas_dzasum_rank_1
#endif
  end interface
  
  interface rocblas_sasum_batched
    function rocblas_sasum_batched_(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_sasum_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sasum_batched_full_rank,&
      rocblas_sasum_batched_rank_0,&
      rocblas_sasum_batched_rank_1
#endif
  end interface
  
  interface rocblas_dasum_batched
    function rocblas_dasum_batched_(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_dasum_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dasum_batched_full_rank,&
      rocblas_dasum_batched_rank_0,&
      rocblas_dasum_batched_rank_1
#endif
  end interface
  
  interface rocblas_scasum_batched
    function rocblas_scasum_batched_(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_scasum_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_scasum_batched_full_rank,&
      rocblas_scasum_batched_rank_0,&
      rocblas_scasum_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asum_batched computes the sum of the magnitudes of the elements in a batch of real vectors x_i,
  !>         or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
  !>         vector, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[out]
  !>     results
  !>               device array or host array of batch_count size for results.
  !>               return is 0.0 if n, incx<=0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch.
  interface rocblas_dzasum_batched
    function rocblas_dzasum_batched_(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_dzasum_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dzasum_batched_full_rank,&
      rocblas_dzasum_batched_rank_0,&
      rocblas_dzasum_batched_rank_1
#endif
  end interface
  
  interface rocblas_sasum_strided_batched
    function rocblas_sasum_strided_batched_(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_sasum_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sasum_strided_batched_rank_0,&
      rocblas_sasum_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dasum_strided_batched
    function rocblas_dasum_strided_batched_(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_dasum_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dasum_strided_batched_rank_0,&
      rocblas_dasum_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_scasum_strided_batched
    function rocblas_scasum_strided_batched_(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_scasum_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_scasum_strided_batched_rank_0,&
      rocblas_scasum_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asum_strided_batched computes the sum of the magnitudes of elements of a real vectors x_i,
  !>         or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
  !>         vector, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n * incx.
  !>     @param[out]
  !>     results
  !>               device pointer or host pointer to array for storing contiguous batch_count results.
  !>               return is 0.0 if n, incx<=0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  interface rocblas_dzasum_strided_batched
    function rocblas_dzasum_strided_batched_(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_dzasum_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dzasum_strided_batched_rank_0,&
      rocblas_dzasum_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_snrm2
    function rocblas_snrm2_(handle,incx,myResult) bind(c, name="rocblas_snrm2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_dnrm2
    function rocblas_dnrm2_(handle,incx,myResult) bind(c, name="rocblas_dnrm2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_scnrm2
    function rocblas_scnrm2_(handle,n,x,incx,myResult) bind(c, name="rocblas_scnrm2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_scnrm2_rank_0,&
      rocblas_scnrm2_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2 computes the euclidean norm of a real or complex vector
  !> 
  !>               result := sqrt( x'*x ) for real vectors
  !>               result := sqrt( x**H*x ) for complex vectors
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the nrm2 product.
  !>               return is 0.0 if n, incx<=0.
  interface rocblas_dznrm2
    function rocblas_dznrm2_(handle,n,x,incx,myResult) bind(c, name="rocblas_dznrm2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dznrm2_rank_0,&
      rocblas_dznrm2_rank_1
#endif
  end interface
  
  interface rocblas_snrm2_batched
    function rocblas_snrm2_batched_(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_snrm2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_snrm2_batched_full_rank,&
      rocblas_snrm2_batched_rank_0,&
      rocblas_snrm2_batched_rank_1
#endif
  end interface
  
  interface rocblas_dnrm2_batched
    function rocblas_dnrm2_batched_(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_dnrm2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dnrm2_batched_full_rank,&
      rocblas_dnrm2_batched_rank_0,&
      rocblas_dnrm2_batched_rank_1
#endif
  end interface
  
  interface rocblas_scnrm2_batched
    function rocblas_scnrm2_batched_(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_scnrm2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_scnrm2_batched_full_rank,&
      rocblas_scnrm2_batched_rank_0,&
      rocblas_scnrm2_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2_batched computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count
  !>               result := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     results
  !>               device pointer or host pointer to array of batch_count size for nrm2 results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !>
  interface rocblas_dznrm2_batched
    function rocblas_dznrm2_batched_(handle,n,x,incx,batch_count,results) bind(c, name="rocblas_dznrm2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dznrm2_batched_full_rank,&
      rocblas_dznrm2_batched_rank_0,&
      rocblas_dznrm2_batched_rank_1
#endif
  end interface
  
  interface rocblas_snrm2_strided_batched
    function rocblas_snrm2_strided_batched_(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_snrm2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_snrm2_strided_batched_rank_0,&
      rocblas_snrm2_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dnrm2_strided_batched
    function rocblas_dnrm2_strided_batched_(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_dnrm2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dnrm2_strided_batched_rank_0,&
      rocblas_dnrm2_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_scnrm2_strided_batched
    function rocblas_scnrm2_strided_batched_(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_scnrm2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_scnrm2_strided_batched_rank_0,&
      rocblas_scnrm2_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2_strided_batched computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count
  !>               := sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n * incx.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     results
  !>               device pointer or host pointer to array for storing contiguous batch_count results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !>
  interface rocblas_dznrm2_strided_batched
    function rocblas_dznrm2_strided_batched_(handle,n,x,incx,stridex,batch_count,results) bind(c, name="rocblas_dznrm2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dznrm2_strided_batched_rank_0,&
      rocblas_dznrm2_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_isamax
    function rocblas_isamax_(handle,myResult) bind(c, name="rocblas_isamax")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_
      type(c_ptr),value :: handle
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_idamax
    function rocblas_idamax_(handle,myResult) bind(c, name="rocblas_idamax")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_
      type(c_ptr),value :: handle
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_icamax
    function rocblas_icamax_(handle,n,x,incx,myResult) bind(c, name="rocblas_icamax")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_icamax_rank_0,&
      rocblas_icamax_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     amax finds the first index of the element of maximum magnitude of a vector x.
  !>    vector
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the amax index.
  !>               return is 0.0 if n, incx<=0.
  interface rocblas_izamax
    function rocblas_izamax_(handle,n,x,incx,myResult) bind(c, name="rocblas_izamax")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_izamax_rank_0,&
      rocblas_izamax_rank_1
#endif
  end interface
  
  interface rocblas_isamax_batched
    function rocblas_isamax_batched_(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_isamax_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_isamax_batched_full_rank,&
      rocblas_isamax_batched_rank_0,&
      rocblas_isamax_batched_rank_1
#endif
  end interface
  
  interface rocblas_idamax_batched
    function rocblas_idamax_batched_(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_idamax_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_idamax_batched_full_rank,&
      rocblas_idamax_batched_rank_0,&
      rocblas_idamax_batched_rank_1
#endif
  end interface
  
  interface rocblas_icamax_batched
    function rocblas_icamax_batched_(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_icamax_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_icamax_batched_full_rank,&
      rocblas_icamax_batched_rank_0,&
      rocblas_icamax_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      amax_batched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch, must be > 0.
  !>     @param[out]
  !>     result
  !>               device or host array of pointers of batch_count size for results.
  !>               return is 0 if n, incx<=0.
  interface rocblas_izamax_batched
    function rocblas_izamax_batched_(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_izamax_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_izamax_batched_full_rank,&
      rocblas_izamax_batched_rank_0,&
      rocblas_izamax_batched_rank_1
#endif
  end interface
  
  interface rocblas_isamax_strided_batched
    function rocblas_isamax_strided_batched_(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_isamax_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_isamax_strided_batched_rank_0,&
      rocblas_isamax_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_idamax_strided_batched
    function rocblas_idamax_strided_batched_(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_idamax_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_idamax_strided_batched_rank_0,&
      rocblas_idamax_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_icamax_strided_batched
    function rocblas_icamax_strided_batched_(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_icamax_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_icamax_strided_batched_rank_0,&
      rocblas_icamax_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      amax_strided_batched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               specifies the pointer increment between one x_i and the next x_(i + 1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device or host pointer for storing contiguous batch_count results.
  !>               return is 0 if n <= 0, incx<=0.
  !>
  interface rocblas_izamax_strided_batched
    function rocblas_izamax_strided_batched_(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_izamax_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_izamax_strided_batched_rank_0,&
      rocblas_izamax_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_isamin
    function rocblas_isamin_(handle,myResult) bind(c, name="rocblas_isamin")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_
      type(c_ptr),value :: handle
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_idamin
    function rocblas_idamin_(handle,myResult) bind(c, name="rocblas_idamin")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_
      type(c_ptr),value :: handle
      type(c_ptr),value :: myResult
    end function

  end interface
  
  interface rocblas_icamin
    function rocblas_icamin_(handle,n,x,incx,myResult) bind(c, name="rocblas_icamin")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_icamin_rank_0,&
      rocblas_icamin_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     amin finds the first index of the element of minimum magnitude of a vector x.
  !> 
  !>    vector
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the amin index.
  !>               return is 0.0 if n, incx<=0.
  interface rocblas_izamin
    function rocblas_izamin_(handle,n,x,incx,myResult) bind(c, name="rocblas_izamin")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_izamin_rank_0,&
      rocblas_izamin_rank_1
#endif
  end interface
  
  interface rocblas_isamin_batched
    function rocblas_isamin_batched_(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_isamin_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_isamin_batched_full_rank,&
      rocblas_isamin_batched_rank_0,&
      rocblas_isamin_batched_rank_1
#endif
  end interface
  
  interface rocblas_idamin_batched
    function rocblas_idamin_batched_(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_idamin_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_idamin_batched_full_rank,&
      rocblas_idamin_batched_rank_0,&
      rocblas_idamin_batched_rank_1
#endif
  end interface
  
  interface rocblas_icamin_batched
    function rocblas_icamin_batched_(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_icamin_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_icamin_batched_full_rank,&
      rocblas_icamin_batched_rank_0,&
      rocblas_icamin_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     amin_batched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch, must be > 0.
  !>     @param[out]
  !>     result
  !>               device or host pointers to array of batch_count size for results.
  !>               return is 0 if n, incx<=0.
  interface rocblas_izamin_batched
    function rocblas_izamin_batched_(handle,n,x,incx,batch_count,myResult) bind(c, name="rocblas_izamin_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_izamin_batched_full_rank,&
      rocblas_izamin_batched_rank_0,&
      rocblas_izamin_batched_rank_1
#endif
  end interface
  
  interface rocblas_isamin_strided_batched
    function rocblas_isamin_strided_batched_(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_isamin_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_isamin_strided_batched_rank_0,&
      rocblas_isamin_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_idamin_strided_batched
    function rocblas_idamin_strided_batched_(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_idamin_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_idamin_strided_batched_rank_0,&
      rocblas_idamin_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_icamin_strided_batched
    function rocblas_icamin_strided_batched_(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_icamin_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_icamin_strided_batched_rank_0,&
      rocblas_icamin_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      amin_strided_batched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               specifies the pointer increment between one x_i and the next x_(i + 1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device or host pointer to array for storing contiguous batch_count results.
  !>               return is 0 if n <= 0, incx<=0.
  !>
  interface rocblas_izamin_strided_batched
    function rocblas_izamin_strided_batched_(handle,n,x,incx,stridex,batch_count,myResult) bind(c, name="rocblas_izamin_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_izamin_strided_batched_rank_0,&
      rocblas_izamin_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_srot
    function rocblas_srot_(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_srot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_srot_rank_0,&
      rocblas_srot_rank_1
#endif
  end interface
  
  interface rocblas_drot
    function rocblas_drot_(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_drot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_drot_rank_0,&
      rocblas_drot_rank_1
#endif
  end interface
  
  interface rocblas_crot
    function rocblas_crot_(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_crot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_crot_rank_0,&
      rocblas_crot_rank_1
#endif
  end interface
  
  interface rocblas_csrot
    function rocblas_csrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_csrot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csrot_rank_0,&
      rocblas_csrot_rank_1
#endif
  end interface
  
  interface rocblas_zrot
    function rocblas_zrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_zrot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zrot_rank_0,&
      rocblas_zrot_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rot applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer storing vector x.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of x.
  !>     @param[inout]
  !>     y       device pointer storing vector y.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of y.
  !>     @param[in]
  !>     c       device pointer or host pointer storing scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer storing scalar sine component of the rotation matrix.
  !>
  interface rocblas_zdrot
    function rocblas_zdrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="rocblas_zdrot")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdrot_rank_0,&
      rocblas_zdrot_rank_1
#endif
  end interface
  
  interface rocblas_srot_batched
    function rocblas_srot_batched_(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_srot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_srot_batched_full_rank,&
      rocblas_srot_batched_rank_0,&
      rocblas_srot_batched_rank_1
#endif
  end interface
  
  interface rocblas_drot_batched
    function rocblas_drot_batched_(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_drot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_drot_batched_full_rank,&
      rocblas_drot_batched_rank_0,&
      rocblas_drot_batched_rank_1
#endif
  end interface
  
  interface rocblas_crot_batched
    function rocblas_crot_batched_(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_crot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_crot_batched_full_rank,&
      rocblas_crot_batched_rank_0,&
      rocblas_crot_batched_rank_1
#endif
  end interface
  
  interface rocblas_csrot_batched
    function rocblas_csrot_batched_(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_csrot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csrot_batched_full_rank,&
      rocblas_csrot_batched_rank_0,&
      rocblas_csrot_batched_rank_1
#endif
  end interface
  
  interface rocblas_zrot_batched
    function rocblas_zrot_batched_(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_zrot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zrot_batched_full_rank,&
      rocblas_zrot_batched_rank_0,&
      rocblas_zrot_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rot_batched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batch_count.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device array of deivce pointers storing each vector x_i.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[inout]
  !>     y       device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !>
  interface rocblas_zdrot_batched
    function rocblas_zdrot_batched_(handle,n,x,incx,y,incy,c,s,batch_count) bind(c, name="rocblas_zdrot_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdrot_batched_full_rank,&
      rocblas_zdrot_batched_rank_0,&
      rocblas_zdrot_batched_rank_1
#endif
  end interface
  
  interface rocblas_srot_strided_batched
    function rocblas_srot_strided_batched_(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_srot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_srot_strided_batched_rank_0,&
      rocblas_srot_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_drot_strided_batched
    function rocblas_drot_strided_batched_(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_drot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_drot_strided_batched_rank_0,&
      rocblas_drot_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_crot_strided_batched
    function rocblas_crot_strided_batched_(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_crot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_crot_strided_batched_rank_0,&
      rocblas_crot_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_csrot_strided_batched
    function rocblas_csrot_strided_batched_(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_csrot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csrot_strided_batched_rank_0,&
      rocblas_csrot_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_zrot_strided_batched
    function rocblas_zrot_strided_batched_(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_zrot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zrot_strided_batched_rank_0,&
      rocblas_zrot_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rot_strided_batched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batch_count.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[in]
  !>     stride_x [rocblas_stride]
  !>              specifies the increment from the beginning of x_i to the beginning of x_(i+1)
  !>     @param[inout]
  !>     y       device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     stride_y [rocblas_stride]
  !>              specifies the increment from the beginning of y_i to the beginning of y_(i+1)
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>             the number of x and y arrays, i.e. the number of batches.
  !>
  interface rocblas_zdrot_strided_batched
    function rocblas_zdrot_strided_batched_(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count) bind(c, name="rocblas_zdrot_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdrot_strided_batched_rank_0,&
      rocblas_zdrot_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_srotg
    function rocblas_srotg_(handle,a,b,c,s) bind(c, name="rocblas_srotg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

  end interface
  
  interface rocblas_drotg
    function rocblas_drotg_(handle,a,b,c,s) bind(c, name="rocblas_drotg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

  end interface
  
  interface rocblas_crotg
    function rocblas_crotg_(handle,a,b,c,s) bind(c, name="rocblas_crotg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotg creates the Givens rotation matrix for the vector (a b).
  !>          Scalars c and s and arrays a and b may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>          If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     a       device pointer or host pointer to input vector element, overwritten with r.
  !>     @param[inout]
  !>     b       device pointer or host pointer to input vector element, overwritten with z.
  !>     @param[inout]
  !>     c       device pointer or host pointer to cosine element of Givens rotation.
  !>     @param[inout]
  !>     s       device pointer or host pointer sine element of Givens rotation.
  !>
  interface rocblas_zrotg
    function rocblas_zrotg_(handle,a,b,c,s) bind(c, name="rocblas_zrotg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

  end interface
  
  interface rocblas_srotg_batched
    function rocblas_srotg_batched_(handle,a,b,c,s,batch_count) bind(c, name="rocblas_srotg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotg_batched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_drotg_batched
    function rocblas_drotg_batched_(handle,a,b,c,s,batch_count) bind(c, name="rocblas_drotg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotg_batched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_crotg_batched
    function rocblas_crotg_batched_(handle,a,b,c,s,batch_count) bind(c, name="rocblas_crotg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crotg_batched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batch_count
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotg_batched creates the Givens rotation matrix for the batched vectors (a_i b_i), for i = 1, ..., batch_count.
  !>          a, b, c, and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>          If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     a       device array of device pointers storing each single input vector element a_i, overwritten with r_i.
  !>     @param[inout]
  !>     b       device array of device pointers storing each single input vector element b_i, overwritten with z_i.
  !>     @param[inout]
  !>     c       device array of device pointers storing each cosine element of Givens rotation for the batch.
  !>     @param[inout]
  !>     s       device array of device pointers storing each sine element of Givens rotation for the batch.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of batches (length of arrays a, b, c, and s).
  !>
  interface rocblas_zrotg_batched
    function rocblas_zrotg_batched_(handle,a,b,c,s,batch_count) bind(c, name="rocblas_zrotg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrotg_batched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_srotg_strided_batched
    function rocblas_srotg_strided_batched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batch_count) bind(c, name="rocblas_srotg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotg_strided_batched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_drotg_strided_batched
    function rocblas_drotg_strided_batched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batch_count) bind(c, name="rocblas_drotg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotg_strided_batched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_crotg_strided_batched
    function rocblas_crotg_strided_batched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batch_count) bind(c, name="rocblas_crotg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crotg_strided_batched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batch_count
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotg_strided_batched creates the Givens rotation matrix for the strided batched vectors (a_i b_i), for i = 1, ..., batch_count.
  !>          a, b, c, and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>          If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     a       device strided_batched pointer or host strided_batched pointer to first single input vector element a_1, overwritten with r.
  !>     @param[in]
  !>     stride_a [rocblas_stride]
  !>              distance between elements of a in batch (distance between a_i and a_(i + 1))
  !>     @param[inout]
  !>     b       device strided_batched pointer or host strided_batched pointer to first single input vector element b_1, overwritten with z.
  !>     @param[in]
  !>     stride_b [rocblas_stride]
  !>              distance between elements of b in batch (distance between b_i and b_(i + 1))
  !>     @param[inout]
  !>     c       device strided_batched pointer or host strided_batched pointer to first cosine element of Givens rotations c_1.
  !>     @param[in]
  !>     stride_c [rocblas_stride]
  !>              distance between elements of c in batch (distance between c_i and c_(i + 1))
  !>     @param[inout]
  !>     s       device strided_batched pointer or host strided_batched pointer to sine element of Givens rotations s_1.
  !>     @param[in]
  !>     stride_s [rocblas_stride]
  !>              distance between elements of s in batch (distance between s_i and s_(i + 1))
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of batches (length of arrays a, b, c, and s).
  !>
  interface rocblas_zrotg_strided_batched
    function rocblas_zrotg_strided_batched_(handle,a,stride_a,b,stride_b,c,stride_c,s,stride_s,batch_count) bind(c, name="rocblas_zrotg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrotg_strided_batched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: s
      integer(c_int64_t),value :: stride_s
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_srotm
    function rocblas_srotm_(handle,n,x,incx,y,incy,param) bind(c, name="rocblas_srotm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_srotm_rank_0,&
      rocblas_srotm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotm applies the modified Givens rotation matrix defined by param to vectors x and y.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer storing vector x.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of x.
  !>     @param[inout]
  !>     y       device pointer storing vector y.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of y.
  !>     @param[in]
  !>     param   device vector or host vector of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>
  interface rocblas_drotm
    function rocblas_drotm_(handle,n,x,incx,y,incy,param) bind(c, name="rocblas_drotm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_drotm_rank_0,&
      rocblas_drotm_rank_1
#endif
  end interface
  
  interface rocblas_srotm_batched
    function rocblas_srotm_batched_(handle,n,x,incx,y,incy,param,batch_count) bind(c, name="rocblas_srotm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_srotm_batched_full_rank,&
      rocblas_srotm_batched_rank_0,&
      rocblas_srotm_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotm_batched applies the modified Givens rotation matrix defined by param_i to batched vectors x_i and y_i, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[inout]
  !>     y       device array of device pointers storing each vector y_1.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     param   device array of device vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may ONLY be stored on the device for the batched version of this function.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !>
  interface rocblas_drotm_batched
    function rocblas_drotm_batched_(handle,n,x,incx,y,incy,param,batch_count) bind(c, name="rocblas_drotm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_drotm_batched_full_rank,&
      rocblas_drotm_batched_rank_0,&
      rocblas_drotm_batched_rank_1
#endif
  end interface
  
  interface rocblas_srotm_strided_batched
    function rocblas_srotm_strided_batched_(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count) bind(c, name="rocblas_srotm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_srotm_strided_batched_rank_0,&
      rocblas_srotm_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotm_strided_batched applies the modified Givens rotation matrix defined by param_i to strided batched vectors x_i and y_i, for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer pointing to first strided batched vector x_1.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[in]
  !>     stride_x [rocblas_stride]
  !>              specifies the increment between the beginning of x_i and x_(i + 1)
  !>     @param[inout]
  !>     y       device pointer pointing to first strided batched vector y_1.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     stride_y [rocblas_stride]
  !>              specifies the increment between the beginning of y_i and y_(i + 1)
  !>     @param[in]
  !>     param   device pointer pointing to first array of 5 elements defining the rotation (param_1).
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may ONLY be stored on the device for the strided_batched version of this function.
  !>     @param[in]
  !>     stride_param [rocblas_stride]
  !>                  specifies the increment between the beginning of param_i and param_(i + 1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !>
  interface rocblas_drotm_strided_batched
    function rocblas_drotm_strided_batched_(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count) bind(c, name="rocblas_drotm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_drotm_strided_batched_rank_0,&
      rocblas_drotm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_srotmg
    function rocblas_srotmg_(handle,d1,d2,x1,y1,param) bind(c, name="rocblas_srotmg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotmg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      type(c_ptr),value :: d2
      type(c_ptr),value :: x1
      type(c_ptr),value :: y1
      type(c_ptr),value :: param
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmg creates the modified Givens rotation matrix for the vector (d1 * x1, d2 * y1).
  !>           Parameters may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>           If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     d1      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[inout]
  !>     d2      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[inout]
  !>     x1      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[in]
  !>     y1      device pointer or host pointer to input scalar.
  !>     @param[out]
  !>     param   device vector or host vector of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>
  interface rocblas_drotmg
    function rocblas_drotmg_(handle,d1,d2,x1,y1,param) bind(c, name="rocblas_drotmg")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotmg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      type(c_ptr),value :: d2
      type(c_ptr),value :: x1
      type(c_ptr),value :: y1
      type(c_ptr),value :: param
    end function

  end interface
  
  interface rocblas_srotmg_batched
    function rocblas_srotmg_batched_(handle,d1,d2,x1,y1,param,batch_count) bind(c, name="rocblas_srotmg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotmg_batched_
      type(c_ptr),value :: handle
      type(c_ptr) :: d1
      type(c_ptr) :: d2
      type(c_ptr) :: x1
      type(c_ptr) :: y1
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmg_batched creates the modified Givens rotation matrix for the batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batch_count.
  !>           Parameters may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>           If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     d1      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[inout]
  !>     d2      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[inout]
  !>     x1      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     y1      device batched array or host batched array of input scalars.
  !>     @param[out]
  !>     param   device batched array or host batched array of vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of instances in the batch.
  !>
  interface rocblas_drotmg_batched
    function rocblas_drotmg_batched_(handle,d1,d2,x1,y1,param,batch_count) bind(c, name="rocblas_drotmg_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotmg_batched_
      type(c_ptr),value :: handle
      type(c_ptr) :: d1
      type(c_ptr) :: d2
      type(c_ptr) :: x1
      type(c_ptr) :: y1
      type(c_ptr) :: param
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_srotmg_strided_batched
    function rocblas_srotmg_strided_batched_(handle,d1,stride_d1,d2,stride_d2,x1,stride_x1,y1,stride_y1,param,stride_param,batch_count) bind(c, name="rocblas_srotmg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotmg_strided_batched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      integer(c_int64_t),value :: stride_d1
      type(c_ptr),value :: d2
      integer(c_int64_t),value :: stride_d2
      type(c_ptr),value :: x1
      integer(c_int64_t),value :: stride_x1
      type(c_ptr),value :: y1
      integer(c_int64_t),value :: stride_y1
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmg_strided_batched creates the modified Givens rotation matrix for the strided batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batch_count.
  !>           Parameters may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>           If the pointer mode is set to rocblas_pointer_mode_host, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to rocblas_pointer_mode_device, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[inout]
  !>     d1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     stride_d1 [rocblas_stride]
  !>               specifies the increment between the beginning of d1_i and d1_(i+1)
  !>     @param[inout]
  !>     d2      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     stride_d2 [rocblas_stride]
  !>               specifies the increment between the beginning of d2_i and d2_(i+1)
  !>     @param[inout]
  !>     x1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     stride_x1 [rocblas_stride]
  !>               specifies the increment between the beginning of x1_i and x1_(i+1)
  !>     @param[in]
  !>     y1      device strided_batched array or host strided_batched array of input scalars.
  !>     @param[in]
  !>     stride_y1 [rocblas_stride]
  !>               specifies the increment between the beginning of y1_i and y1_(i+1)
  !>     @param[out]
  !>     param   device strided_batched array or host strided_batched array of vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !>     @param[in]
  !>     stride_param [rocblas_stride]
  !>                  specifies the increment between the beginning of param_i and param_(i + 1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of instances in the batch.
  !>
  interface rocblas_drotmg_strided_batched
    function rocblas_drotmg_strided_batched_(handle,d1,stride_d1,d2,stride_d2,x1,stride_x1,y1,stride_y1,param,stride_param,batch_count) bind(c, name="rocblas_drotmg_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotmg_strided_batched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      integer(c_int64_t),value :: stride_d1
      type(c_ptr),value :: d2
      integer(c_int64_t),value :: stride_d2
      type(c_ptr),value :: x1
      integer(c_int64_t),value :: stride_x1
      type(c_ptr),value :: y1
      integer(c_int64_t),value :: stride_y1
      type(c_ptr),value :: param
      integer(c_int64_t),value :: stride_param
      integer(c_int),value :: batch_count
    end function

  end interface
  !>  ===========================================================================
  !>     level 2 BLAS
  !>  ===========================================================================
  interface rocblas_sgbmv
    function rocblas_sgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_sgbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgbmv_full_rank,&
      rocblas_sgbmv_rank_0,&
      rocblas_sgbmv_rank_1
#endif
  end interface
  
  interface rocblas_dgbmv
    function rocblas_dgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_dgbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgbmv_full_rank,&
      rocblas_dgbmv_rank_0,&
      rocblas_dgbmv_rank_1
#endif
  end interface
  
  interface rocblas_cgbmv
    function rocblas_cgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_cgbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgbmv_full_rank,&
      rocblas_cgbmv_rank_0,&
      rocblas_cgbmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gbmv performs one of the matrix-vector operations
  !> 
  !>         y := alpha*A*x    + beta*y,   or
  !>         y := alpha*A**T*x + beta*y,   or
  !>         y := alpha*A**H*x + beta*y,
  !> 
  !>     where alpha and beta are scalars, x and y are vectors and A is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     kl        [rocblas_int]
  !>               number of sub-diagonals of A
  !>     @param[in]
  !>     ku        [rocblas_int]
  !>               number of super-diagonals of A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         A     device pointer storing banded matrix A.
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propogates up and down across
  !>               sub/super-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>
  interface rocblas_zgbmv
    function rocblas_zgbmv_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_zgbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgbmv_full_rank,&
      rocblas_zgbmv_rank_0,&
      rocblas_zgbmv_rank_1
#endif
  end interface
  
  interface rocblas_sgbmv_batched
    function rocblas_sgbmv_batched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_sgbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgbmv_batched_full_rank,&
      rocblas_sgbmv_batched_rank_0,&
      rocblas_sgbmv_batched_rank_1
#endif
  end interface
  
  interface rocblas_dgbmv_batched
    function rocblas_dgbmv_batched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_dgbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgbmv_batched_full_rank,&
      rocblas_dgbmv_batched_rank_0,&
      rocblas_dgbmv_batched_rank_1
#endif
  end interface
  
  interface rocblas_cgbmv_batched
    function rocblas_cgbmv_batched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_cgbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgbmv_batched_full_rank,&
      rocblas_cgbmv_batched_rank_0,&
      rocblas_cgbmv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gbmv_batched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i    + beta*y_i,   or
  !>         y_i := alpha*A_i**T*x_i + beta*y_i,   or
  !>         y_i := alpha*A_i**H*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals,
  !>     for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               number of rows of each matrix A_i
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of columns of each matrix A_i
  !>     @param[in]
  !>     kl        [rocblas_int]
  !>               number of sub-diagonals of each A_i
  !>     @param[in]
  !>     ku        [rocblas_int]
  !>               number of super-diagonals of each A_i
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         A     device array of device pointers storing each banded matrix A_i.
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propogates up and down across
  !>               sub/super-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of instances in the batch.
  !>
  interface rocblas_zgbmv_batched
    function rocblas_zgbmv_batched_(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zgbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgbmv_batched_full_rank,&
      rocblas_zgbmv_batched_rank_0,&
      rocblas_zgbmv_batched_rank_1
#endif
  end interface
  
  interface rocblas_sgbmv_strided_batched
    function rocblas_sgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_sgbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgbmv_strided_batched_full_rank,&
      rocblas_sgbmv_strided_batched_rank_0,&
      rocblas_sgbmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dgbmv_strided_batched
    function rocblas_dgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_dgbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgbmv_strided_batched_full_rank,&
      rocblas_dgbmv_strided_batched_rank_0,&
      rocblas_dgbmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cgbmv_strided_batched
    function rocblas_cgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_cgbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgbmv_strided_batched_full_rank,&
      rocblas_cgbmv_strided_batched_rank_0,&
      rocblas_cgbmv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gbmv_strided_batched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i    + beta*y_i,   or
  !>         y_i := alpha*A_i**T*x_i + beta*y_i,   or
  !>         y_i := alpha*A_i**H*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals,
  !>     for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     kl        [rocblas_int]
  !>               number of sub-diagonals of A
  !>     @param[in]
  !>     ku        [rocblas_int]
  !>               number of super-diagonals of A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         A     device pointer to first banded matrix (A_1).
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propogates up and down across
  !>               sub/super-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         device pointer to first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer to first vector (y_1).
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (x_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of instances in the batch.
  !>
  interface rocblas_zgbmv_strided_batched
    function rocblas_zgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_zgbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgbmv_strided_batched_full_rank,&
      rocblas_zgbmv_strided_batched_rank_0,&
      rocblas_zgbmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sgemv
    function rocblas_sgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_sgemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgemv_full_rank,&
      rocblas_sgemv_rank_0,&
      rocblas_sgemv_rank_1
#endif
  end interface
  
  interface rocblas_dgemv
    function rocblas_dgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_dgemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgemv_full_rank,&
      rocblas_dgemv_rank_0,&
      rocblas_dgemv_rank_1
#endif
  end interface
  
  interface rocblas_cgemv
    function rocblas_cgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_cgemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgemv_full_rank,&
      rocblas_cgemv_rank_0,&
      rocblas_cgemv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gemv performs one of the matrix-vector operations
  !> 
  !>         y := alpha*A*x    + beta*y,   or
  !>         y := alpha*A**T*x + beta*y,   or
  !>         y := alpha*A**H*x + beta*y,
  !> 
  !>     where alpha and beta are scalars, x and y are vectors and A is an
  !>     m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>
  interface rocblas_zgemv
    function rocblas_zgemv_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_zgemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgemv_full_rank,&
      rocblas_zgemv_rank_0,&
      rocblas_zgemv_rank_1
#endif
  end interface
  
  interface rocblas_sgemv_batched
    function rocblas_sgemv_batched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_sgemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgemv_batched_full_rank,&
      rocblas_sgemv_batched_rank_0,&
      rocblas_sgemv_batched_rank_1
#endif
  end interface
  
  interface rocblas_dgemv_batched
    function rocblas_dgemv_batched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_dgemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgemv_batched_full_rank,&
      rocblas_dgemv_batched_rank_0,&
      rocblas_dgemv_batched_rank_1
#endif
  end interface
  
  interface rocblas_cgemv_batched
    function rocblas_cgemv_batched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_cgemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgemv_batched_full_rank,&
      rocblas_cgemv_batched_rank_0,&
      rocblas_cgemv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gemv_batched performs a batch of matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i    + beta*y_i,   or
  !>         y_i := alpha*A_i**T*x_i + beta*y_i,   or
  !>         y_i := alpha*A_i**H*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle      [rocblas_handle]
  !>                 handle to the rocblas library context queue.
  !>     @param[in]
  !>     trans       [rocblas_operation]
  !>                 indicates whether matrices A_i are tranposed (conjugated) or not
  !>     @param[in]
  !>     m           [rocblas_int]
  !>                 number of rows of each matrix A_i
  !>     @param[in]
  !>     n           [rocblas_int]
  !>                 number of columns of each matrix A_i
  !>     @param[in]
  !>     alpha       device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A           device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda         [rocblas_int]
  !>                 specifies the leading dimension of each matrix A_i.
  !>     @param[in]
  !>     x           device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx        [rocblas_int]
  !>                 specifies the increment for the elements of each vector x_i.
  !>     @param[in]
  !>     beta        device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y           device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy        [rocblas_int]
  !>                 specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zgemv_batched
    function rocblas_zgemv_batched_(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zgemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgemv_batched_full_rank,&
      rocblas_zgemv_batched_rank_0,&
      rocblas_zgemv_batched_rank_1
#endif
  end interface
  
  interface rocblas_sgemv_strided_batched
    function rocblas_sgemv_strided_batched_(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_sgemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgemv_strided_batched_full_rank,&
      rocblas_sgemv_strided_batched_rank_0,&
      rocblas_sgemv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dgemv_strided_batched
    function rocblas_dgemv_strided_batched_(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_dgemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgemv_strided_batched_full_rank,&
      rocblas_dgemv_strided_batched_rank_0,&
      rocblas_dgemv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cgemv_strided_batched
    function rocblas_cgemv_strided_batched_(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_cgemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgemv_strided_batched_full_rank,&
      rocblas_cgemv_strided_batched_rank_0,&
      rocblas_cgemv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gemv_strided_batched performs a batch of matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i    + beta*y_i,   or
  !>         y_i := alpha*A_i**T*x_i + beta*y_i,   or
  !>         y_i := alpha*A_i**H*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle      [rocblas_handle]
  !>                 handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA      [rocblas_operation]
  !>                 indicates whether matrices A_i are tranposed (conjugated) or not
  !>     @param[in]
  !>     m           [rocblas_int]
  !>                 number of rows of matrices A_i
  !>     @param[in]
  !>     n           [rocblas_int]
  !>                 number of columns of matrices A_i
  !>     @param[in]
  !>     alpha       device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A           device pointer to the first matrix (A_1) in the batch.
  !>     @param[in]
  !>     lda         [rocblas_int]
  !>                 specifies the leading dimension of matrices A_i.
  !>     @param[in]
  !>     strideA     [rocblas_stride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x           device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx        [rocblas_int]
  !>                 specifies the increment for the elements of vectors x_i.
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stride_x is of appropriate size. When trans equals rocblas_operation_none
  !>                 this typically means stride_x >= n * incx, otherwise stride_x >= m * incx.
  !>     @param[in]
  !>     beta        device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y           device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy        [rocblas_int]
  !>                 specifies the increment for the elements of vectors y_i.
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stride_y, however the user should
  !>                 take care to ensure that stride_y is of appropriate size. When trans equals rocblas_operation_none
  !>                 this typically means stride_y >= m * incy, otherwise stride_y >= n * incy. stridey should be non zero.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zgemv_strided_batched
    function rocblas_zgemv_strided_batched_(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_zgemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgemv_strided_batched_full_rank,&
      rocblas_zgemv_strided_batched_rank_0,&
      rocblas_zgemv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_chbmv
    function rocblas_chbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_chbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chbmv_full_rank,&
      rocblas_chbmv_rank_0,&
      rocblas_chbmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hbmv performs the matrix-vector operations
  !> 
  !>         y := alpha*A*x + beta*y
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian band matrix, with k super-diagonals.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: The upper triangular part of A is being supplied.
  !>               rocblas_fill_lower: The lower triangular part of A is being supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of the matrix A.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               the number of super-diagonals of the matrix A. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A. Of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The leading (k + 1) by n part of A must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of A will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == rocblas_fill_lower:
  !>                 The leading (k + 1) by n part of A must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of A will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of A will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. must be >= k + 1
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>
  interface rocblas_zhbmv
    function rocblas_zhbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_zhbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhbmv_full_rank,&
      rocblas_zhbmv_rank_0,&
      rocblas_zhbmv_rank_1
#endif
  end interface
  
  interface rocblas_chbmv_batched
    function rocblas_chbmv_batched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_chbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chbmv_batched_full_rank,&
      rocblas_chbmv_batched_rank_0,&
      rocblas_chbmv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hbmv_batched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: The upper triangular part of each A_i is being supplied.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is being supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               the number of super-diagonals of each matrix A_i. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix_i A of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The leading (k + 1) by n part of each A_i must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of each A_i will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == rocblas_fill_lower:
  !>                 The leading (k + 1) by n part of each A_i must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of each A_i will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zhbmv_batched
    function rocblas_zhbmv_batched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zhbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhbmv_batched_full_rank,&
      rocblas_zhbmv_batched_rank_0,&
      rocblas_zhbmv_batched_rank_1
#endif
  end interface
  
  interface rocblas_chbmv_strided_batched
    function rocblas_chbmv_strided_batched_(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_chbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chbmv_strided_batched_full_rank,&
      rocblas_chbmv_strided_batched_rank_0,&
      rocblas_chbmv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hbmv_strided_batched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: The upper triangular part of each A_i is being supplied.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is being supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               the number of super-diagonals of each matrix A_i. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array pointing to the first matrix A_1. Each A_i is of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The leading (k + 1) by n part of each A_i must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of each A_i will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == rocblas_fill_lower:
  !>                 The leading (k + 1) by n part of each A_i must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of each A_i will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         device array pointing to the first vector y_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array pointing to the first vector y_1.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zhbmv_strided_batched
    function rocblas_zhbmv_strided_batched_(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_zhbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhbmv_strided_batched_full_rank,&
      rocblas_zhbmv_strided_batched_rank_0,&
      rocblas_zhbmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_chemv
    function rocblas_chemv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_chemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chemv_full_rank,&
      rocblas_chemv_rank_0,&
      rocblas_chemv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hemv performs one of the matrix-vector operations
  !> 
  !>         y := alpha*A*x + beta*y
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.
  !>               rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of the matrix A.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A. Of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular part of A must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of A will not be referenced.
  !>               if uplo == rocblas_fill_lower:
  !>                 The lower triangular part of A must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of A will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of A will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. must be >= max(1, n)
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>
  interface rocblas_zhemv
    function rocblas_zhemv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_zhemv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhemv_full_rank,&
      rocblas_zhemv_rank_0,&
      rocblas_zhemv_rank_1
#endif
  end interface
  
  interface rocblas_chemv_batched
    function rocblas_chemv_batched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_chemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chemv_batched_full_rank,&
      rocblas_chemv_batched_rank_0,&
      rocblas_chemv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hemv_batched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.
  !>               rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular part of each A_i must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of each A_i will not be referenced.
  !>               if uplo == rocblas_fill_lower:
  !>                 The lower triangular part of each A_i must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of each A_i will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zhemv_batched
    function rocblas_zhemv_batched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zhemv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhemv_batched_full_rank,&
      rocblas_zhemv_batched_rank_0,&
      rocblas_zhemv_batched_rank_1
#endif
  end interface
  
  interface rocblas_chemv_strided_batched
    function rocblas_chemv_strided_batched_(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_chemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chemv_strided_batched_full_rank,&
      rocblas_chemv_strided_batched_rank_0,&
      rocblas_chemv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hemv_strided_batched performs one of the matrix-vector operations
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.
  !>               rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i of dimension (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular part of each A_i must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of each A_i will not be referenced.
  !>               if uplo == rocblas_fill_lower:
  !>                 The lower triangular part of each A_i must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of each A_i will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) to the next (A_i+1)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zhemv_strided_batched
    function rocblas_zhemv_strided_batched_(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_zhemv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhemv_strided_batched_full_rank,&
      rocblas_zhemv_strided_batched_rank_0,&
      rocblas_zhemv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cher
    function rocblas_cher_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_cher")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cher_full_rank,&
      rocblas_cher_rank_0,&
      rocblas_cher_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*x**H
  !> 
  !>     where alpha is a real scalar, x is a vector, and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied in A.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied in A.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     A         device pointer storing the specified triangular portion of
  !>               the Hermitian matrix A. Of size (lda * n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied. The lower
  !>                 triangluar portion will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied. The upper
  !>                 triangular portion will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. Must be at least max(1, n).
  interface rocblas_zher
    function rocblas_zher_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_zher")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zher_full_rank,&
      rocblas_zher_rank_0,&
      rocblas_zher_rank_1
#endif
  end interface
  
  interface rocblas_cher_batched
    function rocblas_cher_batched_(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_cher_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cher_batched_full_rank,&
      rocblas_cher_batched_rank_0,&
      rocblas_cher_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**H
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in A.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in A.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n * (n + 1)) 2). Array is of at least size batch_count.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular portion
  !>                 of each A_i will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular portion
  !>                 of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. Must be at least max(1, n).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_zher_batched
    function rocblas_zher_batched_(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_zher_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zher_batched_full_rank,&
      rocblas_zher_batched_rank_0,&
      rocblas_zher_batched_rank_1
#endif
  end interface
  
  interface rocblas_cher_strided_batched
    function rocblas_cher_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count) bind(c, name="rocblas_cher_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cher_strided_batched_full_rank,&
      rocblas_cher_strided_batched_rank_0,&
      rocblas_cher_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her_strided_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**H
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n Hermitian matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in A.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in A.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     A         device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_zher_strided_batched
    function rocblas_zher_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count) bind(c, name="rocblas_zher_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zher_strided_batched_full_rank,&
      rocblas_zher_strided_batched_rank_0,&
      rocblas_zher_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cher2
    function rocblas_cher2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_cher2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cher2_full_rank,&
      rocblas_cher2_rank_0,&
      rocblas_cher2_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her2 performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*y**H + conj(alpha)*y*x**H
  !> 
  !>     where alpha is a complex scalar, x and y are vectors, and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     A         device pointer storing the specified triangular portion of
  !>               the Hermitian matrix A. Of size (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied. The lower triangular
  !>                 portion of A will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied. The upper triangular
  !>                 portion of A will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. Must be at least max(lda, 1).
  interface rocblas_zher2
    function rocblas_zher2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_zher2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zher2_full_rank,&
      rocblas_zher2_rank_0,&
      rocblas_zher2_rank_1
#endif
  end interface
  
  interface rocblas_cher2_batched
    function rocblas_cher2_batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_cher2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cher2_batched_full_rank,&
      rocblas_cher2_batched_rank_0,&
      rocblas_cher2_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her2_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n Hermitian matrix for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i of size (lda, n).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. Must be at least max(lda, 1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_zher2_batched
    function rocblas_zher2_batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_zher2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zher2_batched_full_rank,&
      rocblas_zher2_batched_rank_0,&
      rocblas_zher2_batched_rank_1
#endif
  end interface
  
  interface rocblas_cher2_strided_batched
    function rocblas_cher2_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count) bind(c, name="rocblas_cher2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cher2_strided_batched_full_rank,&
      rocblas_cher2_strided_batched_rank_0,&
      rocblas_cher2_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her2_strided_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n Hermitian matrix for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               specifies the stride between the beginning of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               specifies the stride between the beginning of one vector (y_i) and the next (y_i+1).
  !>     @param[inout]
  !>     A         device pointer pointing to the first matrix (A_1). Stores the specified triangular portion of
  !>               each Hermitian matrix A_i.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. Must be at least max(lda, 1).
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               specifies the stride between the beginning of one matrix (A_i) and the next (A_i+1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_zher2_strided_batched
    function rocblas_zher2_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count) bind(c, name="rocblas_zher2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zher2_strided_batched_full_rank,&
      rocblas_zher2_strided_batched_rank_0,&
      rocblas_zher2_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_chpmv
    function rocblas_chpmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="rocblas_chpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chpmv_rank_0,&
      rocblas_chpmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpmv performs the matrix-vector operation
  !> 
  !>         y := alpha*A*x + beta*y
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below).
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied in AP.
  !>               rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of the matrix A, must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n * (n + 1)) 2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>
  interface rocblas_zhpmv
    function rocblas_zhpmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="rocblas_zhpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhpmv_rank_0,&
      rocblas_zhpmv_rank_1
#endif
  end interface
  
  interface rocblas_chpmv_batched
    function rocblas_chpmv_batched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_chpmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chpmv_batched_full_rank,&
      rocblas_chpmv_batched_rank_0,&
      rocblas_chpmv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpmv_batched performs the matrix-vector operation
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below),
  !>     for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
  !>               rocblas_fill_lower: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP      device pointer of device pointers storing the packed version of the specified triangular
  !>             portion of each Hermitian matrix A_i. Each A_i is of at least size ((n * (n + 1)) 2).
  !>             if uplo == rocblas_fill_upper:
  !>             The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>             The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>             so that:
  !>             AP(0) = A(0,0)
  !>             AP(1) = A(0,1)
  !>             AP(2) = A(1,1), etc.
  !>                 Ex: (rocblas_fill_upper; n = 3)
  !>                     (1, 0) (2, 1) (3, 2)
  !>                     (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                     (3,-2) (5, 1) (6, 0)
  !>         if uplo == rocblas_fill_lower:
  !>             The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>             The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>             so that:
  !>             AP(0) = A(0,0)
  !>             AP(1) = A(1,0)
  !>             AP(2) = A(2,1), etc.
  !>                 Ex: (rocblas_fill_lower; n = 3)
  !>                     (1, 0) (2, 1) (3, 2)
  !>                     (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                     (3,-2) (5, 1) (6, 0)
  !>         Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>         to be 0.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zhpmv_batched
    function rocblas_zhpmv_batched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zhpmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhpmv_batched_full_rank,&
      rocblas_zhpmv_batched_rank_0,&
      rocblas_zhpmv_batched_rank_1
#endif
  end interface
  
  interface rocblas_chpmv_strided_batched
    function rocblas_chpmv_strided_batched_(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_chpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chpmv_strided_batched_rank_0,&
      rocblas_chpmv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpmv_strided_batched performs the matrix-vector operation
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below),
  !>     for each batch in i = [1, batch_count].
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
  !>               rocblas_fill_lower: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer pointing to the beginning of the first matrix (AP_1). Stores the packed
  !>               version of the specified triangular portion of each Hermitian matrix AP_i of size ((n * (n + 1)) 2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>         Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>         to be 0.
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (AP_i) and the next one (AP_i+1).
  !>     @param[in]
  !>     x         device array pointing to the beginning of the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array pointing to the beginning of the first vector (y_1).
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zhpmv_strided_batched
    function rocblas_zhpmv_strided_batched_(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count) bind(c, name="rocblas_zhpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhpmv_strided_batched_rank_0,&
      rocblas_zhpmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_chpr
    function rocblas_chpr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_chpr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chpr_rank_0,&
      rocblas_chpr_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*x**H
  !> 
  !>     where alpha is a real scalar, x is a vector, and A is an
  !>     n by n Hermitian matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n * (n + 1)) 2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  interface rocblas_zhpr
    function rocblas_zhpr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_zhpr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhpr_rank_0,&
      rocblas_zhpr_rank_1
#endif
  end interface
  
  interface rocblas_chpr_batched
    function rocblas_chpr_batched_(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_chpr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chpr_batched_full_rank,&
      rocblas_chpr_batched_rank_0,&
      rocblas_chpr_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**H
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n * (n + 1)) 2). Array is of at least size batch_count.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_zhpr_batched
    function rocblas_zhpr_batched_(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_zhpr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhpr_batched_full_rank,&
      rocblas_zhpr_batched_rank_0,&
      rocblas_zhpr_batched_rank_1
#endif
  end interface
  
  interface rocblas_chpr_strided_batched
    function rocblas_chpr_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_chpr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chpr_strided_batched_rank_0,&
      rocblas_chpr_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr_strided_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**H
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_zhpr_strided_batched
    function rocblas_zhpr_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_zhpr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhpr_strided_batched_rank_0,&
      rocblas_zhpr_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_chpr2
    function rocblas_chpr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="rocblas_chpr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chpr2_rank_0,&
      rocblas_chpr2_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr2 performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*y**H + conj(alpha)*y*x**H
  !> 
  !>     where alpha is a complex scalar, x and y are vectors, and A is an
  !>     n by n Hermitian matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n * (n + 1)) 2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  interface rocblas_zhpr2
    function rocblas_zhpr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="rocblas_zhpr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhpr2_rank_0,&
      rocblas_zhpr2_rank_1
#endif
  end interface
  
  interface rocblas_chpr2_batched
    function rocblas_chpr2_batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count) bind(c, name="rocblas_chpr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chpr2_batched_full_rank,&
      rocblas_chpr2_batched_rank_0,&
      rocblas_chpr2_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr2_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n * (n + 1)) 2). Array is of at least size batch_count.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_zhpr2_batched
    function rocblas_zhpr2_batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count) bind(c, name="rocblas_zhpr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhpr2_batched_full_rank,&
      rocblas_zhpr2_batched_rank_0,&
      rocblas_zhpr2_batched_rank_1
#endif
  end interface
  
  interface rocblas_chpr2_strided_batched
    function rocblas_chpr2_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count) bind(c, name="rocblas_chpr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chpr2_strided_batched_rank_0,&
      rocblas_chpr2_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr2_strided_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector (y_1).
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_zhpr2_strided_batched
    function rocblas_zhpr2_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count) bind(c, name="rocblas_zhpr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhpr2_strided_batched_rank_0,&
      rocblas_zhpr2_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_strmv
    function rocblas_strmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_strmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strmv_full_rank,&
      rocblas_strmv_rank_0,&
      rocblas_strmv_rank_1
#endif
  end interface
  
  interface rocblas_dtrmv
    function rocblas_dtrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_dtrmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrmv_full_rank,&
      rocblas_dtrmv_rank_0,&
      rocblas_dtrmv_rank_1
#endif
  end interface
  
  interface rocblas_ctrmv
    function rocblas_ctrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_ctrmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrmv_full_rank,&
      rocblas_ctrmv_rank_0,&
      rocblas_ctrmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trmv performs one of the matrix-vector operations
  !> 
  !>          x = A*x or x = A**T*x,
  !> 
  !>     where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.
  !> 
  !>     The vector x is overwritten.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of A. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing matrix A,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>               lda = max( 1, m ).
  !> 
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>
  interface rocblas_ztrmv
    function rocblas_ztrmv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_ztrmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrmv_full_rank,&
      rocblas_ztrmv_rank_0,&
      rocblas_ztrmv_rank_1
#endif
  end interface
  
  interface rocblas_strmv_strided_batched
    function rocblas_strmv_strided_batched_(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_strmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strmv_strided_batched_full_rank,&
      rocblas_strmv_strided_batched_rank_0,&
      rocblas_strmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtrmv_strided_batched
    function rocblas_dtrmv_strided_batched_(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_dtrmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrmv_strided_batched_full_rank,&
      rocblas_dtrmv_strided_batched_rank_0,&
      rocblas_dtrmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctrmv_strided_batched
    function rocblas_ctrmv_strided_batched_(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_ctrmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrmv_strided_batched_full_rank,&
      rocblas_ctrmv_strided_batched_rank_0,&
      rocblas_ctrmv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trmv_strided_batched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batch_count
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !>     with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of matrices A_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer of the matrix A_0,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A_i.
  !>               lda >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     stride_a  [rocblas_stride]
  !>               stride from the start of one A_i matrix to the next A_{i + 1}
  !> 
  !>     @param[in]
  !>     x         device pointer storing the vector x_0.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of one vector x.
  !> 
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one x_i vector to the next x_{i + 1}
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               The number of batched matrices/vectors.
  !> 
  !>
  interface rocblas_ztrmv_strided_batched
    function rocblas_ztrmv_strided_batched_(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_ztrmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrmv_strided_batched_full_rank,&
      rocblas_ztrmv_strided_batched_rank_0,&
      rocblas_ztrmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_stpmv
    function rocblas_stpmv_(handle,uplo,transA,diag,m,A,x,incx) bind(c, name="rocblas_stpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stpmv_full_rank,&
      rocblas_stpmv_rank_0,&
      rocblas_stpmv_rank_1
#endif
  end interface
  
  interface rocblas_dtpmv
    function rocblas_dtpmv_(handle,uplo,transA,diag,m,A,x,incx) bind(c, name="rocblas_dtpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtpmv_full_rank,&
      rocblas_dtpmv_rank_0,&
      rocblas_dtpmv_rank_1
#endif
  end interface
  
  interface rocblas_ctpmv
    function rocblas_ctpmv_(handle,uplo,transA,diag,m,A,x,incx) bind(c, name="rocblas_ctpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctpmv_full_rank,&
      rocblas_ctpmv_rank_0,&
      rocblas_ctpmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpmv performs one of the matrix-vector operations
  !> 
  !>          x = A*x or x = A**T*x,
  !> 
  !>     where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix, supplied in the pack form.
  !> 
  !>     The vector x is overwritten.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of A. m >= 0.
  !> 
  !>     @param[in]
  !>     A       device pointer storing matrix A,
  !>             of dimension at leat ( m * ( m + 1 ) 2 ).
  !>           Before entry with uplo = rocblas_fill_upper, the array A
  !>           must contain the upper triangular matrix packed sequentially,
  !>           column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
  !>           a_{0,1} and a_{1, 1} respectively, and so on.
  !>           Before entry with uplo = rocblas_fill_lower, the array A
  !>           must contain the lower triangular matrix packed sequentially,
  !>           column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
  !>           a_{1,0} and a_{2,0} respectively, and so on.
  !>           Note that when DIAG = rocblas_diagonal_unit, the diagonal elements of A are
  !>           not referenced, but are assumed to be unity.
  !> 
  !>     @param[in]
  !>     x       device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment for the elements of x. incx must not be zero.
  !>
  interface rocblas_ztpmv
    function rocblas_ztpmv_(handle,uplo,transA,diag,m,A,x,incx) bind(c, name="rocblas_ztpmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztpmv_full_rank,&
      rocblas_ztpmv_rank_0,&
      rocblas_ztpmv_rank_1
#endif
  end interface
  
  interface rocblas_stpmv_strided_batched
    function rocblas_stpmv_strided_batched_(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_stpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stpmv_strided_batched_full_rank,&
      rocblas_stpmv_strided_batched_rank_0,&
      rocblas_stpmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtpmv_strided_batched
    function rocblas_dtpmv_strided_batched_(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_dtpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtpmv_strided_batched_full_rank,&
      rocblas_dtpmv_strided_batched_rank_0,&
      rocblas_dtpmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctpmv_strided_batched
    function rocblas_ctpmv_strided_batched_(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_ctpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctpmv_strided_batched_full_rank,&
      rocblas_ctpmv_strided_batched_rank_0,&
      rocblas_ctpmv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpmv_strided_batched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batch_count
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !>     with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of matrices A_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer of the matrix A_0,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     stride_a  [rocblas_stride]
  !>               stride from the start of one A_i matrix to the next A_{i + 1}
  !> 
  !>     @param[in]
  !>     x         device pointer storing the vector x_0.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of one vector x.
  !> 
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one x_i vector to the next x_{i + 1}
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               The number of batched matrices/vectors.
  !> 
  !>
  interface rocblas_ztpmv_strided_batched
    function rocblas_ztpmv_strided_batched_(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count) bind(c, name="rocblas_ztpmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztpmv_strided_batched_full_rank,&
      rocblas_ztpmv_strided_batched_rank_0,&
      rocblas_ztpmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_stbmv
    function rocblas_stbmv_(handle,uplo,trans,diag,m,k,A,lda,x,incx) bind(c, name="rocblas_stbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stbmv_full_rank,&
      rocblas_stbmv_rank_0,&
      rocblas_stbmv_rank_1
#endif
  end interface
  
  interface rocblas_dtbmv
    function rocblas_dtbmv_(handle,uplo,trans,diag,m,k,A,lda,x,incx) bind(c, name="rocblas_dtbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtbmv_full_rank,&
      rocblas_dtbmv_rank_0,&
      rocblas_dtbmv_rank_1
#endif
  end interface
  
  interface rocblas_ctbmv
    function rocblas_ctbmv_(handle,uplo,trans,diag,m,k,A,lda,x,incx) bind(c, name="rocblas_ctbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctbmv_full_rank,&
      rocblas_ctbmv_rank_0,&
      rocblas_ctbmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbmv performs one of the matrix-vector operations
  !> 
  !>         x := A*x      or
  !>         x := A**T*x   or
  !>         x := A**H*x,
  !> 
  !>     x is a vectors and A is a banded m by m matrix (see description below).
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: A is an upper banded triangular matrix.
  !>               rocblas_fill_lower: A is a  lower banded triangular matrix.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether matrix A is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               rocblas_diagonal_unit: The main diagonal of A is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               rocblas_diagonal_non_unit: No assumptions are made of A's main diagonal.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows and columns of the matrix represented by A.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if uplo == rocblas_fill_upper, k specifies the number of super-diagonals
  !>               of the matrix A.
  !>               if uplo == rocblas_fill_lower, k specifies the number of sub-diagonals
  !>               of the matrix A.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     A         device pointer storing banded triangular matrix A.
  !>               if uplo == rocblas_fill_upper:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (rocblas_fill_upper; m = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == rocblas_fill_lower:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (rocblas_fill_lower; m = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A. lda must satisfy lda > k.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>
  interface rocblas_ztbmv
    function rocblas_ztbmv_(handle,uplo,trans,diag,m,k,A,lda,x,incx) bind(c, name="rocblas_ztbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztbmv_full_rank,&
      rocblas_ztbmv_rank_0,&
      rocblas_ztbmv_rank_1
#endif
  end interface
  
  interface rocblas_stbmv_batched
    function rocblas_stbmv_batched_(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_stbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stbmv_batched_full_rank,&
      rocblas_stbmv_batched_rank_0,&
      rocblas_stbmv_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtbmv_batched
    function rocblas_dtbmv_batched_(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_dtbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtbmv_batched_full_rank,&
      rocblas_dtbmv_batched_rank_0,&
      rocblas_dtbmv_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctbmv_batched
    function rocblas_ctbmv_batched_(handle,uplo,trans,diag,m,k,A,da,x,incx,batch_count) bind(c, name="rocblas_ctbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: da
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctbmv_batched_full_rank,&
      rocblas_ctbmv_batched_rank_0,&
      rocblas_ctbmv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbmv_batched performs one of the matrix-vector operations
  !> 
  !>         x_i := A_i*x_i      or
  !>         x_i := A_i**T*x_i   or
  !>         x_i := A_i**H*x_i,
  !> 
  !>     where (A_i, x_i) is the i-th instance of the batch.
  !>     x_i is a vector and A_i is an m by m matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: each A_i is an upper banded triangular matrix.
  !>               rocblas_fill_lower: each A_i is a  lower banded triangular matrix.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether each matrix A_i is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               rocblas_diagonal_unit: The main diagonal of each A_i is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               rocblas_diagonal_non_unit: No assumptions are made of each A_i's main diagonal.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows and columns of the matrix represented by each A_i.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if uplo == rocblas_fill_upper, k specifies the number of super-diagonals
  !>               of each matrix A_i.
  !>               if uplo == rocblas_fill_lower, k specifies the number of sub-diagonals
  !>               of each matrix A_i.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     A         device array of device pointers storing each banded triangular matrix A_i.
  !>               if uplo == rocblas_fill_upper:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (rocblas_fill_upper; m = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == rocblas_fill_lower:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (rocblas_fill_lower; m = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. lda must satisfy lda > k.
  !>     @param[inout]
  !>     x         device array of device pointer storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_ztbmv_batched
    function rocblas_ztbmv_batched_(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_ztbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztbmv_batched_full_rank,&
      rocblas_ztbmv_batched_rank_0,&
      rocblas_ztbmv_batched_rank_1
#endif
  end interface
  
  interface rocblas_stbmv_strided_batched
    function rocblas_stbmv_strided_batched_(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_stbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stbmv_strided_batched_full_rank,&
      rocblas_stbmv_strided_batched_rank_0,&
      rocblas_stbmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtbmv_strided_batched
    function rocblas_dtbmv_strided_batched_(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_dtbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtbmv_strided_batched_full_rank,&
      rocblas_dtbmv_strided_batched_rank_0,&
      rocblas_dtbmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctbmv_strided_batched
    function rocblas_ctbmv_strided_batched_(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ctbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctbmv_strided_batched_full_rank,&
      rocblas_ctbmv_strided_batched_rank_0,&
      rocblas_ctbmv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbmv_strided_batched performs one of the matrix-vector operations
  !> 
  !>         x_i := A_i*x_i      or
  !>         x_i := A_i**T*x_i   or
  !>         x_i := A_i**H*x_i,
  !> 
  !>     where (A_i, x_i) is the i-th instance of the batch.
  !>     x_i is a vector and A_i is an m by m matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               rocblas_fill_upper: each A_i is an upper banded triangular matrix.
  !>               rocblas_fill_lower: each A_i is a  lower banded triangular matrix.
  !>     @param[in]
  !>     trans     [rocblas_operation]
  !>               indicates whether each matrix A_i is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               rocblas_diagonal_unit: The main diagonal of each A_i is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               rocblas_diagonal_non_unit: No assumptions are made of each A_i's main diagonal.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows and columns of the matrix represented by each A_i.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if uplo == rocblas_fill_upper, k specifies the number of super-diagonals
  !>               of each matrix A_i.
  !>               if uplo == rocblas_fill_lower, k specifies the number of sub-diagonals
  !>               of each matrix A_i.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     A         device array to the first matrix A_i of the batch. Stores each banded triangular matrix A_i.
  !>               if uplo == rocblas_fill_upper:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (rocblas_fill_upper; m = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == rocblas_fill_lower:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (rocblas_fill_lower; m = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i. lda must satisfy lda > k.
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[inout]
  !>     x         device array to the first vector x_i of the batch.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one x_i matrix to the next x_(i + 1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_ztbmv_strided_batched
    function rocblas_ztbmv_strided_batched_(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ztbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztbmv_strided_batched_full_rank,&
      rocblas_ztbmv_strided_batched_rank_0,&
      rocblas_ztbmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_stbsv
    function rocblas_stbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="rocblas_stbsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stbsv_full_rank,&
      rocblas_stbsv_rank_0,&
      rocblas_stbsv_rank_1
#endif
  end interface
  
  interface rocblas_dtbsv
    function rocblas_dtbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="rocblas_dtbsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtbsv_full_rank,&
      rocblas_dtbsv_rank_0,&
      rocblas_dtbsv_rank_1
#endif
  end interface
  
  interface rocblas_ctbsv
    function rocblas_ctbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="rocblas_ctbsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctbsv_full_rank,&
      rocblas_ctbsv_rank_0,&
      rocblas_ctbsv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsv solves
  !> 
  !>          A*x = b or A**T*x = b or A**H*x = b,
  !> 
  !>     where x and b are vectors and A is a banded triangular matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !>                rocblas_operation_none: Solves A*x = b
  !>                rocblas_operation_transpose: Solves A**T*x = b
  !>                rocblas_operation_conjugate_transpose: Solves A**H*x = b
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of A are not used in computations).
  !>             rocblas_diagonal_non_unit: A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of b. n >= 0.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if(uplo == rocblas_fill_upper)
  !>                 k specifies the number of super-diagonals of A.
  !>               if(uplo == rocblas_fill_lower)
  !>                 k specifies the number of sub-diagonals of A.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing the matrix A in banded format.
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>               lda >= (k + 1).
  !> 
  !>     @param[inout]
  !>     x         device pointer storing input vector b. Overwritten by the output vector x.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>
  interface rocblas_ztbsv
    function rocblas_ztbsv_(handle,uplo,transA,diag,n,k,A,lda,x,incx) bind(c, name="rocblas_ztbsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztbsv_full_rank,&
      rocblas_ztbsv_rank_0,&
      rocblas_ztbsv_rank_1
#endif
  end interface
  
  interface rocblas_stbsv_batched
    function rocblas_stbsv_batched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_stbsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stbsv_batched_full_rank,&
      rocblas_stbsv_batched_rank_0,&
      rocblas_stbsv_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtbsv_batched
    function rocblas_dtbsv_batched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_dtbsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtbsv_batched_full_rank,&
      rocblas_dtbsv_batched_rank_0,&
      rocblas_dtbsv_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctbsv_batched
    function rocblas_ctbsv_batched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_ctbsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctbsv_batched_full_rank,&
      rocblas_ctbsv_batched_rank_0,&
      rocblas_ctbsv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsv_batched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a banded triangular matrix,
  !>     for i = [1, batch_count].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !>                rocblas_operation_none: Solves A_i*x_i = b_i
  !>                rocblas_operation_transpose: Solves A_i**T*x_i = b_i
  !>                rocblas_operation_conjugate_transpose: Solves A_i**H*x_i = b_i
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if(uplo == rocblas_fill_upper)
  !>                 k specifies the number of super-diagonals of each A_i.
  !>               if(uplo == rocblas_fill_lower)
  !>                 k specifies the number of sub-diagonals of each A_i.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     A         device vector of device pointers storing each matrix A_i in banded format.
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>               lda >= (k + 1).
  !> 
  !>     @param[inout]
  !>     x         device vector of device pointers storing each input vector b_i. Overwritten by each output
  !>               vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_ztbsv_batched
    function rocblas_ztbsv_batched_(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count) bind(c, name="rocblas_ztbsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztbsv_batched_full_rank,&
      rocblas_ztbsv_batched_rank_0,&
      rocblas_ztbsv_batched_rank_1
#endif
  end interface
  
  interface rocblas_stbsv_strided_batched
    function rocblas_stbsv_strided_batched_(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_stbsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stbsv_strided_batched_full_rank,&
      rocblas_stbsv_strided_batched_rank_0,&
      rocblas_stbsv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtbsv_strided_batched
    function rocblas_dtbsv_strided_batched_(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_dtbsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtbsv_strided_batched_full_rank,&
      rocblas_dtbsv_strided_batched_rank_0,&
      rocblas_dtbsv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctbsv_strided_batched
    function rocblas_ctbsv_strided_batched_(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ctbsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctbsv_strided_batched_full_rank,&
      rocblas_ctbsv_strided_batched_rank_0,&
      rocblas_ctbsv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsv_strided_batched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a banded triangular matrix,
  !>     for i = [1, batch_count].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !>                rocblas_operation_none: Solves A_i*x_i = b_i
  !>                rocblas_operation_transpose: Solves A_i**T*x_i = b_i
  !>                rocblas_operation_conjugate_transpose: Solves A_i**H*x_i = b_i
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               if(uplo == rocblas_fill_upper)
  !>                 k specifies the number of super-diagonals of each A_i.
  !>               if(uplo == rocblas_fill_lower)
  !>                 k specifies the number of sub-diagonals of each A_i.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer pointing to the first banded matrix A_1.
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>               lda >= (k + 1).
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               specifies the distance between the start of one matrix (A_i) and the next (A_i+1).
  !> 
  !>     @param[inout]
  !>     x         device pointer pointing to the first input vector b_1. Overwritten by output vectors x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               specifies the distance between the start of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_ztbsv_strided_batched
    function rocblas_ztbsv_strided_batched_(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ztbsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztbsv_strided_batched_full_rank,&
      rocblas_ztbsv_strided_batched_rank_0,&
      rocblas_ztbsv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_strsv
    function rocblas_strsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_strsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strsv_full_rank,&
      rocblas_strsv_rank_0,&
      rocblas_strsv_rank_1
#endif
  end interface
  
  interface rocblas_dtrsv
    function rocblas_dtrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_dtrsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrsv_full_rank,&
      rocblas_dtrsv_rank_0,&
      rocblas_dtrsv_rank_1
#endif
  end interface
  
  interface rocblas_ctrsv
    function rocblas_ctrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_ctrsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrsv_full_rank,&
      rocblas_ctrsv_rank_0,&
      rocblas_ctrsv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsv solves
  !> 
  !>          A*x = b or A**T*x = b,
  !> 
  !>     where x and b are vectors and A is a triangular matrix.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of b. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer storing matrix A,
  !>               of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>               lda = max( 1, m ).
  !> 
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>
  interface rocblas_ztrsv
    function rocblas_ztrsv_(handle,uplo,transA,diag,m,A,lda,x,incx) bind(c, name="rocblas_ztrsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrsv_full_rank,&
      rocblas_ztrsv_rank_0,&
      rocblas_ztrsv_rank_1
#endif
  end interface
  
  interface rocblas_strsv_batched
    function rocblas_strsv_batched_(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count) bind(c, name="rocblas_strsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strsv_batched_full_rank,&
      rocblas_strsv_batched_rank_0,&
      rocblas_strsv_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtrsv_batched
    function rocblas_dtrsv_batched_(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count) bind(c, name="rocblas_dtrsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrsv_batched_full_rank,&
      rocblas_dtrsv_batched_rank_0,&
      rocblas_dtrsv_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctrsv_batched
    function rocblas_ctrsv_batched_(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count) bind(c, name="rocblas_ctrsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrsv_batched_full_rank,&
      rocblas_ctrsv_batched_rank_0,&
      rocblas_ctrsv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsv_batched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i,
  !> 
  !>     where (A_i, x_i, b_i) is the i-th instance of the batch.
  !>     x_i and b_i are vectors and A_i is an
  !>     m by m triangular matrix.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of b. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i.
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>               lda = max(1, m)
  !> 
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_ztrsv_batched
    function rocblas_ztrsv_batched_(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count) bind(c, name="rocblas_ztrsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrsv_batched_full_rank,&
      rocblas_ztrsv_batched_rank_0,&
      rocblas_ztrsv_batched_rank_1
#endif
  end interface
  
  interface rocblas_strsv_strided_batched
    function rocblas_strsv_strided_batched_(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_strsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strsv_strided_batched_full_rank,&
      rocblas_strsv_strided_batched_rank_0,&
      rocblas_strsv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtrsv_strided_batched
    function rocblas_dtrsv_strided_batched_(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_dtrsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrsv_strided_batched_full_rank,&
      rocblas_dtrsv_strided_batched_rank_0,&
      rocblas_dtrsv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctrsv_strided_batched
    function rocblas_ctrsv_strided_batched_(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ctrsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrsv_strided_batched_full_rank,&
      rocblas_ctrsv_strided_batched_rank_0,&
      rocblas_ctrsv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsv_strided_batched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i,
  !> 
  !>     where (A_i, x_i, b_i) is the i-th instance of the batch.
  !>     x_i and b_i are vectors and A_i is an m by m triangular matrix, for i = 1, ..., batch_count.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [rocblas_operation]
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               m specifies the number of rows of each b_i. m >= 0.
  !> 
  !>     @param[in]
  !>     A         device pointer to the first matrix (A_1) in the batch, of dimension ( lda, m )
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1)
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>               lda = max( 1, m ).
  !> 
  !>     @param[in, out]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !> 
  !>     @param[in]
  !>     stride_x [rocblas_stride]
  !>              stride from the start of one x_i vector to the next x_(i + 1)
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_ztrsv_strided_batched
    function rocblas_ztrsv_strided_batched_(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ztrsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrsv_strided_batched_full_rank,&
      rocblas_ztrsv_strided_batched_rank_0,&
      rocblas_ztrsv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_stpsv
    function rocblas_stpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="rocblas_stpsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stpsv_rank_0,&
      rocblas_stpsv_rank_1
#endif
  end interface
  
  interface rocblas_dtpsv
    function rocblas_dtpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="rocblas_dtpsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtpsv_rank_0,&
      rocblas_dtpsv_rank_1
#endif
  end interface
  
  interface rocblas_ctpsv
    function rocblas_ctpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="rocblas_ctpsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctpsv_rank_0,&
      rocblas_ctpsv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpsv solves
  !> 
  !>          A*x = b or A**T*x = b, or A**H*x = b,
  !> 
  !>     where x and b are vectors and A is a triangular matrix stored in the packed format.
  !> 
  !>     The input vector b is overwritten by the output vector x.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_none: Solves A*x = b
  !>             rocblas_operation_transpose: Solves A**T*x = b
  !>             rocblas_operation_conjugate_transpose: Solves A**H*x = b
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of A are not used in computations).
  !>             rocblas_diagonal_non_unit: A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of b. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer storing the packed version of matrix A,
  !>               of dimension >= (n * (n + 1) 2)
  !> 
  !>     @param[inout]
  !>     x         device pointer storing vector b on input, overwritten by x on output.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>
  interface rocblas_ztpsv
    function rocblas_ztpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="rocblas_ztpsv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztpsv_rank_0,&
      rocblas_ztpsv_rank_1
#endif
  end interface
  
  interface rocblas_stpsv_batched
    function rocblas_stpsv_batched_(handle,uplo,transA,diag,n,AP,x,incx,batch_count) bind(c, name="rocblas_stpsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stpsv_batched_full_rank,&
      rocblas_stpsv_batched_rank_0,&
      rocblas_stpsv_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtpsv_batched
    function rocblas_dtpsv_batched_(handle,uplo,transA,diag,n,AP,x,incx,batch_count) bind(c, name="rocblas_dtpsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtpsv_batched_full_rank,&
      rocblas_dtpsv_batched_rank_0,&
      rocblas_dtpsv_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctpsv_batched
    function rocblas_ctpsv_batched_(handle,uplo,transA,diag,n,AP,x,incx,batch_count) bind(c, name="rocblas_ctpsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctpsv_batched_full_rank,&
      rocblas_ctpsv_batched_rank_0,&
      rocblas_ctpsv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpsv_batched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
  !>     for i in [1, batch_count].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  each A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  each A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_none: Solves A*x = b
  !>             rocblas_operation_transpose: Solves A**T*x = b
  !>             rocblas_operation_conjugate_transpose: Solves A**H*x = b
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device array of device pointers storing the packed versions of each matrix A_i,
  !>               of dimension >= (n * (n + 1) 2)
  !> 
  !>     @param[inout]
  !>     x         device array of device pointers storing each input vector b_i, overwritten by x_i on output.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of instances in the batch.
  !>
  interface rocblas_ztpsv_batched
    function rocblas_ztpsv_batched_(handle,uplo,transA,diag,n,AP,x,incx,batch_count) bind(c, name="rocblas_ztpsv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztpsv_batched_full_rank,&
      rocblas_ztpsv_batched_rank_0,&
      rocblas_ztpsv_batched_rank_1
#endif
  end interface
  
  interface rocblas_stpsv_strided_batched
    function rocblas_stpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_stpsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_stpsv_strided_batched_rank_0,&
      rocblas_stpsv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtpsv_strided_batched
    function rocblas_dtpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_dtpsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtpsv_strided_batched_rank_0,&
      rocblas_dtpsv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctpsv_strided_batched
    function rocblas_ctpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ctpsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctpsv_strided_batched_rank_0,&
      rocblas_ctpsv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpsv_strided_batched solves
  !> 
  !>          A_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
  !>     for i in [1, batch_count].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  each A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  each A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_none: Solves A*x = b
  !>             rocblas_operation_transpose: Solves A**T*x = b
  !>             rocblas_operation_conjugate_transpose: Solves A**H*x = b
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer pointing to the first packed matrix A_1,
  !>               of dimension >= (n * (n + 1) 2)
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the beginning of one packed matrix (AP_i) and the next (AP_i+1).
  !> 
  !>     @param[inout]
  !>     x         device pointer pointing to the first input vector b_1. Overwritten by each x_i on output.
  !> 
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the beginning of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 specifies the number of instances in the batch.
  !>
  interface rocblas_ztpsv_strided_batched
    function rocblas_ztpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count) bind(c, name="rocblas_ztpsv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztpsv_strided_batched_rank_0,&
      rocblas_ztpsv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssymv
    function rocblas_ssymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_ssymv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssymv_full_rank,&
      rocblas_ssymv_rank_0,&
      rocblas_ssymv_rank_1
#endif
  end interface
  
  interface rocblas_dsymv
    function rocblas_dsymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_dsymv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsymv_full_rank,&
      rocblas_dsymv_rank_0,&
      rocblas_dsymv_rank_1
#endif
  end interface
  
  interface rocblas_csymv
    function rocblas_csymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_csymv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csymv_full_rank,&
      rocblas_csymv_rank_0,&
      rocblas_csymv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     symv performs the matrix-vector operation:
  !> 
  !>         y := alpha*A*x + beta*y,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      rocblas_fill
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     A         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y
  !>
  interface rocblas_zsymv
    function rocblas_zsymv_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_zsymv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsymv_full_rank,&
      rocblas_zsymv_rank_0,&
      rocblas_zsymv_rank_1
#endif
  end interface
  
  interface rocblas_ssymv_batched
    function rocblas_ssymv_batched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_ssymv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssymv_batched_full_rank,&
      rocblas_ssymv_batched_rank_0,&
      rocblas_ssymv_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsymv_batched
    function rocblas_dsymv_batched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_dsymv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsymv_batched_full_rank,&
      rocblas_dsymv_batched_rank_0,&
      rocblas_dsymv_batched_rank_1
#endif
  end interface
  
  interface rocblas_csymv_batched
    function rocblas_csymv_batched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_csymv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csymv_batched_full_rank,&
      rocblas_csymv_batched_rank_0,&
      rocblas_csymv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     symv_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batch_count.
  !>     A a should contain an upper or lower triangular symmetric matrix
  !>     and the opposing triangular part of A is not referenced
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zsymv_batched
    function rocblas_zsymv_batched_(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_zsymv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsymv_batched_full_rank,&
      rocblas_zsymv_batched_rank_0,&
      rocblas_zsymv_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssymv_strided_batched
    function rocblas_ssymv_strided_batched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_ssymv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssymv_strided_batched_full_rank,&
      rocblas_ssymv_strided_batched_rank_0,&
      rocblas_ssymv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsymv_strided_batched
    function rocblas_dsymv_strided_batched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_dsymv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsymv_strided_batched_full_rank,&
      rocblas_dsymv_strided_batched_rank_0,&
      rocblas_dsymv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_csymv_strided_batched
    function rocblas_csymv_strided_batched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_csymv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csymv_strided_batched_full_rank,&
      rocblas_csymv_strided_batched_rank_0,&
      rocblas_csymv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     symv_strided_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batch_count.
  !>     A a should contain an upper or lower triangular symmetric matrix
  !>     and the opposing triangular part of A is not referenced
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     strideA     [rocblas_stride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n * incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stride_y, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n * incy. stridey should be non zero.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zsymv_strided_batched
    function rocblas_zsymv_strided_batched_(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_zsymv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsymv_strided_batched_full_rank,&
      rocblas_zsymv_strided_batched_rank_0,&
      rocblas_zsymv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sspmv
    function rocblas_sspmv_(handle,uplo,n,alpha,A,x,incx,beta,y,incy) bind(c, name="rocblas_sspmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sspmv_full_rank,&
      rocblas_sspmv_rank_0,&
      rocblas_sspmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spmv performs the matrix-vector operation:
  !> 
  !>         y := alpha*A*x + beta*y,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      rocblas_fill
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     A         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y
  !>
  interface rocblas_dspmv
    function rocblas_dspmv_(handle,uplo,n,alpha,A,x,incx,beta,y,incy) bind(c, name="rocblas_dspmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dspmv_full_rank,&
      rocblas_dspmv_rank_0,&
      rocblas_dspmv_rank_1
#endif
  end interface
  
  interface rocblas_sspmv_batched
    function rocblas_sspmv_batched_(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_sspmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sspmv_batched_full_rank,&
      rocblas_sspmv_batched_rank_0,&
      rocblas_sspmv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spmv_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batch_count.
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_dspmv_batched
    function rocblas_dspmv_batched_(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_dspmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dspmv_batched_full_rank,&
      rocblas_dspmv_batched_rank_0,&
      rocblas_dspmv_batched_rank_1
#endif
  end interface
  
  interface rocblas_sspmv_strided_batched
    function rocblas_sspmv_strided_batched_(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_sspmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sspmv_strided_batched_full_rank,&
      rocblas_sspmv_strided_batched_rank_0,&
      rocblas_sspmv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spmv_strided_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batch_count.
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     strideA     [rocblas_stride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n * incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n * incy. stridey should be non zero.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_dspmv_strided_batched
    function rocblas_dspmv_strided_batched_(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_dspmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dspmv_strided_batched_full_rank,&
      rocblas_dspmv_strided_batched_rank_0,&
      rocblas_dspmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssbmv
    function rocblas_ssbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_ssbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssbmv_full_rank,&
      rocblas_ssbmv_rank_0,&
      rocblas_ssbmv_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sbmv performs the matrix-vector operation:
  !> 
  !>         y := alpha*A*x + beta*y,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      rocblas_fill
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     A         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of matrix A
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y
  !>
  interface rocblas_dsbmv
    function rocblas_dsbmv_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy) bind(c, name="rocblas_dsbmv")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsbmv_full_rank,&
      rocblas_dsbmv_rank_0,&
      rocblas_dsbmv_rank_1
#endif
  end interface
  
  interface rocblas_dsbmv_batched
    function rocblas_dsbmv_batched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_dsbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsbmv_batched_full_rank,&
      rocblas_dsbmv_batched_rank_0,&
      rocblas_dsbmv_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sbmv_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric banded matrix, for i = 1, ..., batch_count.
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_ssbmv_batched
    function rocblas_ssbmv_batched_(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count) bind(c, name="rocblas_ssbmv_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssbmv_batched_full_rank,&
      rocblas_ssbmv_batched_rank_0,&
      rocblas_ssbmv_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssbmv_strided_batched
    function rocblas_ssbmv_strided_batched_(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_ssbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssbmv_strided_batched_full_rank,&
      rocblas_ssbmv_strided_batched_rank_0,&
      rocblas_ssbmv_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sbmv_strided_batched performs the matrix-vector operation:
  !> 
  !>         y_i := alpha*A_i*x_i + beta*y_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric banded matrix, for i = 1, ..., batch_count.
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     A         Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     strideA     [rocblas_stride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n * incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n * incy. stridey should be non zero.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_dsbmv_strided_batched
    function rocblas_dsbmv_strided_batched_(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count) bind(c, name="rocblas_dsbmv_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsbmv_strided_batched_full_rank,&
      rocblas_dsbmv_strided_batched_rank_0,&
      rocblas_dsbmv_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sger
    function rocblas_sger_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_sger")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sger_full_rank,&
      rocblas_sger_rank_0,&
      rocblas_sger_rank_1
#endif
  end interface
  
  interface rocblas_dger
    function rocblas_dger_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_dger")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dger_full_rank,&
      rocblas_dger_rank_0,&
      rocblas_dger_rank_1
#endif
  end interface
  
  interface rocblas_cgeru
    function rocblas_cgeru_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_cgeru")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgeru_full_rank,&
      rocblas_cgeru_rank_0,&
      rocblas_cgeru_rank_1
#endif
  end interface
  
  interface rocblas_zgeru
    function rocblas_zgeru_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_zgeru")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgeru_full_rank,&
      rocblas_zgeru_rank_0,&
      rocblas_zgeru_rank_1
#endif
  end interface
  
  interface rocblas_cgerc
    function rocblas_cgerc_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_cgerc")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgerc_full_rank,&
      rocblas_cgerc_rank_0,&
      rocblas_cgerc_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     ger,geru,gerc performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*y**T , OR
  !>         A := A + alpha*x*y**H for gerc
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows of the matrix A.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of columns of the matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>
  interface rocblas_zgerc
    function rocblas_zgerc_(handle,m,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_zgerc")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgerc_full_rank,&
      rocblas_zgerc_rank_0,&
      rocblas_zgerc_rank_1
#endif
  end interface
  
  interface rocblas_sger_batched
    function rocblas_sger_batched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_sger_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sger_batched_full_rank,&
      rocblas_sger_batched_rank_0,&
      rocblas_sger_batched_rank_1
#endif
  end interface
  
  interface rocblas_dger_batched
    function rocblas_dger_batched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_dger_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dger_batched_full_rank,&
      rocblas_dger_batched_rank_0,&
      rocblas_dger_batched_rank_1
#endif
  end interface
  
  interface rocblas_cgeru_batched
    function rocblas_cgeru_batched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_cgeru_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgeru_batched_full_rank,&
      rocblas_cgeru_batched_rank_0,&
      rocblas_cgeru_batched_rank_1
#endif
  end interface
  
  interface rocblas_zgeru_batched
    function rocblas_zgeru_batched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_zgeru_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgeru_batched_full_rank,&
      rocblas_zgeru_batched_rank_0,&
      rocblas_zgeru_batched_rank_1
#endif
  end interface
  
  interface rocblas_cgerc_batched
    function rocblas_cgerc_batched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_cgerc_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgerc_batched_full_rank,&
      rocblas_cgerc_batched_rank_0,&
      rocblas_cgerc_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     ger_batched,geru_batched,gerc_batched perform a batch of the matrix-vector operations
  !> 
  !>         A := A + alpha*x*y**T , OR
  !>         A := A + alpha*x*y**H for gerc
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha is a scalar, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows of each matrix A_i.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of columns of eaceh matrix A_i.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each vector x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zgerc_batched
    function rocblas_zgerc_batched_(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_zgerc_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgerc_batched_full_rank,&
      rocblas_zgerc_batched_rank_0,&
      rocblas_zgerc_batched_rank_1
#endif
  end interface
  
  interface rocblas_sger_strided_batched
    function rocblas_sger_strided_batched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_sger_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sger_strided_batched_full_rank,&
      rocblas_sger_strided_batched_rank_0,&
      rocblas_sger_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dger_strided_batched
    function rocblas_dger_strided_batched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_dger_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dger_strided_batched_full_rank,&
      rocblas_dger_strided_batched_rank_0,&
      rocblas_dger_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cgeru_strided_batched
    function rocblas_cgeru_strided_batched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_cgeru_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgeru_strided_batched_full_rank,&
      rocblas_cgeru_strided_batched_rank_0,&
      rocblas_cgeru_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_zgeru_strided_batched
    function rocblas_zgeru_strided_batched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_zgeru_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgeru_strided_batched_full_rank,&
      rocblas_zgeru_strided_batched_rank_0,&
      rocblas_zgeru_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cgerc_strided_batched
    function rocblas_cgerc_strided_batched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_cgerc_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgerc_strided_batched_full_rank,&
      rocblas_cgerc_strided_batched_rank_0,&
      rocblas_cgerc_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     ger_strided_batched,geru_strided_batched,gerc_strided_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**T, OR
  !>         A_i := A_i + alpha*x_i*y_i**H  for gerc
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha is a scalar, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               the number of rows of each matrix A_i.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of columns of each matrix A_i.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increments for the elements of each vector x_i.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= m * incx.
  !>     @param[inout]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     stridey   [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>               There are no restrictions placed on stride_y, however the user should
  !>               take care to ensure that stride_y is of appropriate size, for a typical
  !>               case this means stride_y >= n * incy.
  !>     @param[inout]
  !>     A         device pointer to the first matrix (A_1) in the batch.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA     [rocblas_stride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zgerc_strided_batched
    function rocblas_zgerc_strided_batched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_zgerc_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgerc_strided_batched_full_rank,&
      rocblas_zgerc_strided_batched_rank_0,&
      rocblas_zgerc_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sspr
    function rocblas_sspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_sspr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sspr_rank_0,&
      rocblas_sspr_rank_1
#endif
  end interface
  
  interface rocblas_dspr
    function rocblas_dspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_dspr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dspr_rank_0,&
      rocblas_dspr_rank_1
#endif
  end interface
  
  interface rocblas_cspr
    function rocblas_cspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_cspr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cspr_rank_0,&
      rocblas_cspr_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*x**T
  !> 
  !>     where alpha is a scalar, x is a vector, and A is an
  !>     n by n symmetric matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the symmetric matrix A. Of at least size ((n * (n + 1)) 2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  interface rocblas_zspr
    function rocblas_zspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="rocblas_zspr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zspr_rank_0,&
      rocblas_zspr_rank_1
#endif
  end interface
  
  interface rocblas_sspr_batched
    function rocblas_sspr_batched_(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_sspr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sspr_batched_full_rank,&
      rocblas_sspr_batched_rank_0,&
      rocblas_sspr_batched_rank_1
#endif
  end interface
  
  interface rocblas_dspr_batched
    function rocblas_dspr_batched_(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_dspr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dspr_batched_full_rank,&
      rocblas_dspr_batched_rank_0,&
      rocblas_dspr_batched_rank_1
#endif
  end interface
  
  interface rocblas_cspr_batched
    function rocblas_cspr_batched_(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_cspr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cspr_batched_full_rank,&
      rocblas_cspr_batched_rank_0,&
      rocblas_cspr_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**T
  !> 
  !>     where alpha is a scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i of at least size ((n * (n + 1)) 2). Array is of at least size batch_count.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_zspr_batched
    function rocblas_zspr_batched_(handle,uplo,n,alpha,x,incx,AP,batch_count) bind(c, name="rocblas_zspr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zspr_batched_full_rank,&
      rocblas_zspr_batched_rank_0,&
      rocblas_zspr_batched_rank_1
#endif
  end interface
  
  interface rocblas_sspr_strided_batched
    function rocblas_sspr_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_sspr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sspr_strided_batched_rank_0,&
      rocblas_sspr_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dspr_strided_batched
    function rocblas_dspr_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_dspr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dspr_strided_batched_rank_0,&
      rocblas_dspr_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cspr_strided_batched
    function rocblas_cspr_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_cspr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cspr_strided_batched_rank_0,&
      rocblas_cspr_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr_strided_batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alpha*x_i*x_i**T
  !> 
  !>     where alpha is a scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i. Points to the first A_1.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_zspr_strided_batched
    function rocblas_zspr_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count) bind(c, name="rocblas_zspr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zspr_strided_batched_rank_0,&
      rocblas_zspr_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sspr2
    function rocblas_sspr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="rocblas_sspr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sspr2_rank_0,&
      rocblas_sspr2_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr2 performs the matrix-vector operation
  !> 
  !>         A := A + alpha*x*y**T + alpha*y*x**T
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     n by n symmetric matrix, supplied in packed form.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of A is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the symmetric matrix A. Of at least size ((n * (n + 1)) 2).
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  interface rocblas_dspr2
    function rocblas_dspr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="rocblas_dspr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dspr2_rank_0,&
      rocblas_dspr2_rank_1
#endif
  end interface
  
  interface rocblas_sspr2_batched
    function rocblas_sspr2_batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count) bind(c, name="rocblas_sspr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sspr2_batched_full_rank,&
      rocblas_sspr2_batched_rank_0,&
      rocblas_sspr2_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr2_batched performs the matrix-vector operation
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T
  !> 
  !>     where alpha is a scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i of at least size ((n * (n + 1)) 2). Array is of at least size batch_count.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_dspr2_batched
    function rocblas_dspr2_batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count) bind(c, name="rocblas_dspr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dspr2_batched_full_rank,&
      rocblas_dspr2_batched_rank_0,&
      rocblas_dspr2_batched_rank_1
#endif
  end interface
  
  interface rocblas_sspr2_strided_batched
    function rocblas_sspr2_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count) bind(c, name="rocblas_sspr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sspr2_strided_batched_rank_0,&
      rocblas_sspr2_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr2_strided_batched performs the matrix-vector operation
  !> 
  !>         A_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T
  !> 
  !>     where alpha is a scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
  !>               rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector (y_1).
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stride_y  [rocblas_stride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i. Points to the first A_1.
  !>               if uplo == rocblas_fill_upper:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (rocblas_fill_upper; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == rocblas_fill_lower:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (rocblas_fill_lower; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     stride_A    [rocblas_stride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  interface rocblas_dspr2_strided_batched
    function rocblas_dspr2_strided_batched_(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count) bind(c, name="rocblas_dspr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: stride_A
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dspr2_strided_batched_rank_0,&
      rocblas_dspr2_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssyr
    function rocblas_ssyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_ssyr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyr_full_rank,&
      rocblas_ssyr_rank_0,&
      rocblas_ssyr_rank_1
#endif
  end interface
  
  interface rocblas_dsyr
    function rocblas_dsyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_dsyr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyr_full_rank,&
      rocblas_dsyr_rank_0,&
      rocblas_dsyr_rank_1
#endif
  end interface
  
  interface rocblas_csyr
    function rocblas_csyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_csyr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyr_full_rank,&
      rocblas_csyr_rank_0,&
      rocblas_csyr_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*x**T
  !> 
  !>     where alpha is a scalar, x is a vector, and A is an
  !>     n by n symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>
  interface rocblas_zsyr
    function rocblas_zsyr_(handle,uplo,n,alpha,x,incx,A,lda) bind(c, name="rocblas_zsyr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyr_full_rank,&
      rocblas_zsyr_rank_0,&
      rocblas_zsyr_rank_1
#endif
  end interface
  
  interface rocblas_ssyr_batched
    function rocblas_ssyr_batched_(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_ssyr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyr_batched_full_rank,&
      rocblas_ssyr_batched_rank_0,&
      rocblas_ssyr_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsyr_batched
    function rocblas_dsyr_batched_(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_dsyr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyr_batched_full_rank,&
      rocblas_dsyr_batched_rank_0,&
      rocblas_dsyr_batched_rank_1
#endif
  end interface
  
  interface rocblas_csyr_batched
    function rocblas_csyr_batched_(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_csyr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyr_batched_full_rank,&
      rocblas_csyr_batched_rank_0,&
      rocblas_csyr_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr_batched performs a batch of matrix-vector operations
  !> 
  !>         A[i] := A[i] + alpha*x[i]*x[i]**T
  !> 
  !>     where alpha is a scalar, x is an array of vectors, and A is an array of
  !>     n by n symmetric matrices, for i = 1 , ... , batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zsyr_batched
    function rocblas_zsyr_batched_(handle,uplo,n,alpha,x,incx,A,lda,batch_count) bind(c, name="rocblas_zsyr_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyr_batched_full_rank,&
      rocblas_zsyr_batched_rank_0,&
      rocblas_zsyr_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssyr_strided_batched
    function rocblas_ssyr_strided_batched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count) bind(c, name="rocblas_ssyr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyr_strided_batched_full_rank,&
      rocblas_ssyr_strided_batched_rank_0,&
      rocblas_ssyr_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsyr_strided_batched
    function rocblas_dsyr_strided_batched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count) bind(c, name="rocblas_dsyr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyr_strided_batched_full_rank,&
      rocblas_dsyr_strided_batched_rank_0,&
      rocblas_dsyr_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_csyr_strided_batched
    function rocblas_csyr_strided_batched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count) bind(c, name="rocblas_csyr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyr_strided_batched_full_rank,&
      rocblas_csyr_strided_batched_rank_0,&
      rocblas_csyr_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr_strided_batched performs the matrix-vector operations
  !> 
  !>         A[i] := A[i] + alpha*x[i]*x[i]**T
  !> 
  !>     where alpha is a scalar, vectors, and A is an array of
  !>     n by n symmetric matrices, for i = 1 , ... , batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               specifies the pointer increment between vectors (x_i) and (x_i+1).
  !>     @param[inout]
  !>     A         device pointer to the first matrix A_1.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA   [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>
  interface rocblas_zsyr_strided_batched
    function rocblas_zsyr_strided_batched_(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count) bind(c, name="rocblas_zsyr_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyr_strided_batched_full_rank,&
      rocblas_zsyr_strided_batched_rank_0,&
      rocblas_zsyr_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssyr2
    function rocblas_ssyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_ssyr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyr2_full_rank,&
      rocblas_ssyr2_rank_0,&
      rocblas_ssyr2_rank_1
#endif
  end interface
  
  interface rocblas_dsyr2
    function rocblas_dsyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_dsyr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyr2_full_rank,&
      rocblas_dsyr2_rank_0,&
      rocblas_dsyr2_rank_1
#endif
  end interface
  
  interface rocblas_csyr2
    function rocblas_csyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_csyr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyr2_full_rank,&
      rocblas_csyr2_rank_0,&
      rocblas_csyr2_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr2 performs the matrix-vector operations
  !> 
  !>         A := A + alpha*x*y**T + alpha*y*x**T
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     n by n symmetric matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>
  interface rocblas_zsyr2
    function rocblas_zsyr2_(handle,uplo,n,alpha,x,incx,y,incy,A,lda) bind(c, name="rocblas_zsyr2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyr2_full_rank,&
      rocblas_zsyr2_rank_0,&
      rocblas_zsyr2_rank_1
#endif
  end interface
  
  interface rocblas_ssyr2_batched
    function rocblas_ssyr2_batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_ssyr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyr2_batched_full_rank,&
      rocblas_ssyr2_batched_rank_0,&
      rocblas_ssyr2_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsyr2_batched
    function rocblas_dsyr2_batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_dsyr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyr2_batched_full_rank,&
      rocblas_dsyr2_batched_rank_0,&
      rocblas_dsyr2_batched_rank_1
#endif
  end interface
  
  interface rocblas_csyr2_batched
    function rocblas_csyr2_batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_csyr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyr2_batched_full_rank,&
      rocblas_csyr2_batched_rank_0,&
      rocblas_csyr2_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr2_batched performs a batch of matrix-vector operations
  !> 
  !>         A[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T
  !> 
  !>     where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
  !>     n by n symmetric matrix, for i = 1 , ... , batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zsyr2_batched
    function rocblas_zsyr2_batched_(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count) bind(c, name="rocblas_zsyr2_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyr2_batched_full_rank,&
      rocblas_zsyr2_batched_rank_0,&
      rocblas_zsyr2_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssyr2_strided_batched
    function rocblas_ssyr2_strided_batched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_ssyr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyr2_strided_batched_full_rank,&
      rocblas_ssyr2_strided_batched_rank_0,&
      rocblas_ssyr2_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsyr2_strided_batched
    function rocblas_dsyr2_strided_batched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_dsyr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyr2_strided_batched_full_rank,&
      rocblas_dsyr2_strided_batched_rank_0,&
      rocblas_dsyr2_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_csyr2_strided_batched
    function rocblas_csyr2_strided_batched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_csyr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyr2_strided_batched_full_rank,&
      rocblas_csyr2_strided_batched_rank_0,&
      rocblas_csyr2_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr2_strided_batched the matrix-vector operations
  !> 
  !>         A[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T
  !> 
  !>     where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
  !>     n by n symmetric matrices, for i = 1 , ... , batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of rows and columns of each matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               specifies the pointer increment between vectors (x_i) and (x_i+1).
  !>     @param[in]
  !>     y         device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey   [rocblas_stride]
  !>               specifies the pointer increment between vectors (y_i) and (y_i+1).
  !>     @param[inout]
  !>     A         device pointer to the first matrix A_1.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA   [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>
  interface rocblas_zsyr2_strided_batched
    function rocblas_zsyr2_strided_batched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count) bind(c, name="rocblas_zsyr2_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyr2_strided_batched_full_rank,&
      rocblas_zsyr2_strided_batched_rank_0,&
      rocblas_zsyr2_strided_batched_rank_1
#endif
  end interface
  !>  ===========================================================================
  !>     level 3 BLAS
  !>  ===========================================================================
  interface rocblas_chemm
    function rocblas_chemm_(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_chemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chemm_full_rank,&
      rocblas_chemm_rank_0,&
      rocblas_chemm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemm performs one of the matrix-matrix operations:
  !> 
  !>     C := alpha*A*B + beta*C if side == rocblas_side_left,
  !>     C := alpha*B*A + beta*C if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B and C are m by n matrices, and
  !>     A is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C := alpha*A*B + beta*C
  !>             rocblas_side_right:     C := alpha*B*A + beta*C
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix
  !>             rocblas_fill_lower:  A is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B and C. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B and C. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A and B are not referenced.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             A is m by m if side == rocblas_side_left
  !>             A is n by n if side == rocblas_side_right
  !>             Only the upper/lower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !>
  interface rocblas_zhemm
    function rocblas_zhemm_(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zhemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhemm_full_rank,&
      rocblas_zhemm_rank_0,&
      rocblas_zhemm_rank_1
#endif
  end interface
  
  interface rocblas_chemm_batched
    function rocblas_chemm_batched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_chemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chemm_batched_full_rank,&
      rocblas_chemm_batched_rank_0,&
      rocblas_chemm_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemm_batched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,
  !>     C_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i
  !>             rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix A_i on the GPU.
  !>             A_i is m by m if side == rocblas_side_left
  !>             A_i is n by n if side == rocblas_side_right
  !>             Only the upper/lower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C_i need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C_i. ldc >= max( 1, m )
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zhemm_batched
    function rocblas_zhemm_batched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zhemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhemm_batched_full_rank,&
      rocblas_zhemm_batched_rank_0,&
      rocblas_zhemm_batched_rank_1
#endif
  end interface
  
  interface rocblas_chemm_strided_batched
    function rocblas_chemm_strided_batched_(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_chemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_chemm_strided_batched_full_rank,&
      rocblas_chemm_strided_batched_rank_0,&
      rocblas_chemm_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemm_strided_batched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,
  !>     C_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i
  !>             rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device pointer to first matrix A_1
  !>             A_i is m by m if side == rocblas_side_left
  !>             A_i is n by n if side == rocblas_side_right
  !>             Only the upper/lower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if side = rocblas_operation_none,  ldb >= max( 1, m ),
  !>             otherwise ldb >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>
  interface rocblas_zhemm_strided_batched
    function rocblas_zhemm_strided_batched_(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zhemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zhemm_strided_batched_full_rank,&
      rocblas_zhemm_strided_batched_rank_0,&
      rocblas_zhemm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cherk
    function rocblas_cherk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_cherk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cherk_full_rank,&
      rocblas_cherk_rank_0,&
      rocblas_cherk_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herk performs one of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C := alpha*op( A )*op( A )^H + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, and A is n by k if transA == rocblas_operation_none
  !>         op( A ) = A^H and A is k by n if transA == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H
  !>             rocblas_operation_none:                 op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if transA = rocblas_operation_none, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface rocblas_zherk
    function rocblas_zherk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_zherk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zherk_full_rank,&
      rocblas_zherk_rank_0,&
      rocblas_zherk_rank_1
#endif
  end interface
  
  interface rocblas_cherk_batched
    function rocblas_cherk_batched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_cherk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cherk_batched_full_rank,&
      rocblas_cherk_batched_rank_0,&
      rocblas_cherk_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herk_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( A_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
  !>         op( A_i ) = A_i^H and A_i is k by n if transA == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op(A) = A^H
  !>             rocblas_operation_none:                op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when transA is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zherk_batched
    function rocblas_zherk_batched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_zherk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zherk_batched_full_rank,&
      rocblas_zherk_batched_rank_0,&
      rocblas_zherk_batched_rank_1
#endif
  end interface
  
  interface rocblas_cherk_strided_batched
    function rocblas_cherk_strided_batched_(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_cherk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cherk_strided_batched_full_rank,&
      rocblas_cherk_strided_batched_rank_0,&
      rocblas_cherk_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herk_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( A_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
  !>         op( A_i ) = A_i^H and A_i is k by n if transA == rocblas_operation_conjugate_transpose
  !> 
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op(A) = A^H
  !>             rocblas_operation_none:                op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when transA is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zherk_strided_batched
    function rocblas_zherk_strided_batched_(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zherk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zherk_strided_batched_full_rank,&
      rocblas_zherk_strided_batched_rank_0,&
      rocblas_zherk_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cher2k
    function rocblas_cher2k_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_cher2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cher2k_full_rank,&
      rocblas_cher2k_rank_0,&
      rocblas_cher2k_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2k performs one of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C := alpha*op( A )*op( B )^H + conj(alpha)*op( B )*op( A )^H + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
  !>         op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose:  op( A ) = A^H, op( B ) = B^H
  !>             rocblas_operation_none:                 op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface rocblas_zher2k
    function rocblas_zher2k_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zher2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zher2k_full_rank,&
      rocblas_zher2k_rank_0,&
      rocblas_zher2k_rank_1
#endif
  end interface
  
  interface rocblas_cher2k_batched
    function rocblas_cher2k_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_cher2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cher2k_batched_full_rank,&
      rocblas_cher2k_batched_rank_0,&
      rocblas_cher2k_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2k_batched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op(A) = A^H
  !>             rocblas_operation_none:                op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zher2k_batched
    function rocblas_zher2k_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zher2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zher2k_batched_full_rank,&
      rocblas_zher2k_batched_rank_0,&
      rocblas_zher2k_batched_rank_1
#endif
  end interface
  
  interface rocblas_cher2k_strided_batched
    function rocblas_cher2k_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_cher2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cher2k_strided_batched_full_rank,&
      rocblas_cher2k_strided_batched_rank_0,&
      rocblas_cher2k_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2k_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op( A_i ) = A_i^H, op( B_i ) = B_i^H
  !>             rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zher2k_strided_batched
    function rocblas_zher2k_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zher2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zher2k_strided_batched_full_rank,&
      rocblas_zher2k_strided_batched_rank_0,&
      rocblas_zher2k_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cherkx
    function rocblas_cherkx_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_cherkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cherkx_full_rank,&
      rocblas_cherkx_rank_0,&
      rocblas_cherkx_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkx performs one of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C := alpha*op( A )*op( B )^H + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.
  !> 
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
  !>         op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose:  op( A ) = A^H, op( B ) = B^H
  !>             rocblas_operation_none:                 op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface rocblas_zherkx
    function rocblas_zherkx_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zherkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zherkx_full_rank,&
      rocblas_zherkx_rank_0,&
      rocblas_zherkx_rank_1
#endif
  end interface
  
  interface rocblas_cherkx_batched
    function rocblas_cherkx_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_cherkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cherkx_batched_full_rank,&
      rocblas_cherkx_batched_rank_0,&
      rocblas_cherkx_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkx_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op(A) = A^H
  !>             rocblas_operation_none:                op(A) = A
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zherkx_batched
    function rocblas_zherkx_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zherkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zherkx_batched_full_rank,&
      rocblas_zherkx_batched_rank_0,&
      rocblas_zherkx_batched_rank_1
#endif
  end interface
  
  interface rocblas_cherkx_strided_batched
    function rocblas_cherkx_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_cherkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cherkx_strided_batched_full_rank,&
      rocblas_cherkx_strided_batched_rank_0,&
      rocblas_cherkx_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkx_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^H + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_conjugate_transpose: op( A_i ) = A_i^H, op( B_i ) = B_i^H
  !>             rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zherkx_strided_batched
    function rocblas_zherkx_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zherkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zherkx_strided_batched_full_rank,&
      rocblas_zherkx_strided_batched_rank_0,&
      rocblas_zherkx_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssymm
    function rocblas_ssymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_ssymm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssymm_full_rank,&
      rocblas_ssymm_rank_0,&
      rocblas_ssymm_rank_1
#endif
  end interface
  
  interface rocblas_dsymm
    function rocblas_dsymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_dsymm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsymm_full_rank,&
      rocblas_dsymm_rank_0,&
      rocblas_dsymm_rank_1
#endif
  end interface
  
  interface rocblas_csymm
    function rocblas_csymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_csymm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csymm_full_rank,&
      rocblas_csymm_rank_0,&
      rocblas_csymm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symm performs one of the matrix-matrix operations:
  !> 
  !>     C := alpha*A*B + beta*C if side == rocblas_side_left,
  !>     C := alpha*B*A + beta*C if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B and C are m by n matrices, and
  !>     A is a symmetric matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C := alpha*A*B + beta*C
  !>             rocblas_side_right:     C := alpha*B*A + beta*C
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix
  !>             rocblas_fill_lower:  A is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B and C. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B and C. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A and B are not referenced.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             A is m by m if side == rocblas_side_left
  !>             A is n by n if side == rocblas_side_right
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !>
  interface rocblas_zsymm
    function rocblas_zsymm_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zsymm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsymm_full_rank,&
      rocblas_zsymm_rank_0,&
      rocblas_zsymm_rank_1
#endif
  end interface
  
  interface rocblas_ssymm_batched
    function rocblas_ssymm_batched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_ssymm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssymm_batched_full_rank,&
      rocblas_ssymm_batched_rank_0,&
      rocblas_ssymm_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsymm_batched
    function rocblas_dsymm_batched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_dsymm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsymm_batched_full_rank,&
      rocblas_dsymm_batched_rank_0,&
      rocblas_dsymm_batched_rank_1
#endif
  end interface
  
  interface rocblas_csymm_batched
    function rocblas_csymm_batched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_csymm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csymm_batched_full_rank,&
      rocblas_csymm_batched_rank_0,&
      rocblas_csymm_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symm_batched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,
  !>     C_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a symmetric matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i
  !>             rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix A_i on the GPU.
  !>             A_i is m by m if side == rocblas_side_left
  !>             A_i is n by n if side == rocblas_side_right
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C_i need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C_i. ldc >= max( 1, m )
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zsymm_batched
    function rocblas_zsymm_batched_(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zsymm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsymm_batched_full_rank,&
      rocblas_zsymm_batched_rank_0,&
      rocblas_zsymm_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssymm_strided_batched
    function rocblas_ssymm_strided_batched_(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_ssymm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssymm_strided_batched_full_rank,&
      rocblas_ssymm_strided_batched_rank_0,&
      rocblas_ssymm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsymm_strided_batched
    function rocblas_dsymm_strided_batched_(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_dsymm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsymm_strided_batched_full_rank,&
      rocblas_dsymm_strided_batched_rank_0,&
      rocblas_dsymm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_csymm_strided_batched
    function rocblas_csymm_strided_batched_(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_csymm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csymm_strided_batched_full_rank,&
      rocblas_csymm_strided_batched_rank_0,&
      rocblas_csymm_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symm_strided_batched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,
  !>     C_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a symmetric matrix stored as either upper or lower.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [rocblas_side]
  !>             rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i
  !>             rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A_i is an upper triangular matrix
  !>             rocblas_fill_lower:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     A       device pointer to first matrix A_1
  !>             A_i is m by m if side == rocblas_side_left
  !>             A_i is n by n if side == rocblas_side_right
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zsymm_strided_batched
    function rocblas_zsymm_strided_batched_(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zsymm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsymm_strided_batched_full_rank,&
      rocblas_zsymm_strided_batched_rank_0,&
      rocblas_zsymm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssyrk
    function rocblas_ssyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_ssyrk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyrk_full_rank,&
      rocblas_ssyrk_rank_0,&
      rocblas_ssyrk_rank_1
#endif
  end interface
  
  interface rocblas_dsyrk
    function rocblas_dsyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_dsyrk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyrk_full_rank,&
      rocblas_dsyrk_rank_0,&
      rocblas_dsyrk_rank_1
#endif
  end interface
  
  interface rocblas_csyrk
    function rocblas_csyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_csyrk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyrk_full_rank,&
      rocblas_csyrk_rank_0,&
      rocblas_csyrk_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrk performs one of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C := alpha*op( A )*op( A )^T + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, and A is n by k if transA == rocblas_operation_none
  !>         op( A ) = A^T and A is k by n if transA == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_transpose:           op(A) = A^T
  !>             rocblas_operation_none:                op(A) = A
  !>             rocblas_operation_conjugate_transpose: op(A) = A^T
  !> 
  !>             rocblas_operation_conjugate_transpose is not supported for complex types, see cherk
  !>             and zherk.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if transA = rocblas_operation_none, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface rocblas_zsyrk
    function rocblas_zsyrk_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc) bind(c, name="rocblas_zsyrk")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyrk_full_rank,&
      rocblas_zsyrk_rank_0,&
      rocblas_zsyrk_rank_1
#endif
  end interface
  
  interface rocblas_ssyrk_batched
    function rocblas_ssyrk_batched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_ssyrk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyrk_batched_full_rank,&
      rocblas_ssyrk_batched_rank_0,&
      rocblas_ssyrk_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsyrk_batched
    function rocblas_dsyrk_batched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_dsyrk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyrk_batched_full_rank,&
      rocblas_dsyrk_batched_rank_0,&
      rocblas_dsyrk_batched_rank_1
#endif
  end interface
  
  interface rocblas_csyrk_batched
    function rocblas_csyrk_batched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_csyrk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyrk_batched_full_rank,&
      rocblas_csyrk_batched_rank_0,&
      rocblas_csyrk_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrk_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( A_i )^T + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
  !>         op( A_i ) = A_i^T and A_i is k by n if transA == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_transpose:           op(A) = A^T
  !>             rocblas_operation_none:                op(A) = A
  !>             rocblas_operation_conjugate_transpose: op(A) = A^T
  !> 
  !>             rocblas_operation_conjugate_transpose is not supported for complex types, see cherk
  !>             and zherk.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when transA is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zsyrk_batched
    function rocblas_zsyrk_batched_(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count) bind(c, name="rocblas_zsyrk_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyrk_batched_full_rank,&
      rocblas_zsyrk_batched_rank_0,&
      rocblas_zsyrk_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssyrk_strided_batched
    function rocblas_ssyrk_strided_batched_(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_ssyrk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyrk_strided_batched_full_rank,&
      rocblas_ssyrk_strided_batched_rank_0,&
      rocblas_ssyrk_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsyrk_strided_batched
    function rocblas_dsyrk_strided_batched_(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_dsyrk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyrk_strided_batched_full_rank,&
      rocblas_dsyrk_strided_batched_rank_0,&
      rocblas_dsyrk_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_csyrk_strided_batched
    function rocblas_csyrk_strided_batched_(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_csyrk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyrk_strided_batched_full_rank,&
      rocblas_csyrk_strided_batched_rank_0,&
      rocblas_csyrk_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrk_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( A_i )^T + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
  !>         op( A_i ) = A_i^T and A_i is k by n if transA == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             rocblas_operation_transpose:           op(A) = A^T
  !>             rocblas_operation_none:                op(A) = A
  !>             rocblas_operation_conjugate_transpose: op(A) = A^T
  !> 
  !>             rocblas_operation_conjugate_transpose is not supported for complex types, see cherk
  !>             and zherk.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when transA is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU. on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zsyrk_strided_batched
    function rocblas_zsyrk_strided_batched_(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zsyrk_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyrk_strided_batched_full_rank,&
      rocblas_zsyrk_strided_batched_rank_0,&
      rocblas_zsyrk_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssyr2k
    function rocblas_ssyr2k_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_ssyr2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyr2k_full_rank,&
      rocblas_ssyr2k_rank_0,&
      rocblas_ssyr2k_rank_1
#endif
  end interface
  
  interface rocblas_dsyr2k
    function rocblas_dsyr2k_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_dsyr2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyr2k_full_rank,&
      rocblas_dsyr2k_rank_0,&
      rocblas_dsyr2k_rank_1
#endif
  end interface
  
  interface rocblas_csyr2k
    function rocblas_csyr2k_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_csyr2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyr2k_full_rank,&
      rocblas_csyr2k_rank_0,&
      rocblas_csyr2k_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2k performs one of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C := alpha*(op( A )*op( B )^T + op( B )*op( A )^T) + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
  !>         op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A ) = A^T, op( B ) = B^T
  !>             rocblas_operation_none:           op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A) and op(B). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface rocblas_zsyr2k
    function rocblas_zsyr2k_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zsyr2k")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyr2k_full_rank,&
      rocblas_zsyr2k_rank_0,&
      rocblas_zsyr2k_rank_1
#endif
  end interface
  
  interface rocblas_ssyr2k_batched
    function rocblas_ssyr2k_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_ssyr2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyr2k_batched_full_rank,&
      rocblas_ssyr2k_batched_rank_0,&
      rocblas_ssyr2k_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsyr2k_batched
    function rocblas_dsyr2k_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_dsyr2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyr2k_batched_full_rank,&
      rocblas_dsyr2k_batched_rank_0,&
      rocblas_dsyr2k_batched_rank_1
#endif
  end interface
  
  interface rocblas_csyr2k_batched
    function rocblas_csyr2k_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_csyr2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyr2k_batched_full_rank,&
      rocblas_csyr2k_batched_rank_0,&
      rocblas_csyr2k_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2k_batched performs a batch of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             rocblas_operation_none:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zsyr2k_batched
    function rocblas_zsyr2k_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zsyr2k_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyr2k_batched_full_rank,&
      rocblas_zsyr2k_batched_rank_0,&
      rocblas_zsyr2k_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssyr2k_strided_batched
    function rocblas_ssyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_ssyr2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyr2k_strided_batched_full_rank,&
      rocblas_ssyr2k_strided_batched_rank_0,&
      rocblas_ssyr2k_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsyr2k_strided_batched
    function rocblas_dsyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_dsyr2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyr2k_strided_batched_full_rank,&
      rocblas_dsyr2k_strided_batched_rank_0,&
      rocblas_dsyr2k_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_csyr2k_strided_batched
    function rocblas_csyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_csyr2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyr2k_strided_batched_full_rank,&
      rocblas_csyr2k_strided_batched_rank_0,&
      rocblas_csyr2k_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2k_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             rocblas_operation_none:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zsyr2k_strided_batched
    function rocblas_zsyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zsyr2k_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyr2k_strided_batched_full_rank,&
      rocblas_zsyr2k_strided_batched_rank_0,&
      rocblas_zsyr2k_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssyrkx
    function rocblas_ssyrkx_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_ssyrkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyrkx_full_rank,&
      rocblas_ssyrkx_rank_0,&
      rocblas_ssyrkx_rank_1
#endif
  end interface
  
  interface rocblas_dsyrkx
    function rocblas_dsyrkx_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_dsyrkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyrkx_full_rank,&
      rocblas_dsyrkx_rank_0,&
      rocblas_dsyrkx_rank_1
#endif
  end interface
  
  interface rocblas_csyrkx
    function rocblas_csyrkx_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_csyrkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyrkx_full_rank,&
      rocblas_csyrkx_rank_0,&
      rocblas_csyrkx_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkx performs one of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C := alpha*op( A )*op( B )^T + beta*C
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be symmetric.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
  !>         op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C is an upper triangular matrix
  !>             rocblas_fill_lower:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A ) = A^T, op( B ) = B^T
  !>             rocblas_operation_none:           op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A) and op(B). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     B       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>
  interface rocblas_zsyrkx
    function rocblas_zsyrkx_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zsyrkx")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyrkx_full_rank,&
      rocblas_zsyrkx_rank_0,&
      rocblas_zsyrkx_rank_1
#endif
  end interface
  
  interface rocblas_ssyrkx_batched
    function rocblas_ssyrkx_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_ssyrkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyrkx_batched_full_rank,&
      rocblas_ssyrkx_batched_rank_0,&
      rocblas_ssyrkx_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsyrkx_batched
    function rocblas_dsyrkx_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_dsyrkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyrkx_batched_full_rank,&
      rocblas_dsyrkx_batched_rank_0,&
      rocblas_dsyrkx_batched_rank_1
#endif
  end interface
  
  interface rocblas_csyrkx_batched
    function rocblas_csyrkx_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_csyrkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyrkx_batched_full_rank,&
      rocblas_csyrkx_batched_rank_0,&
      rocblas_csyrkx_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkx_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^T + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             rocblas_operation_none:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>             number of instances in the batch.
  !>
  interface rocblas_zsyrkx_batched
    function rocblas_zsyrkx_batched_(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zsyrkx_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyrkx_batched_full_rank,&
      rocblas_zsyrkx_batched_rank_0,&
      rocblas_zsyrkx_batched_rank_1
#endif
  end interface
  
  interface rocblas_ssyrkx_strided_batched
    function rocblas_ssyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_ssyrkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ssyrkx_strided_batched_full_rank,&
      rocblas_ssyrkx_strided_batched_rank_0,&
      rocblas_ssyrkx_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dsyrkx_strided_batched
    function rocblas_dsyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_dsyrkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dsyrkx_strided_batched_full_rank,&
      rocblas_dsyrkx_strided_batched_rank_0,&
      rocblas_dsyrkx_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_csyrkx_strided_batched
    function rocblas_csyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_csyrkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_csyrkx_strided_batched_full_rank,&
      rocblas_csyrkx_strided_batched_rank_0,&
      rocblas_csyrkx_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkx_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alpha*op( A_i )*op( B_i )^T + beta*C_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  C_i is an upper triangular matrix
  !>             rocblas_fill_lower:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     trans  [rocblas_operation]
  !>             rocblas_operation_transpose:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             rocblas_operation_none:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [rocblas_int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = rocblas_operation_none,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is rocblas_operation_none, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [rocblas_int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = rocblas_operation_none,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     C       Device pointer to the first matrix C_1 on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [rocblas_int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zsyrkx_strided_batched
    function rocblas_zsyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count) bind(c, name="rocblas_zsyrkx_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_C
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zsyrkx_strided_batched_full_rank,&
      rocblas_zsyrkx_strided_batched_rank_0,&
      rocblas_zsyrkx_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_strmm
    function rocblas_strmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_strmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strmm_full_rank,&
      rocblas_strmm_rank_0,&
      rocblas_strmm_rank_1
#endif
  end interface
  
  interface rocblas_dtrmm
    function rocblas_dtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_dtrmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrmm_full_rank,&
      rocblas_dtrmm_rank_0,&
      rocblas_dtrmm_rank_1
#endif
  end interface
  
  interface rocblas_ctrmm
    function rocblas_ctrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_ctrmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrmm_full_rank,&
      rocblas_ctrmm_rank_0,&
      rocblas_ctrmm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm performs one of the matrix-matrix operations
  !> 
  !>     B := alpha*op( A )*B,   or   B := alpha*B*op( A )
  !> 
  !>     where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     When uplo == rocblas_fill_upper the  leading  k by k
  !>     upper triangular part of the array  A must contain the upper
  !>     triangular matrix and the strictly lower triangular part of
  !>     A is not referenced. Here k is m when side == rocblas_side_left
  !>     and is n when side == rocblas_side_right.
  !> 
  !>     When uplo == rocblas_fill_lower the  leading  k by k
  !>     lower triangular part of the array  A must contain the lower
  !>     triangular matrix  and the strictly upper triangular part of
  !>     A is not referenced. Here k is m when  side == rocblas_side_left
  !>     and is n when side == rocblas_side_right.
  !> 
  !>     Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
  !>     A  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             Specifies whether op(A) multiplies B from the left or right as follows:
  !>             rocblas_side_left:       B := alpha*op( A )*B.
  !>             rocblas_side_right:      B := alpha*B*op( A ).
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             Specifies the form of op(A) to be used in the matrix multiplication as follows:
  !>             rocblas_operation_none:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             Specifies whether or not A is unit triangular as follows:
  !>             rocblas_diagonal_unit:      A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to matrix A on the GPU.
  !>             A has dimension ( lda, k ), where k is m
  !>             when  side == rocblas_side_left  and
  !>             is  n  when  side == rocblas_side_right.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side == rocblas_side_left,  lda >= max( 1, m ),
  !>             if side == rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     B       Device pointer to the first matrix B_0 on the GPU.
  !>             On entry,  the leading  m by n part of the array  B must
  !>            contain the matrix  B,  and  on exit  is overwritten  by the
  !>            transformed matrix.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !>
  interface rocblas_ztrmm
    function rocblas_ztrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_ztrmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrmm_full_rank,&
      rocblas_ztrmm_rank_0,&
      rocblas_ztrmm_rank_1
#endif
  end interface
  
  interface rocblas_strmm_batched
    function rocblas_strmm_batched_(handle,side,uplo,transa,diag,m,n,alpha,a,lda,c,ldc,batch_count) bind(c, name="rocblas_strmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: a
      integer(c_int),value :: lda
      type(c_ptr) :: c
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_dtrmm_batched
    function rocblas_dtrmm_batched_(handle,side,uplo,transa,diag,m,n,alpha,a,lda,c,ldc,batch_count) bind(c, name="rocblas_dtrmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: a
      integer(c_int),value :: lda
      type(c_ptr) :: c
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_ctrmm_batched
    function rocblas_ctrmm_batched_(handle,side,uplo,transa,diag,m,n,alpha,a,lda,c,ldc,batch_count) bind(c, name="rocblas_ctrmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: a
      integer(c_int),value :: lda
      type(c_ptr) :: c
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm_batched performs one of the batched matrix-matrix operations
  !> 
  !>     B_i := alpha*op( A_i )*B_i,   or   B_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1
  !> 
  !>     where  alpha  is a scalar,  B_i  is an m by n matrix,  A_i  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             Specifies whether op(A_i) multiplies B_i from the left or right as follows:
  !>             rocblas_side_left:       B_i := alpha*op( A_i )*B_i.
  !>             rocblas_side_right:      B_i := alpha*B_i*op( A_i ).
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
  !>             rocblas_operation_none:    op(A_i) = A_i.
  !>             rocblas_operation_transpose:      op(A_i) = A_i^T.
  !>             rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             Specifies whether or not A_i is unit triangular as follows:
  !>             rocblas_diagonal_unit:      A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i is not referenced and B_i need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device array of device pointers storing each matrix A_i on the GPU.
  !>             Each A_i is of dimension ( lda, k ), where k is m
  !>             when  side == rocblas_side_left  and
  !>             is  n  when  side == rocblas_side_right.
  !> 
  !>         When uplo == rocblas_fill_upper the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == rocblas_fill_lower the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
  !>         A_i  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side == rocblas_side_left,  lda >= max( 1, m ),
  !>             if side == rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>             On entry,  the leading  m by n part of the array  B_i must
  !>            contain the matrix  B_i,  and  on exit  is overwritten  by the
  !>            transformed matrix.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  interface rocblas_ztrmm_batched
    function rocblas_ztrmm_batched_(handle,side,uplo,transa,diag,m,n,alpha,a,lda,c,ldc,batch_count) bind(c, name="rocblas_ztrmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: a
      integer(c_int),value :: lda
      type(c_ptr) :: c
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_strmm_strided_batched
    function rocblas_strmm_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,a,lda,stride_a,c,ldc,stride_c,batch_count) bind(c, name="rocblas_strmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: a
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: c
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_dtrmm_strided_batched
    function rocblas_dtrmm_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,a,lda,stride_a,c,ldc,stride_c,batch_count) bind(c, name="rocblas_dtrmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: a
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: c
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_ctrmm_strided_batched
    function rocblas_ctrmm_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,a,lda,stride_a,c,ldc,stride_c,batch_count) bind(c, name="rocblas_ctrmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: a
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: c
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm_strided_batched performs one of the strided_batched matrix-matrix operations
  !> 
  !>     B_i := alpha*op( A_i )*B_i,   or   B_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1
  !> 
  !>     where  alpha  is a scalar,  B_i  is an m by n matrix,  A_i  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             Specifies whether op(A_i) multiplies B_i from the left or right as follows:
  !>             rocblas_side_left:       B_i := alpha*op( A_i )*B_i.
  !>             rocblas_side_right:      B_i := alpha*B_i*op( A_i ).
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
  !>             rocblas_operation_none:    op(A_i) = A_i.
  !>             rocblas_operation_transpose:      op(A_i) = A_i^T.
  !>             rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             Specifies whether or not A_i is unit triangular as follows:
  !>             rocblas_diagonal_unit:      A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i is not referenced and B_i need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_0 on the GPU.
  !>             Each A_i is of dimension ( lda, k ), where k is m
  !>             when  side == rocblas_side_left  and
  !>             is  n  when  side == rocblas_side_right.
  !> 
  !>         When uplo == rocblas_fill_upper the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == rocblas_fill_lower the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
  !>         A_i  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side == rocblas_side_left,  lda >= max( 1, m ),
  !>             if side == rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[inout]
  !>     B       Device pointer to the first matrix B_0 on the GPU.
  !>             On entry,  the leading  m by n part of the array  B_i must
  !>            contain the matrix  B_i,  and  on exit  is overwritten  by the
  !>            transformed matrix.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).
  !> 
  !>            @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  interface rocblas_ztrmm_strided_batched
    function rocblas_ztrmm_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,a,lda,stride_a,c,ldc,stride_c,batch_count) bind(c, name="rocblas_ztrmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: a
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: c
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_strmm_outofplace
    function rocblas_strmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="rocblas_strmm_outofplace")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strmm_outofplace_full_rank,&
      rocblas_strmm_outofplace_rank_0,&
      rocblas_strmm_outofplace_rank_1
#endif
  end interface
  
  interface rocblas_dtrmm_outofplace
    function rocblas_dtrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="rocblas_dtrmm_outofplace")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrmm_outofplace_full_rank,&
      rocblas_dtrmm_outofplace_rank_0,&
      rocblas_dtrmm_outofplace_rank_1
#endif
  end interface
  
  interface rocblas_ctrmm_outofplace
    function rocblas_ctrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="rocblas_ctrmm_outofplace")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrmm_outofplace_full_rank,&
      rocblas_ctrmm_outofplace_rank_0,&
      rocblas_ctrmm_outofplace_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm_outofplace performs one of the matrix-matrix operations
  !> 
  !>     C := alpha*op( A )*B,   or   C := alpha*B*op( A )
  !> 
  !>     where  alpha  is a scalar,  B and C are m by n matrices,  A  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     Note that trmm_outofplace can provide in-place functionality in the same way as trmm
  !>     by passing in the same address for both matrices B and C.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             Specifies whether op(A) multiplies B from the left or right as follows:
  !>             rocblas_side_left:       C := alpha*op( A )*B.
  !>             rocblas_side_right:      C := alpha*B*op( A ).
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             Specifies the form of op(A) to be used in the matrix multiplication as follows:
  !>             rocblas_operation_none:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             Specifies whether or not A is unit triangular as follows:
  !>             rocblas_diagonal_unit:      A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to matrix A on the GPU.
  !>             A has dimension ( lda, k ), where k is m
  !>             when  side == rocblas_side_left  and
  !>             is  n  when  side == rocblas_side_right.
  !> 
  !>         When uplo == rocblas_fill_upper the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == rocblas_fill_lower the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
  !>         A  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side == rocblas_side_left,  lda >= max( 1, m ),
  !>             if side == rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       Device pointer to the matrix B on the GPU.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !> 
  !>     @param[out]
  !>     C      Device pointer to the matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc   [rocblas_int]
  !>           ldc specifies the first dimension of C. ldc >= max( 1, m).
  !>
  interface rocblas_ztrmm_outofplace
    function rocblas_ztrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="rocblas_ztrmm_outofplace")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrmm_outofplace_full_rank,&
      rocblas_ztrmm_outofplace_rank_0,&
      rocblas_ztrmm_outofplace_rank_1
#endif
  end interface
  
  interface rocblas_strmm_outofplace_batched
    function rocblas_strmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_strmm_outofplace_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strmm_outofplace_batched_full_rank,&
      rocblas_strmm_outofplace_batched_rank_0,&
      rocblas_strmm_outofplace_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtrmm_outofplace_batched
    function rocblas_dtrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_dtrmm_outofplace_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrmm_outofplace_batched_full_rank,&
      rocblas_dtrmm_outofplace_batched_rank_0,&
      rocblas_dtrmm_outofplace_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctrmm_outofplace_batched
    function rocblas_ctrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_ctrmm_outofplace_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrmm_outofplace_batched_full_rank,&
      rocblas_ctrmm_outofplace_batched_rank_0,&
      rocblas_ctrmm_outofplace_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm_outofplace_batched performs one of the batched matrix-matrix operations
  !> 
  !>     C_i := alpha*op( A_i )*B_i,   or   C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1
  !> 
  !>     where  alpha  is a scalar,  B_i  is an m by n matrix,  A_i  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     Note that trmm_outofplace_batched can provide in-place functionality in the same way as trmm_batched
  !>     by passing in the same address for both matrices B and C.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             Specifies whether op(A_i) multiplies B_i from the left or right as follows:
  !>             rocblas_side_left:       C_i := alpha*op( A_i )*B_i.
  !>             rocblas_side_right:      C_i := alpha*B_i*op( A_i ).
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
  !>             rocblas_operation_none:    op(A_i) = A_i.
  !>             rocblas_operation_transpose:      op(A_i) = A_i^T.
  !>             rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             Specifies whether or not A_i is unit triangular as follows:
  !>             rocblas_diagonal_unit:      A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i is not referenced and B_i need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device array of device pointers storing each matrix A_i on the GPU.
  !>             Each A_i is of dimension ( lda, k ), where k is m
  !>             when  side == rocblas_side_left  and
  !>             is  n  when  side == rocblas_side_right.
  !> 
  !>         When uplo == rocblas_fill_upper the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == rocblas_fill_lower the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
  !>         A_i  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side == rocblas_side_left,  lda >= max( 1, m ),
  !>             if side == rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[out]
  !>     C      device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc   [rocblas_int]
  !>           ldc specifies the first dimension of C. ldc >= max( 1, m).
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  interface rocblas_ztrmm_outofplace_batched
    function rocblas_ztrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_ztrmm_outofplace_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrmm_outofplace_batched_full_rank,&
      rocblas_ztrmm_outofplace_batched_rank_0,&
      rocblas_ztrmm_outofplace_batched_rank_1
#endif
  end interface
  
  interface rocblas_strmm_outofplace_strided_batched
    function rocblas_strmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_strmm_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strmm_outofplace_strided_batched_full_rank,&
      rocblas_strmm_outofplace_strided_batched_rank_0,&
      rocblas_strmm_outofplace_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtrmm_outofplace_strided_batched
    function rocblas_dtrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_dtrmm_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrmm_outofplace_strided_batched_full_rank,&
      rocblas_dtrmm_outofplace_strided_batched_rank_0,&
      rocblas_dtrmm_outofplace_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctrmm_outofplace_strided_batched
    function rocblas_ctrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_ctrmm_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrmm_outofplace_strided_batched_full_rank,&
      rocblas_ctrmm_outofplace_strided_batched_rank_0,&
      rocblas_ctrmm_outofplace_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm_outofplace_strided_batched performs one of the strided_batched matrix-matrix operations
  !> 
  !>     C_i := alpha*op( A_i )*B_i,   or   C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1
  !> 
  !>     where  alpha  is a scalar,  B_i  is an m by n matrix,  A_i  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     Note that trmm_outofplace_strided_batched can provide in-place functionality in the same way as trmm_strided_batched
  !>     by passing in the same address for both matrices B and C.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             Specifies whether op(A_i) multiplies B_i from the left or right as follows:
  !>             rocblas_side_left:       C_i := alpha*op( A_i )*B_i.
  !>             rocblas_side_right:      C_i := alpha*B_i*op( A_i ).
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
  !>             rocblas_operation_none:    op(A_i) = A_i.
  !>             rocblas_operation_transpose:      op(A_i) = A_i^T.
  !>             rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             Specifies whether or not A_i is unit triangular as follows:
  !>             rocblas_diagonal_unit:      A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i is not referenced and B_i need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_0 on the GPU.
  !>             Each A_i is of dimension ( lda, k ), where k is m
  !>             when  side == rocblas_side_left  and
  !>             is  n  when  side == rocblas_side_right.
  !> 
  !>         When uplo == rocblas_fill_upper the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == rocblas_fill_lower the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
  !>         A_i  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side == rocblas_side_left,  lda >= max( 1, m ),
  !>             if side == rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     B       Device pointer to the first matrix B_0 on the GPU.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[out]
  !>     C      Device pointer to the first matrix C_0 on the GPU.
  !> 
  !>     @param[in]
  !>     ldc   [rocblas_int]
  !>           ldc specifies the first dimension of C_i. ldc >= max( 1, m).
  !> 
  !>     @param[in]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  interface rocblas_ztrmm_outofplace_strided_batched
    function rocblas_ztrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_ztrmm_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrmm_outofplace_strided_batched_full_rank,&
      rocblas_ztrmm_outofplace_strided_batched_rank_0,&
      rocblas_ztrmm_outofplace_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_strtri
    function rocblas_strtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="rocblas_strtri")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strtri_full_rank,&
      rocblas_strtri_rank_0,&
      rocblas_strtri_rank_1
#endif
  end interface
  
  interface rocblas_dtrtri
    function rocblas_dtrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="rocblas_dtrtri")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrtri_full_rank,&
      rocblas_dtrtri_rank_0,&
      rocblas_dtrtri_rank_1
#endif
  end interface
  
  interface rocblas_ctrtri
    function rocblas_ctrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="rocblas_ctrtri")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrtri_full_rank,&
      rocblas_ctrtri_rank_0,&
      rocblas_ctrtri_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtri  compute the inverse of a matrix A, namely, invA
  !> 
  !>         and write the result into invA;
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>               if rocblas_fill_upper, the lower part of A is not referenced
  !>               if rocblas_fill_lower, the upper part of A is not referenced
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               = 'rocblas_diagonal_non_unit', A is non-unit triangular;
  !>               = 'rocblas_diagonal_unit', A is unit triangular;
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               size of matrix A and invA
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[out]
  !>     invA      device pointer storing matrix invA.
  !>     @param[in]
  !>     ldinvA    [rocblas_int]
  !>               specifies the leading dimension of invA.
  !>
  interface rocblas_ztrtri
    function rocblas_ztrtri_(handle,uplo,diag,n,A,lda,invA,ldinvA) bind(c, name="rocblas_ztrtri")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrtri_full_rank,&
      rocblas_ztrtri_rank_0,&
      rocblas_ztrtri_rank_1
#endif
  end interface
  
  interface rocblas_strtri_batched
    function rocblas_strtri_batched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count) bind(c, name="rocblas_strtri_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strtri_batched_full_rank,&
      rocblas_strtri_batched_rank_0,&
      rocblas_strtri_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtrtri_batched
    function rocblas_dtrtri_batched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count) bind(c, name="rocblas_dtrtri_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrtri_batched_full_rank,&
      rocblas_dtrtri_batched_rank_0,&
      rocblas_dtrtri_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctrtri_batched
    function rocblas_ctrtri_batched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count) bind(c, name="rocblas_ctrtri_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrtri_batched_full_rank,&
      rocblas_ctrtri_batched_rank_0,&
      rocblas_ctrtri_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtri_batched  compute the inverse of A_i and write into invA_i where
  !>                    A_i and invA_i are the i-th matrices in the batch,
  !>                    for i = 1, ..., batch_count.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               = 'rocblas_diagonal_non_unit', A is non-unit triangular;
  !>               = 'rocblas_diagonal_unit', A is unit triangular;
  !>     @param[in]
  !>     n         [rocblas_int]
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[out]
  !>     invA      device array of device pointers storing the inverse of each matrix A_i.
  !>               Partial inplace operation is supported, see below.
  !>               If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
  !>               the inverse of the upper triangular matrix, and the strictly lower
  !>               triangular part of invA is cleared.
  !>               If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
  !>               the inverse of the lower triangular matrix, and the strictly upper
  !>               triangular part of invA is cleared.
  !>     @param[in]
  !>     ldinvA    [rocblas_int]
  !>               specifies the leading dimension of each invA_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               numbers of matrices in the batch
  interface rocblas_ztrtri_batched
    function rocblas_ztrtri_batched_(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count) bind(c, name="rocblas_ztrtri_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrtri_batched_full_rank,&
      rocblas_ztrtri_batched_rank_0,&
      rocblas_ztrtri_batched_rank_1
#endif
  end interface
  
  interface rocblas_strtri_strided_batched
    function rocblas_strtri_strided_batched_(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count) bind(c, name="rocblas_strtri_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strtri_strided_batched_full_rank,&
      rocblas_strtri_strided_batched_rank_0,&
      rocblas_strtri_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtrtri_strided_batched
    function rocblas_dtrtri_strided_batched_(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count) bind(c, name="rocblas_dtrtri_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrtri_strided_batched_full_rank,&
      rocblas_dtrtri_strided_batched_rank_0,&
      rocblas_dtrtri_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctrtri_strided_batched
    function rocblas_ctrtri_strided_batched_(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count) bind(c, name="rocblas_ctrtri_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrtri_strided_batched_full_rank,&
      rocblas_ctrtri_strided_batched_rank_0,&
      rocblas_ctrtri_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtri_strided_batched compute the inverse of A_i and write into invA_i where
  !>                    A_i and invA_i are the i-th matrices in the batch,
  !>                    for i = 1, ..., batch_count
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     uplo      [rocblas_fill]
  !>               specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
  !>     @param[in]
  !>     diag      [rocblas_diagonal]
  !>               = 'rocblas_diagonal_non_unit', A is non-unit triangular;
  !>               = 'rocblas_diagonal_unit', A is unit triangular;
  !>     @param[in]
  !>     n         [rocblas_int]
  !>     @param[in]
  !>     A         device pointer pointing to address of first matrix A_1.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A.
  !>     @param[in]
  !>     stride_a  [rocblas_stride]
  !>              "batch stride a": stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[out]
  !>     invA      device pointer storing the inverses of each matrix A_i.
  !>               Partial inplace operation is supported, see below.
  !>               If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
  !>               the inverse of the upper triangular matrix, and the strictly lower
  !>               triangular part of invA is cleared.
  !>               If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
  !>               the inverse of the lower triangular matrix, and the strictly upper
  !>               triangular part of invA is cleared.
  !>     @param[in]
  !>     ldinvA    [rocblas_int]
  !>               specifies the leading dimension of each invA_i.
  !>     @param[in]
  !>     stride_invA  [rocblas_stride]
  !>                  "batch stride invA": stride from the start of one invA_i matrix to the next invA_(i + 1).
  !>     @param[in]
  !>     batch_count  [rocblas_int]
  !>                  numbers of matrices in the batch
  interface rocblas_ztrtri_strided_batched
    function rocblas_ztrtri_strided_batched_(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count) bind(c, name="rocblas_ztrtri_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrtri_strided_batched_full_rank,&
      rocblas_ztrtri_strided_batched_rank_0,&
      rocblas_ztrtri_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_strsm
    function rocblas_strsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_strsm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strsm_full_rank,&
      rocblas_strsm_rank_0,&
      rocblas_strsm_rank_1
#endif
  end interface
  
  interface rocblas_dtrsm
    function rocblas_dtrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_dtrsm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrsm_full_rank,&
      rocblas_dtrsm_rank_0,&
      rocblas_dtrsm_rank_1
#endif
  end interface
  
  interface rocblas_ctrsm
    function rocblas_ctrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_ctrsm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrsm_full_rank,&
      rocblas_ctrsm_rank_0,&
      rocblas_ctrsm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trsm solves
  !> 
  !>         op(A)*X = alpha*B or  X*op(A) = alpha*B,
  !> 
  !>     where alpha is a scalar, X and B are m by n matrices,
  !>     A is triangular matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     The matrix X is overwritten on B.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !> 
  !>     (where k is m when rocblas_side_left and is n when rocblas_side_right)
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             rocblas_side_left:       op(A)*X = alpha*B.
  !>             rocblas_side_right:      X*op(A) = alpha*B.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             transB:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       device pointer storing matrix A.
  !>             of dimension ( lda, k ), where k is m
  !>             when  rocblas_side_left  and
  !>             is  n  when  rocblas_side_right
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             if side = rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in,out]
  !>     B       device pointer storing matrix B.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !>
  interface rocblas_ztrsm
    function rocblas_ztrsm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb) bind(c, name="rocblas_ztrsm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrsm_full_rank,&
      rocblas_ztrsm_rank_0,&
      rocblas_ztrsm_rank_1
#endif
  end interface
  
  interface rocblas_strsm_batched
    function rocblas_strsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count) bind(c, name="rocblas_strsm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strsm_batched_full_rank,&
      rocblas_strsm_batched_rank_0,&
      rocblas_strsm_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtrsm_batched
    function rocblas_dtrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count) bind(c, name="rocblas_dtrsm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrsm_batched_full_rank,&
      rocblas_dtrsm_batched_rank_0,&
      rocblas_dtrsm_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctrsm_batched
    function rocblas_ctrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count) bind(c, name="rocblas_ctrsm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrsm_batched_full_rank,&
      rocblas_ctrsm_batched_rank_0,&
      rocblas_ctrsm_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !>     \details
  !>     trsm_batched performs the following batched operation:
  !> 
  !>         op(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batch_count.
  !> 
  !>     where alpha is a scalar, X and B are batched m by n matrices,
  !>     A is triangular batched matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i for i = 1, ..., batch_count.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !>     (where k is m when rocblas_side_left and is n when rocblas_side_right)
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             rocblas_side_left:       op(A)*X = alpha*B.
  !>             rocblas_side_right:      X*op(A) = alpha*B.
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  each A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  each A_i is a  lower triangular matrix.
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             transB:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !>     @param[in]
  !>     A       device array of device pointers storing each matrix A_i on the GPU.
  !>             Matricies are of dimension ( lda, k ), where k is m
  !>             when  rocblas_side_left  and is  n  when  rocblas_side_right
  !>             only the upper/lower triangular part is accessed.
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of each A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             if side = rocblas_side_right, lda >= max( 1, n ).
  !>     @param[in,out]
  !>     B       device array of device pointers storing each matrix B_i on the GPU.
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of trsm operatons in the batch.
  interface rocblas_ztrsm_batched
    function rocblas_ztrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count) bind(c, name="rocblas_ztrsm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrsm_batched_full_rank,&
      rocblas_ztrsm_batched_rank_0,&
      rocblas_ztrsm_batched_rank_1
#endif
  end interface
  
  interface rocblas_strsm_strided_batched
    function rocblas_strsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count) bind(c, name="rocblas_strsm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_strsm_strided_batched_full_rank,&
      rocblas_strsm_strided_batched_rank_0,&
      rocblas_strsm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dtrsm_strided_batched
    function rocblas_dtrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count) bind(c, name="rocblas_dtrsm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dtrsm_strided_batched_full_rank,&
      rocblas_dtrsm_strided_batched_rank_0,&
      rocblas_dtrsm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ctrsm_strided_batched
    function rocblas_ctrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count) bind(c, name="rocblas_ctrsm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ctrsm_strided_batched_full_rank,&
      rocblas_ctrsm_strided_batched_rank_0,&
      rocblas_ctrsm_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !>     \details
  !>     trsm_srided_batched performs the following strided batched operation:
  !> 
  !>         op(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batch_count.
  !> 
  !>     where alpha is a scalar, X and B are strided batched m by n matrices,
  !>     A is triangular strided batched matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i for i = 1, ..., batch_count.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !>     (where k is m when rocblas_side_left and is n when rocblas_side_right)
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             rocblas_side_left:       op(A)*X = alpha*B.
  !>             rocblas_side_right:      X*op(A) = alpha*B.
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  each A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  each A_i is a  lower triangular matrix.
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             transB:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !>     @param[in]
  !>     A       device pointer pointing to the first matrix A_1.
  !>             of dimension ( lda, k ), where k is m
  !>             when  rocblas_side_left  and
  !>             is  n  when  rocblas_side_right
  !>             only the upper/lower triangular part is accessed.
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of each A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             if side = rocblas_side_right, lda >= max( 1, n ).
  !>     @param[in]
  !>     stride_a [rocblas_stride]
  !>              stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[in,out]
  !>     B       device pointer pointing to the first matrix B_1.
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !>     @param[in]
  !>     stride_b [rocblas_stride]
  !>              stride from the start of one B_i matrix to the next B_(i + 1).
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of trsm operatons in the batch.
  interface rocblas_ztrsm_strided_batched
    function rocblas_ztrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count) bind(c, name="rocblas_ztrsm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ztrsm_strided_batched_full_rank,&
      rocblas_ztrsm_strided_batched_rank_0,&
      rocblas_ztrsm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sgemm
    function rocblas_sgemm_(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_sgemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgemm_full_rank,&
      rocblas_sgemm_rank_0,&
      rocblas_sgemm_rank_1
#endif
  end interface
  
  interface rocblas_dgemm
    function rocblas_dgemm_(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_dgemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgemm_full_rank,&
      rocblas_dgemm_rank_0,&
      rocblas_dgemm_rank_1
#endif
  end interface
  
  interface rocblas_hgemm
    function rocblas_hgemm_(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_hgemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_hgemm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
    end function

  end interface
  
  interface rocblas_cgemm
    function rocblas_cgemm_(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_cgemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgemm_full_rank,&
      rocblas_cgemm_rank_0,&
      rocblas_cgemm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     gemm performs one of the matrix-matrix operations
  !> 
  !>         C = alpha*op( A )*op( B ) + beta*C,
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !> 
  !>     alpha and beta are scalars, and A, B and C are matrices, with
  !>     op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               number or rows of matrices op( A ) and C
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of columns of matrices op( B ) and C
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               number of columns of matrix op( A ) and number of rows of matrix op( B )
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     B         device pointer storing matrix B.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of B.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in, out]
  !>     C         device pointer storing matrix C on the GPU.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !>
  interface rocblas_zgemm
    function rocblas_zgemm_(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc) bind(c, name="rocblas_zgemm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgemm_full_rank,&
      rocblas_zgemm_rank_0,&
      rocblas_zgemm_rank_1
#endif
  end interface
  
  interface rocblas_sgemm_batched
    function rocblas_sgemm_batched_(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_sgemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgemm_batched_full_rank,&
      rocblas_sgemm_batched_rank_0,&
      rocblas_sgemm_batched_rank_1
#endif
  end interface
  
  interface rocblas_dgemm_batched
    function rocblas_dgemm_batched_(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_dgemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgemm_batched_full_rank,&
      rocblas_dgemm_batched_rank_0,&
      rocblas_dgemm_batched_rank_1
#endif
  end interface
  
  interface rocblas_hgemm_batched
    function rocblas_hgemm_batched_(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_hgemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_hgemm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_cgemm_batched
    function rocblas_cgemm_batched_(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_cgemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgemm_batched_full_rank,&
      rocblas_cgemm_batched_rank_0,&
      rocblas_cgemm_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !>      \details
  !>     gemm_batched performs one of the batched matrix-matrix operations
  !>          C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batch_count.
  !>      where op( X ) is one of
  !>          op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !>      alpha and beta are scalars, and A, B and C are strided batched matrices, with
  !>     op( A ) an m by k by batch_count strided_batched matrix,
  !>     op( B ) an k by n by batch_count strided_batched matrix and
  !>     C an m by n by batch_count strided_batched matrix.
  !>     @param[in]
  !>     handle    [rocblas_handle
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimention m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimention n.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               matrix dimention k.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     B         device array of device pointers storing each matrix B_i.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of each B_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in, out]
  !>     C         device array of device pointers storing each matrix C_i.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of each C_i.
  !>     @param[in]
  !>     batch_count
  !>               [rocblas_int]
  !>               number of gemm operations in the batch
  interface rocblas_zgemm_batched
    function rocblas_zgemm_batched_(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count) bind(c, name="rocblas_zgemm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgemm_batched_full_rank,&
      rocblas_zgemm_batched_rank_0,&
      rocblas_zgemm_batched_rank_1
#endif
  end interface
  
  interface rocblas_sgemm_strided_batched
    function rocblas_sgemm_strided_batched_(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_sgemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgemm_strided_batched_full_rank,&
      rocblas_sgemm_strided_batched_rank_0,&
      rocblas_sgemm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dgemm_strided_batched
    function rocblas_dgemm_strided_batched_(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_dgemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgemm_strided_batched_full_rank,&
      rocblas_dgemm_strided_batched_rank_0,&
      rocblas_dgemm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_hgemm_strided_batched
    function rocblas_hgemm_strided_batched_(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_hgemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_hgemm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_hgemm_kernel_name
    function rocblas_hgemm_kernel_name_(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_hgemm_kernel_name")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_hgemm_kernel_name_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr) :: beta
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

  end interface
  
  interface rocblas_sgemm_kernel_name
    function rocblas_sgemm_kernel_name_(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_sgemm_kernel_name")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_kernel_name_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_float) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgemm_kernel_name_full_rank,&
      rocblas_sgemm_kernel_name_rank_0,&
      rocblas_sgemm_kernel_name_rank_1
#endif
  end interface
  
  interface rocblas_dgemm_kernel_name
    function rocblas_dgemm_kernel_name_(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_dgemm_kernel_name")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_kernel_name_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      real(c_double) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgemm_kernel_name_full_rank,&
      rocblas_dgemm_kernel_name_rank_0,&
      rocblas_dgemm_kernel_name_rank_1
#endif
  end interface
  
  interface rocblas_cgemm_strided_batched
    function rocblas_cgemm_strided_batched_(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_cgemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_float_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgemm_strided_batched_full_rank,&
      rocblas_cgemm_strided_batched_rank_0,&
      rocblas_cgemm_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     gemm_strided_batched performs one of the strided batched matrix-matrix operations
  !> 
  !>         C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batch_count.
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !> 
  !>     alpha and beta are scalars, and A, B and C are strided batched matrices, with
  !>     op( A ) an m by k by batch_count strided_batched matrix,
  !>     op( B ) an k by n by batch_count strided_batched matrix and
  !>     C an m by n by batch_count strided_batched matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimention m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimention n.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               matrix dimention k.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device pointer pointing to the first matrix A_1.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     stride_a  [rocblas_stride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[in]
  !>     B         device pointer pointing to the first matrix B_1.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of each B_i.
  !>     @param[in]
  !>     stride_b  [rocblas_stride]
  !>               stride from the start of one B_i matrix to the next B_(i + 1).
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in, out]
  !>     C         device pointer pointing to the first matrix C_1.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of each C_i.
  !>     @param[in]
  !>     stride_c  [rocblas_stride]
  !>               stride from the start of one C_i matrix to the next C_(i + 1).
  !>     @param[in]
  !>     batch_count
  !>               [rocblas_int]
  !>               number of gemm operatons in the batch
  !>
  interface rocblas_zgemm_strided_batched
    function rocblas_zgemm_strided_batched_(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count) bind(c, name="rocblas_zgemm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transa
      integer(kind(rocblas_operation_none)),value :: transb
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      complex(c_double_complex) :: beta
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgemm_strided_batched_full_rank,&
      rocblas_zgemm_strided_batched_rank_0,&
      rocblas_zgemm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sdgmm
    function rocblas_sdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="rocblas_sdgmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sdgmm_full_rank,&
      rocblas_sdgmm_rank_0,&
      rocblas_sdgmm_rank_1
#endif
  end interface
  
  interface rocblas_ddgmm
    function rocblas_ddgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="rocblas_ddgmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ddgmm_full_rank,&
      rocblas_ddgmm_rank_0,&
      rocblas_ddgmm_rank_1
#endif
  end interface
  
  interface rocblas_cdgmm
    function rocblas_cdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="rocblas_cdgmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cdgmm_full_rank,&
      rocblas_cdgmm_rank_0,&
      rocblas_cdgmm_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     dgmm performs one of the matrix-matrix operations
  !> 
  !>         C = A * diag(x) if side == rocblas_side_right
  !>         C = diag(x) * A if side == rocblas_side_left
  !> 
  !>     where C and A are m by n dimensional matrices. diag( x ) is a diagonal matrix
  !>     and x is vector of dimension n if side == rocblas_side_right and dimension m
  !>     if side == rocblas_side_left.
  !> 
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     side      [rocblas_side]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment between values of x
  !>     @param[in, out]
  !>     C         device pointer storing matrix C.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !>
  interface rocblas_zdgmm
    function rocblas_zdgmm_(handle,side,m,n,A,lda,x,incx,C,ldc) bind(c, name="rocblas_zdgmm")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdgmm_full_rank,&
      rocblas_zdgmm_rank_0,&
      rocblas_zdgmm_rank_1
#endif
  end interface
  
  interface rocblas_sdgmm_batched
    function rocblas_sdgmm_batched_(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count) bind(c, name="rocblas_sdgmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sdgmm_batched_full_rank,&
      rocblas_sdgmm_batched_rank_0,&
      rocblas_sdgmm_batched_rank_1
#endif
  end interface
  
  interface rocblas_ddgmm_batched
    function rocblas_ddgmm_batched_(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count) bind(c, name="rocblas_ddgmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ddgmm_batched_full_rank,&
      rocblas_ddgmm_batched_rank_0,&
      rocblas_ddgmm_batched_rank_1
#endif
  end interface
  
  interface rocblas_cdgmm_batched
    function rocblas_cdgmm_batched_(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count) bind(c, name="rocblas_cdgmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cdgmm_batched_full_rank,&
      rocblas_cdgmm_batched_rank_0,&
      rocblas_cdgmm_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     dgmm_batched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = A_i * diag(x_i) for i = 0, 1, ... batch_count-1 if side == rocblas_side_right
  !>         C_i = diag(x_i) * A_i for i = 0, 1, ... batch_count-1 if side == rocblas_side_left
  !> 
  !>     where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
  !>     and x_i is vector of dimension n if side == rocblas_side_right and dimension m
  !>     if side == rocblas_side_left.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     side      [rocblas_side]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i on the GPU.
  !>               Each A_i is of dimension ( lda, n )
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i on the GPU.
  !>               Each x_i is of dimension n if side == rocblas_side_right and dimension
  !>               m if side == rocblas_side_left
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment between values of x_i
  !>     @param[in, out]
  !>     C         device array of device pointers storing each matrix C_i on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>
  interface rocblas_zdgmm_batched
    function rocblas_zdgmm_batched_(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count) bind(c, name="rocblas_zdgmm_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdgmm_batched_full_rank,&
      rocblas_zdgmm_batched_rank_0,&
      rocblas_zdgmm_batched_rank_1
#endif
  end interface
  
  interface rocblas_sdgmm_strided_batched
    function rocblas_sdgmm_strided_batched_(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count) bind(c, name="rocblas_sdgmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sdgmm_strided_batched_full_rank,&
      rocblas_sdgmm_strided_batched_rank_0,&
      rocblas_sdgmm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_ddgmm_strided_batched
    function rocblas_ddgmm_strided_batched_(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count) bind(c, name="rocblas_ddgmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_ddgmm_strided_batched_full_rank,&
      rocblas_ddgmm_strided_batched_rank_0,&
      rocblas_ddgmm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cdgmm_strided_batched
    function rocblas_cdgmm_strided_batched_(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count) bind(c, name="rocblas_cdgmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cdgmm_strided_batched_full_rank,&
      rocblas_cdgmm_strided_batched_rank_0,&
      rocblas_cdgmm_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     dgmm_strided_batched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = A_i * diag(x_i)   if side == rocblas_side_right   for i = 0, 1, ... batch_count-1
  !>         C_i = diag(x_i) * A_i   if side == rocblas_side_left    for i = 0, 1, ... batch_count-1
  !> 
  !>     where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
  !>     and x_i is vector of dimension n if side == rocblas_side_right and dimension m
  !>     if side == rocblas_side_left.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     side      [rocblas_side]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     A         device pointer to the first matrix A_0 on the GPU.
  !>               Each A_i is of dimension ( lda, n )
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         pointer to the first vector x_0 on the GPU.
  !>               Each x_i is of dimension n if side == rocblas_side_right and dimension
  !>               m if side == rocblas_side_left
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment between values of x
  !>     @param[in]
  !>     stride_x  [rocblas_stride]
  !>               stride from the start of one vector(x_i) and the next one (x_i+1)
  !>     @param[in, out]
  !>     C         device pointer to the first matrix C_0 on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !>     @param[in]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  !>
  interface rocblas_zdgmm_strided_batched
    function rocblas_zdgmm_strided_batched_(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count) bind(c, name="rocblas_zdgmm_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zdgmm_strided_batched_full_rank,&
      rocblas_zdgmm_strided_batched_rank_0,&
      rocblas_zdgmm_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_sgeam
    function rocblas_sgeam_(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="rocblas_sgeam")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgeam_full_rank,&
      rocblas_sgeam_rank_0,&
      rocblas_sgeam_rank_1
#endif
  end interface
  
  interface rocblas_dgeam
    function rocblas_dgeam_(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="rocblas_dgeam")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgeam_full_rank,&
      rocblas_dgeam_rank_0,&
      rocblas_dgeam_rank_1
#endif
  end interface
  
  interface rocblas_cgeam
    function rocblas_cgeam_(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="rocblas_cgeam")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgeam_full_rank,&
      rocblas_cgeam_rank_0,&
      rocblas_cgeam_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     geam performs one of the matrix-matrix operations
  !> 
  !>         C = alpha*op( A ) + beta*op( B ),
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !> 
  !>     alpha and beta are scalars, and A, B and C are matrices, with
  !>     op( A ) an m by n matrix, op( B ) an m by n matrix, and C an m by n matrix.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in]
  !>     B         device pointer storing matrix B.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of B.
  !>     @param[in, out]
  !>     C         device pointer storing matrix C.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !>
  interface rocblas_zgeam
    function rocblas_zgeam_(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc) bind(c, name="rocblas_zgeam")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgeam_full_rank,&
      rocblas_zgeam_rank_0,&
      rocblas_zgeam_rank_1
#endif
  end interface
  
  interface rocblas_sgeam_batched
    function rocblas_sgeam_batched_(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_sgeam_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgeam_batched_full_rank,&
      rocblas_sgeam_batched_rank_0,&
      rocblas_sgeam_batched_rank_1
#endif
  end interface
  
  interface rocblas_dgeam_batched
    function rocblas_dgeam_batched_(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_dgeam_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgeam_batched_full_rank,&
      rocblas_dgeam_batched_rank_0,&
      rocblas_dgeam_batched_rank_1
#endif
  end interface
  
  interface rocblas_cgeam_batched
    function rocblas_cgeam_batched_(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_cgeam_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgeam_batched_full_rank,&
      rocblas_cgeam_batched_rank_0,&
      rocblas_cgeam_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     geam_batched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batch_count - 1
  !> 
  !>     where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
  !>     and op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     A         device array of device pointers storing each matrix A_i on the GPU.
  !>               Each A_i is of dimension ( lda, k ), where k is m
  !>               when  transA == rocblas_operation_none and
  !>               is  n  when  transA == rocblas_operation_transpose.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in]
  !>     B         device array of device pointers storing each matrix B_i on the GPU.
  !>               Each B_i is of dimension ( ldb, k ), where k is m
  !>               when  transB == rocblas_operation_none and
  !>               is  n  when  transB == rocblas_operation_transpose.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of B.
  !>     @param[in, out]
  !>     C         device array of device pointers storing each matrix C_i on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  !>
  interface rocblas_zgeam_batched
    function rocblas_zgeam_batched_(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count) bind(c, name="rocblas_zgeam_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgeam_batched_full_rank,&
      rocblas_zgeam_batched_rank_0,&
      rocblas_zgeam_batched_rank_1
#endif
  end interface
  
  interface rocblas_sgeam_strided_batched
    function rocblas_sgeam_strided_batched_(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_sgeam_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_float) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_sgeam_strided_batched_full_rank,&
      rocblas_sgeam_strided_batched_rank_0,&
      rocblas_sgeam_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_dgeam_strided_batched
    function rocblas_dgeam_strided_batched_(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_dgeam_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      real(c_double) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_dgeam_strided_batched_full_rank,&
      rocblas_dgeam_strided_batched_rank_0,&
      rocblas_dgeam_strided_batched_rank_1
#endif
  end interface
  
  interface rocblas_cgeam_strided_batched
    function rocblas_cgeam_strided_batched_(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_cgeam_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_float_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_cgeam_strided_batched_full_rank,&
      rocblas_cgeam_strided_batched_rank_0,&
      rocblas_cgeam_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     geam_strided_batched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batch_count - 1
  !> 
  !>     where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
  !>     and op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A )
  !> 
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B )
  !> 
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !> 
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !> 
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !> 
  !>     @param[in]
  !>     A         device pointer to the first matrix A_0 on the GPU.
  !>               Each A_i is of dimension ( lda, k ), where k is m
  !>               when  transA == rocblas_operation_none and
  !>               is  n  when  transA == rocblas_operation_transpose.
  !> 
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !> 
  !>     @param[in]
  !>     stride_A  [rocblas_stride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !> 
  !>     @param[in]
  !>     B         pointer to the first matrix B_0 on the GPU.
  !>               Each B_i is of dimension ( ldb, k ), where k is m
  !>               when  transB == rocblas_operation_none and
  !>               is  n  when  transB == rocblas_operation_transpose.
  !> 
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of B.
  !> 
  !>     @param[in]
  !>     stride_B  [rocblas_stride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in, out]
  !>     C         pointer to the first matrix C_0 on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !> 
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !> 
  !>     @param[in]
  !>     stride_C  [rocblas_stride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances i in the batch.
  !>
  interface rocblas_zgeam_strided_batched
    function rocblas_zgeam_strided_batched_(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count) bind(c, name="rocblas_zgeam_strided_batched")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      complex(c_double_complex) :: beta
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure &
      rocblas_zgeam_strided_batched_full_rank,&
      rocblas_zgeam_strided_batched_rank_0,&
      rocblas_zgeam_strided_batched_rank_1
#endif
  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     gemm_ex performs one of the matrix-matrix operations
  !> 
  !>         D = alpha*op( A )*op( B ) + beta*C,
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !> 
  !>     alpha and beta are scalars, and A, B, C, and D are matrices, with
  !>     op( A ) an m by k matrix, op( B ) a k by n matrix and C and D are m by n matrices.
  !> 
  !>     Supported types are as follows:
  !>         - rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
  !>    compute_type
  !>         - rocblas_datatype_f16_r = a_type = b_type; rocblas_datatype_f32_r = c_type = d_type =
  !>    compute_type
  !>         - rocblas_datatype_bf16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
  !>    compute_type
  !>         - rocblas_datatype_bf16_r = a_type = b_type; rocblas_datatype_f32_r = c_type = d_type =
  !>    compute_type
  !>         - rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r = c_type = d_type =
  !>    compute_type
  !>         - rocblas_datatype_f32_c  = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f64_c  = a_type = b_type = c_type = d_type = compute_type
  !> 
  !>     ROCm 4.2 supports two different versions of a = b = i8_r (in) and c = d = i32_r (out):
  !>         - Both versions are rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r =
  !>    c_type = d_type = compute_type, in addition to a last flag param indicating packing input or not.
  !> 
  !>         - Without setting the last param 'flags' (default=none), this is supported for gfx908 or
  !>    later GPUs only. Input a/b won't be packed into int8x4. So the following size restrictions and
  !>    packing pseudo-code is not neccessary.
  !> 
  !>         - Set the last param 'flags' |= rocblas_gemm_flags_pack_int8x4. Input a/b would be packed
  !>    into int8x4, and this will impose some size restrictions on A or B (See below.) For GPUs before
  !>    gfx908, only packed-int8 version is supported so this flag and packing is required, while
  !>    gfx908 GPUs support both versions.
  !> 
  !>     Below are restrictions for rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r =
  !>    c_type = d_type = compute_type; flags |= rocblas_gemm_flags_pack_int8x4:
  !>         - k must be a multiple of 4
  !>         - lda must be a multiple of 4 if transA == rocblas_operation_transpose
  !>         - ldb must be a multiple of 4 if transB == rocblas_operation_none
  !>         - for transA == rocblas_operation_none or transB == rocblas_operation_transpose the matrices
  !>    A and B must
  !>           have each 4 consecutive values in the k dimension packed. This packing can be achieved
  !>    with the following
  !>           pseudo-code. The code assumes the original matrices are in A and B, and the packed
  !>    matrices are A_packed
  !>           and B_packed. The size of the A_packed matrix is the same as the size of the A matrix, and
  !>    the size of
  !>           the B_packed matrix is the same as the size of the B matrix.
  !> 
  !>     @code
  !>     if(transA == rocblas_operation_none)
  !>     {
  !>         int nb = 4;
  !>         for(int i_m = 0; i_m < m; i_m++)
  !>         {
  !>             for(int i_k = 0; i_k < k; i_k++)
  !>             {
  !>                 A_packed[i_k % nb + (i_m + (i_k nb) * lda) * nb] = A[i_m + i_k * lda];
  !>             }
  !>         }
  !>     }
  !>     else
  !>     {
  !>         A_packed = A;
  !>     }
  !>     if(transB == rocblas_operation_transpose)
  !>     {
  !>         int nb = 4;
  !>         for(int i_n = 0; i_n < m; i_n++)
  !>         {
  !>             for(int i_k = 0; i_k < k; i_k++)
  !>             {
  !>                 B_packed[i_k % nb + (i_n + (i_k nb) * ldb) * nb] = B[i_n + i_k * ldb];
  !>             }
  !>         }
  !>     }
  !>     else
  !>     {
  !>         B_packed = B;
  !>     }
  !>     @endcode
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A ).
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B ).
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               matrix dimension k.
  !>     @param[in]
  !>     alpha     [ void *]
  !>               device pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.
  !>     @param[in]
  !>     a         [void *]
  !>               device pointer storing matrix A.
  !>     @param[in]
  !>     a_type    [rocblas_datatype]
  !>               specifies the datatype of matrix A.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     b         [void *]
  !>               device pointer storing matrix B.
  !>     @param[in]
  !>     b_type    [rocblas_datatype]
  !>               specifies the datatype of matrix B.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of B.
  !>     @param[in]
  !>     beta      [ void *]
  !>               device pointer or host pointer specifying the scalar beta. Same datatype as compute_type.
  !>     @param[in]
  !>     c         [void *]
  !>               device pointer storing matrix C.
  !>     @param[in]
  !>     c_type    [rocblas_datatype]
  !>               specifies the datatype of matrix C.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of C.
  !>     @param[out]
  !>     d         [void *]
  !>               device pointer storing matrix D.
  !>     @param[in]
  !>     d_type    [rocblas_datatype]
  !>               specifies the datatype of matrix D.
  !>     @param[in]
  !>     ldd       [rocblas_int]
  !>               specifies the leading dimension of D.
  !>     @param[in]
  !>     compute_type
  !>               [rocblas_datatype]
  !>               specifies the datatype of computation.
  !>     @param[in]
  !>     algo      [rocblas_gemm_algo]
  !>               enumerant specifying the algorithm type.
  !>     @param[in]
  !>     solution_index
  !>               [int32_t]
  !>               reserved for future use.
  !>     @param[in]
  !>     flags     [uint32_t]
  !>               optional gemm flags.
  !>
  interface rocblas_gemm_ex
    function rocblas_gemm_ex_(handle,transA,transB,m,n,k,alpha,a,a_type,lda,b,b_type,ldb,beta,c,c_type,ldc,d,d_type,ldd,compute_type,algo,solution_index,flags) bind(c, name="rocblas_gemm_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_gemm_ex_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: a
      integer(kind(rocblas_datatype_f16_r)),value :: a_type
      integer(c_int),value :: lda
      type(c_ptr),value :: b
      integer(kind(rocblas_datatype_f16_r)),value :: b_type
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr),value :: c
      integer(kind(rocblas_datatype_f16_r)),value :: c_type
      integer(c_int),value :: ldc
      type(c_ptr),value :: d
      integer(kind(rocblas_datatype_f16_r)),value :: d_type
      integer(c_int),value :: ldd
      integer(kind(rocblas_datatype_f16_r)),value :: compute_type
      integer(kind(rocblas_gemm_algo_standard)),value :: algo
      integer(c_int32_t),value :: solution_index
      integer(c_int),value :: flags
    end function

  end interface
  !>  \brief BLAS EX API
  !>     \details
  !>     gemm_batched_ex performs one of the batched matrix-matrix operations
  !>         D_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batch_count.
  !>     where op( X ) is one of
  !>         op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !>     alpha and beta are scalars, and A, B, C, and D are batched pointers to matrices, with
  !>     op( A ) an m by k by batch_count batched matrix,
  !>     op( B ) a k by n by batch_count batched matrix and
  !>     C and D are m by n by batch_count batched matrices.
  !>     The batched matrices are an array of pointers to matrices.
  !>     The number of pointers to matrices is batch_count.
  !>     Supported types are as follows:
  !>         - rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
  !>    compute_type
  !>         - rocblas_datatype_bf16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
  !>    compute_type
  !>         - rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r = c_type = d_type =
  !>    compute_type
  !>         - rocblas_datatype_f32_c  = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f64_c  = a_type = b_type = c_type = d_type = compute_type
  !> 
  !>     ROCm 4.2 supports two different versions of a = b = i8_r (in) and c = d = i32_r (out):
  !>         - Both versions are rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r =
  !>    c_type = d_type = compute_type, in addition to a last flag param indicating packing input or not.
  !> 
  !>         - Without setting the last param 'flags' (default=none), this is supported for gfx908 or
  !>    later GPUs only. Input a/b won't be packed into int8x4. So the following size restrictions and
  !>    packing pseudo-code is not neccessary.
  !> 
  !>         - Set the last param 'flags' |= rocblas_gemm_flags_pack_int8x4. Input a/b would be packed
  !>    into int8x4, and this will impose some size restrictions on A or B (See below.) For GPUs before
  !>    gfx908, only packed-int8 version is supported so this flag and packing is required, while
  !>    gfx908 GPUs support both versions.
  !> 
  !>     Below are restrictions for rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r =
  !>    c_type = d_type = compute_type; flags |= rocblas_gemm_flags_pack_int8x4:
  !>         - k must be a multiple of 4
  !>         - lda must be a multiple of 4 if transA == rocblas_operation_transpose
  !>         - ldb must be a multiple of 4 if transB == rocblas_operation_none
  !>         - for transA == rocblas_operation_none or transB == rocblas_operation_transpose the matrices
  !>    A and B must
  !>           have each 4 consecutive values in the k dimension packed. This packing can be achieved
  !>    with the following
  !>           pseudo-code. The code assumes the original matrices are in A and B, and the packed
  !>    matrices are A_packed
  !>           and B_packed. The size of the A_packed matrix is the same as the size of the A matrix, and
  !>    the size of
  !>           the B_packed matrix is the same as the size of the B matrix.
  !>     @code
  !>     if(transA == rocblas_operation_none)
  !>     {
  !>         int nb = 4;
  !>         for(int i_m = 0; i_m < m; i_m++)
  !>         {
  !>             for(int i_k = 0; i_k < k; i_k++)
  !>             {
  !>                 A_packed[i_k % nb + (i_m + (i_k nb) * lda) * nb] = A[i_m + i_k * lda];
  !>             }
  !>         }
  !>     }
  !>     else
  !>     {
  !>         A_packed = A;
  !>     }
  !>     if(transB == rocblas_operation_transpose)
  !>     {
  !>         int nb = 4;
  !>         for(int i_n = 0; i_n < m; i_n++)
  !>         {
  !>             for(int i_k = 0; i_k < k; i_k++)
  !>             {
  !>                 B_packed[i_k % nb + (i_n + (i_k nb) * ldb) * nb] = B[i_n + i_k * ldb];
  !>             }
  !>         }
  !>     }
  !>     else
  !>     {
  !>         B_packed = B;
  !>     }
  !>     @endcode
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A ).
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B ).
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               matrix dimension k.
  !>     @param[in]
  !>     alpha     [ void *]
  !>               device pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.
  !>     @param[in]
  !>     a         [void *]
  !>               device pointer storing array of pointers to each matrix A_i.
  !>     @param[in]
  !>     a_type    [rocblas_datatype]
  !>               specifies the datatype of each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     b         [void *]
  !>               device pointer storing array of pointers to each matrix B_i.
  !>     @param[in]
  !>     b_type    [rocblas_datatype]
  !>               specifies the datatype of each matrix B_i.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of each B_i.
  !>     @param[in]
  !>     beta      [ void *]
  !>               device pointer or host pointer specifying the scalar beta. Same datatype as compute_type.
  !>     @param[in]
  !>     c         [void *]
  !>               device array of device pointers to each matrix C_i.
  !>     @param[in]
  !>     c_type    [rocblas_datatype]
  !>               specifies the datatype of each matrix C_i.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of each C_i.
  !>     @param[out]
  !>     d         [void *]
  !>               device array of device pointers to each matrix D_i.
  !>     @param[in]
  !>     d_type    [rocblas_datatype]
  !>               specifies the datatype of each matrix D_i.
  !>     @param[in]
  !>     ldd       [rocblas_int]
  !>               specifies the leading dimension of each D_i.
  !>     @param[in]
  !>     batch_count
  !>               [rocblas_int]
  !>               number of gemm operations in the batch.
  !>     @param[in]
  !>     compute_type
  !>               [rocblas_datatype]
  !>               specifies the datatype of computation.
  !>     @param[in]
  !>     algo      [rocblas_gemm_algo]
  !>               enumerant specifying the algorithm type.
  !>     @param[in]
  !>     solution_index
  !>               [int32_t]
  !>               reserved for future use.
  !>     @param[in]
  !>     flags     [uint32_t]
  !>               optional gemm flags.
  !>
  interface rocblas_gemm_batched_ex
    function rocblas_gemm_batched_ex_(handle,transA,transB,m,n,k,alpha,a,a_type,lda,b,b_type,ldb,beta,c,c_type,ldc,d,d_type,ldd,batch_count,compute_type,algo,solution_index,flags) bind(c, name="rocblas_gemm_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_gemm_batched_ex_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: a
      integer(kind(rocblas_datatype_f16_r)),value :: a_type
      integer(c_int),value :: lda
      type(c_ptr),value :: b
      integer(kind(rocblas_datatype_f16_r)),value :: b_type
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr),value :: c
      integer(kind(rocblas_datatype_f16_r)),value :: c_type
      integer(c_int),value :: ldc
      type(c_ptr),value :: d
      integer(kind(rocblas_datatype_f16_r)),value :: d_type
      integer(c_int),value :: ldd
      integer(c_int),value :: batch_count
      integer(kind(rocblas_datatype_f16_r)),value :: compute_type
      integer(kind(rocblas_gemm_algo_standard)),value :: algo
      integer(c_int32_t),value :: solution_index
      integer(c_int),value :: flags
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     gemm_strided_batched_ex performs one of the strided_batched matrix-matrix operations
  !> 
  !>         D_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batch_count
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = X**T   or
  !>         op( X ) = X**H,
  !> 
  !>     alpha and beta are scalars, and A, B, C, and D are strided_batched matrices, with
  !>     op( A ) an m by k by batch_count strided_batched matrix,
  !>     op( B ) a k by n by batch_count strided_batched matrix and
  !>     C and D are m by n by batch_count strided_batched matrices.
  !> 
  !>     The strided_batched matrices are multiple matrices separated by a ant stride.
  !>     The number of matrices is batch_count.
  !> 
  !>     Supported types are as follows:
  !>         - rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
  !>    compute_type
  !>         - rocblas_datatype_bf16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
  !>    compute_type
  !>         - rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r = c_type = d_type =
  !>    compute_type
  !>         - rocblas_datatype_f32_c  = a_type = b_type = c_type = d_type = compute_type
  !>         - rocblas_datatype_f64_c  = a_type = b_type = c_type = d_type = compute_type
  !> 
  !>     ROCm 4.2 supports two different versions of a = b = i8_r (in) and c = d = i32_r (out):
  !>         - Both versions are rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r =
  !>    c_type = d_type = compute_type, in addition to a last flag param indicating packing input or not.
  !> 
  !>         - Without setting the last param 'flags' (default=none), this is supported for gfx908 or
  !>    later GPUs only. Input a/b won't be packed into int8x4. So the following size restrictions and
  !>    packing pseudo-code is not neccessary.
  !> 
  !>         - Set the last param 'flags' |= rocblas_gemm_flags_pack_int8x4. Input a/b would be packed
  !>    into int8x4, and this will impose some size restrictions on A or B (See below.) For GPUs before
  !>    gfx908, only packed-int8 version is supported so this flag and packing is required, while
  !>    gfx908 GPUs support both versions.
  !> 
  !>     Below are restrictions for rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r =
  !>    c_type = d_type = compute_type; flags |= rocblas_gemm_flags_pack_int8x4:
  !>         - k must be a multiple of 4
  !>         - lda must be a multiple of 4 if transA == rocblas_operation_transpose
  !>         - ldb must be a multiple of 4 if transB == rocblas_operation_none
  !>         - for transA == rocblas_operation_none or transB == rocblas_operation_transpose the matrices
  !>    A and B must
  !>           have each 4 consecutive values in the k dimension packed. This packing can be achieved
  !>    with the following
  !>           pseudo-code. The code assumes the original matrices are in A and B, and the packed
  !>    matrices are A_packed
  !>           and B_packed. The size of the A_packed matrix is the same as the size of the A matrix, and
  !>    the size of
  !>           the B_packed matrix is the same as the size of the B matrix.
  !> 
  !>     @code
  !>     if(transA == rocblas_operation_none)
  !>     {
  !>         int nb = 4;
  !>         for(int i_m = 0; i_m < m; i_m++)
  !>         {
  !>             for(int i_k = 0; i_k < k; i_k++)
  !>             {
  !>                 A_packed[i_k % nb + (i_m + (i_k nb) * lda) * nb] = A[i_m + i_k * lda];
  !>             }
  !>         }
  !>     }
  !>     else
  !>     {
  !>         A_packed = A;
  !>     }
  !>     if(transB == rocblas_operation_transpose)
  !>     {
  !>         int nb = 4;
  !>         for(int i_n = 0; i_n < m; i_n++)
  !>         {
  !>             for(int i_k = 0; i_k < k; i_k++)
  !>             {
  !>                 B_packed[i_k % nb + (i_n + (i_k nb) * ldb) * nb] = B[i_n + i_k * ldb];
  !>             }
  !>         }
  !>     }
  !>     else
  !>     {
  !>         B_packed = B;
  !>     }
  !>     @endcode
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     transA    [rocblas_operation]
  !>               specifies the form of op( A ).
  !>     @param[in]
  !>     transB    [rocblas_operation]
  !>               specifies the form of op( B ).
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               matrix dimension k.
  !>     @param[in]
  !>     alpha     [ void *]
  !>               device pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.
  !>     @param[in]
  !>     a         [void *]
  !>               device pointer pointing to first matrix A_1.
  !>     @param[in]
  !>     a_type    [rocblas_datatype]
  !>               specifies the datatype of each matrix A_i.
  !>     @param[in]
  !>     lda       [rocblas_int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     stride_a  [rocblas_stride]
  !>               specifies stride from start of one A_i matrix to the next A_(i + 1).
  !>     @param[in]
  !>     b         [void *]
  !>               device pointer pointing to first matrix B_1.
  !>     @param[in]
  !>     b_type    [rocblas_datatype]
  !>               specifies the datatype of each matrix B_i.
  !>     @param[in]
  !>     ldb       [rocblas_int]
  !>               specifies the leading dimension of each B_i.
  !>     @param[in]
  !>     stride_b  [rocblas_stride]
  !>               specifies stride from start of one B_i matrix to the next B_(i + 1).
  !>     @param[in]
  !>     beta      [ void *]
  !>               device pointer or host pointer specifying the scalar beta. Same datatype as compute_type.
  !>     @param[in]
  !>     c         [void *]
  !>               device pointer pointing to first matrix C_1.
  !>     @param[in]
  !>     c_type    [rocblas_datatype]
  !>               specifies the datatype of each matrix C_i.
  !>     @param[in]
  !>     ldc       [rocblas_int]
  !>               specifies the leading dimension of each C_i.
  !>     @param[in]
  !>     stride_c  [rocblas_stride]
  !>               specifies stride from start of one C_i matrix to the next C_(i + 1).
  !>     @param[out]
  !>     d         [void *]
  !>               device pointer storing each matrix D_i.
  !>     @param[in]
  !>     d_type    [rocblas_datatype]
  !>               specifies the datatype of each matrix D_i.
  !>     @param[in]
  !>     ldd       [rocblas_int]
  !>               specifies the leading dimension of each D_i.
  !>     @param[in]
  !>     stride_d  [rocblas_stride]
  !>               specifies stride from start of one D_i matrix to the next D_(i + 1).
  !>     @param[in]
  !>     batch_count
  !>               [rocblas_int]
  !>               number of gemm operations in the batch.
  !>     @param[in]
  !>     compute_type
  !>               [rocblas_datatype]
  !>               specifies the datatype of computation.
  !>     @param[in]
  !>     algo      [rocblas_gemm_algo]
  !>               enumerant specifying the algorithm type.
  !>     @param[in]
  !>     solution_index
  !>               [int32_t]
  !>               reserved for future use.
  !>     @param[in]
  !>     flags     [uint32_t]
  !>               optional gemm flags.
  !>
  interface rocblas_gemm_strided_batched_ex
    function rocblas_gemm_strided_batched_ex_(handle,transA,transB,m,n,k,alpha,a,a_type,lda,stride_a,b,b_type,ldb,stride_b,beta,c,c_type,ldc,stride_c,d,d_type,ldd,stride_d,batch_count,compute_type,algo,solution_index,flags) bind(c, name="rocblas_gemm_strided_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_gemm_strided_batched_ex_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_operation_none)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: a
      integer(kind(rocblas_datatype_f16_r)),value :: a_type
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_a
      type(c_ptr),value :: b
      integer(kind(rocblas_datatype_f16_r)),value :: b_type
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_b
      type(c_ptr),value :: beta
      type(c_ptr),value :: c
      integer(kind(rocblas_datatype_f16_r)),value :: c_type
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: stride_c
      type(c_ptr),value :: d
      integer(kind(rocblas_datatype_f16_r)),value :: d_type
      integer(c_int),value :: ldd
      integer(c_int64_t),value :: stride_d
      integer(c_int),value :: batch_count
      integer(kind(rocblas_datatype_f16_r)),value :: compute_type
      integer(kind(rocblas_gemm_algo_standard)),value :: algo
      integer(c_int32_t),value :: solution_index
      integer(c_int),value :: flags
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     gemm_ext2 performs the matrix-matrix operations
  !> 
  !>         D = alpha * A * B  + beta * C,
  !> 
  !>     alpha and beta are scalars, and A, B, C, and D are matrices, with A a m by k
  !>     matrtix, B a k by n matrix, and C and D are m by n matrices. Each matrix A, B, C, D
  !>     has independent row and column strides.
  !> 
  !>     This is a beta feature.
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     m         [rocblas_int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     k         [rocblas_int]
  !>               matrix dimension k.
  !>     @param[in]
  !>     alpha     [ void *]
  !>               device pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.
  !>     @param[in]
  !>     a         [void *]
  !>               device pointer storing matrix A.
  !>     @param[in]
  !>     a_type    [rocblas_datatype]
  !>               specifies the datatype of matrix A.
  !>     @param[in]
  !>     row_stride_a [rocblas_int]
  !>               specifies the row stride of A.
  !>     @param[in]
  !>     col_stride_a [rocblas_int]
  !>               specifies the column stride of A.
  !>     @param[in]
  !>     b         [void *]
  !>               device pointer storing matrix B.
  !>     @param[in]
  !>     b_type    [rocblas_datatype]
  !>               specifies the datatype of matrix B.
  !>     @param[in]
  !>     row_stride_b    [rocblas_int]
  !>               specifies the row stride of B.
  !>     @param[in]
  !>     col_stride_a    [rocblas_int]
  !>               specifies the column stride of B.
  !>     @param[in]
  !>     beta      [ void *]
  !>               device pointer or host pointer specifying the scalar beta. Same datatype as compute_type.
  !>     @param[in]
  !>     c         [void *]
  !>               device pointer storing matrix C.
  !>     @param[in]
  !>     c_type    [rocblas_datatype]
  !>               specifies the datatype of matrix C.
  !>     @param[in]
  !>     row_stride_c [rocblas_int]
  !>               specifies the row stride of C.
  !>     @param[in]
  !>     col_stride_c [rocblas_int]
  !>               specifies the column stride of C.
  !>     @param[out]
  !>     d         [void *]
  !>               device pointer storing matrix D.
  !>     @param[in]
  !>     d_type    [rocblas_datatype]
  !>               specifies the datatype of matrix D.
  !>     @param[in]
  !>     row_stride_d [rocblas_int]
  !>               specifies the row stride of D.
  !>     @param[in]
  !>     col_stride_d [rocblas_int]
  !>               specifies the column stride of D.
  !>     @param[in]
  !>     compute_type
  !>               [rocblas_datatype]
  !>               specifies the datatype of computation.
  !>     @param[in]
  !>     algo      [rocblas_gemm_algo]
  !>               enumerant specifying the algorithm type.
  !>     @param[in]
  !>     solution_index
  !>               [int32_t]
  !>               reserved for future use.
  !>     @param[in]
  !>     flags     [uint32_t]
  !>               optional gemm flags.
  !>
  interface rocblas_gemm_ext2
    function rocblas_gemm_ext2_(handle,m,n,k,alpha,a,a_type,row_stride_a,col_stride_a,b,b_type,row_stride_b,col_stride_b,beta,c,c_type,row_stride_c,col_stride_c,d,d_type,row_stride_d,col_stride_d,compute_type,algo,solution_index,flags) bind(c, name="rocblas_gemm_ext2")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_gemm_ext2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: a
      integer(kind(rocblas_datatype_f16_r)),value :: a_type
      integer(c_int64_t),value :: row_stride_a
      integer(c_int64_t),value :: col_stride_a
      type(c_ptr),value :: b
      integer(kind(rocblas_datatype_f16_r)),value :: b_type
      integer(c_int64_t),value :: row_stride_b
      integer(c_int64_t),value :: col_stride_b
      type(c_ptr),value :: beta
      type(c_ptr),value :: c
      integer(kind(rocblas_datatype_f16_r)),value :: c_type
      integer(c_int64_t),value :: row_stride_c
      integer(c_int64_t),value :: col_stride_c
      type(c_ptr),value :: d
      integer(kind(rocblas_datatype_f16_r)),value :: d_type
      integer(c_int64_t),value :: row_stride_d
      integer(c_int64_t),value :: col_stride_d
      integer(kind(rocblas_datatype_f16_r)),value :: compute_type
      integer(kind(rocblas_gemm_algo_standard)),value :: algo
      integer(c_int32_t),value :: solution_index
      integer(c_int),value :: flags
    end function

  end interface
  !>  BLAS EX API
  !> 
  !>     \details
  !>     trsm_ex solves
  !> 
  !>         op(A)*X = alpha*B or X*op(A) = alpha*B,
  !> 
  !>     where alpha is a scalar, X and B are m by n matrices,
  !>     A is triangular matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     The matrix X is overwritten on B.
  !> 
  !>     This function gives the user the ability to reuse the invA matrix between runs.
  !>     If invA == NULL, rocblas_trsm_ex will automatically calculate invA on every run.
  !> 
  !>     Setting up invA:
  !>     The accepted invA matrix consists of the packed 128x128 inverses of the diagonal blocks of
  !>     matrix A, followed by any smaller diagonal block that remains.
  !>     To set up invA it is recommended that rocblas_trtri_batched be used with matrix A as the input.
  !> 
  !>     Device memory of size 128 x k should be allocated for invA ahead of time, where k is m when
  !>     rocblas_side_left and is n when rocblas_side_right. The actual number of elements in invA
  !>     should be passed as invA_size.
  !> 
  !>     To begin, rocblas_trtri_batched must be called on the full 128x128 sized diagonal blocks of
  !>     matrix A. Below are the restricted parameters:
  !>       - n = 128
  !>       - ldinvA = 128
  !>       - stride_invA = 128x128
  !>       - batch_count = k 128,
  !> 
  !>     Then any remaining block may be added:
  !>       - n = k % 128
  !>       - invA = invA + stride_invA * previous_batch_count
  !>       - ldinvA = 128
  !>       - batch_count = 1
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             rocblas_side_left:       op(A)*X = alpha*B.
  !>             rocblas_side_right:      X*op(A) = alpha*B.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  A is an upper triangular matrix.
  !>             rocblas_fill_lower:  A is a lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             transB:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     A is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of B. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of B. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha   [void *]
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced, and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       [void *]
  !>             device pointer storing matrix A.
  !>             of dimension ( lda, k ), where k is m
  !>             when rocblas_side_left and
  !>             is n when rocblas_side_right
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             if side = rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in, out]
  !>     B       [void *]
  !>             device pointer storing matrix B.
  !>             B is of dimension ( ldb, n ).
  !>             Before entry, the leading m by n part of the array B must
  !>             contain the right-hand side matrix B, and on exit is
  !>             overwritten by the solution matrix X.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     invA    [void *]
  !>             device pointer storing the inverse diagonal blocks of A.
  !>             invA is of dimension ( ld_invA, k ), where k is m
  !>             when rocblas_side_left and
  !>             is n when rocblas_side_right.
  !>             ld_invA must be equal to 128.
  !> 
  !>     @param[in]
  !>     invA_size [rocblas_int]
  !>             invA_size specifies the number of elements of device memory in invA.
  !> 
  !>     @param[in]
  !>     compute_type [rocblas_datatype]
  !>             specifies the datatype of computation
  !>
  interface rocblas_trsm_ex
    function rocblas_trsm_ex_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,invA,invA_size,compute_type) bind(c, name="rocblas_trsm_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_trsm_ex_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: invA
      integer(c_int),value :: invA_size
      integer(kind(rocblas_datatype_f16_r)),value :: compute_type
    end function

  end interface
  !>  BLAS EX API
  !> 
  !>     \details
  !>     trsm_batched_ex solves
  !> 
  !>         op(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,
  !> 
  !>     for i = 1, ..., batch_count; and where alpha is a scalar, X and B are arrays of m by n matrices,
  !>     A is an array of triangular matrix and each op(A_i) is one of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i.
  !> 
  !>     This function gives the user the ability to reuse the invA matrix between runs.
  !>     If invA == NULL, rocblas_trsm_batched_ex will automatically calculate each invA_i on every run.
  !> 
  !>     Setting up invA:
  !>     Each accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of
  !>     matrix A_i, followed by any smaller diagonal block that remains.
  !>     To set up each invA_i it is recommended that rocblas_trtri_batched be used with matrix A_i as the input.
  !>     invA is an array of pointers of batch_count length holding each invA_i.
  !> 
  !>     Device memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when
  !>     rocblas_side_left and is n when rocblas_side_right. The actual number of elements in each invA_i
  !>     should be passed as invA_size.
  !> 
  !>     To begin, rocblas_trtri_batched must be called on the full 128x128 sized diagonal blocks of each
  !>     matrix A_i. Below are the restricted parameters:
  !>       - n = 128
  !>       - ldinvA = 128
  !>       - stride_invA = 128x128
  !>       - batch_count = k 128,
  !> 
  !>     Then any remaining block may be added:
  !>       - n = k % 128
  !>       - invA = invA + stride_invA * previous_batch_count
  !>       - ldinvA = 128
  !>       - batch_count = 1
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             rocblas_side_left:       op(A)*X = alpha*B.
  !>             rocblas_side_right:      X*op(A) = alpha*B.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  each A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  each A_i is a lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             transB:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha   [void *]
  !>             device pointer or host pointer alpha specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced, and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       [void *]
  !>             device array of device pointers storing each matrix A_i.
  !>             each A_i is of dimension ( lda, k ), where k is m
  !>             when rocblas_side_left and
  !>             is n when rocblas_side_right
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of each A_i.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             if side = rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in, out]
  !>     B       [void *]
  !>             device array of device pointers storing each matrix B_i.
  !>             each B_i is of dimension ( ldb, n ).
  !>             Before entry, the leading m by n part of the array B_i must
  !>             contain the right-hand side matrix B_i, and on exit is
  !>             overwritten by the solution matrix X_i
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>             specifies how many batches.
  !> 
  !>     @param[in]
  !>     invA    [void *]
  !>             device array of device pointers storing the inverse diagonal blocks of each A_i.
  !>             each invA_i is of dimension ( ld_invA, k ), where k is m
  !>             when rocblas_side_left and
  !>             is n when rocblas_side_right.
  !>             ld_invA must be equal to 128.
  !> 
  !>     @param[in]
  !>     invA_size [rocblas_int]
  !>             invA_size specifies the number of elements of device memory in each invA_i.
  !> 
  !>     @param[in]
  !>     compute_type [rocblas_datatype]
  !>             specifies the datatype of computation
  !>
  interface rocblas_trsm_batched_ex
    function rocblas_trsm_batched_ex_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count,invA,invA_size,compute_type) bind(c, name="rocblas_trsm_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_trsm_batched_ex_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
      type(c_ptr),value :: invA
      integer(c_int),value :: invA_size
      integer(kind(rocblas_datatype_f16_r)),value :: compute_type
    end function

  end interface
  !>  BLAS EX API
  !> 
  !>     \details
  !>     trsm_strided_batched_ex solves
  !> 
  !>         op(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,
  !> 
  !>     for i = 1, ..., batch_count; and where alpha is a scalar, X and B are strided batched m by n matrices,
  !>     A is a strided batched triangular matrix and op(A_i) is one of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i.
  !> 
  !>     This function gives the user the ability to reuse each invA_i matrix between runs.
  !>     If invA == NULL, rocblas_trsm_batched_ex will automatically calculate each invA_i on every run.
  !> 
  !>     Setting up invA:
  !>     Each accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of
  !>     matrix A_i, followed by any smaller diagonal block that remains.
  !>     To set up invA_i it is recommended that rocblas_trtri_batched be used with matrix A_i as the input.
  !>     invA is a contiguous piece of memory holding each invA_i.
  !> 
  !>     Device memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when
  !>     rocblas_side_left and is n when rocblas_side_right. The actual number of elements in each invA_i
  !>     should be passed as invA_size.
  !> 
  !>     To begin, rocblas_trtri_batched must be called on the full 128x128 sized diagonal blocks of each
  !>     matrix A_i. Below are the restricted parameters:
  !>       - n = 128
  !>       - ldinvA = 128
  !>       - stride_invA = 128x128
  !>       - batch_count = k 128,
  !> 
  !>     Then any remaining block may be added:
  !>       - n = k % 128
  !>       - invA = invA + stride_invA * previous_batch_count
  !>       - ldinvA = 128
  !>       - batch_count = 1
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [rocblas_side]
  !>             rocblas_side_left:       op(A)*X = alpha*B.
  !>             rocblas_side_right:      X*op(A) = alpha*B.
  !> 
  !>     @param[in]
  !>     uplo    [rocblas_fill]
  !>             rocblas_fill_upper:  each A_i is an upper triangular matrix.
  !>             rocblas_fill_lower:  each A_i is a lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [rocblas_operation]
  !>             transB:    op(A) = A.
  !>             rocblas_operation_transpose:      op(A) = A^T.
  !>             rocblas_operation_conjugate_transpose:  op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [rocblas_diagonal]
  !>             rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.
  !>             rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [rocblas_int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha   [void *]
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced, and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       [void *]
  !>             device pointer storing matrix A.
  !>             of dimension ( lda, k ), where k is m
  !>             when rocblas_side_left and
  !>             is n when rocblas_side_right
  !>             only the upper/lower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [rocblas_int]
  !>             lda specifies the first dimension of A.
  !>             if side = rocblas_side_left,  lda >= max( 1, m ),
  !>             if side = rocblas_side_right, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     stride_A [rocblas_stride]
  !>             The stride between each A matrix.
  !> 
  !>     @param[in, out]
  !>     B       [void *]
  !>             device pointer pointing to first matrix B_i.
  !>             each B_i is of dimension ( ldb, n ).
  !>             Before entry, the leading m by n part of each array B_i must
  !>             contain the right-hand side of matrix B_i, and on exit is
  !>             overwritten by the solution matrix X_i.
  !> 
  !>     @param[in]
  !>     ldb    [rocblas_int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     stride_B [rocblas_stride]
  !>             The stride between each B_i matrix.
  !> 
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>             specifies how many batches.
  !> 
  !>     @param[in]
  !>     invA    [void *]
  !>             device pointer storing the inverse diagonal blocks of each A_i.
  !>             invA points to the first invA_1.
  !>             each invA_i is of dimension ( ld_invA, k ), where k is m
  !>             when rocblas_side_left and
  !>             is n when rocblas_side_right.
  !>             ld_invA must be equal to 128.
  !> 
  !>     @param[in]
  !>     invA_size [rocblas_int]
  !>             invA_size specifies the number of elements of device memory in each invA_i.
  !> 
  !>     @param[in]
  !>     stride_invA [rocblas_stride]
  !>             The stride between each invA matrix.
  !> 
  !>     @param[in]
  !>     compute_type [rocblas_datatype]
  !>             specifies the datatype of computation
  !>
  interface rocblas_trsm_strided_batched_ex
    function rocblas_trsm_strided_batched_ex_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,batch_count,invA,invA_size,stride_invA,compute_type) bind(c, name="rocblas_trsm_strided_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_trsm_strided_batched_ex_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: transA
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: stride_A
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: stride_B
      integer(c_int),value :: batch_count
      type(c_ptr),value :: invA
      integer(c_int),value :: invA_size
      integer(c_int64_t),value :: stride_invA
      integer(kind(rocblas_datatype_f16_r)),value :: compute_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     axpy_ex   computes ant alpha multiplied by vector x, plus vector y
  !> 
  !>         y := alpha * x + y
  !> 
  !>         Currently supported datatypes are as follows:
  !> 
  !>         -------------------------------------------------
  !>         | alpha_type | x_type | y_type | execution_type |
  !>         |------------|--------|--------|----------------|
  !>         |  f16_r     | f16_r  |  f16_r |      f16_r     |
  !>         |  f16_r     | f16_r  |  f16_r |      f32_r     |
  !>         |  f32_r     | f16_r  |  f16_r |      f32_r     |
  !>         |  f32_r     | f32_r  |  f32_r |      f32_r     |
  !>         |  f64_r     | f64_r  |  f64_r |      f64_r     |
  !>         |  f32_c     | f32_c  |  f32_c |      f32_c     |
  !>         |  f64_c     | f64_c  |  f64_c |      f64_c     |
  !>         -------------------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to specify the scalar alpha.
  !>     @param[in]
  !>     alpha_type [rocblas_datatype]
  !>               specifies the datatype of alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     y_type [rocblas_datatype]
  !>           specifies the datatype of vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                   specifies the datatype of computation.
  !>
  interface rocblas_axpy_ex
    function rocblas_axpy_ex_(handle,n,alpha,alpha_type,x,x_type,incx,y,y_type,incy,execution_type) bind(c, name="rocblas_axpy_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_axpy_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(rocblas_datatype_f16_r)),value :: alpha_type
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     axpy_batched_ex   computes ant alpha multiplied by vector x, plus vector y over
  !>                       a set of batched vectors.
  !> 
  !>         y := alpha * x + y
  !> 
  !>         Currently supported datatypes are as follows:
  !> 
  !>         -------------------------------------------------
  !>         | alpha_type | x_type | y_type | execution_type |
  !>         |------------|--------|--------|----------------|
  !>         |  f16_r     | f16_r  |  f16_r |      f16_r     |
  !>         |  f16_r     | f16_r  |  f16_r |      f32_r     |
  !>         |  f32_r     | f16_r  |  f16_r |      f32_r     |
  !>         |  f32_r     | f32_r  |  f32_r |      f32_r     |
  !>         |  f64_r     | f64_r  |  f64_r |      f64_r     |
  !>         |  f32_c     | f32_c  |  f32_c |      f32_c     |
  !>         |  f64_c     | f64_c  |  f64_c |      f64_c     |
  !>         -------------------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to specify the scalar alpha.
  !>     @param[in]
  !>     alpha_type [rocblas_datatype]
  !>               specifies the datatype of alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     y_type [rocblas_datatype]
  !>           specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                   specifies the datatype of computation.
  !>
  interface rocblas_axpy_batched_ex
    function rocblas_axpy_batched_ex_(handle,n,alpha,alpha_type,x,x_type,incx,y,y_type,incy,batch_count,execution_type) bind(c, name="rocblas_axpy_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_axpy_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(rocblas_datatype_f16_r)),value :: alpha_type
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     axpy_strided_batched_ex   computes ant alpha multiplied by vector x, plus vector y over
  !>                       a set of strided batched vectors.
  !> 
  !>         y := alpha * x + y
  !> 
  !>         Currently supported datatypes are as follows:
  !> 
  !>         -------------------------------------------------
  !>         | alpha_type | x_type | y_type | execution_type |
  !>         |------------|--------|--------|----------------|
  !>         |  f16_r     | f16_r  |  f16_r |      f16_r     |
  !>         |  f16_r     | f16_r  |  f16_r |      f32_r     |
  !>         |  f32_r     | f16_r  |  f16_r |      f32_r     |
  !>         |  f32_r     | f32_r  |  f32_r |      f32_r     |
  !>         |  f64_r     | f64_r  |  f64_r |      f64_r     |
  !>         |  f32_c     | f32_c  |  f32_c |      f32_c     |
  !>         |  f64_c     | f64_c  |  f64_c |      f64_c     |
  !>         -------------------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to specify the scalar alpha.
  !>     @param[in]
  !>     alpha_type [rocblas_datatype]
  !>               specifies the datatype of alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) to the next one (x_i+1).
  !>               There are no restrictions placed on stridex, however the user should
  !>               take care to ensure that stridex is of appropriate size, for a typical
  !>               case this means stridex >= n * incx.
  !>     @param[inout]
  !>     y         device pointer to the first vector y_1.
  !>     @param[in]
  !>     y_type [rocblas_datatype]
  !>           specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey   [rocblas_stride]
  !>               stride from the start of one vector (y_i) to the next one (y_i+1).
  !>               There are no restrictions placed on stridey, however the user should
  !>               take care to ensure that stridey is of appropriate size, for a typical
  !>               case this means stridey >= n * incy.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                   specifies the datatype of computation.
  !>
  interface rocblas_axpy_strided_batched_ex
    function rocblas_axpy_strided_batched_ex_(handle,n,alpha,alpha_type,x,x_type,incx,stridex,y,y_type,incy,stridey,batch_count,execution_type) bind(c, name="rocblas_axpy_strided_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_axpy_strided_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(rocblas_datatype_f16_r)),value :: alpha_type
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batch_count
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     dot_ex  performs the dot product of vectors x and y
  !> 
  !>         result = x * y;
  !> 
  !>     dotc_ex  performs the dot product of the conjugate of complex vector x and complex vector y
  !> 
  !>         result = conjugate (x) * y;
  !> 
  !>         Currently supported datatypes are as follows:
  !> 
  !>         --------------------------------------------------
  !>         | x_type | y_type | result_type | execution_type |
  !>         |--------|--------|-------------|----------------|
  !>         | f16_r  | f16_r  |    f16_r    |     f16_r      |
  !>         | f16_r  | f16_r  |    f16_r    |     f32_r      |
  !>         | bf16_r | bf16_r |    bf16_r   |     f32_r      |
  !>         | f32_r  | f32_r  |    f32_r    |     f32_r      |
  !>         | f64_r  | f64_r  |    f64_r    |     f64_r      |
  !>         | f32_c  | f32_c  |    f32_c    |     f32_c      |
  !>         | f64_c  | f64_c  |    f64_c    |     f64_c      |
  !>         --------------------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     y_type [rocblas_datatype]
  !>           specifies the datatype of vector y.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the dot product.
  !>               return is 0.0 if n <= 0.
  !>     @param[in]
  !>     result_type [rocblas_datatype]
  !>                 specifies the datatype of the result.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                   specifies the datatype of computation.
  !>
  interface rocblas_dot_ex
    function rocblas_dot_ex_(handle,n,x,x_type,incx,y,y_type,incy,myResult,result_type,execution_type) bind(c, name="rocblas_dot_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dot_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      integer(kind(rocblas_datatype_f16_r)),value :: result_type
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  
  interface rocblas_dotc_ex
    function rocblas_dotc_ex_(handle,n,x,x_type,incx,y,y_type,incy,myResult,result_type,execution_type) bind(c, name="rocblas_dotc_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dotc_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      integer(kind(rocblas_datatype_f16_r)),value :: result_type
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     dot_batched_ex performs a batch of dot products of vectors x and y
  !> 
  !>         result_i = x_i * y_i;
  !> 
  !>     dotc_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y
  !> 
  !>         result_i = conjugate (x_i) * y_i;
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors, for i = 1, ..., batch_count
  !> 
  !>         Currently supported datatypes are as follows:
  !> 
  !>         --------------------------------------------------
  !>         | x_type | y_type | result_type | execution_type |
  !>         |--------|--------|-------------|----------------|
  !>         | f16_r  | f16_r  |    f16_r    |     f16_r      |
  !>         | f16_r  | f16_r  |    f16_r    |     f32_r      |
  !>         | bf16_r | bf16_r |    bf16_r   |     f32_r      |
  !>         | f32_r  | f32_r  |    f32_r    |     f32_r      |
  !>         | f64_r  | f64_r  |    f64_r    |     f64_r      |
  !>         | f32_c  | f32_c  |    f32_c    |     f32_c      |
  !>         | f64_c  | f64_c  |    f64_c    |     f64_c      |
  !>         --------------------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     y_type [rocblas_datatype]
  !>           specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>     @param[inout]
  !>     result
  !>               device array or host array of batch_count size to store the dot products of each batch.
  !>               return 0.0 for each element if n <= 0.
  !>     @param[in]
  !>     result_type [rocblas_datatype]
  !>                 specifies the datatype of the result.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                   specifies the datatype of computation.
  !>
  interface rocblas_dot_batched_ex
    function rocblas_dot_batched_ex_(handle,n,x,x_type,incx,y,y_type,incy,batch_count,myResult,result_type,execution_type) bind(c, name="rocblas_dot_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dot_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      integer(kind(rocblas_datatype_f16_r)),value :: result_type
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  
  interface rocblas_dotc_batched_ex
    function rocblas_dotc_batched_ex_(handle,n,x,x_type,incx,y,y_type,incy,batch_count,myResult,result_type,execution_type) bind(c, name="rocblas_dotc_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dotc_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      integer(kind(rocblas_datatype_f16_r)),value :: result_type
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     dot_strided_batched_ex  performs a batch of dot products of vectors x and y
  !> 
  !>         result_i = x_i * y_i;
  !> 
  !>     dotc_strided_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y
  !> 
  !>         result_i = conjugate (x_i) * y_i;
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors, for i = 1, ..., batch_count
  !> 
  !>         Currently supported datatypes are as follows:
  !> 
  !>         --------------------------------------------------
  !>         | x_type | y_type | result_type | execution_type |
  !>         |--------|--------|-------------|----------------|
  !>         | f16_r  | f16_r  |    f16_r    |     f16_r      |
  !>         | f16_r  | f16_r  |    f16_r    |     f32_r      |
  !>         | bf16_r | bf16_r |    bf16_r   |     f32_r      |
  !>         | f32_r  | f32_r  |    f32_r    |     f32_r      |
  !>         | f64_r  | f64_r  |    f64_r    |     f64_r      |
  !>         | f32_c  | f32_c  |    f32_c    |     f32_c      |
  !>         | f64_c  | f64_c  |    f64_c    |     f64_c      |
  !>         --------------------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stride_x    [rocblas_stride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     y_type [rocblas_datatype]
  !>           specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy      [rocblas_int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stride_y    [rocblas_stride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1)
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch
  !>     @param[inout]
  !>     result
  !>               device array or host array of batch_count size to store the dot products of each batch.
  !>               return 0.0 for each element if n <= 0.
  !>     @param[in]
  !>     result_type [rocblas_datatype]
  !>                 specifies the datatype of the result.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                   specifies the datatype of computation.
  !>
  interface rocblas_dot_strided_batched_ex
    function rocblas_dot_strided_batched_ex_(handle,n,x,x_type,incx,stride_x,y,y_type,incy,stride_y,batch_count,myResult,result_type,execution_type) bind(c, name="rocblas_dot_strided_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dot_strided_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      integer(kind(rocblas_datatype_f16_r)),value :: result_type
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  
  interface rocblas_dotc_strided_batched_ex
    function rocblas_dotc_strided_batched_ex_(handle,n,x,x_type,incx,stride_x,y,y_type,incy,stride_y,batch_count,myResult,result_type,execution_type) bind(c, name="rocblas_dotc_strided_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dotc_strided_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      integer(c_int),value :: batch_count
      type(c_ptr),value :: myResult
      integer(kind(rocblas_datatype_f16_r)),value :: result_type
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS_EX API
  !> 
  !>     \details
  !>     nrm2_ex computes the euclidean norm of a real or complex vector
  !> 
  !>               result := sqrt( x'*x ) for real vectors
  !>               result := sqrt( x**H*x ) for complex vectors
  !> 
  !>     Currently supported datatypes are as follows:
  !> 
  !>         -------------------------------------
  !>         |  x_type | result | execution_type |
  !>         |---------|--------|----------------|
  !>         |  f16_r  |  f16_r |     f32_r      |
  !>         |  f32_r  |  f32_r |     f32_r      |
  !>         |  f64_r  |  f64_r |     f64_r      |
  !>         |  f32_c  |  f32_r |     f32_r      |
  !>         |  f64_c  |  f64_r |     f64_r      |
  !>         -------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of the vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the nrm2 product.
  !>               return is 0.0 if n, incx<=0.
  !>     @param[in]
  !>     result_type [rocblas_datatype]
  !>                 specifies the datatype of the result.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                   specifies the datatype of computation.
  interface rocblas_nrm2_ex
    function rocblas_nrm2_ex_(handle,n,x,x_type,incx,results,result_type,execution_type) bind(c, name="rocblas_nrm2_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_nrm2_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      type(c_ptr),value :: results
      integer(kind(rocblas_datatype_f16_r)),value :: result_type
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS_EX API
  !> 
  !>     \details
  !>     nrm2_batched_ex computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count
  !>               result := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batch_count
  !> 
  !>     Currently supported datatypes are as follows:
  !> 
  !>         -------------------------------------
  !>         |  x_type | result | execution_type |
  !>         |---------|--------|----------------|
  !>         |  f16_r  |  f16_r |     f32_r      |
  !>         |  f32_r  |  f32_r |     f32_r      |
  !>         |  f64_r  |  f64_r |     f64_r      |
  !>         |  f32_c  |  f32_r |     f32_r      |
  !>         |  f64_c  |  f64_r |     f64_r      |
  !>         -------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     results
  !>               device pointer or host pointer to array of batch_count size for nrm2 results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !>     @param[in]
  !>     result_type [rocblas_datatype]
  !>                 specifies the datatype of the result.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                   specifies the datatype of computation.
  !>
  interface rocblas_nrm2_batched_ex
    function rocblas_nrm2_batched_ex_(handle,n,x,x_type,incx,batch_count,results,result_type,execution_type) bind(c, name="rocblas_nrm2_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_nrm2_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      integer(kind(rocblas_datatype_f16_r)),value :: result_type
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS_EX API
  !> 
  !>     \details
  !>     nrm2_strided_batched_ex computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count
  !>               := sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batch_count
  !> 
  !>     Currently supported datatypes are as follows:
  !> 
  !>         -------------------------------------
  !>         |  x_type | result | execution_type |
  !>         |---------|--------|----------------|
  !>         |  f16_r  |  f16_r |     f32_r      |
  !>         |  f32_r  |  f32_r |     f32_r      |
  !>         |  f64_r  |  f64_r |     f64_r      |
  !>         |  f32_c  |  f32_r |     f32_r      |
  !>         |  f64_c  |  f64_r |     f64_r      |
  !>         -------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n * incx.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     results
  !>               device pointer or host pointer to array for storing contiguous batch_count results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !>     @param[in]
  !>     result_type [rocblas_datatype]
  !>                 specifies the datatype of the result.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                   specifies the datatype of computation.
  !>
  interface rocblas_nrm2_strided_batched_ex
    function rocblas_nrm2_strided_batched_ex_(handle,n,x,x_type,incx,stride_x,batch_count,results,result_type,execution_type) bind(c, name="rocblas_nrm2_strided_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_nrm2_strided_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      integer(c_int),value :: batch_count
      type(c_ptr),value :: results
      integer(kind(rocblas_datatype_f16_r)),value :: result_type
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     rot_ex applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     In the case where cs_type is real:
  !>         x := c * x + s * y
  !>             y := c * y - s * x
  !> 
  !>     In the case where cs_type is complex, the imaginary part of c is ignored:
  !>         x := real(c) * x + s * y
  !>             y := real(c) * y - conj(s) * x
  !> 
  !>     Currently supported datatypes are as follows:
  !> 
  !>         ------------------------------------------------
  !>         |  x_type | y_type  | cs_type | execution_type |
  !>         |---------|---------|---------|----------------|
  !>         |  bf16_r |  bf16_r | bf16_r  |  f32_r         |
  !>         |  f16_r  |  f16_r  | f16_r   |  f32_r         |
  !>         |  f32_r  |  f32_r  | f32_r   |  f32_r         |
  !>         |  f64_r  |  f64_r  | f64_r   |  f64_r         |
  !>         |  f32_c  |  f32_c  | f32_c   |  f32_c         |
  !>         |  f32_c  |  f32_c  | f32_r   |  f32_c         |
  !>         |  f64_c  |  f64_c  | f64_c   |  f64_c         |
  !>         |  f64_c  |  f64_c  | f64_r   |  f64_c         |
  !>         ------------------------------------------------
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer storing vector x.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of vector x.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of x.
  !>     @param[inout]
  !>     y       device pointer storing vector y.
  !>     @param[in]
  !>     y_type [rocblas_datatype]
  !>            specifies the datatype of vector y.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of y.
  !>     @param[in]
  !>     c       device pointer or host pointer storing scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer storing scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     cs_type [rocblas_datatype]
  !>             specifies the datatype of c and s.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                    specifies the datatype of computation.
  !>
  interface rocblas_rot_ex
    function rocblas_rot_ex_(handle,n,x,x_type,incx,y,y_type,incy,c,s,cs_type,execution_type) bind(c, name="rocblas_rot_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_rot_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(rocblas_datatype_f16_r)),value :: cs_type
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     rot_batched_ex applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batch_count.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     In the case where cs_type is real:
  !>             x := c * x + s * y
  !>             y := c * y - s * x
  !> 
  !>         In the case where cs_type is complex, the imaginary part of c is ignored:
  !>             x := real(c) * x + s * y
  !>             y := real(c) * y - conj(s) * x
  !> 
  !>     Currently supported datatypes are as follows:
  !> 
  !>         ------------------------------------------------
  !>         |  x_type | y_type  | cs_type | execution_type |
  !>         |---------|---------|---------|----------------|
  !>         |  bf16_r |  bf16_r | bf16_r  |  f32_r         |
  !>         |  f16_r  |  f16_r  | f16_r   |  f32_r         |
  !>         |  f32_r  |  f32_r  | f32_r   |  f32_r         |
  !>         |  f64_r  |  f64_r  | f64_r   |  f64_r         |
  !>         |  f32_c  |  f32_c  | f32_c   |  f32_c         |
  !>         |  f32_c  |  f32_c  | f32_r   |  f32_c         |
  !>         |  f64_c  |  f64_c  | f64_c   |  f64_c         |
  !>         |  f64_c  |  f64_c  | f64_r   |  f64_c         |
  !>         ------------------------------------------------
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device array of deivce pointers storing each vector x_i.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[inout]
  !>     y       device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     y_type [rocblas_datatype]
  !>            specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     cs_type [rocblas_datatype]
  !>             specifies the datatype of c and s.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                    specifies the datatype of computation.
  !>
  interface rocblas_rot_batched_ex
    function rocblas_rot_batched_ex_(handle,n,x,x_type,incx,y,y_type,incy,c,s,cs_type,batch_count,execution_type) bind(c, name="rocblas_rot_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_rot_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(rocblas_datatype_f16_r)),value :: cs_type
      integer(c_int),value :: batch_count
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rot_strided_batched_ex applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batch_count.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.
  !> 
  !>     In the case where cs_type is real:
  !>             x := c * x + s * y
  !>             y := c * y - s * x
  !> 
  !>         In the case where cs_type is complex, the imaginary part of c is ignored:
  !>             x := real(c) * x + s * y
  !>             y := real(c) * y - conj(s) * x
  !> 
  !>     Currently supported datatypes are as follows:
  !> 
  !>         ------------------------------------------------
  !>         |  x_type | y_type  | cs_type | execution_type |
  !>         |---------|---------|---------|----------------|
  !>         |  bf16_r |  bf16_r | bf16_r  |  f32_r         |
  !>         |  f16_r  |  f16_r  | f16_r   |  f32_r         |
  !>         |  f32_r  |  f32_r  | f32_r   |  f32_r         |
  !>         |  f64_r  |  f64_r  | f64_r   |  f64_r         |
  !>         |  f32_c  |  f32_c  | f32_c   |  f32_c         |
  !>         |  f32_c  |  f32_c  | f32_r   |  f32_c         |
  !>         |  f64_c  |  f64_c  | f64_c   |  f64_c         |
  !>         |  f64_c  |  f64_c  | f64_r   |  f64_c         |
  !>         ------------------------------------------------
  !> 
  !>     @param[in]
  !>     handle  [rocblas_handle]
  !>             handle to the rocblas library context queue.
  !>     @param[in]
  !>     n       [rocblas_int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device pointer to the first vector x_1.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx    [rocblas_int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[in]
  !>     stride_x [rocblas_stride]
  !>              specifies the increment from the beginning of x_i to the beginning of x_(i+1)
  !>     @param[inout]
  !>     y       device pointer to the first vector y_1.
  !>     @param[in]
  !>     y_type [rocblas_datatype]
  !>            specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy    [rocblas_int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     stride_y [rocblas_stride]
  !>              specifies the increment from the beginning of y_i to the beginning of y_(i+1)
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     cs_type [rocblas_datatype]
  !>             specifies the datatype of c and s.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>             the number of x and y arrays, i.e. the number of batches.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                    specifies the datatype of computation.
  !>
  interface rocblas_rot_strided_batched_ex
    function rocblas_rot_strided_batched_ex_(handle,n,x,x_type,incx,stride_x,y,y_type,incy,stride_y,c,s,cs_type,batch_count,execution_type) bind(c, name="rocblas_rot_strided_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_rot_strided_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stride_x
      type(c_ptr),value :: y
      integer(kind(rocblas_datatype_f16_r)),value :: y_type
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stride_y
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(rocblas_datatype_f16_r)),value :: cs_type
      integer(c_int),value :: batch_count
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     scal_ex  scales each element of vector x with scalar alpha.
  !> 
  !>         x := alpha * x
  !> 
  !>     Currently supported datatypes are as follows:
  !> 
  !>         ----------------------------------------
  !>         | alpha_type | x_type | execution_type |
  !>         |------------|--------|----------------|
  !>         |  f16_r     | f16_r  |     f16_r      |
  !>         |  f16_r     | f16_r  |     f32_r      |
  !>         |  f32_r     | f16_r  |     f32_r      |
  !>         |  f32_r     | f32_r  |     f32_r      |
  !>         |  f64_r     | f64_r  |     f64_r      |
  !>         |  f32_c     | f32_c  |     f32_c      |
  !>         |  f64_c     | f64_c  |     f64_c      |
  !>         |  f32_r     | f32_c  |     f32_c      |
  !>         |  f64_r     | f64_c  |     f64_c      |
  !>         ----------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     alpha     device pointer or host pointer for the scalar alpha.
  !>     @param[in]
  !>     alpha_type [rocblas_datatype]
  !>                specifies the datatype of alpha.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of vector x.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                    specifies the datatype of computation.
  !>
  interface rocblas_scal_ex
    function rocblas_scal_ex_(handle,n,alpha,alpha_type,x,x_type,incx,execution_type) bind(c, name="rocblas_scal_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scal_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(rocblas_datatype_f16_r)),value :: alpha_type
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     scal_batched_ex  scales each element of each vector x_i with scalar alpha.
  !> 
  !>         x_i := alpha * x_i
  !> 
  !>     Currently supported datatypes are as follows:
  !> 
  !>         ----------------------------------------
  !>         | alpha_type | x_type | execution_type |
  !>         |------------|--------|----------------|
  !>         |  f16_r     | f16_r  |     f16_r      |
  !>         |  f16_r     | f16_r  |     f32_r      |
  !>         |  f32_r     | f16_r  |     f32_r      |
  !>         |  f32_r     | f32_r  |     f32_r      |
  !>         |  f64_r     | f64_r  |     f64_r      |
  !>         |  f32_c     | f32_c  |     f32_c      |
  !>         |  f64_c     | f64_c  |     f64_c      |
  !>         |  f32_r     | f32_c  |     f32_c      |
  !>         |  f64_r     | f64_c  |     f64_c      |
  !>         ----------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     alpha     device pointer or host pointer for the scalar alpha.
  !>     @param[in]
  !>     alpha_type [rocblas_datatype]
  !>                specifies the datatype of alpha.
  !>     @param[inout]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                    specifies the datatype of computation.
  !>
  interface rocblas_scal_batched_ex
    function rocblas_scal_batched_ex_(handle,n,alpha,alpha_type,x,x_type,incx,batch_count,execution_type) bind(c, name="rocblas_scal_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scal_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(rocblas_datatype_f16_r)),value :: alpha_type
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      integer(c_int),value :: batch_count
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief BLAS EX API
  !> 
  !>     \details
  !>     scal_strided_batched_ex  scales each element of vector x with scalar alpha over a set
  !>                              of strided batched vectors.
  !> 
  !>         x := alpha * x
  !> 
  !>     Currently supported datatypes are as follows:
  !> 
  !>         ----------------------------------------
  !>         | alpha_type | x_type | execution_type |
  !>         |------------|--------|----------------|
  !>         |  f16_r     | f16_r  |     f16_r      |
  !>         |  f16_r     | f16_r  |     f32_r      |
  !>         |  f32_r     | f16_r  |     f32_r      |
  !>         |  f32_r     | f32_r  |     f32_r      |
  !>         |  f64_r     | f64_r  |     f64_r      |
  !>         |  f32_c     | f32_c  |     f32_c      |
  !>         |  f64_c     | f64_c  |     f64_c      |
  !>         |  f32_r     | f32_c  |     f32_c      |
  !>         |  f64_r     | f64_c  |     f64_c      |
  !>         ----------------------------------------
  !> 
  !>     @param[in]
  !>     handle    [rocblas_handle]
  !>               handle to the rocblas library context queue.
  !>     @param[in]
  !>     n         [rocblas_int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     alpha     device pointer or host pointer for the scalar alpha.
  !>     @param[in]
  !>     alpha_type [rocblas_datatype]
  !>                specifies the datatype of alpha.
  !>     @param[inout]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     x_type [rocblas_datatype]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [rocblas_int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [rocblas_stride]
  !>               stride from the start of one vector (x_i) to the next one (x_i+1).
  !>               There are no restrictions placed on stridex, however the user should
  !>               take care to ensure that stridex is of appropriate size, for a typical
  !>               case this means stridex >= n * incx.
  !>     @param[in]
  !>     batch_count [rocblas_int]
  !>                 number of instances in the batch.
  !>     @param[in]
  !>     execution_type [rocblas_datatype]
  !>                    specifies the datatype of computation.
  !>
  interface rocblas_scal_strided_batched_ex
    function rocblas_scal_strided_batched_ex_(handle,n,alpha,alpha_type,x,x_type,incx,stridex,batch_count,execution_type) bind(c, name="rocblas_scal_strided_batched_ex")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scal_strided_batched_ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(rocblas_datatype_f16_r)),value :: alpha_type
      type(c_ptr),value :: x
      integer(kind(rocblas_datatype_f16_r)),value :: x_type
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batch_count
      integer(kind(rocblas_datatype_f16_r)),value :: execution_type
    end function

  end interface
  !>  \brief   loads char* buf with the rocblas library version. size_t len
  !>     is the maximum length of char* buf.
  !>     \details
  !> 
  !>     @param[in, out]
  !>     buf             pointer to buffer for version string
  !> 
  !>     @param[in]
  !>     len             length of buf
  !>
  interface rocblas_get_version_string
    function rocblas_get_version_string_(buf,len) bind(c, name="rocblas_get_version_string")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_version_string_
      type(c_ptr),value :: buf
      integer(c_size_t),value :: len
    end function

  end interface
  !>  \brief   Queries the minimum buffer size for a successful call to
  !>     \ref rocblas_get_version_string
  !>     \details
  !> 
  !>     @param[out]
  !>     len             pointer to size_t for storing the length
  !>
  interface rocblas_get_version_string_size
    function rocblas_get_version_string_size_(len) bind(c, name="rocblas_get_version_string_size")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_version_string_size_
      type(c_ptr),value :: len
    end function

  end interface
  !>  \brief
  !>     \details
  !>     Indicates that subsequent rocBLAS kernel calls should collect the optimal device memory size in bytes for their given kernel arguments,
  !>     and keep track of the maximum.
  !>     Each kernel call can reuse temporary device memory on the same stream, so the maximum is collected.
  !>     Returns rocblas_status_size_query_mismatch if another size query is already in progress; returns rocblas_status_success otherwise.
  !>     @param[in]
  !>     handle          rocblas handle
  interface rocblas_start_device_memory_size_query
    function rocblas_start_device_memory_size_query_(handle) bind(c, name="rocblas_start_device_memory_size_query")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_start_device_memory_size_query_
      type(c_ptr),value :: handle
    end function

  end interface
  !>  \brief
  !>     \details
  !>     Stops collecting optimal device memory size information
  !>     Returns rocblas_status_size_query_mismatch if a collection is not underway; rocblas_status_invalid_handle if handle is nullptr;
  !>     rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise
  !>     @param[in]
  !>     handle          rocblas handle
  !>     @param[out]
  !>     size            maximum of the optimal sizes collected
  interface rocblas_stop_device_memory_size_query
    function rocblas_stop_device_memory_size_query_(handle,mySize) bind(c, name="rocblas_stop_device_memory_size_query")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stop_device_memory_size_query_
      type(c_ptr),value :: handle
      integer(c_size_t) :: mySize
    end function

  end interface
  
  interface rocblas_device_malloc_ptr
    function rocblas_device_malloc_ptr_(ptr,res) bind(c, name="rocblas_device_malloc_ptr")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_device_malloc_ptr_
      type(c_ptr),value :: ptr
      type(c_ptr) :: res
    end function

  end interface
  
  interface rocblas_device_malloc_get
    function rocblas_device_malloc_get_(ptr,index,res) bind(c, name="rocblas_device_malloc_get")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_device_malloc_get_
      type(c_ptr),value :: ptr
      integer(c_size_t),value :: index
      type(c_ptr) :: res
    end function

  end interface
  
  interface rocblas_device_malloc_free
    function rocblas_device_malloc_free_(ptr) bind(c, name="rocblas_device_malloc_free")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_device_malloc_free_
      type(c_ptr),value :: ptr
    end function

  end interface
  !>  \brief
  !>     \details
  !>     Gets the current device memory size for the handle
  !>     Returns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise
  !>     @param[in]
  !>     handle          rocblas handle
  !>     @param[out]
  !>     size            current device memory size for the handle
  interface rocblas_get_device_memory_size
    function rocblas_get_device_memory_size_(handle,mySize) bind(c, name="rocblas_get_device_memory_size")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_device_memory_size_
      type(c_ptr),value :: handle
      integer(c_size_t) :: mySize
    end function

  end interface
  !>  \brief
  !>     \details
  !>     Changes the size of allocated device memory at runtime.
  !> 
  !>     Any previously allocated device memory managed by the handle is freed.
  !> 
  !>     If size > 0 sets the device memory size to the specified size (in bytes)
  !>     If size == 0 frees the memory allocated so far, and lets rocBLAS manage device memory in the future, expanding it when necessary
  !>     Returns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise
  !>     @param[in]
  !>     handle          rocblas handle
  !>     @param[in]
  !>     size            size of allocated device memory
  interface rocblas_set_device_memory_size
    function rocblas_set_device_memory_size_(handle,mySize) bind(c, name="rocblas_set_device_memory_size")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_device_memory_size_
      type(c_ptr),value :: handle
      integer(c_size_t),value :: mySize
    end function

  end interface
  !>  \brief
  !>     \details
  !>     Sets the device workspace for the handle to use.
  !> 
  !>     Any previously allocated device memory managed by the handle is freed.
  !> 
  !>     Returns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_success otherwise
  !>     @param[in]
  !>     handle          rocblas handle
  !>     @param[in]
  !>     addr            address of workspace memory
  !>     @param[in]
  !>     size            size of workspace memory
  !>
  interface rocblas_set_workspace
    function rocblas_set_workspace_(handle,addr,mySize) bind(c, name="rocblas_set_workspace")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_workspace_
      type(c_ptr),value :: handle
      type(c_ptr),value :: addr
      integer(c_size_t),value :: mySize
    end function

  end interface
  !>  \brief create handle
  interface rocblas_create_handle
    function rocblas_create_handle_(handle) bind(c, name="rocblas_create_handle")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_create_handle_
      type(c_ptr) :: handle
    end function

  end interface
  !>  \brief destroy handle
  interface rocblas_destroy_handle
    function rocblas_destroy_handle_(handle) bind(c, name="rocblas_destroy_handle")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_destroy_handle_
      type(c_ptr),value :: handle
    end function

  end interface
  !>  \brief set stream for handle
  interface rocblas_set_stream
    function rocblas_set_stream_(handle,stream) bind(c, name="rocblas_set_stream")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_stream_
      type(c_ptr),value :: handle
      type(c_ptr),value :: stream
    end function

  end interface
  !>  \brief get stream [0] from handle
  interface rocblas_get_stream
    function rocblas_get_stream_(handle,stream) bind(c, name="rocblas_get_stream")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_stream_
      type(c_ptr),value :: handle
      type(c_ptr) :: stream
    end function

  end interface
  !>  \brief set rocblas_pointer_mode
  interface rocblas_set_pointer_mode
    function rocblas_set_pointer_mode_(handle,pointer_mode) bind(c, name="rocblas_set_pointer_mode")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_pointer_mode_
      type(c_ptr),value :: handle
      integer(kind(rocblas_pointer_mode_host)),value :: pointer_mode
    end function

  end interface
  !>  \brief get rocblas_pointer_mode
  interface rocblas_get_pointer_mode
    function rocblas_get_pointer_mode_(handle,pointer_mode) bind(c, name="rocblas_get_pointer_mode")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_pointer_mode_
      type(c_ptr),value :: handle
      type(c_ptr),value :: pointer_mode
    end function

  end interface
  !>  \brief set rocblas_atomics_mode
  interface rocblas_set_atomics_mode
    function rocblas_set_atomics_mode_(handle,atomics_mode) bind(c, name="rocblas_set_atomics_mode")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_atomics_mode_
      type(c_ptr),value :: handle
      integer(kind(rocblas_atomics_not_allowed)),value :: atomics_mode
    end function

  end interface
  !>  \brief get rocblas_atomics_mode
  interface rocblas_get_atomics_mode
    function rocblas_get_atomics_mode_(handle,atomics_mode) bind(c, name="rocblas_get_atomics_mode")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_atomics_mode_
      type(c_ptr),value :: handle
      type(c_ptr),value :: atomics_mode
    end function

  end interface
  !>  \brief query the preferable supported int8 input layout for gemm
  !>      \details
  !>     Indicates the supported int8 input layout for gemm according to the device.
  !>     If the device supports packed-int8x4 (1) only, output flag is rocblas_gemm_flags_pack_int8x4
  !>     and users must bitwise-or your flag with rocblas_gemm_flags_pack_int8x4.
  !>     If output flag is rocblas_gemm_flags_none (0), then unpacked int8 is preferable and suggested.
  !>     @param[in]
  !>     handle      [rocblas_handle]
  !>                 the handle of device
  !>     @param[out]
  !>     flag        pointer to rocblas_gemm_flags
  interface rocblas_query_int8_layout_flag
    function rocblas_query_int8_layout_flag_(handle,flag) bind(c, name="rocblas_query_int8_layout_flag")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_query_int8_layout_flag_
      type(c_ptr),value :: handle
      type(c_ptr),value :: flag
    end function

  end interface
  !>  Function to set start/stop event handlers (for internal use only)
  interface rocblas_set_start_stop_events
    function rocblas_set_start_stop_events_(handle,startEvent,stopEvent) bind(c, name="rocblas_set_start_stop_events")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_start_stop_events_
      type(c_ptr),value :: handle
      type(c_ptr),value :: startEvent
      type(c_ptr),value :: stopEvent
    end function

  end interface
  
  interface rocblas_set_solution_fitness_query
    function rocblas_set_solution_fitness_query_(handle,fitness) bind(c, name="rocblas_set_solution_fitness_query")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_solution_fitness_query_
      type(c_ptr),value :: handle
      type(c_ptr),value :: fitness
    end function

  end interface
  !>  \brief specifies the performance metric that solution selection uses
  !>      \details
  !>     Determines which performance metric will be used by Tensile when selecting the optimal solution
  !>     for gemm problems. If a valid solution benchmarked for this performance metric does not exist
  !>     for a problem, Tensile will default to a solution benchmarked for overall performance instead.
  !>     @param[in]
  !>     handle      [rocblas_handle]
  !>                 the handle of device
  !>     @param[in]
  !>     metric      [rocblas_performance_metric]
  !>                 the performance metric to be used
  interface rocblas_set_performance_metric
    function rocblas_set_performance_metric_(handle,metric) bind(c, name="rocblas_set_performance_metric")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_set_performance_metric_
      type(c_ptr),value :: handle
      integer(kind(rocblas_default_performance_metric)),value :: metric
    end function

  end interface
  !>  \brief returns the performance metric being used for solution selection
  !>      \details
  !>     Returns the performance metric used by Tensile to select the optimal solution for gemm problems.
  !>     @param[in]
  !>     handle      [rocblas_handle]
  !>                 the handle of device
  !>     @param[out]
  !>     metric      [rocblas_performance_metric*]
  !>                 pointer to where the metric will be stored
  interface rocblas_get_performance_metric
    function rocblas_get_performance_metric_(handle,metric) bind(c, name="rocblas_get_performance_metric")
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_get_performance_metric_
      type(c_ptr),value :: handle
      type(c_ptr),value :: metric
    end function

  end interface

#ifdef USE_FPOINTER_INTERFACES
  contains
    function rocblas_cscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_cscal_rank_0 = rocblas_cscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_cscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_cscal_rank_1 = rocblas_cscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_zscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_zscal_rank_0 = rocblas_zscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_zscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_zscal_rank_1 = rocblas_zscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_csscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_csscal_rank_0 = rocblas_csscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_csscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_csscal_rank_1 = rocblas_csscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_zdscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_zdscal_rank_0 = rocblas_zdscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_zdscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_zdscal_rank_1 = rocblas_zdscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function rocblas_sscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_sscal_batched_full_rank = rocblas_sscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_sscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_sscal_batched_rank_0 = rocblas_sscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_sscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_sscal_batched_rank_1 = rocblas_sscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_dscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dscal_batched_full_rank = rocblas_dscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_dscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dscal_batched_rank_0 = rocblas_dscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_dscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dscal_batched_rank_1 = rocblas_dscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_cscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_cscal_batched_full_rank = rocblas_cscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_cscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_cscal_batched_rank_0 = rocblas_cscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_cscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_cscal_batched_rank_1 = rocblas_cscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_zscal_batched_full_rank = rocblas_zscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_zscal_batched_rank_0 = rocblas_zscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_zscal_batched_rank_1 = rocblas_zscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_csscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_csscal_batched_full_rank = rocblas_csscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_csscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_csscal_batched_rank_0 = rocblas_csscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_csscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_csscal_batched_rank_1 = rocblas_csscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zdscal_batched_full_rank(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_zdscal_batched_full_rank = rocblas_zdscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zdscal_batched_rank_0(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_zdscal_batched_rank_0 = rocblas_zdscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_zdscal_batched_rank_1(handle,n,alpha,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_zdscal_batched_rank_1 = rocblas_zdscal_batched_(handle,n,alpha,c_loc(x),incx,batch_count)
    end function

    function rocblas_sscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_sscal_strided_batched_rank_0 = rocblas_sscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_sscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sscal_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_sscal_strided_batched_rank_1 = rocblas_sscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dscal_strided_batched_rank_0 = rocblas_dscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dscal_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dscal_strided_batched_rank_1 = rocblas_dscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_cscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_cscal_strided_batched_rank_0 = rocblas_cscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_cscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cscal_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_cscal_strided_batched_rank_1 = rocblas_cscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_zscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_zscal_strided_batched_rank_0 = rocblas_zscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_zscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zscal_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_zscal_strided_batched_rank_1 = rocblas_zscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_csscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_csscal_strided_batched_rank_0 = rocblas_csscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_csscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csscal_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_csscal_strided_batched_rank_1 = rocblas_csscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_zdscal_strided_batched_rank_0(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_zdscal_strided_batched_rank_0 = rocblas_zdscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_zdscal_strided_batched_rank_1(handle,n,alpha,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdscal_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_zdscal_strided_batched_rank_1 = rocblas_zdscal_strided_batched_(handle,n,alpha,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_scopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      rocblas_scopy_rank_0 = rocblas_scopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_scopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_scopy_rank_1 = rocblas_scopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_dcopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      rocblas_dcopy_rank_0 = rocblas_dcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_dcopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dcopy_rank_1 = rocblas_dcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_ccopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_ccopy_rank_0 = rocblas_ccopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_ccopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_ccopy_rank_1 = rocblas_ccopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zcopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_zcopy_rank_0 = rocblas_zcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zcopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zcopy_rank_1 = rocblas_zcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_scopy_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_scopy_batched_full_rank = rocblas_scopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_scopy_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_scopy_batched_rank_0 = rocblas_scopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_scopy_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_scopy_batched_rank_1 = rocblas_scopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dcopy_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dcopy_batched_full_rank = rocblas_dcopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dcopy_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dcopy_batched_rank_0 = rocblas_dcopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dcopy_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dcopy_batched_rank_1 = rocblas_dcopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_ccopy_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_ccopy_batched_full_rank = rocblas_ccopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_ccopy_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_ccopy_batched_rank_0 = rocblas_ccopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_ccopy_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_ccopy_batched_rank_1 = rocblas_ccopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zcopy_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zcopy_batched_full_rank = rocblas_zcopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zcopy_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zcopy_batched_rank_0 = rocblas_zcopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zcopy_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zcopy_batched_rank_1 = rocblas_zcopy_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_scopy_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_scopy_strided_batched_rank_0 = rocblas_scopy_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_scopy_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scopy_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_scopy_strided_batched_rank_1 = rocblas_scopy_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dcopy_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dcopy_strided_batched_rank_0 = rocblas_dcopy_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dcopy_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dcopy_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dcopy_strided_batched_rank_1 = rocblas_dcopy_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ccopy_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_ccopy_strided_batched_rank_0 = rocblas_ccopy_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ccopy_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ccopy_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_ccopy_strided_batched_rank_1 = rocblas_ccopy_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zcopy_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zcopy_strided_batched_rank_0 = rocblas_zcopy_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zcopy_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zcopy_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zcopy_strided_batched_rank_1 = rocblas_zcopy_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sdot_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_sdot_rank_0 = rocblas_sdot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_sdot_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_sdot_rank_1 = rocblas_sdot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_ddot_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_ddot_rank_0 = rocblas_ddot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_ddot_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_ddot_rank_1 = rocblas_ddot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_cdotu_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_cdotu_rank_0 = rocblas_cdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_cdotu_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_cdotu_rank_1 = rocblas_cdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_zdotu_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_zdotu_rank_0 = rocblas_zdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_zdotu_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_zdotu_rank_1 = rocblas_zdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_cdotc_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_cdotc_rank_0 = rocblas_cdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_cdotc_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_cdotc_rank_1 = rocblas_cdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_zdotc_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_zdotc_rank_0 = rocblas_zdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_zdotc_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      rocblas_zdotc_rank_1 = rocblas_zdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function rocblas_sdot_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_sdot_batched_full_rank = rocblas_sdot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_sdot_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_sdot_batched_rank_0 = rocblas_sdot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_sdot_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_sdot_batched_rank_1 = rocblas_sdot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_ddot_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_ddot_batched_full_rank = rocblas_ddot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_ddot_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_ddot_batched_rank_0 = rocblas_ddot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_ddot_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_ddot_batched_rank_1 = rocblas_ddot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotu_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_cdotu_batched_full_rank = rocblas_cdotu_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotu_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_cdotu_batched_rank_0 = rocblas_cdotu_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotu_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_cdotu_batched_rank_1 = rocblas_cdotu_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotu_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_zdotu_batched_full_rank = rocblas_zdotu_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotu_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_zdotu_batched_rank_0 = rocblas_zdotu_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotu_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_zdotu_batched_rank_1 = rocblas_zdotu_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotc_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_cdotc_batched_full_rank = rocblas_cdotc_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotc_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_cdotc_batched_rank_0 = rocblas_cdotc_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_cdotc_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_cdotc_batched_rank_1 = rocblas_cdotc_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotc_batched_full_rank(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_zdotc_batched_full_rank = rocblas_zdotc_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotc_batched_rank_0(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_zdotc_batched_rank_0 = rocblas_zdotc_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_zdotc_batched_rank_1(handle,n,x,incx,y,incy,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_zdotc_batched_rank_1 = rocblas_zdotc_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count,myResult)
    end function

    function rocblas_sdot_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_sdot_strided_batched_rank_0 = rocblas_sdot_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_sdot_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdot_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_sdot_strided_batched_rank_1 = rocblas_sdot_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_ddot_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_ddot_strided_batched_rank_0 = rocblas_ddot_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_ddot_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddot_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_ddot_strided_batched_rank_1 = rocblas_ddot_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_cdotu_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_cdotu_strided_batched_rank_0 = rocblas_cdotu_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_cdotu_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotu_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_cdotu_strided_batched_rank_1 = rocblas_cdotu_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_zdotu_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_zdotu_strided_batched_rank_0 = rocblas_zdotu_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_zdotu_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotu_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_zdotu_strided_batched_rank_1 = rocblas_zdotu_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_cdotc_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_cdotc_strided_batched_rank_0 = rocblas_cdotc_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_cdotc_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdotc_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_cdotc_strided_batched_rank_1 = rocblas_cdotc_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_zdotc_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_zdotc_strided_batched_rank_0 = rocblas_zdotc_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_zdotc_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdotc_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_zdotc_strided_batched_rank_1 = rocblas_zdotc_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count,myResult)
    end function

    function rocblas_cswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_cswap_rank_0 = rocblas_cswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_cswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_cswap_rank_1 = rocblas_cswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_zswap_rank_0 = rocblas_zswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zswap_rank_1 = rocblas_zswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_sswap_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sswap_batched_full_rank = rocblas_sswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_sswap_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sswap_batched_rank_0 = rocblas_sswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_sswap_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sswap_batched_rank_1 = rocblas_sswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dswap_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dswap_batched_full_rank = rocblas_dswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dswap_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dswap_batched_rank_0 = rocblas_dswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_dswap_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dswap_batched_rank_1 = rocblas_dswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_cswap_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_cswap_batched_full_rank = rocblas_cswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_cswap_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_cswap_batched_rank_0 = rocblas_cswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_cswap_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_cswap_batched_rank_1 = rocblas_cswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zswap_batched_full_rank(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zswap_batched_full_rank = rocblas_zswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zswap_batched_rank_0(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zswap_batched_rank_0 = rocblas_zswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zswap_batched_rank_1(handle,n,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zswap_batched_rank_1 = rocblas_zswap_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_sswap_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_sswap_strided_batched_rank_0 = rocblas_sswap_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sswap_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sswap_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_sswap_strided_batched_rank_1 = rocblas_sswap_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dswap_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dswap_strided_batched_rank_0 = rocblas_dswap_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dswap_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dswap_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dswap_strided_batched_rank_1 = rocblas_dswap_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_cswap_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_cswap_strided_batched_rank_0 = rocblas_cswap_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_cswap_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cswap_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_cswap_strided_batched_rank_1 = rocblas_cswap_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zswap_strided_batched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zswap_strided_batched_rank_0 = rocblas_zswap_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zswap_strided_batched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zswap_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zswap_strided_batched_rank_1 = rocblas_zswap_strided_batched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_saxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      rocblas_saxpy_rank_0 = rocblas_saxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_saxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_saxpy_rank_1 = rocblas_saxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_daxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      rocblas_daxpy_rank_0 = rocblas_daxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_daxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_daxpy_rank_1 = rocblas_daxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_caxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_caxpy_rank_0 = rocblas_caxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_caxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_caxpy_rank_1 = rocblas_caxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zaxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_zaxpy_rank_0 = rocblas_zaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_zaxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zaxpy_rank_1 = rocblas_zaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function rocblas_saxpy_batched_full_rank(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_saxpy_batched_full_rank = rocblas_saxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_saxpy_batched_rank_0(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_saxpy_batched_rank_0 = rocblas_saxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_saxpy_batched_rank_1(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_saxpy_batched_rank_1 = rocblas_saxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_daxpy_batched_full_rank(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_daxpy_batched_full_rank = rocblas_daxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_daxpy_batched_rank_0(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_daxpy_batched_rank_0 = rocblas_daxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_daxpy_batched_rank_1(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_daxpy_batched_rank_1 = rocblas_daxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_caxpy_batched_full_rank(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_caxpy_batched_full_rank = rocblas_caxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_caxpy_batched_rank_0(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_caxpy_batched_rank_0 = rocblas_caxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_caxpy_batched_rank_1(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_caxpy_batched_rank_1 = rocblas_caxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zaxpy_batched_full_rank(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zaxpy_batched_full_rank = rocblas_zaxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zaxpy_batched_rank_0(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zaxpy_batched_rank_0 = rocblas_zaxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_zaxpy_batched_rank_1(handle,n,alpha,x,incx,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zaxpy_batched_rank_1 = rocblas_zaxpy_batched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batch_count)
    end function

    function rocblas_saxpy_strided_batched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_saxpy_strided_batched_rank_0 = rocblas_saxpy_strided_batched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_saxpy_strided_batched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_saxpy_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_saxpy_strided_batched_rank_1 = rocblas_saxpy_strided_batched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_daxpy_strided_batched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_daxpy_strided_batched_rank_0 = rocblas_daxpy_strided_batched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_daxpy_strided_batched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_daxpy_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_daxpy_strided_batched_rank_1 = rocblas_daxpy_strided_batched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_caxpy_strided_batched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_caxpy_strided_batched_rank_0 = rocblas_caxpy_strided_batched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_caxpy_strided_batched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_caxpy_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_caxpy_strided_batched_rank_1 = rocblas_caxpy_strided_batched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zaxpy_strided_batched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zaxpy_strided_batched_rank_0 = rocblas_zaxpy_strided_batched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zaxpy_strided_batched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zaxpy_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zaxpy_strided_batched_rank_1 = rocblas_zaxpy_strided_batched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_scasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_scasum_rank_0 = rocblas_scasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_scasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_scasum_rank_1 = rocblas_scasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_dzasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_dzasum_rank_0 = rocblas_dzasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_dzasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_dzasum_rank_1 = rocblas_dzasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_sasum_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_sasum_batched_full_rank = rocblas_sasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_sasum_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_sasum_batched_rank_0 = rocblas_sasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_sasum_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_sasum_batched_rank_1 = rocblas_sasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dasum_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dasum_batched_full_rank = rocblas_dasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dasum_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dasum_batched_rank_0 = rocblas_dasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dasum_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dasum_batched_rank_1 = rocblas_dasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scasum_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_scasum_batched_full_rank = rocblas_scasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scasum_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_scasum_batched_rank_0 = rocblas_scasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scasum_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_scasum_batched_rank_1 = rocblas_scasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dzasum_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dzasum_batched_full_rank = rocblas_dzasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dzasum_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dzasum_batched_rank_0 = rocblas_dzasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dzasum_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dzasum_batched_rank_1 = rocblas_dzasum_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_sasum_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_sasum_strided_batched_rank_0 = rocblas_sasum_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_sasum_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sasum_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_sasum_strided_batched_rank_1 = rocblas_sasum_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dasum_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dasum_strided_batched_rank_0 = rocblas_dasum_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dasum_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dasum_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dasum_strided_batched_rank_1 = rocblas_dasum_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_scasum_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_scasum_strided_batched_rank_0 = rocblas_scasum_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_scasum_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scasum_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_scasum_strided_batched_rank_1 = rocblas_scasum_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dzasum_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dzasum_strided_batched_rank_0 = rocblas_dzasum_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dzasum_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dzasum_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dzasum_strided_batched_rank_1 = rocblas_dzasum_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_scnrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_scnrm2_rank_0 = rocblas_scnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_scnrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_scnrm2_rank_1 = rocblas_scnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_dznrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_dznrm2_rank_0 = rocblas_dznrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_dznrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_dznrm2_rank_1 = rocblas_dznrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_snrm2_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_snrm2_batched_full_rank = rocblas_snrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_snrm2_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_snrm2_batched_rank_0 = rocblas_snrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_snrm2_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_snrm2_batched_rank_1 = rocblas_snrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dnrm2_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dnrm2_batched_full_rank = rocblas_dnrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dnrm2_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dnrm2_batched_rank_0 = rocblas_dnrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dnrm2_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dnrm2_batched_rank_1 = rocblas_dnrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scnrm2_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_scnrm2_batched_full_rank = rocblas_scnrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scnrm2_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_scnrm2_batched_rank_0 = rocblas_scnrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_scnrm2_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_scnrm2_batched_rank_1 = rocblas_scnrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dznrm2_batched_full_rank(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dznrm2_batched_full_rank = rocblas_dznrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dznrm2_batched_rank_0(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dznrm2_batched_rank_0 = rocblas_dznrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_dznrm2_batched_rank_1(handle,n,x,incx,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dznrm2_batched_rank_1 = rocblas_dznrm2_batched_(handle,n,c_loc(x),incx,batch_count,results)
    end function

    function rocblas_snrm2_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_snrm2_strided_batched_rank_0 = rocblas_snrm2_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_snrm2_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_snrm2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_snrm2_strided_batched_rank_1 = rocblas_snrm2_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dnrm2_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dnrm2_strided_batched_rank_0 = rocblas_dnrm2_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dnrm2_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dnrm2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dnrm2_strided_batched_rank_1 = rocblas_dnrm2_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_scnrm2_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_scnrm2_strided_batched_rank_0 = rocblas_scnrm2_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_scnrm2_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_scnrm2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_scnrm2_strided_batched_rank_1 = rocblas_scnrm2_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dznrm2_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dznrm2_strided_batched_rank_0 = rocblas_dznrm2_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_dznrm2_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,results)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dznrm2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: results
      !
      rocblas_dznrm2_strided_batched_rank_1 = rocblas_dznrm2_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,results)
    end function

    function rocblas_icamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_icamax_rank_0 = rocblas_icamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_icamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_icamax_rank_1 = rocblas_icamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_izamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_izamax_rank_0 = rocblas_izamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_izamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_izamax_rank_1 = rocblas_izamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_isamax_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_isamax_batched_full_rank = rocblas_isamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamax_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_isamax_batched_rank_0 = rocblas_isamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamax_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_isamax_batched_rank_1 = rocblas_isamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamax_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_idamax_batched_full_rank = rocblas_idamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamax_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_idamax_batched_rank_0 = rocblas_idamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamax_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_idamax_batched_rank_1 = rocblas_idamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamax_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_icamax_batched_full_rank = rocblas_icamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamax_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_icamax_batched_rank_0 = rocblas_icamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamax_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_icamax_batched_rank_1 = rocblas_icamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamax_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_izamax_batched_full_rank = rocblas_izamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamax_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_izamax_batched_rank_0 = rocblas_izamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamax_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_izamax_batched_rank_1 = rocblas_izamax_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamax_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_isamax_strided_batched_rank_0 = rocblas_isamax_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_isamax_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamax_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_isamax_strided_batched_rank_1 = rocblas_isamax_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_idamax_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_idamax_strided_batched_rank_0 = rocblas_idamax_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_idamax_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamax_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_idamax_strided_batched_rank_1 = rocblas_idamax_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_icamax_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_icamax_strided_batched_rank_0 = rocblas_icamax_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_icamax_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamax_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_icamax_strided_batched_rank_1 = rocblas_icamax_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_izamax_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_izamax_strided_batched_rank_0 = rocblas_izamax_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_izamax_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamax_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_izamax_strided_batched_rank_1 = rocblas_izamax_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_icamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_icamin_rank_0 = rocblas_icamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_icamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_icamin_rank_1 = rocblas_icamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_izamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_izamin_rank_0 = rocblas_izamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_izamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      rocblas_izamin_rank_1 = rocblas_izamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function rocblas_isamin_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_isamin_batched_full_rank = rocblas_isamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamin_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_isamin_batched_rank_0 = rocblas_isamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamin_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_isamin_batched_rank_1 = rocblas_isamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamin_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_idamin_batched_full_rank = rocblas_idamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamin_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_idamin_batched_rank_0 = rocblas_idamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_idamin_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_idamin_batched_rank_1 = rocblas_idamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamin_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_icamin_batched_full_rank = rocblas_icamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamin_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_icamin_batched_rank_0 = rocblas_icamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_icamin_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_icamin_batched_rank_1 = rocblas_icamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamin_batched_full_rank(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_izamin_batched_full_rank = rocblas_izamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamin_batched_rank_0(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_izamin_batched_rank_0 = rocblas_izamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_izamin_batched_rank_1(handle,n,x,incx,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_izamin_batched_rank_1 = rocblas_izamin_batched_(handle,n,c_loc(x),incx,batch_count,myResult)
    end function

    function rocblas_isamin_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_isamin_strided_batched_rank_0 = rocblas_isamin_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_isamin_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_isamin_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_isamin_strided_batched_rank_1 = rocblas_isamin_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_idamin_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_idamin_strided_batched_rank_0 = rocblas_idamin_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_idamin_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_idamin_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_idamin_strided_batched_rank_1 = rocblas_idamin_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_icamin_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_icamin_strided_batched_rank_0 = rocblas_icamin_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_icamin_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_icamin_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_icamin_strided_batched_rank_1 = rocblas_icamin_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_izamin_strided_batched_rank_0(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_izamin_strided_batched_rank_0 = rocblas_izamin_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_izamin_strided_batched_rank_1(handle,n,x,incx,stridex,batch_count,myResult)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_izamin_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      type(c_ptr) :: myResult
      !
      rocblas_izamin_strided_batched_rank_1 = rocblas_izamin_strided_batched_(handle,n,c_loc(x),incx,stridex,batch_count,myResult)
    end function

    function rocblas_srot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_srot_rank_0 = rocblas_srot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_srot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_srot_rank_1 = rocblas_srot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_drot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_drot_rank_0 = rocblas_drot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_drot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_drot_rank_1 = rocblas_drot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_crot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_crot_rank_0 = rocblas_crot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_crot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_crot_rank_1 = rocblas_crot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_csrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_csrot_rank_0 = rocblas_csrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_csrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_csrot_rank_1 = rocblas_csrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_zrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_zrot_rank_0 = rocblas_zrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_zrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_zrot_rank_1 = rocblas_zrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_zdrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_zdrot_rank_0 = rocblas_zdrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_zdrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      rocblas_zdrot_rank_1 = rocblas_zdrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function rocblas_srot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_srot_batched_full_rank = rocblas_srot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_srot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_srot_batched_rank_0 = rocblas_srot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_srot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_srot_batched_rank_1 = rocblas_srot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_drot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_drot_batched_full_rank = rocblas_drot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_drot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_drot_batched_rank_0 = rocblas_drot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_drot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_drot_batched_rank_1 = rocblas_drot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_crot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_crot_batched_full_rank = rocblas_crot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_crot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_crot_batched_rank_0 = rocblas_crot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_crot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_crot_batched_rank_1 = rocblas_crot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_csrot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_csrot_batched_full_rank = rocblas_csrot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_csrot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_csrot_batched_rank_0 = rocblas_csrot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_csrot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_csrot_batched_rank_1 = rocblas_csrot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zrot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_zrot_batched_full_rank = rocblas_zrot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zrot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_zrot_batched_rank_0 = rocblas_zrot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zrot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_zrot_batched_rank_1 = rocblas_zrot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zdrot_batched_full_rank(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_zdrot_batched_full_rank = rocblas_zdrot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zdrot_batched_rank_0(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_zdrot_batched_rank_0 = rocblas_zdrot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_zdrot_batched_rank_1(handle,n,x,incx,y,incy,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_zdrot_batched_rank_1 = rocblas_zdrot_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batch_count)
    end function

    function rocblas_srot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_srot_strided_batched_rank_0 = rocblas_srot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_srot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srot_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_srot_strided_batched_rank_1 = rocblas_srot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_drot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_drot_strided_batched_rank_0 = rocblas_drot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_drot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drot_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_drot_strided_batched_rank_1 = rocblas_drot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_crot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_crot_strided_batched_rank_0 = rocblas_crot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_crot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_crot_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_crot_strided_batched_rank_1 = rocblas_crot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_csrot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_csrot_strided_batched_rank_0 = rocblas_csrot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_csrot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csrot_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_csrot_strided_batched_rank_1 = rocblas_csrot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_zrot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_zrot_strided_batched_rank_0 = rocblas_zrot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_zrot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zrot_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_zrot_strided_batched_rank_1 = rocblas_zrot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_zdrot_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_zdrot_strided_batched_rank_0 = rocblas_zdrot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_zdrot_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,c,s,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdrot_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batch_count
      !
      rocblas_zdrot_strided_batched_rank_1 = rocblas_zdrot_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c,s,batch_count)
    end function

    function rocblas_srotm_rank_0(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      rocblas_srotm_rank_0 = rocblas_srotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function rocblas_srotm_rank_1(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      rocblas_srotm_rank_1 = rocblas_srotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function rocblas_drotm_rank_0(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      rocblas_drotm_rank_0 = rocblas_drotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function rocblas_drotm_rank_1(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      rocblas_drotm_rank_1 = rocblas_drotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function rocblas_srotm_batched_full_rank(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batch_count
      !
      rocblas_srotm_batched_full_rank = rocblas_srotm_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_srotm_batched_rank_0(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batch_count
      !
      rocblas_srotm_batched_rank_0 = rocblas_srotm_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_srotm_batched_rank_1(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batch_count
      !
      rocblas_srotm_batched_rank_1 = rocblas_srotm_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_drotm_batched_full_rank(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batch_count
      !
      rocblas_drotm_batched_full_rank = rocblas_drotm_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_drotm_batched_rank_0(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batch_count
      !
      rocblas_drotm_batched_rank_0 = rocblas_drotm_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_drotm_batched_rank_1(handle,n,x,incx,y,incy,param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batch_count
      !
      rocblas_drotm_batched_rank_1 = rocblas_drotm_batched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batch_count)
    end function

    function rocblas_srotm_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: param
      integer(c_int64_t) :: stride_param
      integer(c_int) :: batch_count
      !
      rocblas_srotm_strided_batched_rank_0 = rocblas_srotm_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,param,stride_param,batch_count)
    end function

    function rocblas_srotm_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_srotm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: param
      integer(c_int64_t) :: stride_param
      integer(c_int) :: batch_count
      !
      rocblas_srotm_strided_batched_rank_1 = rocblas_srotm_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,param,stride_param,batch_count)
    end function

    function rocblas_drotm_strided_batched_rank_0(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: param
      integer(c_int64_t) :: stride_param
      integer(c_int) :: batch_count
      !
      rocblas_drotm_strided_batched_rank_0 = rocblas_drotm_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,param,stride_param,batch_count)
    end function

    function rocblas_drotm_strided_batched_rank_1(handle,n,x,incx,stride_x,y,incy,stride_y,param,stride_param,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_drotm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: param
      integer(c_int64_t) :: stride_param
      integer(c_int) :: batch_count
      !
      rocblas_drotm_strided_batched_rank_1 = rocblas_drotm_strided_batched_(handle,n,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,param,stride_param,batch_count)
    end function

    function rocblas_sgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_sgbmv_full_rank = rocblas_sgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      rocblas_sgbmv_rank_0 = rocblas_sgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_sgbmv_rank_1 = rocblas_sgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dgbmv_full_rank = rocblas_dgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      rocblas_dgbmv_rank_0 = rocblas_dgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dgbmv_rank_1 = rocblas_dgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_cgbmv_full_rank = rocblas_cgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_cgbmv_rank_0 = rocblas_cgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_cgbmv_rank_1 = rocblas_cgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgbmv_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zgbmv_full_rank = rocblas_zgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_zgbmv_rank_0 = rocblas_zgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zgbmv_rank_1 = rocblas_zgbmv_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgbmv_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sgbmv_batched_full_rank = rocblas_sgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgbmv_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sgbmv_batched_rank_0 = rocblas_sgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgbmv_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sgbmv_batched_rank_1 = rocblas_sgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgbmv_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dgbmv_batched_full_rank = rocblas_dgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgbmv_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dgbmv_batched_rank_0 = rocblas_dgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgbmv_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dgbmv_batched_rank_1 = rocblas_dgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgbmv_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_cgbmv_batched_full_rank = rocblas_cgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgbmv_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_cgbmv_batched_rank_0 = rocblas_cgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgbmv_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_cgbmv_batched_rank_1 = rocblas_cgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgbmv_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zgbmv_batched_full_rank = rocblas_zgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgbmv_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zgbmv_batched_rank_0 = rocblas_zgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgbmv_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zgbmv_batched_rank_1 = rocblas_zgbmv_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgbmv_strided_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_sgbmv_strided_batched_full_rank = rocblas_sgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_sgbmv_strided_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_sgbmv_strided_batched_rank_0 = rocblas_sgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_sgbmv_strided_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_sgbmv_strided_batched_rank_1 = rocblas_sgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_dgbmv_strided_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_dgbmv_strided_batched_full_rank = rocblas_dgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_dgbmv_strided_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_dgbmv_strided_batched_rank_0 = rocblas_dgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_dgbmv_strided_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_dgbmv_strided_batched_rank_1 = rocblas_dgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_cgbmv_strided_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_cgbmv_strided_batched_full_rank = rocblas_cgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_cgbmv_strided_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_cgbmv_strided_batched_rank_0 = rocblas_cgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_cgbmv_strided_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_cgbmv_strided_batched_rank_1 = rocblas_cgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zgbmv_strided_batched_full_rank(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zgbmv_strided_batched_full_rank = rocblas_zgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zgbmv_strided_batched_rank_0(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zgbmv_strided_batched_rank_0 = rocblas_zgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zgbmv_strided_batched_rank_1(handle,trans,m,n,kl,ku,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zgbmv_strided_batched_rank_1 = rocblas_zgbmv_strided_batched_(handle,trans,m,n,kl,ku,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_sgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_sgemv_full_rank = rocblas_sgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      rocblas_sgemv_rank_0 = rocblas_sgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_sgemv_rank_1 = rocblas_sgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dgemv_full_rank = rocblas_dgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      rocblas_dgemv_rank_0 = rocblas_dgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dgemv_rank_1 = rocblas_dgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_cgemv_full_rank = rocblas_cgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_cgemv_rank_0 = rocblas_cgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_cgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_cgemv_rank_1 = rocblas_cgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgemv_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zgemv_full_rank = rocblas_zgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgemv_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_zgemv_rank_0 = rocblas_zgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zgemv_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zgemv_rank_1 = rocblas_zgemv_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sgemv_batched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sgemv_batched_full_rank = rocblas_sgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgemv_batched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sgemv_batched_rank_0 = rocblas_sgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgemv_batched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sgemv_batched_rank_1 = rocblas_sgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgemv_batched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dgemv_batched_full_rank = rocblas_dgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgemv_batched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dgemv_batched_rank_0 = rocblas_dgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dgemv_batched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dgemv_batched_rank_1 = rocblas_dgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgemv_batched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_cgemv_batched_full_rank = rocblas_cgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgemv_batched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_cgemv_batched_rank_0 = rocblas_cgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_cgemv_batched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_cgemv_batched_rank_1 = rocblas_cgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgemv_batched_full_rank(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zgemv_batched_full_rank = rocblas_zgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgemv_batched_rank_0(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zgemv_batched_rank_0 = rocblas_zgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zgemv_batched_rank_1(handle,trans,m,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zgemv_batched_rank_1 = rocblas_zgemv_batched_(handle,trans,m,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sgemv_strided_batched_full_rank(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_sgemv_strided_batched_full_rank = rocblas_sgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sgemv_strided_batched_rank_0(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_sgemv_strided_batched_rank_0 = rocblas_sgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sgemv_strided_batched_rank_1(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_sgemv_strided_batched_rank_1 = rocblas_sgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dgemv_strided_batched_full_rank(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dgemv_strided_batched_full_rank = rocblas_dgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dgemv_strided_batched_rank_0(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dgemv_strided_batched_rank_0 = rocblas_dgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dgemv_strided_batched_rank_1(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dgemv_strided_batched_rank_1 = rocblas_dgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_cgemv_strided_batched_full_rank(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_cgemv_strided_batched_full_rank = rocblas_cgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_cgemv_strided_batched_rank_0(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_cgemv_strided_batched_rank_0 = rocblas_cgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_cgemv_strided_batched_rank_1(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_cgemv_strided_batched_rank_1 = rocblas_cgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zgemv_strided_batched_full_rank(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zgemv_strided_batched_full_rank = rocblas_zgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zgemv_strided_batched_rank_0(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zgemv_strided_batched_rank_0 = rocblas_zgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zgemv_strided_batched_rank_1(handle,transA,m,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zgemv_strided_batched_rank_1 = rocblas_zgemv_strided_batched_(handle,transA,m,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_chbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_chbmv_full_rank = rocblas_chbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_chbmv_rank_0 = rocblas_chbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_chbmv_rank_1 = rocblas_chbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zhbmv_full_rank = rocblas_zhbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_zhbmv_rank_0 = rocblas_zhbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zhbmv_rank_1 = rocblas_zhbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chbmv_batched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_chbmv_batched_full_rank = rocblas_chbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chbmv_batched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_chbmv_batched_rank_0 = rocblas_chbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chbmv_batched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_chbmv_batched_rank_1 = rocblas_chbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhbmv_batched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zhbmv_batched_full_rank = rocblas_zhbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhbmv_batched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zhbmv_batched_rank_0 = rocblas_zhbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhbmv_batched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zhbmv_batched_rank_1 = rocblas_zhbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chbmv_strided_batched_full_rank(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_chbmv_strided_batched_full_rank = rocblas_chbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chbmv_strided_batched_rank_0(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_chbmv_strided_batched_rank_0 = rocblas_chbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chbmv_strided_batched_rank_1(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_chbmv_strided_batched_rank_1 = rocblas_chbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhbmv_strided_batched_full_rank(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zhbmv_strided_batched_full_rank = rocblas_zhbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhbmv_strided_batched_rank_0(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zhbmv_strided_batched_rank_0 = rocblas_zhbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhbmv_strided_batched_rank_1(handle,uplo,n,k,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zhbmv_strided_batched_rank_1 = rocblas_zhbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chemv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_chemv_full_rank = rocblas_chemv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chemv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_chemv_rank_0 = rocblas_chemv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chemv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_chemv_rank_1 = rocblas_chemv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhemv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zhemv_full_rank = rocblas_zhemv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhemv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_zhemv_rank_0 = rocblas_zhemv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhemv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zhemv_rank_1 = rocblas_zhemv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chemv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_chemv_batched_full_rank = rocblas_chemv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chemv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_chemv_batched_rank_0 = rocblas_chemv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chemv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_chemv_batched_rank_1 = rocblas_chemv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhemv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zhemv_batched_full_rank = rocblas_zhemv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhemv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zhemv_batched_rank_0 = rocblas_zhemv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhemv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zhemv_batched_rank_1 = rocblas_zhemv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chemv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_chemv_strided_batched_full_rank = rocblas_chemv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chemv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_chemv_strided_batched_rank_0 = rocblas_chemv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chemv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_chemv_strided_batched_rank_1 = rocblas_chemv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhemv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zhemv_strided_batched_full_rank = rocblas_zhemv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhemv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zhemv_strided_batched_rank_0 = rocblas_zhemv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhemv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zhemv_strided_batched_rank_1 = rocblas_zhemv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_cher_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_cher_full_rank = rocblas_cher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_cher_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_cher_rank_0 = rocblas_cher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_cher_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_cher_rank_1 = rocblas_cher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zher_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_zher_full_rank = rocblas_zher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zher_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_zher_rank_0 = rocblas_zher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zher_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_zher_rank_1 = rocblas_zher_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_cher_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cher_batched_full_rank = rocblas_cher_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cher_batched_rank_0 = rocblas_cher_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cher_batched_rank_1 = rocblas_cher_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zher_batched_full_rank = rocblas_zher_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zher_batched_rank_0 = rocblas_zher_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zher_batched_rank_1 = rocblas_zher_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_cher_strided_batched_full_rank = rocblas_cher_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_cher_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_cher_strided_batched_rank_0 = rocblas_cher_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_cher_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_cher_strided_batched_rank_1 = rocblas_cher_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zher_strided_batched_full_rank = rocblas_zher_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zher_strided_batched_rank_0 = rocblas_zher_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zher_strided_batched_rank_1 = rocblas_zher_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_cher2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_cher2_full_rank = rocblas_cher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cher2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_cher2_rank_0 = rocblas_cher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cher2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_cher2_rank_1 = rocblas_cher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zher2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_zher2_full_rank = rocblas_zher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zher2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_zher2_rank_0 = rocblas_zher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zher2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_zher2_rank_1 = rocblas_zher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cher2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cher2_batched_full_rank = rocblas_cher2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cher2_batched_rank_0 = rocblas_cher2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cher2_batched_rank_1 = rocblas_cher2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zher2_batched_full_rank = rocblas_zher2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zher2_batched_rank_0 = rocblas_zher2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zher2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zher2_batched_rank_1 = rocblas_zher2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cher2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_cher2_strided_batched_full_rank = rocblas_cher2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_cher2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_cher2_strided_batched_rank_0 = rocblas_cher2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_cher2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_cher2_strided_batched_rank_1 = rocblas_cher2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zher2_strided_batched_full_rank = rocblas_zher2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zher2_strided_batched_rank_0 = rocblas_zher2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_zher2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,A,lda,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zher2_strided_batched_rank_1 = rocblas_zher2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,c_loc(A),lda,stride_A,batch_count)
    end function

    function rocblas_chpmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_chpmv_rank_0 = rocblas_chpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chpmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_chpmv_rank_1 = rocblas_chpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhpmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_zhpmv_rank_0 = rocblas_zhpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zhpmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zhpmv_rank_1 = rocblas_zhpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_chpmv_batched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_chpmv_batched_full_rank = rocblas_chpmv_batched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chpmv_batched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_chpmv_batched_rank_0 = rocblas_chpmv_batched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chpmv_batched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_chpmv_batched_rank_1 = rocblas_chpmv_batched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhpmv_batched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zhpmv_batched_full_rank = rocblas_zhpmv_batched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhpmv_batched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zhpmv_batched_rank_0 = rocblas_zhpmv_batched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zhpmv_batched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zhpmv_batched_rank_1 = rocblas_zhpmv_batched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_chpmv_strided_batched_rank_0(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_chpmv_strided_batched_rank_0 = rocblas_chpmv_strided_batched_(handle,uplo,n,alpha,AP,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chpmv_strided_batched_rank_1(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_chpmv_strided_batched_rank_1 = rocblas_chpmv_strided_batched_(handle,uplo,n,alpha,AP,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhpmv_strided_batched_rank_0(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zhpmv_strided_batched_rank_0 = rocblas_zhpmv_strided_batched_(handle,uplo,n,alpha,AP,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_zhpmv_strided_batched_rank_1(handle,uplo,n,alpha,AP,stride_A,x,incx,stride_x,beta,y,incy,stride_y,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      integer(c_int) :: batch_count
      !
      rocblas_zhpmv_strided_batched_rank_1 = rocblas_zhpmv_strided_batched_(handle,uplo,n,alpha,AP,stride_A,c_loc(x),incx,stride_x,beta,c_loc(y),incy,stride_y,batch_count)
    end function

    function rocblas_chpr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_chpr_rank_0 = rocblas_chpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_chpr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_chpr_rank_1 = rocblas_chpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_zhpr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_zhpr_rank_0 = rocblas_zhpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_zhpr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_zhpr_rank_1 = rocblas_zhpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_chpr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_chpr_batched_full_rank = rocblas_chpr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_chpr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_chpr_batched_rank_0 = rocblas_chpr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_chpr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_chpr_batched_rank_1 = rocblas_chpr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zhpr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_zhpr_batched_full_rank = rocblas_zhpr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zhpr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_zhpr_batched_rank_0 = rocblas_zhpr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zhpr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_zhpr_batched_rank_1 = rocblas_zhpr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_chpr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_chpr_strided_batched_rank_0 = rocblas_chpr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_chpr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_chpr_strided_batched_rank_1 = rocblas_chpr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_zhpr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zhpr_strided_batched_rank_0 = rocblas_zhpr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_zhpr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zhpr_strided_batched_rank_1 = rocblas_zhpr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_chpr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      rocblas_chpr2_rank_0 = rocblas_chpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_chpr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      rocblas_chpr2_rank_1 = rocblas_chpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_zhpr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      rocblas_zhpr2_rank_0 = rocblas_zhpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_zhpr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      rocblas_zhpr2_rank_1 = rocblas_zhpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_chpr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_chpr2_batched_full_rank = rocblas_chpr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_chpr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_chpr2_batched_rank_0 = rocblas_chpr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_chpr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_chpr2_batched_rank_1 = rocblas_chpr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_zhpr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_zhpr2_batched_full_rank = rocblas_zhpr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_zhpr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_zhpr2_batched_rank_0 = rocblas_zhpr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_zhpr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_zhpr2_batched_rank_1 = rocblas_zhpr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_chpr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_chpr2_strided_batched_rank_0 = rocblas_chpr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_chpr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chpr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_chpr2_strided_batched_rank_1 = rocblas_chpr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_zhpr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zhpr2_strided_batched_rank_0 = rocblas_zhpr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_zhpr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhpr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zhpr2_strided_batched_rank_1 = rocblas_zhpr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_strmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_strmv_full_rank = rocblas_strmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      rocblas_strmv_rank_0 = rocblas_strmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_strmv_rank_1 = rocblas_strmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtrmv_full_rank = rocblas_dtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      rocblas_dtrmv_rank_0 = rocblas_dtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtrmv_rank_1 = rocblas_dtrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctrmv_full_rank = rocblas_ctrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ctrmv_rank_0 = rocblas_ctrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctrmv_rank_1 = rocblas_ctrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrmv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztrmv_full_rank = rocblas_ztrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrmv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ztrmv_rank_0 = rocblas_ztrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrmv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztrmv_rank_1 = rocblas_ztrmv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_strmv_strided_batched_full_rank = rocblas_strmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_strmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_strmv_strided_batched_rank_0 = rocblas_strmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_strmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_strmv_strided_batched_rank_1 = rocblas_strmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtrmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_dtrmv_strided_batched_full_rank = rocblas_dtrmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtrmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_dtrmv_strided_batched_rank_0 = rocblas_dtrmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtrmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_dtrmv_strided_batched_rank_1 = rocblas_dtrmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctrmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ctrmv_strided_batched_full_rank = rocblas_ctrmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctrmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ctrmv_strided_batched_rank_0 = rocblas_ctrmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctrmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ctrmv_strided_batched_rank_1 = rocblas_ctrmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztrmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ztrmv_strided_batched_full_rank = rocblas_ztrmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztrmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ztrmv_strided_batched_rank_0 = rocblas_ztrmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztrmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stridea
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ztrmv_strided_batched_rank_1 = rocblas_ztrmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_stpmv_full_rank(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:) :: A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_stpmv_full_rank = rocblas_stpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_stpmv_rank_0(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      rocblas_stpmv_rank_0 = rocblas_stpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_stpmv_rank_1(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_stpmv_rank_1 = rocblas_stpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_dtpmv_full_rank(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:) :: A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtpmv_full_rank = rocblas_dtpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_dtpmv_rank_0(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      rocblas_dtpmv_rank_0 = rocblas_dtpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_dtpmv_rank_1(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtpmv_rank_1 = rocblas_dtpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ctpmv_full_rank(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctpmv_full_rank = rocblas_ctpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ctpmv_rank_0(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ctpmv_rank_0 = rocblas_ctpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ctpmv_rank_1(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctpmv_rank_1 = rocblas_ctpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ztpmv_full_rank(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztpmv_full_rank = rocblas_ztpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ztpmv_rank_0(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ztpmv_rank_0 = rocblas_ztpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_ztpmv_rank_1(handle,uplo,transA,diag,m,A,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztpmv_rank_1 = rocblas_ztpmv_(handle,uplo,transA,diag,m,c_loc(A),c_loc(x),incx)
    end function

    function rocblas_stpmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int64_t) :: stridea
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_stpmv_strided_batched_full_rank = rocblas_stpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_stpmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int64_t) :: stridea
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_stpmv_strided_batched_rank_0 = rocblas_stpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_stpmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int64_t) :: stridea
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_stpmv_strided_batched_rank_1 = rocblas_stpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtpmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int64_t) :: stridea
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_dtpmv_strided_batched_full_rank = rocblas_dtpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtpmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int64_t) :: stridea
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_dtpmv_strided_batched_rank_0 = rocblas_dtpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_dtpmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int64_t) :: stridea
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_dtpmv_strided_batched_rank_1 = rocblas_dtpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctpmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int64_t) :: stridea
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ctpmv_strided_batched_full_rank = rocblas_ctpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctpmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int64_t) :: stridea
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ctpmv_strided_batched_rank_0 = rocblas_ctpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ctpmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int64_t) :: stridea
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ctpmv_strided_batched_rank_1 = rocblas_ctpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztpmv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int64_t) :: stridea
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ztpmv_strided_batched_full_rank = rocblas_ztpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztpmv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int64_t) :: stridea
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ztpmv_strided_batched_rank_0 = rocblas_ztpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_ztpmv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,stridea,x,incx,stridex,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int64_t) :: stridea
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batch_count
      !
      rocblas_ztpmv_strided_batched_rank_1 = rocblas_ztpmv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),stridea,c_loc(x),incx,stridex,batch_count)
    end function

    function rocblas_stbmv_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_stbmv_full_rank = rocblas_stbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbmv_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      rocblas_stbmv_rank_0 = rocblas_stbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbmv_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_stbmv_rank_1 = rocblas_stbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbmv_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtbmv_full_rank = rocblas_dtbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbmv_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      rocblas_dtbmv_rank_0 = rocblas_dtbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbmv_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtbmv_rank_1 = rocblas_dtbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbmv_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctbmv_full_rank = rocblas_ctbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbmv_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ctbmv_rank_0 = rocblas_ctbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbmv_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctbmv_rank_1 = rocblas_ctbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbmv_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztbmv_full_rank = rocblas_ztbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbmv_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ztbmv_rank_0 = rocblas_ztbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbmv_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztbmv_rank_1 = rocblas_ztbmv_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbmv_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_stbmv_batched_full_rank = rocblas_stbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbmv_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_stbmv_batched_rank_0 = rocblas_stbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbmv_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_stbmv_batched_rank_1 = rocblas_stbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbmv_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtbmv_batched_full_rank = rocblas_dtbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbmv_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtbmv_batched_rank_0 = rocblas_dtbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbmv_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtbmv_batched_rank_1 = rocblas_dtbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbmv_batched_full_rank(handle,uplo,trans,diag,m,k,A,da,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: da
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctbmv_batched_full_rank = rocblas_ctbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),da,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbmv_batched_rank_0(handle,uplo,trans,diag,m,k,A,da,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: da
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctbmv_batched_rank_0 = rocblas_ctbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),da,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbmv_batched_rank_1(handle,uplo,trans,diag,m,k,A,da,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: da
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctbmv_batched_rank_1 = rocblas_ctbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),da,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbmv_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztbmv_batched_full_rank = rocblas_ztbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbmv_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztbmv_batched_rank_0 = rocblas_ztbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbmv_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztbmv_batched_rank_1 = rocblas_ztbmv_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbmv_strided_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_stbmv_strided_batched_full_rank = rocblas_stbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stbmv_strided_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_stbmv_strided_batched_rank_0 = rocblas_stbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stbmv_strided_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_stbmv_strided_batched_rank_1 = rocblas_stbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbmv_strided_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtbmv_strided_batched_full_rank = rocblas_dtbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbmv_strided_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtbmv_strided_batched_rank_0 = rocblas_dtbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbmv_strided_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtbmv_strided_batched_rank_1 = rocblas_dtbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbmv_strided_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctbmv_strided_batched_full_rank = rocblas_ctbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbmv_strided_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctbmv_strided_batched_rank_0 = rocblas_ctbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbmv_strided_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctbmv_strided_batched_rank_1 = rocblas_ctbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbmv_strided_batched_full_rank(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztbmv_strided_batched_full_rank = rocblas_ztbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbmv_strided_batched_rank_0(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztbmv_strided_batched_rank_0 = rocblas_ztbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbmv_strided_batched_rank_1(handle,uplo,trans,diag,m,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztbmv_strided_batched_rank_1 = rocblas_ztbmv_strided_batched_(handle,uplo,trans,diag,m,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_stbsv_full_rank = rocblas_stbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      rocblas_stbsv_rank_0 = rocblas_stbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_stbsv_rank_1 = rocblas_stbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtbsv_full_rank = rocblas_dtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      rocblas_dtbsv_rank_0 = rocblas_dtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtbsv_rank_1 = rocblas_dtbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctbsv_full_rank = rocblas_ctbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ctbsv_rank_0 = rocblas_ctbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctbsv_rank_1 = rocblas_ctbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbsv_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztbsv_full_rank = rocblas_ztbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbsv_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ztbsv_rank_0 = rocblas_ztbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztbsv_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztbsv_rank_1 = rocblas_ztbsv_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_stbsv_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_stbsv_batched_full_rank = rocblas_stbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbsv_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_stbsv_batched_rank_0 = rocblas_stbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbsv_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_stbsv_batched_rank_1 = rocblas_stbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbsv_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtbsv_batched_full_rank = rocblas_dtbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbsv_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtbsv_batched_rank_0 = rocblas_dtbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtbsv_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtbsv_batched_rank_1 = rocblas_dtbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbsv_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctbsv_batched_full_rank = rocblas_ctbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbsv_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctbsv_batched_rank_0 = rocblas_ctbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctbsv_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctbsv_batched_rank_1 = rocblas_ctbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbsv_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztbsv_batched_full_rank = rocblas_ztbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbsv_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztbsv_batched_rank_0 = rocblas_ztbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztbsv_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztbsv_batched_rank_1 = rocblas_ztbsv_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_stbsv_strided_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_stbsv_strided_batched_full_rank = rocblas_stbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stbsv_strided_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_stbsv_strided_batched_rank_0 = rocblas_stbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stbsv_strided_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stbsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_stbsv_strided_batched_rank_1 = rocblas_stbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbsv_strided_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtbsv_strided_batched_full_rank = rocblas_dtbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbsv_strided_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtbsv_strided_batched_rank_0 = rocblas_dtbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtbsv_strided_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtbsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtbsv_strided_batched_rank_1 = rocblas_dtbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbsv_strided_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctbsv_strided_batched_full_rank = rocblas_ctbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbsv_strided_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctbsv_strided_batched_rank_0 = rocblas_ctbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctbsv_strided_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctbsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctbsv_strided_batched_rank_1 = rocblas_ctbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbsv_strided_batched_full_rank(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztbsv_strided_batched_full_rank = rocblas_ztbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbsv_strided_batched_rank_0(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztbsv_strided_batched_rank_0 = rocblas_ztbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztbsv_strided_batched_rank_1(handle,uplo,transA,diag,n,k,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztbsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztbsv_strided_batched_rank_1 = rocblas_ztbsv_strided_batched_(handle,uplo,transA,diag,n,k,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_strsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_strsv_full_rank = rocblas_strsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      rocblas_strsv_rank_0 = rocblas_strsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_strsv_rank_1 = rocblas_strsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtrsv_full_rank = rocblas_dtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      rocblas_dtrsv_rank_0 = rocblas_dtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_dtrsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtrsv_rank_1 = rocblas_dtrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctrsv_full_rank = rocblas_ctrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ctrsv_rank_0 = rocblas_ctrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ctrsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctrsv_rank_1 = rocblas_ctrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrsv_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztrsv_full_rank = rocblas_ztrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrsv_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ztrsv_rank_0 = rocblas_ztrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_ztrsv_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztrsv_rank_1 = rocblas_ztrsv_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx)
    end function

    function rocblas_strsv_batched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_strsv_batched_full_rank = rocblas_strsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_strsv_batched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_strsv_batched_rank_0 = rocblas_strsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_strsv_batched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_strsv_batched_rank_1 = rocblas_strsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtrsv_batched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtrsv_batched_full_rank = rocblas_dtrsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtrsv_batched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtrsv_batched_rank_0 = rocblas_dtrsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtrsv_batched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtrsv_batched_rank_1 = rocblas_dtrsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctrsv_batched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctrsv_batched_full_rank = rocblas_ctrsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctrsv_batched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctrsv_batched_rank_0 = rocblas_ctrsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctrsv_batched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctrsv_batched_rank_1 = rocblas_ctrsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztrsv_batched_full_rank(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztrsv_batched_full_rank = rocblas_ztrsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztrsv_batched_rank_0(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztrsv_batched_rank_0 = rocblas_ztrsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztrsv_batched_rank_1(handle,uplo,transA,diag,m,A,lda,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztrsv_batched_rank_1 = rocblas_ztrsv_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,c_loc(x),incx,batch_count)
    end function

    function rocblas_strsv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_strsv_strided_batched_full_rank = rocblas_strsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_strsv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_strsv_strided_batched_rank_0 = rocblas_strsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_strsv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_strsv_strided_batched_rank_1 = rocblas_strsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtrsv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtrsv_strided_batched_full_rank = rocblas_dtrsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtrsv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtrsv_strided_batched_rank_0 = rocblas_dtrsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtrsv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtrsv_strided_batched_rank_1 = rocblas_dtrsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctrsv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctrsv_strided_batched_full_rank = rocblas_ctrsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctrsv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctrsv_strided_batched_rank_0 = rocblas_ctrsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctrsv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctrsv_strided_batched_rank_1 = rocblas_ctrsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztrsv_strided_batched_full_rank(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztrsv_strided_batched_full_rank = rocblas_ztrsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztrsv_strided_batched_rank_0(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztrsv_strided_batched_rank_0 = rocblas_ztrsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztrsv_strided_batched_rank_1(handle,uplo,transA,diag,m,A,lda,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztrsv_strided_batched_rank_1 = rocblas_ztrsv_strided_batched_(handle,uplo,transA,diag,m,c_loc(A),lda,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      rocblas_stpsv_rank_0 = rocblas_stpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_stpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_stpsv_rank_1 = rocblas_stpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_dtpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      rocblas_dtpsv_rank_0 = rocblas_dtpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_dtpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_dtpsv_rank_1 = rocblas_dtpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_ctpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ctpsv_rank_0 = rocblas_ctpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_ctpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ctpsv_rank_1 = rocblas_ctpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_ztpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      rocblas_ztpsv_rank_0 = rocblas_ztpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_ztpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocblas_ztpsv_rank_1 = rocblas_ztpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function rocblas_stpsv_batched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_stpsv_batched_full_rank = rocblas_stpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_stpsv_batched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_stpsv_batched_rank_0 = rocblas_stpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_stpsv_batched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_stpsv_batched_rank_1 = rocblas_stpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtpsv_batched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtpsv_batched_full_rank = rocblas_dtpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtpsv_batched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtpsv_batched_rank_0 = rocblas_dtpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_dtpsv_batched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_dtpsv_batched_rank_1 = rocblas_dtpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctpsv_batched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctpsv_batched_full_rank = rocblas_ctpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctpsv_batched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctpsv_batched_rank_0 = rocblas_ctpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ctpsv_batched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ctpsv_batched_rank_1 = rocblas_ctpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztpsv_batched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztpsv_batched_full_rank = rocblas_ztpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztpsv_batched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztpsv_batched_rank_0 = rocblas_ztpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_ztpsv_batched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batch_count
      !
      rocblas_ztpsv_batched_rank_1 = rocblas_ztpsv_batched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batch_count)
    end function

    function rocblas_stpsv_strided_batched_rank_0(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_stpsv_strided_batched_rank_0 = rocblas_stpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_stpsv_strided_batched_rank_1(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_stpsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_stpsv_strided_batched_rank_1 = rocblas_stpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtpsv_strided_batched_rank_0(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtpsv_strided_batched_rank_0 = rocblas_dtpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_dtpsv_strided_batched_rank_1(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtpsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_dtpsv_strided_batched_rank_1 = rocblas_dtpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctpsv_strided_batched_rank_0(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctpsv_strided_batched_rank_0 = rocblas_ctpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ctpsv_strided_batched_rank_1(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctpsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ctpsv_strided_batched_rank_1 = rocblas_ctpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztpsv_strided_batched_rank_0(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztpsv_strided_batched_rank_0 = rocblas_ztpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ztpsv_strided_batched_rank_1(handle,uplo,transA,diag,n,AP,stride_A,x,incx,stride_x,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztpsv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      integer(c_int) :: batch_count
      !
      rocblas_ztpsv_strided_batched_rank_1 = rocblas_ztpsv_strided_batched_(handle,uplo,transA,diag,n,AP,stride_A,c_loc(x),incx,stride_x,batch_count)
    end function

    function rocblas_ssymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_ssymv_full_rank = rocblas_ssymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_ssymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      rocblas_ssymv_rank_0 = rocblas_ssymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_ssymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_ssymv_rank_1 = rocblas_ssymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dsymv_full_rank = rocblas_dsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      rocblas_dsymv_rank_0 = rocblas_dsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dsymv_rank_1 = rocblas_dsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_csymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_csymv_full_rank = rocblas_csymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_csymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_csymv_rank_0 = rocblas_csymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_csymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_csymv_rank_1 = rocblas_csymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zsymv_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zsymv_full_rank = rocblas_zsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zsymv_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      rocblas_zsymv_rank_0 = rocblas_zsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_zsymv_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_zsymv_rank_1 = rocblas_zsymv_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_ssymv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_ssymv_batched_full_rank = rocblas_ssymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssymv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_ssymv_batched_rank_0 = rocblas_ssymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssymv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_ssymv_batched_rank_1 = rocblas_ssymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dsymv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dsymv_batched_full_rank = rocblas_dsymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dsymv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dsymv_batched_rank_0 = rocblas_dsymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dsymv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dsymv_batched_rank_1 = rocblas_dsymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_csymv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_csymv_batched_full_rank = rocblas_csymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_csymv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_csymv_batched_rank_0 = rocblas_csymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_csymv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_csymv_batched_rank_1 = rocblas_csymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zsymv_batched_full_rank(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zsymv_batched_full_rank = rocblas_zsymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zsymv_batched_rank_0(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zsymv_batched_rank_0 = rocblas_zsymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_zsymv_batched_rank_1(handle,uplo,n,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_zsymv_batched_rank_1 = rocblas_zsymv_batched_(handle,uplo,n,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssymv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_ssymv_strided_batched_full_rank = rocblas_ssymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ssymv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_ssymv_strided_batched_rank_0 = rocblas_ssymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ssymv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_ssymv_strided_batched_rank_1 = rocblas_ssymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsymv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dsymv_strided_batched_full_rank = rocblas_dsymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsymv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dsymv_strided_batched_rank_0 = rocblas_dsymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsymv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dsymv_strided_batched_rank_1 = rocblas_dsymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_csymv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_csymv_strided_batched_full_rank = rocblas_csymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_csymv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_csymv_strided_batched_rank_0 = rocblas_csymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_csymv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_csymv_strided_batched_rank_1 = rocblas_csymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zsymv_strided_batched_full_rank(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zsymv_strided_batched_full_rank = rocblas_zsymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zsymv_strided_batched_rank_0(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zsymv_strided_batched_rank_0 = rocblas_zsymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_zsymv_strided_batched_rank_1(handle,uplo,n,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_zsymv_strided_batched_rank_1 = rocblas_zsymv_strided_batched_(handle,uplo,n,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sspmv_full_rank(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_sspmv_full_rank = rocblas_sspmv_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sspmv_rank_0(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      rocblas_sspmv_rank_0 = rocblas_sspmv_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sspmv_rank_1(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_sspmv_rank_1 = rocblas_sspmv_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dspmv_full_rank(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dspmv_full_rank = rocblas_dspmv_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dspmv_rank_0(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      rocblas_dspmv_rank_0 = rocblas_dspmv_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dspmv_rank_1(handle,uplo,n,alpha,A,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dspmv_rank_1 = rocblas_dspmv_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_sspmv_batched_full_rank(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sspmv_batched_full_rank = rocblas_sspmv_batched_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sspmv_batched_rank_0(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sspmv_batched_rank_0 = rocblas_sspmv_batched_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sspmv_batched_rank_1(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_sspmv_batched_rank_1 = rocblas_sspmv_batched_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dspmv_batched_full_rank(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dspmv_batched_full_rank = rocblas_dspmv_batched_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dspmv_batched_rank_0(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dspmv_batched_rank_0 = rocblas_dspmv_batched_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dspmv_batched_rank_1(handle,uplo,n,alpha,A,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dspmv_batched_rank_1 = rocblas_dspmv_batched_(handle,uplo,n,alpha,c_loc(A),c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_sspmv_strided_batched_full_rank(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_sspmv_strided_batched_full_rank = rocblas_sspmv_strided_batched_(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sspmv_strided_batched_rank_0(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_sspmv_strided_batched_rank_0 = rocblas_sspmv_strided_batched_(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sspmv_strided_batched_rank_1(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_sspmv_strided_batched_rank_1 = rocblas_sspmv_strided_batched_(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dspmv_strided_batched_full_rank(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dspmv_strided_batched_full_rank = rocblas_dspmv_strided_batched_(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dspmv_strided_batched_rank_0(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dspmv_strided_batched_rank_0 = rocblas_dspmv_strided_batched_(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dspmv_strided_batched_rank_1(handle,uplo,n,alpha,A,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dspmv_strided_batched_rank_1 = rocblas_dspmv_strided_batched_(handle,uplo,n,alpha,c_loc(A),strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ssbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_ssbmv_full_rank = rocblas_ssbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_ssbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      rocblas_ssbmv_rank_0 = rocblas_ssbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_ssbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_ssbmv_rank_1 = rocblas_ssbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsbmv_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dsbmv_full_rank = rocblas_dsbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsbmv_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      rocblas_dsbmv_rank_0 = rocblas_dsbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsbmv_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      rocblas_dsbmv_rank_1 = rocblas_dsbmv_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function rocblas_dsbmv_batched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dsbmv_batched_full_rank = rocblas_dsbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dsbmv_batched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dsbmv_batched_rank_0 = rocblas_dsbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_dsbmv_batched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_dsbmv_batched_rank_1 = rocblas_dsbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssbmv_batched_full_rank(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_ssbmv_batched_full_rank = rocblas_ssbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssbmv_batched_rank_0(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_ssbmv_batched_rank_0 = rocblas_ssbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssbmv_batched_rank_1(handle,uplo,n,k,alpha,A,lda,x,incx,beta,y,incy,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batch_count
      !
      rocblas_ssbmv_batched_rank_1 = rocblas_ssbmv_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,c_loc(x),incx,beta,c_loc(y),incy,batch_count)
    end function

    function rocblas_ssbmv_strided_batched_full_rank(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_ssbmv_strided_batched_full_rank = rocblas_ssbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ssbmv_strided_batched_rank_0(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_ssbmv_strided_batched_rank_0 = rocblas_ssbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_ssbmv_strided_batched_rank_1(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_ssbmv_strided_batched_rank_1 = rocblas_ssbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsbmv_strided_batched_full_rank(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dsbmv_strided_batched_full_rank = rocblas_dsbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsbmv_strided_batched_rank_0(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dsbmv_strided_batched_rank_0 = rocblas_dsbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_dsbmv_strided_batched_rank_1(handle,uplo,n,k,alpha,A,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsbmv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batch_count
      !
      rocblas_dsbmv_strided_batched_rank_1 = rocblas_dsbmv_strided_batched_(handle,uplo,n,k,alpha,c_loc(A),lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batch_count)
    end function

    function rocblas_sger_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_sger_full_rank = rocblas_sger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_sger_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      real(c_float),target :: A
      integer(c_int) :: lda
      !
      rocblas_sger_rank_0 = rocblas_sger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_sger_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_sger_rank_1 = rocblas_sger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dger_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_dger_full_rank = rocblas_dger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dger_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      real(c_double),target :: A
      integer(c_int) :: lda
      !
      rocblas_dger_rank_0 = rocblas_dger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dger_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_dger_rank_1 = rocblas_dger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgeru_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_cgeru_full_rank = rocblas_cgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgeru_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_cgeru_rank_0 = rocblas_cgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgeru_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_cgeru_rank_1 = rocblas_cgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgeru_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_zgeru_full_rank = rocblas_zgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgeru_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_zgeru_rank_0 = rocblas_zgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgeru_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_zgeru_rank_1 = rocblas_zgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgerc_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_cgerc_full_rank = rocblas_cgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgerc_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_cgerc_rank_0 = rocblas_cgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_cgerc_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_cgerc_rank_1 = rocblas_cgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgerc_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_zgerc_full_rank = rocblas_zgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgerc_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_zgerc_rank_0 = rocblas_zgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zgerc_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_zgerc_rank_1 = rocblas_zgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_sger_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_sger_batched_full_rank = rocblas_sger_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_sger_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_sger_batched_rank_0 = rocblas_sger_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_sger_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_sger_batched_rank_1 = rocblas_sger_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dger_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_dger_batched_full_rank = rocblas_dger_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dger_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_dger_batched_rank_0 = rocblas_dger_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dger_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_dger_batched_rank_1 = rocblas_dger_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgeru_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cgeru_batched_full_rank = rocblas_cgeru_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgeru_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cgeru_batched_rank_0 = rocblas_cgeru_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgeru_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cgeru_batched_rank_1 = rocblas_cgeru_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgeru_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zgeru_batched_full_rank = rocblas_zgeru_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgeru_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zgeru_batched_rank_0 = rocblas_zgeru_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgeru_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zgeru_batched_rank_1 = rocblas_zgeru_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgerc_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cgerc_batched_full_rank = rocblas_cgerc_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgerc_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cgerc_batched_rank_0 = rocblas_cgerc_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_cgerc_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_cgerc_batched_rank_1 = rocblas_cgerc_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgerc_batched_full_rank(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zgerc_batched_full_rank = rocblas_zgerc_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgerc_batched_rank_0(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zgerc_batched_rank_0 = rocblas_zgerc_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zgerc_batched_rank_1(handle,m,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zgerc_batched_rank_1 = rocblas_zgerc_batched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_sger_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_sger_strided_batched_full_rank = rocblas_sger_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_sger_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_sger_strided_batched_rank_0 = rocblas_sger_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_sger_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sger_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_sger_strided_batched_rank_1 = rocblas_sger_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dger_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_dger_strided_batched_full_rank = rocblas_dger_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dger_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_dger_strided_batched_rank_0 = rocblas_dger_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dger_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dger_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_dger_strided_batched_rank_1 = rocblas_dger_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgeru_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_cgeru_strided_batched_full_rank = rocblas_cgeru_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgeru_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_cgeru_strided_batched_rank_0 = rocblas_cgeru_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgeru_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeru_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_cgeru_strided_batched_rank_1 = rocblas_cgeru_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgeru_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zgeru_strided_batched_full_rank = rocblas_zgeru_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgeru_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zgeru_strided_batched_rank_0 = rocblas_zgeru_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgeru_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeru_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zgeru_strided_batched_rank_1 = rocblas_zgeru_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgerc_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_cgerc_strided_batched_full_rank = rocblas_cgerc_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgerc_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_cgerc_strided_batched_rank_0 = rocblas_cgerc_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_cgerc_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgerc_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_cgerc_strided_batched_rank_1 = rocblas_cgerc_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgerc_strided_batched_full_rank(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zgerc_strided_batched_full_rank = rocblas_zgerc_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgerc_strided_batched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zgerc_strided_batched_rank_0 = rocblas_zgerc_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zgerc_strided_batched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgerc_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zgerc_strided_batched_rank_1 = rocblas_zgerc_strided_batched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_sspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_sspr_rank_0 = rocblas_sspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_sspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_sspr_rank_1 = rocblas_sspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_dspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_dspr_rank_0 = rocblas_dspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_dspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_dspr_rank_1 = rocblas_dspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_cspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_cspr_rank_0 = rocblas_cspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_cspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_cspr_rank_1 = rocblas_cspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_zspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_zspr_rank_0 = rocblas_zspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_zspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      rocblas_zspr_rank_1 = rocblas_zspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function rocblas_sspr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_sspr_batched_full_rank = rocblas_sspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_sspr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_sspr_batched_rank_0 = rocblas_sspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_sspr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_sspr_batched_rank_1 = rocblas_sspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_dspr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_dspr_batched_full_rank = rocblas_dspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_dspr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_dspr_batched_rank_0 = rocblas_dspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_dspr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_dspr_batched_rank_1 = rocblas_dspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_cspr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_cspr_batched_full_rank = rocblas_cspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_cspr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_cspr_batched_rank_0 = rocblas_cspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_cspr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_cspr_batched_rank_1 = rocblas_cspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zspr_batched_full_rank(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_zspr_batched_full_rank = rocblas_zspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zspr_batched_rank_0(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_zspr_batched_rank_0 = rocblas_zspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_zspr_batched_rank_1(handle,uplo,n,alpha,x,incx,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_zspr_batched_rank_1 = rocblas_zspr_batched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batch_count)
    end function

    function rocblas_sspr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_sspr_strided_batched_rank_0 = rocblas_sspr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_sspr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_sspr_strided_batched_rank_1 = rocblas_sspr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_dspr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_dspr_strided_batched_rank_0 = rocblas_dspr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_dspr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_dspr_strided_batched_rank_1 = rocblas_dspr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_cspr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_cspr_strided_batched_rank_0 = rocblas_cspr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_cspr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cspr_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_cspr_strided_batched_rank_1 = rocblas_cspr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_zspr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zspr_strided_batched_rank_0 = rocblas_zspr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_zspr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zspr_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_zspr_strided_batched_rank_1 = rocblas_zspr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,AP,stride_A,batch_count)
    end function

    function rocblas_sspr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      rocblas_sspr2_rank_0 = rocblas_sspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_sspr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      rocblas_sspr2_rank_1 = rocblas_sspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_dspr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      rocblas_dspr2_rank_0 = rocblas_dspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_dspr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      rocblas_dspr2_rank_1 = rocblas_dspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function rocblas_sspr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_sspr2_batched_full_rank = rocblas_sspr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_sspr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_sspr2_batched_rank_0 = rocblas_sspr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_sspr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_sspr2_batched_rank_1 = rocblas_sspr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_dspr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_dspr2_batched_full_rank = rocblas_dspr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_dspr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_dspr2_batched_rank_0 = rocblas_dspr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_dspr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batch_count
      !
      rocblas_dspr2_batched_rank_1 = rocblas_dspr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batch_count)
    end function

    function rocblas_sspr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_sspr2_strided_batched_rank_0 = rocblas_sspr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_sspr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sspr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_sspr2_strided_batched_rank_1 = rocblas_sspr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_dspr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_dspr2_strided_batched_rank_0 = rocblas_dspr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_dspr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stride_x,y,incy,stride_y,AP,stride_A,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dspr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stride_y
      type(c_ptr) :: AP
      integer(c_int64_t) :: stride_A
      integer(c_int) :: batch_count
      !
      rocblas_dspr2_strided_batched_rank_1 = rocblas_dspr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stride_x,c_loc(y),incy,stride_y,AP,stride_A,batch_count)
    end function

    function rocblas_ssyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_ssyr_full_rank = rocblas_ssyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_ssyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: A
      integer(c_int) :: lda
      !
      rocblas_ssyr_rank_0 = rocblas_ssyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_ssyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_ssyr_rank_1 = rocblas_ssyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_dsyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_dsyr_full_rank = rocblas_dsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_dsyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: A
      integer(c_int) :: lda
      !
      rocblas_dsyr_rank_0 = rocblas_dsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_dsyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_dsyr_rank_1 = rocblas_dsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_csyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_csyr_full_rank = rocblas_csyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_csyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_csyr_rank_0 = rocblas_csyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_csyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_csyr_rank_1 = rocblas_csyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zsyr_full_rank(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_zsyr_full_rank = rocblas_zsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zsyr_rank_0(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_zsyr_rank_0 = rocblas_zsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_zsyr_rank_1(handle,uplo,n,alpha,x,incx,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_zsyr_rank_1 = rocblas_zsyr_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda)
    end function

    function rocblas_ssyr_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_ssyr_batched_full_rank = rocblas_ssyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_ssyr_batched_rank_0 = rocblas_ssyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_ssyr_batched_rank_1 = rocblas_ssyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_dsyr_batched_full_rank = rocblas_dsyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_dsyr_batched_rank_0 = rocblas_dsyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_dsyr_batched_rank_1 = rocblas_dsyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_csyr_batched_full_rank = rocblas_csyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_csyr_batched_rank_0 = rocblas_csyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_csyr_batched_rank_1 = rocblas_csyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr_batched_full_rank(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zsyr_batched_full_rank = rocblas_zsyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr_batched_rank_0(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zsyr_batched_rank_0 = rocblas_zsyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr_batched_rank_1(handle,uplo,n,alpha,x,incx,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zsyr_batched_rank_1 = rocblas_zsyr_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_ssyr_strided_batched_full_rank = rocblas_ssyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_ssyr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_ssyr_strided_batched_rank_0 = rocblas_ssyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_ssyr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_ssyr_strided_batched_rank_1 = rocblas_ssyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_dsyr_strided_batched_full_rank = rocblas_dsyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_dsyr_strided_batched_rank_0 = rocblas_dsyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_dsyr_strided_batched_rank_1 = rocblas_dsyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_csyr_strided_batched_full_rank = rocblas_csyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_csyr_strided_batched_rank_0 = rocblas_csyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_csyr_strided_batched_rank_1 = rocblas_csyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zsyr_strided_batched_full_rank = rocblas_zsyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zsyr_strided_batched_rank_0 = rocblas_zsyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zsyr_strided_batched_rank_1 = rocblas_zsyr_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_ssyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_ssyr2_full_rank = rocblas_ssyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_ssyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      real(c_float),target :: A
      integer(c_int) :: lda
      !
      rocblas_ssyr2_rank_0 = rocblas_ssyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_ssyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_ssyr2_rank_1 = rocblas_ssyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dsyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_dsyr2_full_rank = rocblas_dsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      real(c_double),target :: A
      integer(c_int) :: lda
      !
      rocblas_dsyr2_rank_0 = rocblas_dsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_dsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_dsyr2_rank_1 = rocblas_dsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_csyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_csyr2_full_rank = rocblas_csyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_csyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_csyr2_rank_0 = rocblas_csyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_csyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_csyr2_rank_1 = rocblas_csyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zsyr2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocblas_zsyr2_full_rank = rocblas_zsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      rocblas_zsyr2_rank_0 = rocblas_zsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_zsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocblas_zsyr2_rank_1 = rocblas_zsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda)
    end function

    function rocblas_ssyr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2_batched_full_rank = rocblas_ssyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2_batched_rank_0 = rocblas_ssyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2_batched_rank_1 = rocblas_ssyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2_batched_full_rank = rocblas_dsyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2_batched_rank_0 = rocblas_dsyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_dsyr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2_batched_rank_1 = rocblas_dsyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_csyr2_batched_full_rank = rocblas_csyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_csyr2_batched_rank_0 = rocblas_csyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_csyr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_csyr2_batched_rank_1 = rocblas_csyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr2_batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2_batched_full_rank = rocblas_zsyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr2_batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2_batched_rank_0 = rocblas_zsyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_zsyr2_batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,A,lda,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2_batched_rank_1 = rocblas_zsyr2_batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,c_loc(A),lda,batch_count)
    end function

    function rocblas_ssyr2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2_strided_batched_full_rank = rocblas_ssyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_ssyr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2_strided_batched_rank_0 = rocblas_ssyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_ssyr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2_strided_batched_rank_1 = rocblas_ssyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2_strided_batched_full_rank = rocblas_dsyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2_strided_batched_rank_0 = rocblas_dsyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_dsyr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2_strided_batched_rank_1 = rocblas_dsyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_csyr2_strided_batched_full_rank = rocblas_csyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_csyr2_strided_batched_rank_0 = rocblas_csyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_csyr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_csyr2_strided_batched_rank_1 = rocblas_csyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr2_strided_batched_full_rank(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2_strided_batched_full_rank = rocblas_zsyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr2_strided_batched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2_strided_batched_rank_0 = rocblas_zsyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_zsyr2_strided_batched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,A,lda,strideA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2_strided_batched_rank_1 = rocblas_zsyr2_strided_batched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c_loc(A),lda,strideA,batch_count)
    end function

    function rocblas_chemm_full_rank(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_chemm_full_rank = rocblas_chemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_chemm_rank_0(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_chemm_rank_0 = rocblas_chemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_chemm_rank_1(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_chemm_rank_1 = rocblas_chemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zhemm_full_rank(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zhemm_full_rank = rocblas_zhemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zhemm_rank_0(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zhemm_rank_0 = rocblas_zhemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zhemm_rank_1(handle,side,uplo,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zhemm_rank_1 = rocblas_zhemm_(handle,side,uplo,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_chemm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_chemm_batched_full_rank = rocblas_chemm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_chemm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_chemm_batched_rank_0 = rocblas_chemm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_chemm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_chemm_batched_rank_1 = rocblas_chemm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zhemm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zhemm_batched_full_rank = rocblas_zhemm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zhemm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zhemm_batched_rank_0 = rocblas_zhemm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zhemm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zhemm_batched_rank_1 = rocblas_zhemm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_chemm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_chemm_strided_batched_full_rank = rocblas_chemm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_chemm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_chemm_strided_batched_rank_0 = rocblas_chemm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_chemm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_chemm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_chemm_strided_batched_rank_1 = rocblas_chemm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zhemm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zhemm_strided_batched_full_rank = rocblas_zhemm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zhemm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zhemm_strided_batched_rank_0 = rocblas_zhemm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zhemm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zhemm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zhemm_strided_batched_rank_1 = rocblas_zhemm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cherk_full_rank = rocblas_cherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_cherk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_cherk_rank_0 = rocblas_cherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_cherk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cherk_rank_1 = rocblas_cherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zherk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zherk_full_rank = rocblas_zherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zherk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zherk_rank_0 = rocblas_zherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zherk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zherk_rank_1 = rocblas_zherk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_cherk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cherk_batched_full_rank = rocblas_cherk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cherk_batched_rank_0 = rocblas_cherk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cherk_batched_rank_1 = rocblas_cherk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zherk_batched_full_rank = rocblas_zherk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zherk_batched_rank_0 = rocblas_zherk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zherk_batched_rank_1 = rocblas_zherk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_cherk_strided_batched_full_rank = rocblas_cherk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_cherk_strided_batched_rank_0 = rocblas_cherk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherk_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_cherk_strided_batched_rank_1 = rocblas_cherk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zherk_strided_batched_full_rank = rocblas_zherk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zherk_strided_batched_rank_0 = rocblas_zherk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherk_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zherk_strided_batched_rank_1 = rocblas_zherk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cher2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cher2k_full_rank = rocblas_cher2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cher2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_cher2k_rank_0 = rocblas_cher2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cher2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cher2k_rank_1 = rocblas_cher2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zher2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zher2k_full_rank = rocblas_zher2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zher2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zher2k_rank_0 = rocblas_zher2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zher2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zher2k_rank_1 = rocblas_zher2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cher2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cher2k_batched_full_rank = rocblas_cher2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cher2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cher2k_batched_rank_0 = rocblas_cher2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cher2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cher2k_batched_rank_1 = rocblas_cher2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zher2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zher2k_batched_full_rank = rocblas_zher2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zher2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zher2k_batched_rank_0 = rocblas_zher2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zher2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zher2k_batched_rank_1 = rocblas_zher2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cher2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_cher2k_strided_batched_full_rank = rocblas_cher2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cher2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_cher2k_strided_batched_rank_0 = rocblas_cher2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cher2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cher2k_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_cher2k_strided_batched_rank_1 = rocblas_cher2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zher2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zher2k_strided_batched_full_rank = rocblas_zher2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zher2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zher2k_strided_batched_rank_0 = rocblas_zher2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zher2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zher2k_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zher2k_strided_batched_rank_1 = rocblas_zher2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cherkx_full_rank = rocblas_cherkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cherkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_cherkx_rank_0 = rocblas_cherkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cherkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cherkx_rank_1 = rocblas_cherkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zherkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zherkx_full_rank = rocblas_zherkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zherkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zherkx_rank_0 = rocblas_zherkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zherkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zherkx_rank_1 = rocblas_zherkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cherkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cherkx_batched_full_rank = rocblas_cherkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cherkx_batched_rank_0 = rocblas_cherkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cherkx_batched_rank_1 = rocblas_cherkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zherkx_batched_full_rank = rocblas_zherkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zherkx_batched_rank_0 = rocblas_zherkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zherkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zherkx_batched_rank_1 = rocblas_zherkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cherkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_cherkx_strided_batched_full_rank = rocblas_cherkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_cherkx_strided_batched_rank_0 = rocblas_cherkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_cherkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cherkx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_cherkx_strided_batched_rank_1 = rocblas_cherkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zherkx_strided_batched_full_rank = rocblas_zherkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zherkx_strided_batched_rank_0 = rocblas_zherkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zherkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zherkx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zherkx_strided_batched_rank_1 = rocblas_zherkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ssymm_full_rank = rocblas_ssymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocblas_ssymm_rank_0 = rocblas_ssymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ssymm_rank_1 = rocblas_ssymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dsymm_full_rank = rocblas_dsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocblas_dsymm_rank_0 = rocblas_dsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dsymm_rank_1 = rocblas_dsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_csymm_full_rank = rocblas_csymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_csymm_rank_0 = rocblas_csymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_csymm_rank_1 = rocblas_csymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsymm_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zsymm_full_rank = rocblas_zsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsymm_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zsymm_rank_0 = rocblas_zsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsymm_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zsymm_rank_1 = rocblas_zsymm_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssymm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssymm_batched_full_rank = rocblas_ssymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssymm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssymm_batched_rank_0 = rocblas_ssymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssymm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssymm_batched_rank_1 = rocblas_ssymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsymm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsymm_batched_full_rank = rocblas_dsymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsymm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsymm_batched_rank_0 = rocblas_dsymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsymm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsymm_batched_rank_1 = rocblas_dsymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csymm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csymm_batched_full_rank = rocblas_csymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csymm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csymm_batched_rank_0 = rocblas_csymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csymm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csymm_batched_rank_1 = rocblas_csymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsymm_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsymm_batched_full_rank = rocblas_zsymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsymm_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsymm_batched_rank_0 = rocblas_zsymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsymm_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsymm_batched_rank_1 = rocblas_zsymm_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssymm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssymm_strided_batched_full_rank = rocblas_ssymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssymm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssymm_strided_batched_rank_0 = rocblas_ssymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssymm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssymm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssymm_strided_batched_rank_1 = rocblas_ssymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsymm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsymm_strided_batched_full_rank = rocblas_dsymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsymm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsymm_strided_batched_rank_0 = rocblas_dsymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsymm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsymm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsymm_strided_batched_rank_1 = rocblas_dsymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csymm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csymm_strided_batched_full_rank = rocblas_csymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csymm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csymm_strided_batched_rank_0 = rocblas_csymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csymm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csymm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csymm_strided_batched_rank_1 = rocblas_csymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsymm_strided_batched_full_rank(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsymm_strided_batched_full_rank = rocblas_zsymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsymm_strided_batched_rank_0(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsymm_strided_batched_rank_0 = rocblas_zsymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsymm_strided_batched_rank_1(handle,side,uplo,m,n,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsymm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsymm_strided_batched_rank_1 = rocblas_zsymm_strided_batched_(handle,side,uplo,m,n,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ssyrk_full_rank = rocblas_ssyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocblas_ssyrk_rank_0 = rocblas_ssyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ssyrk_rank_1 = rocblas_ssyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dsyrk_full_rank = rocblas_dsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocblas_dsyrk_rank_0 = rocblas_dsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dsyrk_rank_1 = rocblas_dsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_csyrk_full_rank = rocblas_csyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_csyrk_rank_0 = rocblas_csyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_csyrk_rank_1 = rocblas_csyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrk_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zsyrk_full_rank = rocblas_zsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrk_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zsyrk_rank_0 = rocblas_zsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrk_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zsyrk_rank_1 = rocblas_zsyrk_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssyrk_batched_full_rank = rocblas_ssyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssyrk_batched_rank_0 = rocblas_ssyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssyrk_batched_rank_1 = rocblas_ssyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsyrk_batched_full_rank = rocblas_dsyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsyrk_batched_rank_0 = rocblas_dsyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsyrk_batched_rank_1 = rocblas_dsyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csyrk_batched_full_rank = rocblas_csyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csyrk_batched_rank_0 = rocblas_csyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csyrk_batched_rank_1 = rocblas_csyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrk_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsyrk_batched_full_rank = rocblas_zsyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrk_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsyrk_batched_rank_0 = rocblas_zsyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrk_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsyrk_batched_rank_1 = rocblas_zsyrk_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssyrk_strided_batched_full_rank = rocblas_ssyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssyrk_strided_batched_rank_0 = rocblas_ssyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrk_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssyrk_strided_batched_rank_1 = rocblas_ssyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsyrk_strided_batched_full_rank = rocblas_dsyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsyrk_strided_batched_rank_0 = rocblas_dsyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrk_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsyrk_strided_batched_rank_1 = rocblas_dsyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csyrk_strided_batched_full_rank = rocblas_csyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csyrk_strided_batched_rank_0 = rocblas_csyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrk_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csyrk_strided_batched_rank_1 = rocblas_csyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrk_strided_batched_full_rank(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsyrk_strided_batched_full_rank = rocblas_zsyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrk_strided_batched_rank_0(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsyrk_strided_batched_rank_0 = rocblas_zsyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrk_strided_batched_rank_1(handle,uplo,transA,n,k,alpha,A,lda,stride_A,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrk_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsyrk_strided_batched_rank_1 = rocblas_zsyrk_strided_batched_(handle,uplo,transA,n,k,alpha,c_loc(A),lda,stride_A,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyr2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ssyr2k_full_rank = rocblas_ssyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyr2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocblas_ssyr2k_rank_0 = rocblas_ssyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyr2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ssyr2k_rank_1 = rocblas_ssyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyr2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dsyr2k_full_rank = rocblas_dsyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyr2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocblas_dsyr2k_rank_0 = rocblas_dsyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyr2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dsyr2k_rank_1 = rocblas_dsyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyr2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_csyr2k_full_rank = rocblas_csyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyr2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_csyr2k_rank_0 = rocblas_csyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyr2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_csyr2k_rank_1 = rocblas_csyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyr2k_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zsyr2k_full_rank = rocblas_zsyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyr2k_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zsyr2k_rank_0 = rocblas_zsyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyr2k_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zsyr2k_rank_1 = rocblas_zsyr2k_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyr2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2k_batched_full_rank = rocblas_ssyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyr2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2k_batched_rank_0 = rocblas_ssyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyr2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2k_batched_rank_1 = rocblas_ssyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyr2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2k_batched_full_rank = rocblas_dsyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyr2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2k_batched_rank_0 = rocblas_dsyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyr2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2k_batched_rank_1 = rocblas_dsyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyr2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csyr2k_batched_full_rank = rocblas_csyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyr2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csyr2k_batched_rank_0 = rocblas_csyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyr2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csyr2k_batched_rank_1 = rocblas_csyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyr2k_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2k_batched_full_rank = rocblas_zsyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyr2k_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2k_batched_rank_0 = rocblas_zsyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyr2k_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2k_batched_rank_1 = rocblas_zsyr2k_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyr2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2k_strided_batched_full_rank = rocblas_ssyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyr2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2k_strided_batched_rank_0 = rocblas_ssyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyr2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyr2k_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssyr2k_strided_batched_rank_1 = rocblas_ssyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyr2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2k_strided_batched_full_rank = rocblas_dsyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyr2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2k_strided_batched_rank_0 = rocblas_dsyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyr2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyr2k_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsyr2k_strided_batched_rank_1 = rocblas_dsyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyr2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csyr2k_strided_batched_full_rank = rocblas_csyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyr2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csyr2k_strided_batched_rank_0 = rocblas_csyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyr2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyr2k_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csyr2k_strided_batched_rank_1 = rocblas_csyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyr2k_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2k_strided_batched_full_rank = rocblas_zsyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyr2k_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2k_strided_batched_rank_0 = rocblas_zsyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyr2k_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyr2k_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsyr2k_strided_batched_rank_1 = rocblas_zsyr2k_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ssyrkx_full_rank = rocblas_ssyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocblas_ssyrkx_rank_0 = rocblas_ssyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ssyrkx_rank_1 = rocblas_ssyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dsyrkx_full_rank = rocblas_dsyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocblas_dsyrkx_rank_0 = rocblas_dsyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dsyrkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dsyrkx_rank_1 = rocblas_dsyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_csyrkx_full_rank = rocblas_csyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_csyrkx_rank_0 = rocblas_csyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_csyrkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_csyrkx_rank_1 = rocblas_csyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrkx_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zsyrkx_full_rank = rocblas_zsyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrkx_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zsyrkx_rank_0 = rocblas_zsyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zsyrkx_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zsyrkx_rank_1 = rocblas_zsyrkx_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_ssyrkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssyrkx_batched_full_rank = rocblas_ssyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssyrkx_batched_rank_0 = rocblas_ssyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ssyrkx_batched_rank_1 = rocblas_ssyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsyrkx_batched_full_rank = rocblas_dsyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsyrkx_batched_rank_0 = rocblas_dsyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dsyrkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dsyrkx_batched_rank_1 = rocblas_dsyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csyrkx_batched_full_rank = rocblas_csyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csyrkx_batched_rank_0 = rocblas_csyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_csyrkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_csyrkx_batched_rank_1 = rocblas_csyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrkx_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsyrkx_batched_full_rank = rocblas_zsyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrkx_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsyrkx_batched_rank_0 = rocblas_zsyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zsyrkx_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zsyrkx_batched_rank_1 = rocblas_zsyrkx_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ssyrkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssyrkx_strided_batched_full_rank = rocblas_ssyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssyrkx_strided_batched_rank_0 = rocblas_ssyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_ssyrkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ssyrkx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_ssyrkx_strided_batched_rank_1 = rocblas_ssyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsyrkx_strided_batched_full_rank = rocblas_dsyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsyrkx_strided_batched_rank_0 = rocblas_dsyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_dsyrkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dsyrkx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_dsyrkx_strided_batched_rank_1 = rocblas_dsyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csyrkx_strided_batched_full_rank = rocblas_csyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csyrkx_strided_batched_rank_0 = rocblas_csyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_csyrkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_csyrkx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_csyrkx_strided_batched_rank_1 = rocblas_csyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrkx_strided_batched_full_rank(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsyrkx_strided_batched_full_rank = rocblas_zsyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrkx_strided_batched_rank_0(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsyrkx_strided_batched_rank_0 = rocblas_zsyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_zsyrkx_strided_batched_rank_1(handle,uplo,trans,n,k,alpha,A,lda,stride_A,B,ldb,stride_B,beta,C,ldc,stride_C,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zsyrkx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_A
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_B
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_C
      integer(c_int) :: batch_count
      !
      rocblas_zsyrkx_strided_batched_rank_1 = rocblas_zsyrkx_strided_batched_(handle,uplo,trans,n,k,alpha,c_loc(A),lda,stride_A,c_loc(B),ldb,stride_B,beta,c_loc(C),ldc,stride_C,batch_count)
    end function

    function rocblas_strmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocblas_strmm_full_rank = rocblas_strmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      !
      rocblas_strmm_rank_0 = rocblas_strmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocblas_strmm_rank_1 = rocblas_strmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocblas_dtrmm_full_rank = rocblas_dtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      !
      rocblas_dtrmm_rank_0 = rocblas_dtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocblas_dtrmm_rank_1 = rocblas_dtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocblas_ctrmm_full_rank = rocblas_ctrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      !
      rocblas_ctrmm_rank_0 = rocblas_ctrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocblas_ctrmm_rank_1 = rocblas_ctrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocblas_ztrmm_full_rank = rocblas_ztrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      !
      rocblas_ztrmm_rank_0 = rocblas_ztrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocblas_ztrmm_rank_1 = rocblas_ztrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strmm_outofplace_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_strmm_outofplace_full_rank = rocblas_strmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_strmm_outofplace_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocblas_strmm_outofplace_rank_0 = rocblas_strmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_strmm_outofplace_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_strmm_outofplace_rank_1 = rocblas_strmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_dtrmm_outofplace_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dtrmm_outofplace_full_rank = rocblas_dtrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_dtrmm_outofplace_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocblas_dtrmm_outofplace_rank_0 = rocblas_dtrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_dtrmm_outofplace_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dtrmm_outofplace_rank_1 = rocblas_dtrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_ctrmm_outofplace_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ctrmm_outofplace_full_rank = rocblas_ctrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_ctrmm_outofplace_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_ctrmm_outofplace_rank_0 = rocblas_ctrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_ctrmm_outofplace_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ctrmm_outofplace_rank_1 = rocblas_ctrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_ztrmm_outofplace_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ztrmm_outofplace_full_rank = rocblas_ztrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_ztrmm_outofplace_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_ztrmm_outofplace_rank_0 = rocblas_ztrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_ztrmm_outofplace_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ztrmm_outofplace_rank_1 = rocblas_ztrmm_outofplace_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_strmm_outofplace_batched_full_rank(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_strmm_outofplace_batched_full_rank = rocblas_strmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_strmm_outofplace_batched_rank_0(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_strmm_outofplace_batched_rank_0 = rocblas_strmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_strmm_outofplace_batched_rank_1(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_strmm_outofplace_batched_rank_1 = rocblas_strmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dtrmm_outofplace_batched_full_rank(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dtrmm_outofplace_batched_full_rank = rocblas_dtrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dtrmm_outofplace_batched_rank_0(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dtrmm_outofplace_batched_rank_0 = rocblas_dtrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dtrmm_outofplace_batched_rank_1(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dtrmm_outofplace_batched_rank_1 = rocblas_dtrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ctrmm_outofplace_batched_full_rank(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ctrmm_outofplace_batched_full_rank = rocblas_ctrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ctrmm_outofplace_batched_rank_0(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ctrmm_outofplace_batched_rank_0 = rocblas_ctrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ctrmm_outofplace_batched_rank_1(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ctrmm_outofplace_batched_rank_1 = rocblas_ctrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ztrmm_outofplace_batched_full_rank(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ztrmm_outofplace_batched_full_rank = rocblas_ztrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ztrmm_outofplace_batched_rank_0(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ztrmm_outofplace_batched_rank_0 = rocblas_ztrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ztrmm_outofplace_batched_rank_1(handle,side,uplo,transa,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ztrmm_outofplace_batched_rank_1 = rocblas_ztrmm_outofplace_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_strmm_outofplace_strided_batched_full_rank(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_strmm_outofplace_strided_batched_full_rank = rocblas_strmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_strmm_outofplace_strided_batched_rank_0(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_strmm_outofplace_strided_batched_rank_0 = rocblas_strmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_strmm_outofplace_strided_batched_rank_1(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strmm_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_strmm_outofplace_strided_batched_rank_1 = rocblas_strmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dtrmm_outofplace_strided_batched_full_rank(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dtrmm_outofplace_strided_batched_full_rank = rocblas_dtrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dtrmm_outofplace_strided_batched_rank_0(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dtrmm_outofplace_strided_batched_rank_0 = rocblas_dtrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dtrmm_outofplace_strided_batched_rank_1(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrmm_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dtrmm_outofplace_strided_batched_rank_1 = rocblas_dtrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ctrmm_outofplace_strided_batched_full_rank(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_ctrmm_outofplace_strided_batched_full_rank = rocblas_ctrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ctrmm_outofplace_strided_batched_rank_0(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_ctrmm_outofplace_strided_batched_rank_0 = rocblas_ctrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ctrmm_outofplace_strided_batched_rank_1(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrmm_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_ctrmm_outofplace_strided_batched_rank_1 = rocblas_ctrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ztrmm_outofplace_strided_batched_full_rank(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_ztrmm_outofplace_strided_batched_full_rank = rocblas_ztrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ztrmm_outofplace_strided_batched_rank_0(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_ztrmm_outofplace_strided_batched_rank_0 = rocblas_ztrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ztrmm_outofplace_strided_batched_rank_1(handle,side,uplo,transa,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrmm_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_ztrmm_outofplace_strided_batched_rank_1 = rocblas_ztrmm_outofplace_strided_batched_(handle,side,uplo,transa,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_strtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_strtri_full_rank = rocblas_strtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_strtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_strtri_rank_0 = rocblas_strtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_strtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_strtri_rank_1 = rocblas_strtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_dtrtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_dtrtri_full_rank = rocblas_dtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_dtrtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_dtrtri_rank_0 = rocblas_dtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_dtrtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_dtrtri_rank_1 = rocblas_dtrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ctrtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_ctrtri_full_rank = rocblas_ctrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ctrtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_ctrtri_rank_0 = rocblas_ctrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ctrtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_ctrtri_rank_1 = rocblas_ctrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ztrtri_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_ztrtri_full_rank = rocblas_ztrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ztrtri_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_ztrtri_rank_0 = rocblas_ztrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_ztrtri_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      rocblas_ztrtri_rank_1 = rocblas_ztrtri_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA)
    end function

    function rocblas_strtri_batched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_strtri_batched_full_rank = rocblas_strtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_strtri_batched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_strtri_batched_rank_0 = rocblas_strtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_strtri_batched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_strtri_batched_rank_1 = rocblas_strtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_dtrtri_batched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_dtrtri_batched_full_rank = rocblas_dtrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_dtrtri_batched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_dtrtri_batched_rank_0 = rocblas_dtrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_dtrtri_batched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_dtrtri_batched_rank_1 = rocblas_dtrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ctrtri_batched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_ctrtri_batched_full_rank = rocblas_ctrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ctrtri_batched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_ctrtri_batched_rank_0 = rocblas_ctrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ctrtri_batched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_ctrtri_batched_rank_1 = rocblas_ctrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ztrtri_batched_full_rank(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_ztrtri_batched_full_rank = rocblas_ztrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ztrtri_batched_rank_0(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_ztrtri_batched_rank_0 = rocblas_ztrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_ztrtri_batched_rank_1(handle,uplo,diag,n,A,lda,invA,ldinvA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batch_count
      !
      rocblas_ztrtri_batched_rank_1 = rocblas_ztrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,c_loc(invA),ldinvA,batch_count)
    end function

    function rocblas_strtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_strtri_strided_batched_full_rank = rocblas_strtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_strtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_strtri_strided_batched_rank_0 = rocblas_strtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_strtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strtri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_strtri_strided_batched_rank_1 = rocblas_strtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_dtrtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_dtrtri_strided_batched_full_rank = rocblas_dtrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_dtrtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_dtrtri_strided_batched_rank_0 = rocblas_dtrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_dtrtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrtri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_dtrtri_strided_batched_rank_1 = rocblas_dtrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ctrtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_ctrtri_strided_batched_full_rank = rocblas_ctrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ctrtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_ctrtri_strided_batched_rank_0 = rocblas_ctrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ctrtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrtri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_ctrtri_strided_batched_rank_1 = rocblas_ctrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ztrtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_ztrtri_strided_batched_full_rank = rocblas_ztrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ztrtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_ztrtri_strided_batched_rank_0 = rocblas_ztrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_ztrtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,stride_a,invA,ldinvA,stride_invA,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrtri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batch_count
      !
      rocblas_ztrtri_strided_batched_rank_1 = rocblas_ztrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,stride_a,c_loc(invA),ldinvA,stride_invA,batch_count)
    end function

    function rocblas_strsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocblas_strsm_full_rank = rocblas_strsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      !
      rocblas_strsm_rank_0 = rocblas_strsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocblas_strsm_rank_1 = rocblas_strsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocblas_dtrsm_full_rank = rocblas_dtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      !
      rocblas_dtrsm_rank_0 = rocblas_dtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_dtrsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocblas_dtrsm_rank_1 = rocblas_dtrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocblas_ctrsm_full_rank = rocblas_ctrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      !
      rocblas_ctrsm_rank_0 = rocblas_ctrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ctrsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocblas_ctrsm_rank_1 = rocblas_ctrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrsm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocblas_ztrsm_full_rank = rocblas_ztrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrsm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      !
      rocblas_ztrsm_rank_0 = rocblas_ztrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_ztrsm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocblas_ztrsm_rank_1 = rocblas_ztrsm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocblas_strsm_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_strsm_batched_full_rank = rocblas_strsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_strsm_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_strsm_batched_rank_0 = rocblas_strsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_strsm_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_strsm_batched_rank_1 = rocblas_strsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_dtrsm_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_dtrsm_batched_full_rank = rocblas_dtrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_dtrsm_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_dtrsm_batched_rank_0 = rocblas_dtrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_dtrsm_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_dtrsm_batched_rank_1 = rocblas_dtrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ctrsm_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_ctrsm_batched_full_rank = rocblas_ctrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ctrsm_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_ctrsm_batched_rank_0 = rocblas_ctrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ctrsm_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_ctrsm_batched_rank_1 = rocblas_ctrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ztrsm_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_ztrsm_batched_full_rank = rocblas_ztrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ztrsm_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_ztrsm_batched_rank_0 = rocblas_ztrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_ztrsm_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocblas_ztrsm_batched_rank_1 = rocblas_ztrsm_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocblas_strsm_strided_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_strsm_strided_batched_full_rank = rocblas_strsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_strsm_strided_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_strsm_strided_batched_rank_0 = rocblas_strsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_strsm_strided_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_strsm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_strsm_strided_batched_rank_1 = rocblas_strsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_dtrsm_strided_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_dtrsm_strided_batched_full_rank = rocblas_dtrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_dtrsm_strided_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_dtrsm_strided_batched_rank_0 = rocblas_dtrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_dtrsm_strided_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dtrsm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_dtrsm_strided_batched_rank_1 = rocblas_dtrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ctrsm_strided_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_ctrsm_strided_batched_full_rank = rocblas_ctrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ctrsm_strided_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_ctrsm_strided_batched_rank_0 = rocblas_ctrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ctrsm_strided_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ctrsm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_ctrsm_strided_batched_rank_1 = rocblas_ctrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ztrsm_strided_batched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_ztrsm_strided_batched_full_rank = rocblas_ztrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ztrsm_strided_batched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_ztrsm_strided_batched_rank_0 = rocblas_ztrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_ztrsm_strided_batched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,stride_a,B,ldb,stride_b,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ztrsm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      integer(c_int) :: batch_count
      !
      rocblas_ztrsm_strided_batched_rank_1 = rocblas_ztrsm_strided_batched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,batch_count)
    end function

    function rocblas_sgemm_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_sgemm_full_rank = rocblas_sgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_sgemm_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocblas_sgemm_rank_0 = rocblas_sgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_sgemm_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_sgemm_rank_1 = rocblas_sgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dgemm_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dgemm_full_rank = rocblas_dgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dgemm_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocblas_dgemm_rank_0 = rocblas_dgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_dgemm_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dgemm_rank_1 = rocblas_dgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cgemm_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cgemm_full_rank = rocblas_cgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cgemm_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_cgemm_rank_0 = rocblas_cgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_cgemm_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cgemm_rank_1 = rocblas_cgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zgemm_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zgemm_full_rank = rocblas_zgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zgemm_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zgemm_rank_0 = rocblas_zgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_zgemm_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zgemm_rank_1 = rocblas_zgemm_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc)
    end function

    function rocblas_sgemm_batched_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_sgemm_batched_full_rank = rocblas_sgemm_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgemm_batched_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_sgemm_batched_rank_0 = rocblas_sgemm_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgemm_batched_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_sgemm_batched_rank_1 = rocblas_sgemm_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgemm_batched_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dgemm_batched_full_rank = rocblas_dgemm_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgemm_batched_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dgemm_batched_rank_0 = rocblas_dgemm_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgemm_batched_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dgemm_batched_rank_1 = rocblas_dgemm_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgemm_batched_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cgemm_batched_full_rank = rocblas_cgemm_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgemm_batched_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cgemm_batched_rank_0 = rocblas_cgemm_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgemm_batched_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cgemm_batched_rank_1 = rocblas_cgemm_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgemm_batched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_operation_none)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zgemm_batched_full_rank = rocblas_zgemm_batched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgemm_batched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_operation_none)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zgemm_batched_rank_0 = rocblas_zgemm_batched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgemm_batched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,B,ldb,beta,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_operation_none)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zgemm_batched_rank_1 = rocblas_zgemm_batched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,c_loc(B),ldb,beta,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgemm_strided_batched_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sgemm_strided_batched_full_rank = rocblas_sgemm_strided_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgemm_strided_batched_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sgemm_strided_batched_rank_0 = rocblas_sgemm_strided_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgemm_strided_batched_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sgemm_strided_batched_rank_1 = rocblas_sgemm_strided_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_strided_batched_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dgemm_strided_batched_full_rank = rocblas_dgemm_strided_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_strided_batched_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dgemm_strided_batched_rank_0 = rocblas_dgemm_strided_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_strided_batched_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dgemm_strided_batched_rank_1 = rocblas_dgemm_strided_batched_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgemm_kernel_name_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_kernel_name_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sgemm_kernel_name_full_rank = rocblas_sgemm_kernel_name_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgemm_kernel_name_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_kernel_name_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float) :: beta
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sgemm_kernel_name_rank_0 = rocblas_sgemm_kernel_name_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgemm_kernel_name_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgemm_kernel_name_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sgemm_kernel_name_rank_1 = rocblas_sgemm_kernel_name_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_kernel_name_full_rank(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_kernel_name_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dgemm_kernel_name_full_rank = rocblas_dgemm_kernel_name_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_kernel_name_rank_0(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_kernel_name_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double) :: beta
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dgemm_kernel_name_rank_0 = rocblas_dgemm_kernel_name_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgemm_kernel_name_rank_1(handle,transA,transB,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgemm_kernel_name_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dgemm_kernel_name_rank_1 = rocblas_dgemm_kernel_name_(handle,transA,transB,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgemm_strided_batched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_operation_none)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_cgemm_strided_batched_full_rank = rocblas_cgemm_strided_batched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgemm_strided_batched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_operation_none)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_cgemm_strided_batched_rank_0 = rocblas_cgemm_strided_batched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgemm_strided_batched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgemm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_operation_none)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_cgemm_strided_batched_rank_1 = rocblas_cgemm_strided_batched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgemm_strided_batched_full_rank(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_operation_none)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_zgemm_strided_batched_full_rank = rocblas_zgemm_strided_batched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgemm_strided_batched_rank_0(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_operation_none)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_zgemm_strided_batched_rank_0 = rocblas_zgemm_strided_batched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgemm_strided_batched_rank_1(handle,transa,transb,m,n,k,alpha,A,lda,stride_a,B,ldb,stride_b,beta,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgemm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transa
      integer(kind(rocblas_operation_none)) :: transb
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_zgemm_strided_batched_rank_1 = rocblas_zgemm_strided_batched_(handle,transa,transb,m,n,k,alpha,c_loc(A),lda,stride_a,c_loc(B),ldb,stride_b,beta,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sdgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_sdgmm_full_rank = rocblas_sdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_sdgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocblas_sdgmm_rank_0 = rocblas_sdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_sdgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_sdgmm_rank_1 = rocblas_sdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_ddgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ddgmm_full_rank = rocblas_ddgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_ddgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocblas_ddgmm_rank_0 = rocblas_ddgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_ddgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_ddgmm_rank_1 = rocblas_ddgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_cdgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cdgmm_full_rank = rocblas_cdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_cdgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_cdgmm_rank_0 = rocblas_cdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_cdgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cdgmm_rank_1 = rocblas_cdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_zdgmm_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zdgmm_full_rank = rocblas_zdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_zdgmm_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zdgmm_rank_0 = rocblas_zdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_zdgmm_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zdgmm_rank_1 = rocblas_zdgmm_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc)
    end function

    function rocblas_sdgmm_batched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_sdgmm_batched_full_rank = rocblas_sdgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sdgmm_batched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_sdgmm_batched_rank_0 = rocblas_sdgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sdgmm_batched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_sdgmm_batched_rank_1 = rocblas_sdgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ddgmm_batched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ddgmm_batched_full_rank = rocblas_ddgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ddgmm_batched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ddgmm_batched_rank_0 = rocblas_ddgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_ddgmm_batched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_ddgmm_batched_rank_1 = rocblas_ddgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cdgmm_batched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cdgmm_batched_full_rank = rocblas_cdgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cdgmm_batched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cdgmm_batched_rank_0 = rocblas_cdgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cdgmm_batched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cdgmm_batched_rank_1 = rocblas_cdgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zdgmm_batched_full_rank(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zdgmm_batched_full_rank = rocblas_zdgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zdgmm_batched_rank_0(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zdgmm_batched_rank_0 = rocblas_zdgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zdgmm_batched_rank_1(handle,side,m,n,A,lda,x,incx,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zdgmm_batched_rank_1 = rocblas_zdgmm_batched_(handle,side,m,n,c_loc(A),lda,c_loc(x),incx,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sdgmm_strided_batched_full_rank(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sdgmm_strided_batched_full_rank = rocblas_sdgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sdgmm_strided_batched_rank_0(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sdgmm_strided_batched_rank_0 = rocblas_sdgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sdgmm_strided_batched_rank_1(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sdgmm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sdgmm_strided_batched_rank_1 = rocblas_sdgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ddgmm_strided_batched_full_rank(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_ddgmm_strided_batched_full_rank = rocblas_ddgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ddgmm_strided_batched_rank_0(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_ddgmm_strided_batched_rank_0 = rocblas_ddgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_ddgmm_strided_batched_rank_1(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_ddgmm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_ddgmm_strided_batched_rank_1 = rocblas_ddgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cdgmm_strided_batched_full_rank(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_cdgmm_strided_batched_full_rank = rocblas_cdgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cdgmm_strided_batched_rank_0(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_cdgmm_strided_batched_rank_0 = rocblas_cdgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cdgmm_strided_batched_rank_1(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cdgmm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_cdgmm_strided_batched_rank_1 = rocblas_cdgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zdgmm_strided_batched_full_rank(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_zdgmm_strided_batched_full_rank = rocblas_zdgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zdgmm_strided_batched_rank_0(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_zdgmm_strided_batched_rank_0 = rocblas_zdgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zdgmm_strided_batched_rank_1(handle,side,m,n,A,lda,stride_a,x,incx,stride_x,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zdgmm_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stride_x
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_zdgmm_strided_batched_rank_1 = rocblas_zdgmm_strided_batched_(handle,side,m,n,c_loc(A),lda,stride_a,c_loc(x),incx,stride_x,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgeam_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_sgeam_full_rank = rocblas_sgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_sgeam_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocblas_sgeam_rank_0 = rocblas_sgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_sgeam_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_sgeam_rank_1 = rocblas_sgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_dgeam_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dgeam_full_rank = rocblas_dgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_dgeam_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocblas_dgeam_rank_0 = rocblas_dgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_dgeam_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_dgeam_rank_1 = rocblas_dgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_cgeam_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cgeam_full_rank = rocblas_cgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_cgeam_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_cgeam_rank_0 = rocblas_cgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_cgeam_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_cgeam_rank_1 = rocblas_cgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_zgeam_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zgeam_full_rank = rocblas_zgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_zgeam_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocblas_zgeam_rank_0 = rocblas_zgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_zgeam_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocblas_zgeam_rank_1 = rocblas_zgeam_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function rocblas_sgeam_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_sgeam_batched_full_rank = rocblas_sgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgeam_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_sgeam_batched_rank_0 = rocblas_sgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgeam_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_sgeam_batched_rank_1 = rocblas_sgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgeam_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dgeam_batched_full_rank = rocblas_dgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgeam_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dgeam_batched_rank_0 = rocblas_dgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_dgeam_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_dgeam_batched_rank_1 = rocblas_dgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgeam_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cgeam_batched_full_rank = rocblas_cgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgeam_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cgeam_batched_rank_0 = rocblas_cgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_cgeam_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_cgeam_batched_rank_1 = rocblas_cgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgeam_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zgeam_batched_full_rank = rocblas_zgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgeam_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zgeam_batched_rank_0 = rocblas_zgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_zgeam_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,beta,B,ldb,C,ldc,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batch_count
      !
      rocblas_zgeam_batched_rank_1 = rocblas_zgeam_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,beta,c_loc(B),ldb,c_loc(C),ldc,batch_count)
    end function

    function rocblas_sgeam_strided_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sgeam_strided_batched_full_rank = rocblas_sgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgeam_strided_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float) :: beta
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sgeam_strided_batched_rank_0 = rocblas_sgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_sgeam_strided_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_sgeam_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_sgeam_strided_batched_rank_1 = rocblas_sgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgeam_strided_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dgeam_strided_batched_full_rank = rocblas_dgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgeam_strided_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double) :: beta
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dgeam_strided_batched_rank_0 = rocblas_dgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_dgeam_strided_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_dgeam_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_dgeam_strided_batched_rank_1 = rocblas_dgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgeam_strided_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_cgeam_strided_batched_full_rank = rocblas_cgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgeam_strided_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_cgeam_strided_batched_rank_0 = rocblas_cgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_cgeam_strided_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_cgeam_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_cgeam_strided_batched_rank_1 = rocblas_cgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgeam_strided_batched_full_rank(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_zgeam_strided_batched_full_rank = rocblas_zgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgeam_strided_batched_rank_0(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_zgeam_strided_batched_rank_0 = rocblas_zgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

    function rocblas_zgeam_strided_batched_rank_1(handle,transA,transB,m,n,alpha,A,lda,stride_a,beta,B,ldb,stride_b,C,ldc,stride_c,batch_count)
      use iso_c_binding
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocblas_zgeam_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: transA
      integer(kind(rocblas_operation_none)) :: transB
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: stride_a
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: stride_b
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: stride_c
      integer(c_int) :: batch_count
      !
      rocblas_zgeam_strided_batched_rank_1 = rocblas_zgeam_strided_batched_(handle,transA,transB,m,n,alpha,c_loc(A),lda,stride_a,beta,c_loc(B),ldb,stride_b,c_loc(C),ldc,stride_c,batch_count)
    end function

  
#endif
end module hipfort_rocblas