# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.
import os
import copy
import logging

import addtoplevelpath
import fort2hip.model as model
import translator.translator as translator
import indexer.indexer as indexer
import indexer.scoper as scoper
import scanner.scanner as scanner
import utils.logging
import utils.fileutils

INDEXER_ERROR_CODE = 1000

def GET_DEFAULT_BLOCK_DIMS(kernelName,dim):
    block_dims = { 1 : [128], 2 : [128,1,1], 3: [128,1,1] }
    return block_dims[dim]

def GET_DEFAULT_LAUNCH_BOUNDS(kernelName):
    return None

fort2hipDir = os.path.dirname(__file__)
exec(open("{0}/fort2hip_options.py.in".format(fort2hipDir)).read())

def _intrnl_convert_dim3(dim3,dimensions,doFilter=True):
     result = []
     specified = dim3
     if doFilter:
         specified = [ x for x in dim3 if type(x) != int or x > 0 ]
     for i,value in enumerate(specified):
          if i >= dimensions:
              break
          el = {}
          el["dim"]   = chr(ord("X")+i)
          el["value"] = value
          result.append(el)
     return result

# arg for kernel generator
# array is split into multiple args
def _intrnl_init_arg(argname,f_type,kind,qualifiers=[],c_type="",is_array=False):
    f_type_final = f_type
    if len(kind):
        f_type_final += "({})".format(kind)
    arg = {
      "name"            : argname.replace("%","_") , # TODO structures
      "callarg_name"     : argname,
      "qualifiers"      : qualifiers,
      "type"            : f_type_final,
      "orig_type"        : f_type_final,
      "c_type"          : c_type,
      "c_size"          : "",
      "c_value"         : "",
      "c_suffix"        : "", # TODO still needed?
      "is_array"         : is_array,
      "reductionOp"     : "",
      "bytes_per_element" : translator.bytes(f_type,kind,default="-1")
    }
    if not len(c_type):
        arg["c_type"] = translator.convertToCType(f_type,kind,"void")
    if is_array:
        arg["c_type"] += " * __restrict__"
    return arg

def _intrnl_create_argument_context(ivar,argname,deviceptr_names=[],is_loop_kernel_arg=False):
    """
    Create an argument context dictionary based on a indexed variable.

    :param ivar: A variable description provided by the indexer.
    :type ivar: STDeclaration
    :return: a dicts containing Fortran `type` and `qualifiers` (`type`, `qualifiers`), C type (`c_type`), and `name` of the argument
    :rtype: dict
    """
    arg = _intrnl_init_arg(argname,ivar["f_type"],ivar["kind"],[ "value" ],"",ivar["rank"]>0)
    if "parameter" in ivar["qualifiers"] and not ivar["value"] is None:
        arg["c_value"] = ivar["value"] 
    lbound_args = []  # additional arguments that we introduce if variable is an array
    count_args      = []
    macro          = None
    # treat arrays
    rank = ivar["rank"] 
    if rank > 0:
        if argname in deviceptr_names:
            arg["callarg_name"] = "c_loc({})".format(argname)
        else: 
            arg["callarg_name"] = scanner.devVarName(argname)
        arg["type"]       = "type(c_ptr)"
        arg["qualifiers"] = [ "value" ]
        for d in range(1,rank+1):
             # lower bounds
             bound_arg = _intrnl_init_arg("{}_lb{}".format(argname,d),"integer","c_int",["value","intent(in)"],"const int")
             bound_arg["callarg_name"] = "lbound({},{})".format(argname,d)
             lbound_args.append(bound_arg)
             # number of elements per dimensions
             count_arg = _intrnl_init_arg("{}_n{}".format(argname,d),"integer","c_int",["value","intent(in)"],"const int")
             count_arg["callarg_name"] = "size({},{})".format(argname,d)
             count_args.append(count_arg)
        # create macro expression
        if is_loop_kernel_arg and not ivar["unspecified_bounds"]:
            macro = { "expr" : ivar["index_macro"] }
        else:
            macro = { "expr" : ivar["index_macro_with_placeholders"] }
    return arg, lbound_args, count_args, macro

def _intrnl_derive_kernel_arguments(scope, varnames, local_vars, loop_vars, whiteList=[], is_loop_kernel_arg=False, deviceptr_names=[]):
    """
    Derive code generation contexts for the different interfaces and subroutines that 
    are generated by the fort2hip module.

    :param: varnames a list of Fortran varnames or derived type memebers such as 'a%b%c'
    """
    utils.logging.logEnterFunction(LOG_PREFIX,"__derive_kernel_arguments")
    
    kernelArgs          = []
    unknownArgs         = []
    cKernelLocalVars    = []
    macros              = []
    localArgs           = []
    localCpuRoutineArgs = []
    inputArrays         = []

    def include_arg_(name):
        nameLower = name.lower().strip()
        if len(whiteList):
            return nameLower in whiteList
        else:
            if nameLower.startswith("_"): # Fortran names never start with _; can be exploited when modifying code
                return False
            else:
                return True
    
    varnamesLower = [name.lower() for name in varnames]
    for name in varnamesLower:
        if include_arg_(name):
            ivar, discovered = scoper.searchScopeForVariable(\
              scope,translator.create_index_search_tag_for_variable(name)) # TODO treat implicit here
            argname = name
            if not discovered:
                arg = _intrnl_init_arg(name,"TODO declaration not found","",[],"TODO declaration not found")
                unknownArgs.append(arg)
            else:
                arg, lowerBoundArgs, countArgs, macro = _intrnl_create_argument_context(ivar,name,deviceptr_names)
                argname = name.lower().replace("%","_") # TODO
                # modify argument
                if argname in loop_vars: # specific for loop kernels
                    arg["qualifiers"]=[]
                    localCpuRoutineArgs.append(arg)
                elif argname in local_vars:
                    arg["qualifiers"]=[]
                    if ivar["rank"] > 0:
                        arg["c_size"] = ivar["total_count"]
                    if "shared" in ivar["qualifiers"]:
                        arg["c_type"] = "__shared__" + arg["c_type"] 
                    localCpuRoutineArgs.append(arg)
                    cKernelLocalVars.append(arg)
                else:
                    rank = ivar["rank"]
                    if rank > 0: 
                        inputArrays.append({ "name" : name, "rank" : rank })
                        arg["c_size"]    = ""
                        dimensions = "dimension({0})".format(",".join([":"]*rank))
                        # Fortran size expression for allocate
                        f_size = []
                        for i in range(0,rank):
                            f_size.append("{lb}:{lb}+{siz}-1".format(\
                                lb=lowerBoundArgs[i]["name"],siz=countArgs[i]["name"]))
                        localCpuRoutineArgs.append(\
                          { "name" : name,
                            "type" : arg["orig_type"],
                            "qualifiers" : ["allocatable",dimensions,"target"],
                            "bounds" : ",".join(f_size),
                            "bytes_per_element" : arg["bytes_per_element"]
                          }\
                        )
                    kernelArgs.append(arg)
                    for countArg in countArgs:
                        kernelArgs.append(countArg)
                    for boundArg in lowerBoundArgs:
                        kernelArgs.append(boundArg)
                if not macro is None:
                    macros.append(macro)

    # remove unknown arguments that are actually bound variables (<arg>_n<dim> or <arg>_lb<dim>)
    for unknownKernelArg in unknownArgs:
        append = True
        for kernelArg in kernelArgs:
            if unknownKernelArg["name"].lower() == kernelArg["name"].lower():
                append = False
                break
        if append:
            kernelArgs.append(unknownKernelArg)

    utils.logging.logLeaveFunction(LOG_PREFIX,"__derive_kernel_arguments")
    return kernelArgs, cKernelLocalVars, macros, inputArrays, localCpuRoutineArgs
    
def _intrnl_update_context_from_loop_kernels(loop_kernels,index,hipContext,fContext):
    """
    loop_kernels is a list of STCufloop_kernel objects.
    hipContext, fContext are inout arguments for generating C/Fortran files, respectively.
    """
    utils.logging.logEnterFunction(LOG_PREFIX,"__updateContextFromLoopKernels")
    
    generateLauncher    = EMIT_KERNEL_LAUNCHER
    generateCPULauncher = generateLauncher and EMIT_CPU_IMPLEMENTATION
    
    hipContext["have_reductions"] = False
    for stkernel in loop_kernels:
        parentTag = stkernel._parent.tag()
        scope     = scoper.createScope(index,parentTag)
   
        # translate and analyze kernels
        parse_result = translator.parse_loop_kernel(stkernel.code,scope)

        kernelArgs, cKernelLocalVars, macros, inputArrays, localCpuRoutineArgs =\
          _intrnl_derive_kernel_arguments(scope,\
            parse_result.variables_in_body(),\
            parse_result.localScalars(),\
            parse_result.loopVars(),\
            [], True, parse_result.deviceptrs())
        
        utils.logging.logDebug3("parse result:\n```"+parse_result.c_str().rstrip()+"\n```")

        # general
        kernelName         = stkernel.kernelName()
        kernelLauncherName = stkernel.kernelLauncherName()
   
        # treat reductionVars vars / acc default(present) vars
        hipContext["have_reductions"] = False # |= len(reductionOps)
        kernelCallArgNames    = []
        cpuKernelCallArgNames = []
        reductions            = parse_result.gangTeamReductions(translator.make_c_str)
        reductionVars         = []
        for arg in kernelArgs:
            name  = arg["name"]
            c_type = arg["c_type"]
            cpuKernelCallArgNames.append(name)
            isReductionVar = False
            for op,variables in reductions.items():
                if name.lower() in [var.lower() for var in variables]:
                    # modify argument
                    arg["qualifiers"].remove("value")
                    arg["c_type"] = c_type + "*"
                    # reductionVars buffer var
                    bufferName = "_d_" + name
                    var = { "buffer": bufferName, "name" : name, "type" : c_type, "op" : op }
                    reductionVars.append(var)
                    # call args
                    kernelCallArgNames.append(bufferName)
                    isReductionVar = True
            if not isReductionVar:
                kernelCallArgNames.append(name)
                if type(stkernel) is scanner.STAccLoopKernel:
                    if len(arg["c_size"]):
                        stkernel.appendDefaultPresentVar(name)
            hipContext["have_reductions"] |= isReductionVar
        # C loop kernel
        dimensions  = parse_result.numDimensions()
        block = _intrnl_convert_dim3(parse_result.numThreadsInBlock(),dimensions)
        # TODO more logging
        if not len(block):
            defaultBlockSize = GET_BLOCK_DIMS(kernelName,dimensions)
            block = _intrnl_convert_dim3(defaultBlockSize,dimensions)
        hipKernelDict = {}
        hipKernelDict["is_loop_kernel"]          = True
        hipKernelDict["modifier"]              = "__global__"
        hipKernelDict["return_type"]            = "void"
        hipKernelDict["generate_debug_code"]     = EMIT_DEBUG_CODE
        hipKernelDict["generate_launcher"]      = generateLauncher 
        hipKernelDict["generate_cpu_launcher"]   = generateCPULauncher
        
        launchBounds = GET_LAUNCH_BOUNDS(kernelName)
        if launchBounds != None and len(launchBounds):
            hipKernelDict["launch_bounds"]      = "_intrnl_launch_bounds___({})".format(launchBounds)
        else:
            hipKernelDict["launch_bounds"]      = ""
        hipKernelDict["size"]                  = _intrnl_convert_dim3(parse_result.problemSize(),dimensions,doFilter=False)
        hipKernelDict["grid"]                  = _intrnl_convert_dim3(parse_result.numGangsTeamsBlocks(),dimensions)
        hipKernelDict["block"]                 = block
        hipKernelDict["gridDims"  ]            = [ "{}_grid{}".format(kernelName,x["dim"])  for x in block ] # grid might not be always defined
        hipKernelDict["blockDims"  ]           = [ "{}_block{}".format(kernelName,x["dim"]) for x in block ]
        hipKernelDict["kernel_name"]            = kernelName
        hipKernelDict["macros"]                = macros
        hipKernelDict["c_body"]                 = parse_result.c_str()
        originalSnippet = "".join(stkernel.lines())
        if PRETTIFY_EMITTED_FORTRAN_CODE:
            hipKernelDict["f_body"]                 = utils.fileutils.prettifyFCode(originalSnippet)
        else:
            hipKernelDict["f_body"]                 = originalSnippet
        hipKernelDict["kernel_args"]            = ["{} {}{}{}".format(a["c_type"],a["name"],a["c_size"],a["c_suffix"]) for a in kernelArgs]
        hipKernelDict["kernel_call_arg_names"]    = kernelCallArgNames
        hipKernelDict["cpu_kernel_call_arg_names"] = cpuKernelCallArgNames
        hipKernelDict["reductions"]            = reductionVars
        hipKernelDict["kernel_local_vars"]       = ["{} {}{}".format(a["c_type"],a["name"],a["c_size"]) for a in cKernelLocalVars]
        hipKernelDict["interface_name"]         = kernelLauncherName
        hipKernelDict["interface_comment"]      = "" # kernelLaunchInfo.c_str()
        hipKernelDict["interface_args"]         = hipKernelDict["kernel_args"]
        hipKernelDict["interface_arg_names"]     = [arg["name"] for arg in kernelArgs] # excludes the stream;
        hipKernelDict["input_arrays"]           = inputArrays
        #inout_arrays_in_body                   = [name.lower for name in parse_result.inout_arrays_in_body()]
        #hipKernelDict["output_arrays"]       = [array for array in inputArrays if array.lower() in inout_arrays_in_body]
        hipKernelDict["output_arrays"]          = inputArrays
        hipContext["kernels"].append(hipKernelDict)

        if generateLauncher:
            # Fortran interface with automatic derivation of stkernel launch parameters
            fInterfaceDictAuto = {}
            fInterfaceDictAuto["c_name"]    = kernelLauncherName + "_auto"
            fInterfaceDictAuto["f_name"]    = kernelLauncherName + "_auto"
            fInterfaceDictAuto["type"]     = "subroutine"
            fInterfaceDictAuto["args"]     = [
              {"type" : "integer(c_int)", "qualifiers" : ["value", "intent(in)"], "name" : "sharedMem", "c_size" : "" },
              {"type" : "type(c_ptr)"   , "qualifiers" : ["value", "intent(in)"], "name" : "stream",   "c_size": ""},
            ]
            fInterfaceDictAuto["args"]    += kernelArgs
            fInterfaceDictAuto["argnames"] = [arg["name"] for arg in fInterfaceDictAuto["args"]]

            # for test
            fInterfaceDictAuto["do_test"]   = False # True
            fInterfaceDictAuto["test_comment"] = ["Fortran implementation:"] + stkernel.code
            #fInterfaceDictAuto["test_comment"] = ["","Hints:","Device variables in scope:"] + ["".join(declared.lines()).lower() for declared in deviceVarsInScope]

            #######################################################################
            # Feed argument names back to STLoopKernel for host code modification
            #######################################################################
            stkernel.kernelArgNames = [arg["callarg_name"] for arg in kernelArgs]
            stkernel.gridFStr       = parse_result.gridExpressionFStr()
            stkernel.blockFStr      = parse_result.blockExpressionFStr()
            # TODO use indexer to check if block and dim expressions are actually dim3 types or introduce overloaded make_dim3 interface to hipfort
            stkernel.streamFStr     = parse_result.stream()    # TODO consistency
            stkernel.sharedMemFstr  = parse_result.sharedMem() # TODO consistency

            # Fortran interface with manual specification of stkernel launch parameters
            fInterfaceDictManual = copy.deepcopy(fInterfaceDictAuto)
            fInterfaceDictManual["c_name"] = kernelLauncherName
            fInterfaceDictManual["f_name"] = kernelLauncherName
            fInterfaceDictManual["args"] = [
              {"type" : "type(dim3)", "qualifiers" : ["intent(in)"], "name" : "grid", "c_size": ""},
              {"type" : "type(dim3)", "qualifiers" : ["intent(in)"], "name" : "block", "c_size": ""},
              {"type" : "integer(c_int)", "qualifiers" : ["value", "intent(in)"], "name" : "sharedMem", "c_size" : "" },
              {"type" : "type(c_ptr)"   , "qualifiers" : ["value", "intent(in)"], "name" : "stream",   "c_size": ""},
            ]
            fInterfaceDictManual["args"]    += kernelArgs
            fInterfaceDictManual["argnames"] = [arg["name"] for arg in fInterfaceDictManual["args"]]
            fInterfaceDictManual["do_test"]   = False
            
            fContext["interfaces"].append(fInterfaceDictManual)
            fContext["interfaces"].append(fInterfaceDictAuto)

            if generateCPULauncher:
                # External CPU interface
                fCPUInterfaceDict = copy.deepcopy(fInterfaceDictAuto)
                fCPUInterfaceDict["f_name"] = kernelLauncherName + "_cpu" 
                fCPUInterfaceDict["c_name"] = kernelLauncherName + "_cpu"
                fCPUInterfaceDict["do_test"] = False

                # Internal CPU routine
                fCPURoutineDict = copy.deepcopy(fInterfaceDictAuto)
                fCPURoutineDict["f_name"]    = kernelLauncherName + "_cpu1" 
                fCPURoutineDict["c_name"]    = kernelLauncherName + "_cpu1"
                
                # rename copied modified args
                for i,val in enumerate(fCPURoutineDict["args"]):
                    varName = val["name"]
                    if val.get("is_array",False):
                        fCPURoutineDict["args"][i]["name"] = "d_{}".format(varName)

                fCPURoutineDict["argnames"] = [a["name"] for a in fCPURoutineDict["args"]]
                fCPURoutineDict["args"]    += localCpuRoutineArgs # ordering important
                # add mallocs, memcpys , frees
                prolog = ""
                epilog = "\n"
                for arg in localCpuRoutineArgs:
                     if len(arg.get("bounds","")): # is local Fortran array
                       localArray = arg["name"]
                       # device to host
                       prolog += "allocate({var}({bounds}))\n".format(var=localArray,bounds=arg["bounds"])
                       prolog += "CALL hipCheck(hipMemcpy(c_loc({var}),d_{var},{bpe}_8*SIZE({var}),hipMemcpyDeviceToHost))\n".format(var=localArray,bpe=arg["bytes_per_element"])
                       # host to device
                       epilog += "CALL hipCheck(hipMemcpy(d_{var},c_loc({var}),{bpe}_8*SIZE({var}),hipMemcpyHostToDevice))\n".format(var=localArray,bpe=arg["bytes_per_element"])
                       epilog += "deallocate({var})\n".format(var=localArray)
                fCPURoutineDict["body"] = prolog + "".join(stkernel.code).rstrip("\n") + epilog

                # Add all definitions to context
                fContext["interfaces"].append(fCPUInterfaceDict)
                fContext["routines"].append(fCPURoutineDict)
    
    utils.logging.logLeaveFunction(LOG_PREFIX,"__updateContextFromLoopKernels")

# TODO check if this can be combined with other routine
def _intrnl_update_context_from_device_procedures(deviceProcedures,index,hipContext,fContext):
    """
    deviceProcedures is a list of STProcedure objects.
    hipContext, fContext are inout arguments for generating C/Fortran files, respectively.
    """
    global EMIT_KERNEL_LAUNCHER
    global EMIT_CPU_IMPLEMENTATION
    global EMIT_DEBUG_CODE

    utils.logging.logEnterFunction(LOG_PREFIX,"__update_context_from_device_procedures")
    
    for stprocedure in deviceProcedures:
        scope       = scoper.createScope(index,stprocedure.tag())
        iprocedure  = stprocedure.indexRecord
        isFunction  = iprocedure["kind"] == "function"
        
        hipContext["includes"] += _intrnl_createIncludesFromUsedModules(iprocedure,index)

        fBody = "\n".join(stprocedure.code)
        if isFunction:
            result_name = iprocedure["result_name"]
            ivar_result = next([var for var in iprocedure["variables"] if var["name"] == iprocedure["result_name"]],None)
            if ivar_result != None:
                resultType = ivar_result["c_type"]
                parse_result = translator.parse_procedure_body(stprocedure.code,scope,ivar_result["name"])
            else:
                msg = "could not identify return value for function ''"
                utils.logging.logError(msg)
                sys.exit(INDEXER_ERROR_CODE)
        else:
            resultType = "void"
            parse_result = translator.parse_procedure_body(stprocedure.code,scope)
        utils.logging.logDebug3(LOG_PREFIX,"_intrnl_update_context_from_device_procedures","parse result:\n```"+parse_result.c_str().rstrip()+"\n```")

        # TODO: look up functions and subroutines called internally and supply to parse_result before calling c_str()
    
        ## general
        generateLauncher   = EMIT_KERNEL_LAUNCHER and stprocedure.isKernelSubroutine()
        kernelName         = iprocedure["name"]
        kernelLauncherName = "launch_" + kernelName

        # sort identifiers: put dummy args first
        # TODO(dominic): More detailed analysis what to do with non-dummy args
        dummy_args = iprocedure["dummy_args"]
        varnames   = parse_result.variables_in_body()
        local_vars = []
        for ivar in iprocedure["variables"]:
            if ivar["name"] not in dummy_args:  
                local_vars.append(ivar["name"])

        # TODO also check 'used' variables from other modules; should be in scope
        # TODO also add implicit variables; should be in scope

        kernelArgs, cKernelLocalVars, macros, inputArrays, localCpuRoutineArgs =\
          _intrnl_derive_kernel_arguments(scope,varnames,local_vars,[],dummy_args,False,deviceptr_names=[])
        #print(argnames)

        # C routine and C stprocedure launcher
        hipKernelDict = {}
        launchBounds = GET_LAUNCH_BOUNDS(kernelName)
        if launchBounds != None and len(launchBounds) and stprocedure.isKernelSubroutine():
            hipKernelDict["launch_bounds"]      = "_intrnl_launch_bounds___({})".format(launchBounds)
        else:
            hipKernelDict["launch_bounds"]      = ""
        hipKernelDict["generate_debug_code"]   = EMIT_DEBUG_CODE
        hipKernelDict["generate_launcher"]    = generateLauncher
        hipKernelDict["generate_cpu_launcher"] = False
        hipKernelDict["modifier"]            = "__global__" if stprocedure.isKernelSubroutine() else "__device__"
        hipKernelDict["return_type"]          = resultType
        hipKernelDict["is_loop_kernel"]        = False
        hipKernelDict["kernel_name"]          = kernelName
        hipKernelDict["macros"]              = macros
        hipKernelDict["c_body"]               = parse_result.c_str()
        hipKernelDict["f_body"]               = "".join(stprocedure.lines())
        hipKernelDict["kernel_args"] = []
        # device procedures take all C args as reference or pointer
        # kernel proceduers take all C args as value or (device) pointer
        for arg in kernelArgs:
            c_type = arg["c_type"]
            if not stprocedure.isKernelSubroutine() and not arg["is_array"]:
                c_type += "&"
            hipKernelDict["kernel_args"].append(c_type + " " + arg["name"])
        hipKernelDict["kernel_local_vars"]       = ["{0} {1}{2} {3}".format(a["c_type"],a["name"],a["c_size"],"= " + a["c_suffix"] if "c_suffix" in a else "") for a in cKernelLocalVars]
        hipKernelDict["interface_name"]         = kernelLauncherName
        hipKernelDict["interface_args"]         = hipKernelDict["kernel_args"]
        hipKernelDict["interface_comment"]      = ""
        hipKernelDict["interface_arg_names"]     = [arg["name"] for arg in kernelArgs]
        hipKernelDict["input_arrays"]           = inputArrays
        #inout_arrays_in_body                   = [name.lower for name in parse_result.inout_arrays_in_body()]
        #hipKernelDict["output_arrays"]       = [array for array in inputArrays if array.lower() in inout_arrays_in_body]
        hipKernelDict["output_arrays"]          = inputArrays
        hipKernelDict["kernel_call_arg_names"]    = hipKernelDict["interface_arg_names"] # TODO(05/12/21): Normally this information must be passed to other kernels
        hipKernelDict["cpu_kernel_call_arg_names"] = hipKernelDict["interface_arg_names"] 
        hipKernelDict["reductions"]            = []
        hipContext["kernels"].append(hipKernelDict)

        if generateLauncher:
            # Fortran interface with manual specification of kernel launch parameters
            fInterfaceDictManual = {}
            fInterfaceDictManual["c_name"]       = kernelLauncherName
            fInterfaceDictManual["f_name"]       = kernelLauncherName
            fInterfaceDictManual["test_comment"] = ["Fortran implementation:"] + stprocedure.code
            fInterfaceDictManual["type"]        = "subroutine"
            fInterfaceDictManual["args"]        = [
                {"type" : "type(dim3)", "qualifiers" : ["intent(in)"], "name" : "grid"},
                {"type" : "type(dim3)", "qualifiers" : ["intent(in)"], "name" : "block"},
                {"type" : "integer(c_int)", "qualifiers" : ["value", "intent(in)"], "name" : "sharedMem"},
                {"type" : "type(c_ptr)", "qualifiers" : ["value", "intent(in)"], "name" : "stream"},
            ]
            fInterfaceDictManual["args"]    += kernelArgs
            fInterfaceDictManual["argnames"] = [arg["name"] for arg in fInterfaceDictManual["args"]]
            fInterfaceDictManual["do_test"]   = True
            fContext["interfaces"].append(fInterfaceDictManual)
    
    utils.logging.logEnterFunction(LOG_PREFIX,"__update_context_from_device_procedures")

def _intrnl_writeFile(outfilePath,kind,content):
    utils.logging.logEnterFunction(LOG_PREFIX,"__writeFile")
    
    with open(outfilePath,"w") as outfile:
        outfile.write(content)
        msg = "created {}: ".format(kind).ljust(40) + outfilePath
        utils.logging.logInfo(LOG_PREFIX,"__writeFile",msg)
    
    utils.logging.logLeaveFunction(LOG_PREFIX,"__writeFile")


def _intrnl_createIncludesFromUsedModules(indexRecord,index):
    """Create include statement for a module's/subprogram's used modules that are present in the index."""
    used_modules  = [irecord["name"] for irecord in indexRecord["used_modules"]]
    includes     = []
    for iuse in index:
        if iuse["name"] in used_modules:
            includes.append(iuse["name"] + HIP_FILE_EXT)
    return includes
# API

def generate_gpufort_headers(outputDir):
    """Create the header files that all GPUFORT HIP kernels rely on."""
    utils.logging.logEnterFunction(LOG_PREFIX,"__renderTemplates",\
      {"outputDir": outputDir})
    
    gpufortHeaderFilePath = outputDir + "/gpufort.h"
    model.GpufortHeaderModel().generateFile(gpufortHeaderFilePath)
    msg = "created gpufort main header: ".ljust(40) + gpufortHeaderFilePath
    utils.logging.logInfo(LOG_PREFIX,"__renderTemplates",msg)
    
    gpufortReductionsHeaderFilePath = outputDir + "/gpufort_reductions.h"
    model.GpufortReductionsHeaderModel().generateFile(gpufortReductionsHeaderFilePath)
    msg = "created gpufort reductions header file: ".ljust(40) + gpufortReductionsHeaderFilePath
    utils.logging.logInfo(LOG_PREFIX,"__renderTemplates",msg)

    utils.logging.logLeaveFunction(LOG_PREFIX,"generate_gpufort_headers")


def generate_hip_files(stree,index,kernelsToConvertToHip,translationSourcePath,generateCode):
    """
    :param stree:        [inout] the scanner tree holds nodes that store the Fortran code lines of the kernels
    :param generateCode: generate code or just feed kernel signature information
                         back to the scanner tree.
    :note The signatures of the identified kernels must be fed back to the 
          scanner tree even when no kernel files are written.
    """
    global FORTRAN_MODULE_PREAMBLE
    global PRETTIFY_EMITTED_C_CODE
    global PRETTIFY_EMITTED_FORTRAN_CODE
    global CLANG_FORMAT_STYLE
    global FORTRAN_MODULE_FILE_EXT
    global HIP_FILE_EXT    
    global FORTRAN_MODULE_SUFFIX

    utils.logging.logEnterFunction(LOG_PREFIX,"generate_hip_files",\
      {"kernelsToConvertToHip":" ".join(kernelsToConvertToHip),\
       "translationSourcePath": translationSourcePath,\
       "generateCode":generateCode})
    def select_(kernel):
        nonlocal kernelsToConvertToHip
        if not len(kernelsToConvertToHip):
            return False
        else: 
            condition1 = not kernel._ignoreInS2STranslation
            condition2 = \
                    kernelsToConvertToHip[0] == "*" or\
                    kernel.minLineno() in kernelsToConvertToHip or\
                    kernel.kernelName() in kernelsToConvertToHip
            return condition1 and condition2
    def loop_kernelFilter_(child):
        return isinstance(child, scanner.STLoopKernel) and select_(child)
    def deviceProcedureFilter_(child):
        return type(child) is scanner.STProcedure and\
          child.mustBeAvailableOnDevice() and select_(child)

    fortranModuleFilepath = None
    mainHipFilepath       = None
    outputDir             = os.path.dirname(translationSourcePath)
   
    haveReductions     = False
    hipModuleFilenames = []
    fortranModules     = []
    programOrModules = stree.find_all(filter=lambda child: type(child) in [scanner.STProgram,scanner.STModule], recursively=False)
    for stmodule in programOrModules:
        # file names & paths
        moduleName        = stmodule.name.lower()
        hipModuleFilename = moduleName + HIP_FILE_EXT
        hipModuleFilenames.append(hipModuleFilename)
        hipModuleFilepath = outputDir+"/"+hipModuleFilename
        guard             = hipModuleFilename.replace(".","_").replace("-","_").upper() 
        # extract kernels
        loop_kernels     = stmodule.find_all(filter=loop_kernelFilter_, recursively=True)
        deviceProcedures = stmodule.find_all(filter=deviceProcedureFilter_, recursively=True)
        # TODO: Also extract derived types
        # derivedtypes = ....
        
        # TODO handle includes
        imodule = next((irecord for irecord in index if irecord["name"] == moduleName),None)
        if imodule == None:
            utils.logging.logError(LOG_PREFIX,"generate_hip_files","could not find record for module '{}'.".format(moduleName))
            sys.exit() # TODO add error code
        includes = _intrnl_createIncludesFromUsedModules(imodule,index)
        if len(loop_kernels) or len(deviceProcedures):
            utils.logging.logDebug2(LOG_PREFIX,"generate_hip_files",\
              "detected loop kernels: {}; detected device subprograms {}".format(\
              len(loop_kernels),len(deviceProcedures)))

            # Context for HIP implementation
            hipContext = {}
            hipContext["guard"]    = guard 
            hipContext["includes"] = [ "hip/hip_runtime.h", "hip/hip_complex.h" ] + includes
            hipContext["kernels"]  = []
            
            # Context for Fortran interface/implementation
            fContext = {}
            fContext["name"]     = moduleName + FORTRAN_MODULE_SUFFIX
            fContext["preamble"] = ""
            fContext["used"]       = ["hipfort"]
            if EMIT_CPU_IMPLEMENTATION:
                fContext["used"].append("hipfort_check")

            fContext["interfaces"] = []
            fContext["routines"]   = []
            
            _intrnl_update_context_from_loop_kernels(loop_kernels,index,hipContext,fContext)
            _intrnl_update_context_from_device_procedures(deviceProcedures,index,hipContext,fContext)
            
            if generateCode:
                haveReductions = haveReductions or hipContext["have_reductions"]

                _intrnl_writeFile(\
                   hipModuleFilepath,"HIP C++ implementation file",\
                   model.HipImplementationModel().generateCode(hipContext))
                if PRETTIFY_EMITTED_C_CODE:
                    utils.fileutils.prettifyCFile(hipModuleFilepath,CLANG_FORMAT_STYLE)
                if len(fContext["interfaces"]):
                   fortranModules.append(\
                     model.InterfaceModuleModel().generateCode(fContext))
        else:
            content = "\n".join(["#include \"{}\"".format(filename) for filename in includes])
            if len(content):
                content = "#ifndef {0}\n#define {0}\n{1}\n#endif // {0}".format(
                  guard,content)
            _intrnl_writeFile(\
               hipModuleFilepath,"HIP C++ implementation file",content)

    if generateCode:
        # main HIP file
        mainHipFilepath = translationSourcePath + HIP_FILE_EXT
        content = "\n".join(["#include \"{}\"".format(filename) for filename in hipModuleFilenames])
        _intrnl_writeFile(mainHipFilepath,"main HIP C++ file",content)

        # Fortran module file
        if len(fortranModules):
            fortranModuleFilepath = translationSourcePath + FORTRAN_MODULE_FILE_EXT
            content               = "\n".join(fortranModules)
            if len(FORTRAN_MODULE_PREAMBLE):
                content = FORTRAN_MODULE_PREAMBLE + "\n" + content
            _intrnl_writeFile(fortranModuleFilepath,"interface/testing module",content)
            if PRETTIFY_EMITTED_FORTRAN_CODE:
                utils.fileutils.prettifyFFile(fortranModuleFilepath)
    
    utils.logging.logLeaveFunction(LOG_PREFIX,"generate_hip_files")
    
    return fortranModuleFilepath, mainHipFilepath
