EMPTY_CPP_FILE_CONTEXT = {
  "prolog"          : "",
  "guard"           : "",
  "snippets"        : [],
  "includes"        : [],
  "includes_prolog" : "",
  "includes_epilog" : "",
  }
 
EMPTY_F03_MODULE_CONTEXT = {
  "name"                : "",
  "prolog"              : "",
  "used_modules"        : [],
  "rendered_types"      : [],
  "rendered_interfaces" : [],
  "rendered_routines"   : [], 
  }

def fort2hip_module_name(stnode):
    """Name of module file generated by fort2hip for module/program/procedure.
    """
    global FORTRAN_SUFFIX
    return "{}{}".format(stnode.tag().replace(":","_"),FORTRAN_MODULE_SUFFIX)

def parent_fort2hip_modules(stnode):
    if not stnode.parent == None and not isinstance(stnode.parent,scanner.STRoot):
        return [{ "name": fort2hip_module_name(stnode.parent.name.lower), "only": [] }]
    else:
        return []

def used_modules(stnode,inode):
   used_modules = [{"name": mod,"only:"[]} for mod in ["gpufort_array"]
   used_modules += inode["used_modules"] # local modules
   used_modules += parent_fort2hip_modules(stnode)  
   return used_modules

class DerivedTypesGenerator:
    def __init__(itypes,
                 itypes_local=[],
                 used_modules=[]):
        """Constructor.
        :param list itypes:       all derived type index entries for a given scope (including local derived types) 
        :param list itypes_local: all derived types in the local procedure or program scope. They must
                                  be recreated in the declaration list of the copy functions.
        :param list used_modules: The used modules that should appear as use statements in the declaration list of 
                                  the copy routines.
        """
        self.itypes         = itypes
        self.itypes_local   = itypes_local
        self.interop_suffix = "_interop"
        self.orig_var       = "orig_type",
        self.interop_var    = "interop_type",
    def render_derived_type_definitions_cpp():
        return [fort2hip.model.render_derived_types_cpp(types)]
    def render_derived_type_definitions_f03():
        snippets = [
                   fort2hip.model.render_derived_types_f03(self.itypes,
                                                           self.interop_suffix)
                   ]
        for itype in self.itypes_local:
            snippets.append("".join(itype["statements"]))
        return snippets 
    def render_derived_type_routines_f03():
        return [
               fort2hip.model.render_derived_type_size_bytes_routines_f03(self.itypes,
                                                                          self.interop_suffix,
                                                                          self.used_modules)
               fort2hip.model.render_derived_type_copy_scalars_routines_f03(self.itypes,
                                                                            self.interop_suffix,
                                                                            self.used_modules)
               fort2hip.model.render_derived_type_copy_array_member_routines_f03(self.itypes,
                                                                                 self.interop_suffix,
                                                                                 self.orig_var,
                                                                                 self.interop_var,
                                                                                 self.used_modules)
               ]
        
class KernelGeneratorBase:
    @staticmethod
    def strip_member_access(var_exprs):
        """Strip off member access parts from derived type member access expressions,
           e.g. 'a%b%c' becomes 'a'.
        """
        result = []
        return [var_expr.split("%",maxsplit=1)[0] for var_expr in var_exprs]
    @staticmethod
    def lookup_index_vars(var_exprs,
                           consumed_var_exprs=[]):
        """Search scope for index vars and remove corresponding 
           var expression from all_vars2 list."""
        ivars              = []
        for var_expr in var_exprs:
            ivar, _ = scoper.search_scope_for_variable(scope,var_expr,error_handling)
            ivars.append(ivar)
            consumed_var_exprs.append(var_expr)
        return ivars
    @staticmethod
    def lookup_index_entries_for_vars_in_kernel_body(scope,
                                                     all_vars,
                                                     reductions,
                                                     shared_vars,
                                                     local_vars,
                                                     error_handling=None):
        Lookup index variables
        """
        :param list all_vars: List of all variable expressions (var)
        :param list reductions: List of tuples pairing a reduction operation with the associated
                                 variable expressions
        :param list shared:     List of variable expressions that are shared by the workitems/threads in a workgroup/threadblock
        :param list local_vars: List of variable expressions that can be mapped to local variables per workitem/thread
        :param str error_handling: Emit error messages if set to 'strict'; else emit warning
        :note: Emits errors (or warning) if a variable in another list is not present in all_vars
        :note: Emits errors (or warning) if a reduction variable is part of a struct.
        :return: A tuple containing (in this order): global variables, reduced global variables, shared variables, local variables
                 as list of index entries. The reduced global variables have an extra field 'op' that
                 contains the reduction operation.
        """
        utils.logging.log_enter_function(LOG_PREFIX,"lookup_index_entries_for_variables")
    
        consumed  = []
        ilocal_vars  = lookup_index_vars(self._strip_member_access_(local_vars),
                                         consumed)
        ishared_vars = lookup_index_vars(self._strip_member_access_(shared_vars),
                                          consumed)
        all_vars2 = [v for v in strip_member_access(all_vars) if not v in consumed]
     
        rglobal_reduced_vars = []
        iglobal_vars         = []
    
        for reduction_op,var_exprs in reductions.items():
            for var_expr in var_exprs:
                if "%" in var_expr:
                   if error_handling=="strict":
                       pass # TODO error
                   else:
                       pass # TOOD warn
                else:
                   ivar, _ = scoper.search_scope_for_variable(scope,var_expr,error_handling)
                   rvar    = copy.deepcopy(ivar)
                   rvar["op"] = reduction_op
                   global_reduced_vars.append(rvar)
                try:
                    all_vars2.remove(var_expr)
                except:
                    pass # TODO error
        for var_expr in all_vars2:
            ivar, _ = scoper.search_scope_for_variable(scope,var_expr,error_handling)
            global_vars.append(ivar)
    
        utils.logging.log_leave_function(LOG_PREFIX,"lookup_index_entries_for_variables")
        return iglobal_vars, rglobal_reduced_vars, ishared_vars, ilocal_vars
    
    def _create_kernel_base_context(self,
                                    kernel_name,
                                    c_body)
        global GET_LAUNCH_BOUNDS
        launch_bounds = GET_LAUNCH_BOUNDS(kernel_name)
        return {
               "name"          : kernel_name,
               "launch_bounds" : "" if launch_bounds == None else launch_bounds,
               "c_body"        : c_body,
               }
    def _create_kernel_launcher_base_context(self,
                                             kernel_name,
                                             kind,
                                             problem_size,
                                             debug_output):
        return {
               "kind"         : kind,
               "name"         : "_".join(["launch",kernel_name,kind]),
               "used_modules" : [],
               "problem_size" : problem_size,
               "debug_output" : debug_output,
               }
    def render_kernel_cpp(self):
        """:return: Snippets created by this routine.
        :note: to be defined by subclass.
        """
        return []
    def render_kernel_launch_routine_cpp(self):
        """:return: Snippets created by this routine.
        :note: to be defined by subclass."""
        return []
    def render_kernel_launch_interface_f03(self):
        """:return: Snippets created by this routine.
        :note: to be defined by subclass."""
        return []
    def render_kernel_launch_routine_f03(self):
        """:return: Snippets created by this routine.
        :note: to be defined by subclass.
        """
        return []

class HipKernelGeneratorBase(KernelGeneratorBase):
    def __init__(self,
                 kernel_name,
                 scope,
                 error_handling=None):
        self.kernel_name    = kernel_name
        self.scope          = scope
        self.error_handling = error_handling
        # to be set by subclass:
        self.c_body                = ""
        self.all_vars              = []
        self.global_reductions     = []
        self.shared_vars           = []
        self.local_vars            = []
    def _create_loop_kernel_context():
        kernel = self._create_kernel_base_context(self,
                                                  kernel_name,
                                                  c_body)
        kernel["global_vars"],
        kernel["global_reduced_vars"],
        kernel["shared_vars"],
        kernel["local_vars"] = lookup_index_entries_for_vars_in_kernel_body(scope,
                                                                            self.all_vars,
                                                                            self.global_reductions,
                                                                            self.shared_vars,
                                                                            self.local_vars,
                                                                            error_handling)
        return kernel
    def _create_kernel_launcher_base_context(self,
                                             kernel_name,
                                             kind,
                                             problem_size,
                                             debug_output):
        """Create base context for kernel launcher code generation."""
        return {
               "kind"         : kind,
               "name"         : "_".join(["launch",kernel_name,kind]),
               "used_modules" : [],
               "problem_size" : problem_size,
               "debug_output" : debug_output,
               }
    def _create_hip_kernel_launcher_context(self,
                                            kernel_name,
                                            kind,
                                            debug_output,
                                            problem_size,
                                            grid  = [],
                                            block = []):
        """Create context for HIP kernel launcher code generation.
        :param str kind:   
        :param list grid:  d-dimensional list of string expressions for the grid dimensions
        :param list block: d-dimensional list of string expressions for the block dimensions
        :note: Parameters grid & block are only required if the kind is set to "hip".
        """
        kernel_launcher = create_kernel_launcher_base_context(kernel_name,
                                                              kind,
                                                              problem_size,
                                                              debug_output)
        if kind == "hip":
            kernel_launcher["grid"]  = grid
            kernel_launcher["block"] = block
        return kernel_launcher
    def _create_cpu_kernel_launcher_context(self,
                                           kernel_name):
        # for launcher interface
        kernel_launcher = {}
        kernel_launcher["name"] = "_".join(["launch",kernel_name,"cpu"])
        kernel_launcher["debug_output"]  = True
        kernel_launcher["kind"]          = "cpu"
        kernel_launcher["used_modules"]  = []
        return kernel_launcher

# derived classes
class HipKernelGenerator4LoopNest(HipKernelGeneratorBase):
    def __init__(self,
                 kernel_name,
                 ttloopkernel,
                 scope,
                 fortran_snippet=None,
                 error_handling=None):
        HipKernelGeneratorBase.__init__(self,
                                        kernel_name,
                                        scope,
                                        fortran_snippet,
                                        error_handling)
        self.all_vars          = ttloopkernel.vars_in_body()
        self.global_reductions = ttloopkernel.global_reductions()
        self.shared_vars       = ttloopkernel.gang_team_shared_vars()
        self.local_vars        = ttloopkernel.local_scalars()

class HipKernelGenerator4CufKernel(HipKernelGeneratorBase):
    def __init__(self,
                 kernel_name,
                 ttprocedure,
                 iprocedure,
                 scope,
                 fortran_snippet=None,
                 error_handling=None):
        HipKernelGeneratorBase.__init__(self,
                                        kernel_name,
                                        scope,
                                        fortran_snippet,
                                        error_handling)
        all_var_exprs             = self._strip_member_access(ttprocedure.vars_in_body()) # in the body, there might be variables present from used modules
        all_local_and_shared_vars = [varexpr for varexpr in varexprs if varexpr not in iprocedure["dummy_args"]]
        #ordered_varnames          = iprocedure["dummy_args"] + all_local_and_shared_vars
        self.global_reductions = []
        self.shared_vars       =  

#class HipKernelGenerator4AcceleratorRoutine(HipKernelGeneratorBase):
#    def __init__(self,
#                 ttloopkernel,
#                 kernel_name,
#                 scope,
#                 error_handling=None):
