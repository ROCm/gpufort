# SPDX-License-Identifier: MIT
# Copyright (c) 2021 Advanced Micro Devices, Inc. All rights reserved.
import os
import copy
import logging

import addtoplevelpath
import translator.translator as translator
import indexer.indexer as indexer
import indexer.scoper as scoper
import scanner.scanner as scanner
import utils.logging
import utils.fileutils

import fort2x.filegen

fort2x_dir = os.path.dirname(__file__)
exec(open(os.path.join(fort2x_dir,"fort2x_options.py.in")).read())

class CodeGenerator:
    """Generate code from a scanner tree and index information.
    """
    def __init__(self,
                 stree,
                 index,
                 kernels_to_convert      = ["*"],
                 fortran_module_preamble = FORTAN_MODULE_PREAMBLE,
                 cpp_file_preamble       = CPP_FILE_PREAMBLE,
                 fortran_module_suffix   = FORTRAN_MODULE_SUFFIX,
                 fortran_module_file_ext = FORTRAN_MODULE_FILE_EXT,
                 cpp_file_ext            = CPP_FILE_EXT):
        self.stree                   = stree  
        self.index                   = index
        self.kernels_to_convert      = kernels_to_convert 
        self.fortran_module_suffix   = fortran_module_suffix
        self.fortran_module_file_ext = fortran_module_file_ext
        self.cpp_file_ext            = cpp_file_ext           
        #
        self.file_contexts  = []
    def __consider_kernel(self,
                          stkernel):
        if not len(self.kernels_to_convert):
            return False
        else: 
            condition1 = not stkernel.ignore_in_s2s_translation
            condition2 = \
                    self.kernels_to_convert[0] == "*" or\
                    stkernel.min_lineno() in self.kernels_to_convert or\
                    stkernel.kernel_name() in self.kernels_to_convert
            return condition1 and condition2
    def __loop_kernel_filter(self,
                             child):
        return isinstance(child, scanner.STLoopKernel) and self._consider_kernel(child)
    def __device_procedure_filter(self,
                                 stprocedure):
        #  TODO distinguish between device routines and global routines
        return type(stprocedure) is scanner.STProcedure and\
               stprocedure.must_be_available_on_device() and consider_kernel(stprocedure)

    def _fort2x_module_name(self,
                            stnode):
        global FORTRAN_MODULE_PREAMBLE
        """Name of module file generated by fort2x for module/program/procedure."""
        return "{}{}".format(stnode.tag().replace(":","_"))
    def _parent_fort2x_modules(self,
                               stnode):
        if not stnode.parent == None and not isinstance(stnode.parent, scanner.STRoot):
            return [{ "name": self.fort2x_module_name(stnode.parent), "only": [] }]
        else:
            return []
    def _used_modules(self,
                      stnode,
                      inode):
       used_modules = [{"name": mod,"only:"[]} for mod in [
                                                          "iso_c_binding",
                                                          "hipfort",
                                                          "gpufort_array",
                                                          ]]
       used_modules += inode["used_modules"] # local modules
       used_modules += self.parent_fort2x_modules(stnode)  
       return used_modules
    def _render_derived_types(self,
                              itypes,
                              used_modules,
                              cpp_filegen,
                              fortran_modulegen):
        assert False, "Must be implemented by subclass!"
    def _render_loop_nest(self,
                            stkernel,
                            cpp_filegen,
                            fortran_modulegen):
        assert False, "Must be implemented by subclass!"
    def _render_device_procedure(self,
                                 stnode,
                                 cpp_filegen,
                                 fortran_modulegen):
        assert False, "Must be implemented by subclass!"
    def traverse_scanner_tree(self):
        """Traverse scanner tree and call subcalls render methods.
        """
        file_contexts     = []
        cpp_filegen       = None
        fortran_modulegen = None
        def traverse_node_(stnode)
            """Traverse the scanner tree and emit code generation context.
            """
            nonlocal cpp_filegens
            nonlocal fortran_modulegens
            nonlocal cpp_filegen
            nonlocal fortran_modulegen
            # main
            if isinstance(stnode,scanner.STRoot):
                pass
            elif self.__loop_kernel_filter(stnode):
                self._render_loop_nest(stnode,
                                         cpp_filegen,
                                         fortran_modulegen)
            elif self.__device_procedure_filter(stnode): # handle before STProcedure (without attributes) is handled
                inode = next((irecord for irecord in self.index if irecord["name"] == stnode_name),None)
                self._render_device_procedure(stnode,
                                              inode,
                                              cpp_filegen,
                                              fortran_modulegen)
            elif isinstance(stnode,
                           (scanner.STProgram,
                           scanner.STModule,
                           scanner.STProcedure)):
                stnode_name      = stnode.name.lower()
                stnode_is_module = isinstance(stnode,STModule)
                inode = next((irecord for irecord in self.index if irecord["name"] == stnode_name),None)
                if inode == None:
                    utils.logging.log_error(LOG_PREFIX,\
                                            "traverse_scanner_tree",\
                                            "could not find self.index record for scanner tree node '{}'.".format(stnode_name))
                    sys.exit() # TODO add error code
    
                itypes_local = inode["types"] # local types
                used_modules = used_modules(stnode,inode)
 
                # no loop kernels in parent but device routines or global kernels
                stnode_fort2x_module_name = fort2x_module_name(stnode)
                cpp_file_name             = "{}{}".format(stnode_fort2x_module_name,self.cpp_file_ext)
                guard                     = "_{}{}_".format("".join(e for e in cpp_file_name if e.isalnum() else "_")).upper()
                
                cpp_filegen = filegen.CppFileGenerator(guard,
                                                       self.cpp_file_preamble)
                fortran_modulegen = filegen.FortranModuleGenerator(stnode_fort2x_module_name,
                                                                   self.fortran_module_preamble)
                fortran_modulegen.used_modules = used_modules(stnode,inode)

                if stnode.parent == scanner.STRoot:
                    self._render_derived_types(itypes,
                                               local_used_modules,
                                               cpp_filegen,
                                               fortran_modulegen)
                for stchildnode in stnode.children:
                    traverse_node_(stchildnode)
                file_contexts.append((
                                     stnode_is_module,
                                     cpp_file_name,
                                     fortran_modulegen,
                                     cpp_filegen
                                     ))
            return file_contexts
    def generate_code(self):
        # One file per cpp_filegen
        # and one combined file that does all the includes
        fortran_output = "" 
        cpp_files      = []
        if not len(self.file_contexts):
            self.file_contexts = self.traverse_scanner_tree()
        for tup in self.file_contexts:             
            stnode_is_module,\
            cpp_file_name,\
            fortran_modulegen,\
            cpp_filegen = tup
            fortran_output += fortran_modulegen.generate_code()
            
            cpp_files.append((cpp_file_name,
                              cpp_filegen.generate_code())
