# SPDX-License-Identifier: MIT
# Copyright (c) 2021 Advanced Micro Devices, Inc. All rights reserved.
import os
import copy
import logging

import addtoplevelpath
import translator.translator as translator
import indexer.indexer as indexer
import indexer.scoper as scoper
import scanner.scanner as scanner
import utils.logging
import utils.fileutils

import fort2x.filegen

fort2x_dir = os.path.dirname(__file__)
exec(open(os.path.join(fort2x_dir,"fort2x_options.py.in")).read())

class CodeGenerator:
    def __init__(self,
                 stree,
                 index,
                 kernels_to_convert=["*"]):
        global
        self.stree              = stree
        self.index              = index
        self.kernels_to_convert = kernels_to_convert 
        self.cppfile_prolog     = 
    def _consider_kernel(self,
                         stkernel):
        nonlocal kernels_to_convert
        if not len(kernels_to_convert):
            return False
        else: 
            condition1 = not stkernel.ignore_in_s2s_translation
            condition2 = \
                    kernels_to_convert[0] == "*" or\
                    stkernel.min_lineno() in kernels_to_convert or\
                    stkernel.kernel_name() in kernels_to_convert
            return condition1 and condition2
    def _loop_kernel_filter(self,
                            child,
                            kernels_to_convert=["*"]):
        return isinstance(child, scanner.STLoopKernel) and self._consider_kernel(child)
    #  TODO distinguish between device routines and global routines
    def _device_procedure_filter(self,
                                 stprocedure,
                                 kernels_to_convert=["*"]):
        return type(stprocedure) is scanner.STProcedure and\
               stprocedure.must_be_available_on_device() and consider_kernel(stprocedure)

    def _fort2x_module_name(self,
                            stnode):
        """Name of module file generated by fort2x for module/program/procedure.
        """
        assert False, "To be implemented by subclass"
    def _parent_fort2x_modules(self,
                               stnode):
        if not stnode.parent == None and not isinstance(stnode.parent, scanner.STRoot):
            return [{ "name": self.fort2x_module_name(stnode.parent), "only": [] }]
        else:
            return []
    def _used_modules(self,
                      stnode,
                      inode):
       used_modules = [{"name": mod,"only:"[]} for mod in ["gpufort_array"]
       used_modules += inode["used_modules"] # local modules
       used_modules += self.parent_fort2x_modules(stnode)  
       return used_modules
    def _render_loop_kernel(self,
                            stkernel,
                            cppfilegen,
                            f03filegen):
        utils.logging.log_enter_function(LOG_PREFIX,"self.__render_loop_kernel")
    
        ttloopkernel = stkernel.parse_result
        scope        = scoper.create_scope(stkernel.parent_tag)
 
        utils.logging.log_debug3(LOG_PREFIX,"_intrnl_update_context_from_loop_kernels","parse result:\n```"+ttloopkernel.c_str().rstrip()+"\n```")
    
        # general
        kernel_name          = stkernel.kernel_name()
        kernel_launcher_name = stkernel.kernel_launcher_name()
    
        kernel_context = create_loop_kernel_context(stkernel.kernel_name(),
                                                    ttloopkernel,
                                                    scope,
                                                    error_handling):
    
    
        hip_context["have_reductions"] = False # |= len(reduction_ops)
    
    def _render_device_procedure(stnode,
                                 current_cppfilegen,
                                 current_f03filegen):
        pass
    def traverse_scanner_tree(self):
        cpp_file_contexts   = []
        f03_module_contexts = []
        current_cppfilegen  = None
        current_f03filegen  = None
        def traverse_node_(stnode)
            """Traverse the scanner tree and emit code generation context.
            """
            nonlocal cpp_file_contexts
            nonlocal f03_file_contexts
            nonlocal current_cppfilegen
            nonlocal current_f03filegen
            # main
            if isinstance(stnode,scanner.STRoot):
                pass
            elif loop_kernel_filter(stnode):
                self._render_loop_kernel(stnode,
                                         current_cppfilegen,
                                         current_f03filegen)
            elif device_procedure_filter(stnode): # handle before STProcedure (without attributes) is handled
                inode = next((irecord for irecord in self.index if irecord["name"] == stnode_name),None)
                self._render_device_procedure(stnode,
                                              inode,
                                              current_cppfilegen,
                                              current_f03filegen)
            elif isinstance(stnode,
                           (scanner.STProgram,
                           scanner.STModule,
                           scanner.STProcedure)):
                stnode_name      = stnode.name.lower()
                stnode_is_module = isinstance(stnode,STModule)
                stnode_fort2x_module_name = fort2x_module_name(stnode)
                inode = next((irecord for irecord in self.index if irecord["name"] == stnode_name),None)
                if inode == None:
                    utils.logging.log_error(LOG_PREFIX,\
                                            "traverse_scanner_tree",\
                                            "could not find self.index record for scanner tree node '{}'.".format(stnode_name))
                    sys.exit() # TODO add error code
    
                itypes_local       = inode["types"] # local types
                local_used_modules = used_modules(stnode,inode)
                # derived_type_snippets = render_types(itypes)
                if stnode_is_module:
                    module_used_modules = local_used_modules
                # no loop kernels in parent but device routines or global kernels
                current_cppfilegen = filegen.CppFileGenerator(
    
                current_f03filegen = filegen.FortranModuleGenerator(stnode_fort2x_module_name,
                                                                    FORTRAN_MODULE_PREAMBLE):
                for stchildnode in stnode.children:
                   traverse_node_(stchildnode,
                                  self.index,
                                  kernels_to_convert)
                cpp_file_contexts.append(current_cppfilegen)
                f03_file_contexts.append(current_f03filegen)
            return cpp_file_contexts, f03_file_contexts
    def generate_code(self):
        pass 
