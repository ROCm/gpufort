# SPDX-License-Identifier: MIT
# Copyright (c) 2021 Advanced Micro Devices, Inc. All rights reserved.
import os
import copy
import logging

import addtoplevelpath
import translator.translator as translator
import indexer.indexer as indexer
import indexer.scoper as scoper
import scanner.scanner as scanner
import utils.logging
import utils.fileutils

import fort2x.filegen

fort2x_dir = os.path.dirname(__file__)
exec(open(os.path.join(fort2x_dir,"fort2x_options.py.in")).read())

# TODO has side effects as generated code
# might be partially used within the original file again

class CodeGenerator:
    """Modify a scanner tree and generate Fortran and C/C++ code from it."""
    def __init__(self,
                 stree,
                 index,
                 **kwargs):
        r"""Constructor.
        :param stree: Scanner tree created by GPUFORT's scanner component.
        :param index: Index data structure created by GPUFORT's indexer component.
        
        :param \*\*kwargs: See below.
        
        :Keyword Arguments:

        * *kernels_to_convert* (`list`):
            Filter the kernels to convert to C++ by their name or their id. Pass ['*'] 
            to extract all kernels [default: ['*']]
        * *cpp_file_preamble* (`str`):
            A preamble to write at the top of the files produced by the C++ generators
            that can be created by this class [default: fort2x.CPP_FILE_PREAMBLE].
        * *cpp_file_ext* (`str`):
            File extension for the generated C++ files [default: fort2x.CPP_FILE_EXT].
        """
        self.stree = stree  
        self.index = index
        utils.kwargs.set_from_kwargs(self,"kernels_to_convert",["*"],**kwargs)
        utils.kwargs.set_from_kwargs(self,"cpp_file_preamble",CPP_FILE_PREAMBLE,**kwargs)
        utils.kwargs.set_from_kwargs(self,"cpp_file_ext",CPP_FILE_EXT,**kwargs)
        utils.kwargs.set_from_kwargs(self,"default_modules",DEFAULT_MODULES,**kwargs)
        utils.kwargs.set_from_kwargs(self,"default_includes",DEFAULT_INCLUDES,**kwargs)
        # must be adjusted by subclasses
        #
        self.main_filegen        = fort2x.filegen.CppFileGenerator("",self.cpp_file_preamble)
        self.filegens_per_module = []
        self._traversed          = False
    @staticmethod
    def _indent(text,indent):
        return "\n".join([indent+line for line in text.split("\n")])
    @staticmethod
    def _create_cpp_guard(cpp_file_name):
        result = ""
        for c in cpp_file_name:
            result += c.upper() if c.isalnum() else "_"
        return "{}".format(result) 
    @staticmethod
    def _fort2x_node_name(stnode):
        """Name of module file generated by fort2x for module/program/procedure."""
        return "{}{}".format(stnode.tag().replace(":","_"))
    def _create_includes_from_used_modules(self,
                                            irecord):
        """Create include statement for a module's/subprogram's used modules that are present in the self.index."""
        used_modules  = [irecord["name"] for irecord in irecord["used_modules"]]
        includes      = []
        for imodule in self.index:
            if imodule["name"] in used_modules:
                includes.append("".join([imodule["name"],self.cpp_file_ext]))
        return includes
    def _consider_kernel(self,
                          stkernel):
        if not len(self.kernels_to_convert):
            return False
        else: 
            condition1 = not stkernel.ignore_in_s2s_translation
            condition2 = \
                    self.kernels_to_convert[0] == "*" or\
                    stkernel.min_lineno() in self.kernels_to_convert or\
                    stkernel.kernel_name() in self.kernels_to_convert
            return condition1 and condition2
    def _loop_kernel_filter(self,
                             child):
        return isinstance(child, scanner.STLoopKernel) and self._consider_kernel(child)
    def _device_procedure_filter(self,
                                  stprocedure):
        #  TODO distinguish between device routines and global routines
        return type(stprocedure) is scanner.STProcedure and\
               stprocedure.must_be_available_on_device() and consider_kernel(stprocedure)
    def _make_module_dicts(self,module_names):
       return [{"name" : mod,"only" : []} for mod in module_names]
    def _render_derived_types(self,
                              itypes,
                              used_modules,
                              cpp_filegen,
                              fortran_modulegen):
        assert False, "Must be implemented by subclass!"
    def _render_loop_nest(self,
                          stkernel,
                          cpp_filegen,
                          fortran_modulegen):
        assert False, "Must be implemented by subclass!"
    def _render_device_procedure(self,
                                 stnode,
                                 cpp_filegen,
                                 fortran_modulegen):
        assert False, "Must be implemented by subclass!"
    def _modify_stcontainer(self,
                            stcontainer,
                            fortran_modulegen):
        """This routine performs the following operations:
        - Add default GPUFORT use statements to the container node.
        - Add rendered derived types and interfaces after the declaration section of the
              container node.
        - Add rendered routines before end statement.
        - Add "contains" (if not present) to end statement.
        """
        # add GPUFORT use statements
        indent = stnode.first_line_indent()+" "*2
        if len(fortran_modulegen.rendered_types):
            for mod in self.default_modules:
                stnode.add_to_epilog("{}use {}".format(indent,mod),prepend=True)
        # types and interfaces
        stlastdeclnode = stnode.last_entry_in_decl_list()
        for snippet in fortran_modulegen.rendered_types:
            stlastdeclnode.add_to_epilog(_indent(snippet))
        for snippet in fortran_modulegen.rendered_interfaces:
            stlastdeclnode.add_to_epilog(_indent(snippet))
        # routines
        stend      = stnode.end_statement() 
        #add_to_prolog(self,line,prepend=False):
        for snippet in fortran_modulegen.rendered_routines:
            stend.add_to_prolog(CodeGenerator._indent(snippet))
        if not stnode.has_contains_statement():
            stend.add_to_prolog(CodeGenerator._indent("contains"),prepend=True)   
    def _traverse_scanner_tree(self):
        """Traverse scanner tree and call subcalls render methods.
        """
        cpp_filegen       = None
        fortran_modulegen = None
        def traverse_node_(stnode):
            """Traverse the scanner tree and emit code generation context.
            """
            nonlocal cpp_filegen
            nonlocal fortran_modulegen
            # main
            if isinstance(stnode,scanner.STRoot):
                pass
            elif self._loop_kernel_filter(stnode):
                self._render_loop_nest(stnode,
                                       cpp_filegen,
                                       fortran_modulegen)
            elif self._device_procedure_filter(stnode): # handle before STProcedure (without attributes) is handled
                inode = next((irecord for irecord in self.index if irecord["name"] == stnode_name),None)
                self._render_device_procedure(stnode,
                                              inode,
                                              cpp_filegen,
                                              fortran_modulegen)
            elif isinstance(stnode,
                           (scanner.STProgram,
                           scanner.STModule,
                           scanner.STProcedure)):
                stnode_name      = stnode.name.lower()
                # no loop kernels in parent but device routines or global kernels
                if stnode.parent == scanner.STRoot:
                    inode = next((irecord for irecord in self.index if irecord["name"] == stnode_name),None)
                    cpp_file_name = "{}{}".format(CodeGenerator._fort2x_node_name(stnode),
                                                  self.cpp_file_ext)
                    cpp_filegen = fort2x.filegen.CppFileGenerator(CodeGenerator._create_cpp_guard(cpp_file_name),
                                                                  self.cpp_file_preamble)
                    fortran_modulegen = fort2x.filegen.FortranModuleGenerator("",
                                                                              self.fortran_preamble)
                    fortran_modulegen.default_modules = self._make_module_dicts(self.default_modules)
                else:
                    assert isinstance(stnode,STProcedure)
                    inode = stnode.index_record    
                if inode == None:
                    utils.logging.log_error(LOG_PREFIX,\
                                            "traverse_scanner_tree",\
                                            "could not find self.index record for scanner tree node '{}'.".format(stnode_name))
                    sys.exit() # TODO add error code
                cpp_filegen.includes += self._create_includes_from_used_modules(inode)
                # types
                itypes = inode["types"]
                if len(itypes) and stnode.parent == scanner.STRoot:
                    self._render_derived_types(itypes,
                                               local_used_modules,
                                               cpp_filegen,
                                               fortran_modulegen)
                elif len(itypes):
                    utils.logging.log_warning(LOG_PREFIX,\
                                              "traverse_scanner_tree",\
                                              "won't create interoperable type for derived types declared in procedure '{}'.".format(stnode_name))
                
                # traverse children
                for stchildnode in stnode.children:
                    traverse_node_(stchildnode)

                if isinstance(stnode.parent,(scanner.STRoot,scanner.STModule)):
                    if fortran_modulegen.stores_any_code():
                        self._modify_stcontainer(stnode,fortran_modulegen)
               
                if isinstance(stnode,STModule):
                    self.main_filegen.includes.append(cpp_file_name)
                    self.filegens_per_module.append((
                                                   cpp_file_name,
                                                   cpp_filegen,
                                                   ))
                else:
                    self.main_filegen.merge(cpp_filegen)
        traverse_node_(self.stree)
        traversed = True
    def traverse_and_create_cpp_generators(self,
                                                guard="MY_GUARD_H"):
        """Generates one C++ file ('main C++ file') for the non-module program units
        in the Fortran file plus one C++ file per each of the modules in the Fortran 
        file. The main C++ file includes the per-module C++ files.
        :param str guard: Compilation guard macro for the C++ file.
        :note: Always creates the main C++ file even if no code was generated
               to always have the same output.
        :return: One file generator for the main C++ file plus the file generators
                 for the C++ files per module as list of tuples (file name, file generator).
        """
        if not self._traversed:
            self._traverse_scanner_tree()
        # main file
        self.main_filegen.guard = guard 
        return self.main_filegen, self.filegens_per_module 
    def traverse_and_generate_cpp_files(self,
                                        main_cpp_file_path):
        """Writes one C++ file ('main C++ file') for the non-module program units
        in the Fortran file plus one C++ file per each of the modules in the file.
        The main C++ file includes the per-module C++ files.
        :param str main_cpp_file_path: File name for the main C++ file.
        :note: Always creates the main C++ file even if no code was generated
               to always have the same output.
        """
        output_dir         = os.path.dirname(main_cpp_file_path)
        main_cpp_file_name = os.path.basename(main_cpp_file_path)
        if not self._traversed:
            self.cpp_file_contexts = self._traverse_scanner_tree()
        # main file
        self.main_filegen.guard = CodeGenerator._create_cpp_guard(main_cpp_file_name)
        self.main_filegen.generate_file(main_cpp_file_path)
        # 
        for pair in self.filegens_per_module:
            cpp_file_name, cpp_filegen = pair
            cpp_filegen.generate_file(os.path.join(output_dir,cpp_file_name))
