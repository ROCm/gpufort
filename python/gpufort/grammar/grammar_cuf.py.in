# SPDX-License-Identifier: MIT
# Copyright (c) 2020-2022 Advanced Micro Devices, Inc. All rights reserved.
#!/usr/bin/env python3
#from grammar_f03 import *

## CUDA Fortran specific
## CUF LoopNest loop directive
cuf_kernel_do_auto = Literal("*")
cuf_kernel_do_dim3 = LPAR + delimitedList(arithmetic_logical_expression) + RPAR

cuf_kernel_do_arg_grid  = cuf_kernel_do_auto | cuf_kernel_do_dim3 | rvalue
cuf_kernel_do_arg_block = grid.copy()
cuf_kernel_do_arg_sharedmem = Optional(arithmetic_logical_expression,default=None) 
cuf_kernel_do_arg_stream  = Optional(
   Regex(r"(stream\s*=)?",re.IGNORECASE).suppress() 
   + arithmetic_logical_expression
   ,default=None
)

cuf_kernel_do_launch_params = (
  Group(Suppress("<<<") + 
  Optional(grid,default="*")  + COMMA 
  + Optional(thread_block,default="*") + OPTCOMMA 
  + Optional(pyparsing_common.integer,default=0) + OPTCOMMA 
  + stream_arg + OPTCOMMA
  + Suppress(">>>")
) # grid,thread_block,shmem,stream

cuf_kernel_do_arg_num_loops = Optional(LPAR + arithmetic_logical_expression + RPAR,default=None)

# directives
cuf_kernel_do =(
  PRAGMA + Regex(r"cuf\s*kernel\s*do*",re.IGNORECASE) 
  + cuf_kernel_do_arg_num_loops 
  + Optional(cuf_kernel_do_launch_params,default=None)
)

# scanner/analysis
ALLOCATE   = Regex(r"\ballocate\b",re.IGNORECASE).suppress()
ALLOCATED  = Regex(r"\ballocatedb",re.IGNORECASE).suppress()
DEALLOCATE = Regex(r"\bdeallocate\b",re.IGNORECASE).suppress()

allocated = ALLOCATED  + LPAR + rvalue     + RPAR
memcpy = rvalue + EQ + rvalue + ( Suppress(";") | LineEnd() )
NOT = CASELESS_LITERAL(".NOT.").suppress() 
non_zero_check = rvalue + oneOf("/ = .ne.",caseless = CASELESS).suppress() + Suppress("0")
pointer_assignment = rvalue + PEQ + rvalue

# kernelextractor/analysis
CUDAMALLOC,CUDAMEMCPY,CUDAMEMCPYASYNC,CUDAMEMCPY2D,CUDAMEMCPY2DASYNC,CUDAMEMCPY3D,CUDAMEMCPY3DASYNC = makeCaselessLiteral(\
  "cudamalloc,cudamemcpy,cudamemcpyasync,cudamemcpy2d,cudamemcpy2dasync,cudamemcpy3d,cudamemcpy3dasync")
# dest,count # kind is inferred from dest and src
cuf_cudamalloc = CUDAMALLOC + LPAR + identifier + COMMA + arithmetic_expression + RPAR
# dest,src,count,[,stream] # kind is inferred from dest and src
cuda_memcpy_type     = oneOf("cudamemcpyhosttohost cudamemcpyhosttodevice cudamemcpydevicetohost cudamemcpydevicetodevice",caseless=CASELESS)
cuda_memcpy_args_ext  = Optional(COMMA + cuda_memcpy_type,default=None) + Optional(COMMA + stream_arg,default=None)
cuf_cudamemcpy_args  = separatedSequence([rvalue,rvalue,arithmetic_expression]) + cuda_memcpy_args_ext
cuf_cudamemcpy      = ( CUDAMEMCPYASYNC | CUDAMEMCPY ) + LPAR + cuf_cudamemcpy_args + RPAR
# dest,dpitch(count),src,spitch(count),width(count),height(count)[,stream] # kind is inferred from dest and src
cuf_cudamemcpy2d_args  = separatedSequence([rvalue,arithmetic_expression,rvalue,arithmetic_expression,arithmetic_expression,arithmetic_expression]) + cuda_memcpy_args_ext
cuf_cudamemcpy2D      = ( CUDAMEMCPY2D | CUDAMEMCPY2DASYNC )  + LPAR + cuf_cudamemcpy2d_args + RPAR
# dest,dpitch(count),src,spitch(count),width(count),height(count),depth(count),[,stream] # kind is inferred from dest and src
cuf_cudamemcpy3d_args  = separatedSequence([rvalue,arithmetic_expression,rvalue,arithmetic_expression,arithmetic_expression,arithmetic_expression,arithmetic_expression]) + cuda_memcpy_args_ext
cuf_cudamemcpy3D      = ( CUDAMEMCPY3D | CUDAMEMCPY3DASYNC ) + LPAR + cuf_cudamemcpy3d_args + RPAR
cuf_cudamemcpy_variant = cuf_cudamemcpy | cuf_cudamemcpy2D | cuf_cudamemcpy3D
# cublas/analysis
cublas_operation_type = Regex("'[NTCntc]'")#.setParseAction(lambda tokens: "hipblas_op_"+tokens[0].strip("'").upper())
#cublas_arglist       = Group(delimitedList(cublas_operation_type | rvalue))
# TODO: Explicitly scan for ttrvalues in cublas_arglist's arithmetic_logical_expression when transforming host code
cublas_arglist   = Group(delimitedList(cublas_operation_type | arithmetic_logical_expression)) 
cuf_cublas_call  = CASELESS_LITERAL("cublas").suppress() + identifier + LPAR + cublas_arglist + RPAR  # emits 2 tokens

# anchors; TODO(Dominic): Can be simplified
cudaAPI        = Regex(r"\b").suppress() + Combine(oneOf("cublas cufft cusparse cuda cusolver",caseless=CASELESS) + identifier)
# cuda_lib_call is used to detect any CUDA library calls;
# they are then analysed and transformed using more specific constructs
cuda_lib_call = ((identifier + EQ) | CALL).suppress() + cudaAPI + LPAR + Optional(tensor_access_args,default=None) + RPAR # emits 3 tokens -> *,
