# SPDX-License-Identifier: MIT
# Copyright (c) 2020-2022 Advanced Micro Devices, Inc. All rights reserved.
LPAR,RPAR = map(Suppress, "()")
EQ,ELEM,COMMA,DOT,UNDERSCORE = map(Suppress, "=%,._")
PEQ=Suppress("=>")
COLONS=Suppress("::")
OPTCOMMA = Optional(COMMA)

CALL,ATTRIBUTES,LEN,KIND,DIM = makeCaselessLiteral("call,attributes,len,kind,dim",suppress=True)

# basic

identifier = pyparsing_common.identifier.copy()
integer    = pyparsing_common.integer.copy()
number     = Regex(r"[+-]?(\.\d+|\d+(\.\d*)?)([eEdD]([+-]?\d+(\.\d*)?))?(_\w+)?")
logical    = Regex(r"\.(true|false)\.", re.IGNORECASE)
character  = QuotedString('"', escQuote='\\') | QuotedString("'", escQuote="\\")
OPTSIGN    = Optional(Regex("[-+]|\.not\.",re.IGNORECASE),default="")

# arithmetic logical expressions and assignments
arith_expr = Forward()
tensor_access_arg = Forward()
tensor_access_args = Optional(Group(delimitedList(tensor_access_arg)),default=None) #  emits one token
tensor_access = identifier + LPAR + tensor_access_args + RPAR # emits 3 tokens: *,

func_kind = COMMA + ( KIND + EQ + arith_expr ) # emits one token # todo: generalize to named args

# derived_types
derived_type_rvalue = Forward()
derived_type_elem = (( tensor_access | identifier ) + ELEM + derived_type_rvalue )
derived_type_rvalue <<= derived_type_elem | tensor_access | identifier

complex_arith_expr = Forward()
conversion      = Forward()
inquiry_function = Forward()

#rvalue = OPTSIGN + (conversion | inquiry_function | complex_arith_expr | derived_type_elem | tensor_access | identifier | logical | character | number)  # |: ordered OR, order is important

# |: ordered OR, order is import
# somehow adding the Group is import to prevent that the expression is inlined 
rvalue = Group(conversion | inquiry_function | derived_type_elem | tensor_access | identifier | logical | character | number)  # |: ordered OR, order is import
# Add Group to have same structure as rvalue
lvalue           = Group(derived_type_elem | tensor_access | identifier)

fortran_subroutine_call = CALL + tensor_access

# assignments
l_arith_operator_1 = Regex(r"[+-]")
l_arith_operator_2 = Regex(r"[+\-*/]")
condition_op_1 = Regex(r"\.not\.",re.IGNORECASE)
condition_op_2 = Regex(r"[<>=/]=|[<>]|\.(eqv|neqv|eq|ne|lt|gt|le|ge|and|or|xor)\.",re.IGNORECASE)
arith_expr <<= infixNotation(rvalue | complex_arith_expr,
    [
      (l_arith_operator_1, 1, opAssoc.RIGHT),
      (l_arith_operator_2, 2, opAssoc.LEFT),
    ],
)
arith_logic_expr = infixNotation(arith_expr, #NOTE: Slower because of the additional operators
    [
      (condition_op_1, 1, opAssoc.RIGHT),
      (condition_op_2, 2, opAssoc.LEFT),
    ],
)

# use in preprocessing step
power_value1 = rvalue
power_value2 = LPAR + arith_expr + RPAR
power_value  = power_value2 | rvalue
power        = power_value + Suppress("**") + power_value

assignment_begin = lvalue + EQ
assignment       = lvalue + EQ + arith_logic_expr # ! emits 2 tokens: *,*
keyword_argument = identifier + EQ + arith_logic_expr

MATLPAR = Regex(r"\(\/|\[").suppress()
MATRPAR = Regex(r"\/\)|\]").suppress()
matrix_arith_expr = MATLPAR + Group(delimitedList(arith_logic_expr)) + MATRPAR
matrix_assignment            = lvalue + EQ + matrix_arith_expr

complex_arith_expr <<= LPAR + Group(arith_expr + COMMA + arith_expr) + RPAR 
complex_assignment = lvalue + EQ + complex_arith_expr

fortran_assignment = matrix_assignment | complex_assignment | assignment

single_colon  = (Literal(":") + ~Literal(":")).suppress()
stride        = single_colon + arith_expr
tensor_slice0  = single_colon.copy().setParseAction(lambda tokens: [None,None])           
tensor_slice1a = (arith_expr + single_colon).setParseAction(lambda tokens: [None,tokens[0]]) 
tensor_slice1b = (single_colon + arith_expr).setParseAction(lambda tokens: [tokens[0],None])
tensor_slice2  = (arith_expr + single_colon + arith_expr)
tensor_slice   = (tensor_slice2 | tensor_slice1b | tensor_slice1a | tensor_slice0) + Optional(stride,default=None)
# define forward declared tokens
argument = tensor_slice | arith_logic_expr
tensor_access_arg <<= argument | keyword_argument

# conversion functions
# todo: check type of variable when translating
# see http://userweb.eng.gla.ac.uk/peter.smart/com/com/f77-conv.htm
# for now, always assume conversion between complex and float types
REAL,FLOAT,DBLE,CMPLX,DCMPLX,AIMAG,CONJG,DCONJG = makeCaselessLiteral("real,float,dble,cmplx,dcmplx,aimag,conjg,dconjg",suppress=True)
single_arg_plus_kind = LPAR + (~func_kind+arith_expr) + Optional(func_kind,default=None) + RPAR # emits 2 tokens: *,*,*
double_arg_plus_kind = LPAR + (~func_kind+arith_expr) + Optional(COMMA + (~func_kind+arith_expr),default="0") +\
                           Optional(func_kind,default=None) + RPAR # emits 2 tokens: *,*,*

convert_to_extract_real   = ( REAL | FLOAT ) + single_arg_plus_kind # emits 2 tokens,
convert_to_double         = DBLE   + single_arg_plus_kind # emits 2 tokens,
convert_to_complex        = CMPLX  + double_arg_plus_kind # emits 3 tokens, op (x,y) -> x+iy | c.x = x, c.y = b  ; op: x -> (x,0) -> x+i0 -> | c.x = x, c.y =0
convert_to_double_complex = DCMPLX + double_arg_plus_kind # emits 3 tokens, op (x,y) -> x+iy | c.x = x, c.y = b  ; op: x -> (x,0) -> x+i0 -> | c.x = x, c.y =0
extract_imag              = AIMAG  + single_arg_plus_kind # emits 1 tokens, op: x+iy -> y
conjugate                 = CONJG  + single_arg_plus_kind # emits 1 tokens, op: x+iy -> x-iy | c.y = -c.y
conjugate_double_complex  = DCONJG + single_arg_plus_kind # emits 1 tokens, op: x+iy -> x-iy | c.y = -c.y

conversion <<= convert_to_extract_real | convert_to_double | convert_to_complex | convert_to_double_complex | extract_imag | conjugate | conjugate_double_complex

# inquiry functions
SIZE,LBOUND,UBOUND = makeCaselessLiteral("size,lbound,ubound",suppress=True)
inquiry_dim_arg  = ( integer | arith_expr ) 
inquiry_kind_arg = ( integer | arith_expr ) 
inquiry_function_arg = lvalue + Optional(COMMA + Optional(DIM + EQ) + inquiry_dim_arg,default=None) + Optional(COMMA + Optional(KIND + EQ) + inquiry_kind_arg,default=None)
size_inquiry   = SIZE   + LPAR + inquiry_function_arg + RPAR  
lbound_inquiry = LBOUND + LPAR + inquiry_function_arg + RPAR 
ubound_inquiry = UBOUND + LPAR + inquiry_function_arg + RPAR 
inquiry_function <<= size_inquiry | lbound_inquiry | ubound_inquiry

## Condition
### If statement
WHILE,IF,ELSE,THEN,DO,END,SELECT,CASE,DEFAULT,WHERE,FORALL,FOREACH = makeCaselessLiteral(
 "while,if,else,then,do,end,select,case,default,where,forall,foreach",suppress=True)

block = Forward() # forward declaration

# Example:
#
#  IF (x < 50) THEN
#     Grade = 'f'
#  ELSE IF (x < 60) THEN
#     Grade = 'd'
#  ELSEIF (x < 70) THEN
#     Grade = 'c'
#  ELSE IF (x < 80) THEN
#     Grade = 'b'
#  ELSE
#     Grade = 'a'
#  END IF
fortran_if_else_if = Optional(CASELESS_LITERAL("else"),default="") + IF + LPAR + arith_logic_expr + RPAR + THEN
fortran_else       = ELSE

#[name:] select case (expression)
#   case (selector1)
#   ! some statements
#   ... case (selector2)
#   ! other statements
#   ...
#   case default
#   ! more statements
#   ...
#end select [name]
fortran_select_case     = Regex(r"(\w+\s*:)?\s*select\s+case\s*\(",re.IGNORECASE).suppress() + arith_logic_expr + RPAR
fortran_case            = Regex(r"case\s*\(",re.IGNORECASE).suppress() + arith_logic_expr + RPAR
fortran_case_default    = Regex(r"case\s+default",re.IGNORECASE).suppress() # todo: not sure if still needed
fortran_end_select_case = Regex(r"end\s*select(\s+\w+)?",re.IGNORECASE).suppress() # todo: not sure if still needed

## Do/while Loop
do_loop_start    = Regex(r"(\w+\s*:)?\s*do",re.IGNORECASE).suppress()
fortran_do       = do_loop_start + assignment + COMMA + arith_expr + Optional(COMMA + arith_expr,default=None)
fortran_do_while = do_loop_start + WHILE + LPAR + arith_logic_expr + RPAR 

# attributes/qualifiers
INTENT,IN,OUT,INOUT,DIMENSION = makeCaselessLiteral(\
  "intent,in,out,inout,dimension")
INTENT = INTENT.suppress()
DIMENSION = DIMENSION.suppress()

# todo: get rid of this too
comment            = Combine(Literal("!") + ~(~White()+Literal("$")) + restOfLine())

raw_identifier     = pyparsing_common.identifier.copy() # produces a string instead of a identifier translator tree node
raw_identifier_list = Group(delimitedList(raw_identifier))