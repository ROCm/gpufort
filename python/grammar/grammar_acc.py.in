#from grammar_acc import *

# OpenACC
ACC,KERNELS,PARALLEL,LOOP,DATA,ENTER,EXIT,HOST_DATA,ATOMIC,UPDATE,SERIAL,CACHE,ROUTINE,DECLARE = makeCaselessLiteral("acc,kernels,parallel,loop,data,enter,exit,host_data,atomic,update,serial,cache,routine,declare",suppress=True)

ASYNC,WAIT,NUM_GANGS,NUM_WORKERS,VECTOR_LENGTH,DEVICE_TYPE,COPY,COPYIN,COPYOUT,CREATE,NO_CREATE,PRESENT,DEVICEPTR,ATTACH,DETACH,DEFAULT,NONE,PRIVATE,FIRST_PRIVATE,REDUCTION,DELETE,ROUTINE,USE_DEVICE,COLLAPSE,SELF,DEVICE,HOST,BIND,DEVICE_RESIDENT,LINK,TILE=\
  makeCaselessLiteral("async,wait,num_gangs,num_workers,vector_length,device_type,copy,copyin,copyout,create,no_create,present,deviceptr,attach,detach,default,none,private,first_private,reduction,delete,routine,use_device,collapse,self,device,host,bind,device_resident,link,tile",suppress=True)

GANG,VECTOR,WORKER = makeCaselessLiteral("gang,vector,worker",suppress=False)

accVarList = Group(delimitedList(allocateRvalue)) 

accReductionOperator = oneOf("+ * max min iand ior ieor .and. .or. .eqv. .neqv.", caseless=CASELESS)
accReductionVar      = accReductionOperator + Suppress(":") + allocateRvalue
accReductionVarList  = Group(delimitedList(accReductionVar))

# clauses
acc_gang             = GANG + Optional(LPAR + integer + RPAR,default = -1)
acc_worker           = WORKER + Optional(LPAR + integer + RPAR,default = -1)
acc_vector           = VECTOR + Optional(LPAR + integer + RPAR,default = -1)
acc_num_gangs        = NUM_GANGS + LPAR + integer + RPAR 
acc_num_workers      = NUM_WORKERS + LPAR + integer + RPAR 
acc_vector_length    = VECTOR_LENGTH + LPAR + integer + RPAR

acc_device_type      = DEVICE_TYPE + LPAR + Group(delimitedList(identifier | Literal("*"))) + RPAR
acc_if               = IF + LPAR + arithmeticLogicalExpression + RPAR
acc_copy             = COPY + LPAR + accVarList + RPAR
acc_copyin           = COPYIN + LPAR + accVarList + RPAR
acc_copyout          = COPYOUT + LPAR + accVarList + RPAR

acc_create           = CREATE + LPAR + accVarList + RPAR
acc_no_create        = NO_CREATE + LPAR + accVarList + RPAR
acc_present          = PRESENT + LPAR + accVarList + RPAR
acc_deviceptr        = DEVICEPTR + LPAR + accVarList + RPAR
acc_attach           = ATTACH + LPAR + accVarList + RPAR
acc_detach           = DETACH + LPAR + accVarList + RPAR
acc_default          = DEFAULT + LPAR +  (CASELESS_LITERAL("none") | CASELESS_LITERAL("present")) + RPAR
acc_use_device       = USE_DEVICE + LPAR + accVarList + RPAR
acc_private          = PRIVATE + LPAR + accVarList + RPAR
acc_reduction        = REDUCTION + LPAR + accReductionVarList + RPAR
acc_delete           = DELETE + LPAR + accVarList + RPAR
acc_routine          = ROUTINE + LPAR + identifier + RPAR
acc_private          = PRIVATE + LPAR + accVarList + RPAR
acc_first_private    = FIRST_PRIVATE + LPAR + accVarList + RPAR 
acc_collapse         = COLLAPSE + LPAR + integer + RPAR
acc_device           = DEVICE + LPAR + accVarList + RPAR
acc_host             = HOST + LPAR + accVarList + RPAR
acc_self             = SELF + LPAR + accVarList + RPAR
acc_bind             = BIND + LPAR + identifier + RPAR
acc_device_resident  = DEVICE_RESIDENT + LPAR + accVarList + RPAR
acc_link             = LINK + LPAR + accVarList + RPAR
acc_tile             = TILE + LPAR + Group(integer + Suppress(",") + integer) + RPAR
acc_wait             = WAIT + Optional(LPAR + accVarList + RPAR, default=[])
acc_async            = ASYNC + Optional(LPAR + rvalue + RPAR, default = "0") 

# TODO(acc) Add more clauses where needed
# Probably need to support collapse and reduction ...
acc_seq,acc_auto,acc_independent,acc_read,acc_write,acc_capture,acc_nohost,acc_finalize,acc_if_present = makeCaselessLiteral("seq,auto,independent,read,write,capture,nohost,finalize,if_present",suppress=False)

# ACC LoopKernel directive
ACC_START = PRAGMA + ACC
ACC_END   = ACC_START.copy() + END

acc_clause = acc_if | acc_self | acc_host | acc_async | acc_wait | acc_num_gangs | acc_num_workers | acc_vector_length | acc_device_type |\
    acc_copy | acc_copyin | acc_copyout | acc_create | acc_present | acc_deviceptr | acc_default |\
    acc_private | acc_first_private | acc_no_create | acc_delete | acc_reduction | acc_detach | acc_collapse |\
    acc_use_device | acc_device | acc_bind | acc_device_resident | acc_link | acc_tile | acc_seq | acc_auto |\
    acc_independent | acc_gang | acc_worker | acc_vector | acc_read | acc_write | acc_capture |\
    acc_nohost | acc_finalize | acc_if_present 

acc_clause_list = Optional(OneOrMore(Optional(ACC_START + Literal("&")).suppress() + acc_clause), default=[])

##
## DIRECTVIES
##
acc_update = ACC_START + UPDATE + acc_clause_list # 2 tokens -> [(False|True),[*]],*

acc_wait = ACC_START + acc_wait + acc_clause_list

acc_host_data        = ACC_START + HOST_DATA + acc_clause_list 
ACC_END_HOST_DATA    = ACC_END + HOST_DATA
acc_host_data_region = acc_host_data + block + ACC_END_HOST_DATA 

acc_data        = ACC_START + HOST_DATA + acc_clause_list 
ACC_END_DATA    = ACC_END + DATA
acc_data_region = acc_data + block + ACC_END_DATA 

acc_enter_data = ACC_START + ENTER + DATA + acc_clause_list
acc_exit_data  = ACC_START + EXIT  + DATA + acc_clause_list

acc_loop          = ACC_START + LOOP + acc_clause_list

# kernels / parallels
acc_kernels         = ACC_START + KERNELS + acc_clause_list
acc_parallel        = ACC_START + PARALLEL + acc_clause_list
acc_parallel_loop = ACC_START + PARALLEL + LOOP + acc_clause_list
acc_kernels_loop  = ACC_START + KERNELS + LOOP + acc_clause_list

ACC_END_KERNELS       = ACC_END + KERNELS
ACC_END_PARALLEL      = ACC_END + PARALLEL
ACC_END_PARALLEL_LOOP = ACC_END_PARALLEL.copy() + LOOP # copy() allows us to attach different parse action
ACC_END_KERNELS_LOOP  = ACC_END_KERNELS.copy()  + LOOP

acc_routine =  ACC_START + ROUTINE + Optional(LPAR + identifier + RPAR,default = None) + acc_clause_list
acc_declare = ACC_START + DECLARE + acc_clause_list
acc_atomic  = ACC_START + ATOMIC + Optional(acc_clause_list,default = "update") +\
               block +\
           Optional( ACC_END + ATOMIC )
acc_serial = ACC_START + SERIAL + acc_clause_list +\
              block +\
            ACC_END + SERIAL
acc_cache = ACC_START + CACHE + LPAR + accVarList + RPAR

# regions
acc_kernels_region       = acc_kernels + block + Optional(ACC_END_KERNELS) 
acc_parallel_region      = acc_parallel + block + Optional(ACC_END_PARALLEL)
acc_parallel_loop_region = acc_parallel_loop + annotatedDoLoop + Optional(ACC_END_PARALLEL_LOOP)
acc_kernels_loop_region  = acc_kernels_loop  + annotatedDoLoop + Optional(ACC_END_KERNELS_LOOP)

accDirective = acc_kernels_loop | acc_parallel_loop | acc_kernels | acc_parallel | acc_wait | acc_host_data | acc_data | acc_enter_data | acc_exit_data | acc_loop | acc_routine | acc_atomic | acc_update | acc_serial | acc_cache | acc_declare
accKernelBodyDirective = acc_loop | acc_serial | acc_atomic | acc_cache

accLoopKernel = acc_parallel_loop_region | acc_kernels_loop_region | acc_parallel_region | acc_kernels_region # emits 1 token

# Ideally pass the following:
# multiple acc directives/lines 
# !acc ...
# !acc ...
# some Fortran code
