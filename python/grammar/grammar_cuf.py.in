# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.
#!/usr/bin/env python3
#from grammar_f03 import *

## CUDA Fortran specific
## CUF LoopKernel loop directive
CUF,KERNEL,STREAM = makeCaselessLiteral("cuf,kernel,stream",suppress=True)

dim3        = LPAR + delimitedList(arithmeticExpression) + RPAR
grid        = Literal("*") | dim3 
threadBlock = grid.copy()
streamType  = ( derivedTypeElem | funcCall | identifier | number )
streamArg   = Optional(STREAM + EQ) + Optional(streamType,default="0")
kernelLaunchArgs = Group(Suppress("<<<") + \
  Optional(grid,default="*")  + COMMA + \
  Optional(threadBlock,default="*") + OPTCOMMA + \
  Optional(pyparsing_common.integer,default=0) + OPTCOMMA + \
  streamArg + OPTCOMMA +\
  Suppress(">>>")) # grid,threadBlock,shmem,stream
numLoopsToMapArg = Optional(LPAR + pyparsing_common.integer + RPAR,default=1)

# directives
cuf_kernel_do = PRAGMA + CUF + KERNEL + DO + numLoopsToMapArg + Optional(kernelLaunchArgs,default=["*","*",0,"0"])

# scanner/analysis
ALLOCATE,ALLOCATED,DEALLOCATE = makeCaselessLiteral("allocate,allocated,deallocate",suppress=True)
allocateRValue                =  (( derivedTypeElem | identifier ) + bounds) | derivedTypeElem | identifier # TODO check if this can be generalized
allocateRValueList            = delimitedList(allocateRValue)

allocate                         = ALLOCATE + LPAR + allocateRValueList + RPAR
allocated                        = ALLOCATED + LPAR + allocateRValue + RPAR
deallocate                       = DEALLOCATE + LPAR + allocateRValueList + RPAR
memCpyValue                      = allocateRValue.copy() # TODO check if duplicate
memcpy                           = memCpyValue + EQ + memCpyValue + ( Suppress(";") | LineEnd() )
NOT                              = CASELESS_LITERAL(".NOT.").suppress() 
nonZeroCheck                     = allocateRValue + oneOf("/= .ne.",caseless=CASELESS).suppress() + Suppress("0")
pointerAssignment                = allocateRValue + PEQ + allocateRValue
singleLineIfNotAllocatedAllocate = IF + LPAR + NOT + allocated + RPAR + ~THEN + allocate + ~ENDIF # produces two tokens
singleLineIfAllocatedDeallocate  = IF + LPAR + allocated + RPAR + ~THEN + deallocate + ~ENDIF # produces two tokens

# kernelextractor/analysis
CUDAMALLOC,CUDAMEMCPY,CUDAMEMCPYASYNC,CUDAMEMCPY2D,CUDAMEMCPY2DASYNC,CUDAMEMCPY3D,CUDAMEMCPY3DASYNC = makeCaselessLiteral(\
  "cudamalloc,cudamemcpy,cudamemcpyasync,cudamemcpy2d,cudamemcpy2dasync,cudamemcpy3d,cudamemcpy3dasync")
# dest,count # kind is inferred from dest and src
cufCudaMalloc = CUDAMALLOC + LPAR + identifier + COMMA + arithmeticExpression + RPAR
# dest,src,count,[,stream] # kind is inferred from dest and src
cudaMemcpyType     = oneOf("cudamemcpyhosttohost cudamemcpyhosttodevice cudamemcpydevicetohost cudamemcpydevicetodevice",caseless=CASELESS)
cudaMemcpyArgsExt  = Optional(COMMA + cudaMemcpyType,default=None) + Optional(COMMA + streamArg,default=None)
cufCudaMemcpyArgs  = separatedSequence([allocateRValue,allocateRValue,arithmeticExpression]) + cudaMemcpyArgsExt
cufCudaMemcpy      = ( CUDAMEMCPYASYNC | CUDAMEMCPY ) + LPAR + cufCudaMemcpyArgs + RPAR
# dest,dpitch(count),src,spitch(count),width(count),height(count)[,stream] # kind is inferred from dest and src
cufCudaMemcpy2DArgs  = separatedSequence([allocateRValue,arithmeticExpression,allocateRValue,arithmeticExpression,arithmeticExpression,arithmeticExpression]) + cudaMemcpyArgsExt
cufCudaMemcpy2D      = ( CUDAMEMCPY2D | CUDAMEMCPY2DASYNC )  + LPAR + cufCudaMemcpy2DArgs + RPAR
# dest,dpitch(count),src,spitch(count),width(count),height(count),depth(count),[,stream] # kind is inferred from dest and src
cufCudaMemcpy3DArgs  = separatedSequence([allocateRValue,arithmeticExpression,allocateRValue,arithmeticExpression,arithmeticExpression,arithmeticExpression,arithmeticExpression]) + cudaMemcpyArgsExt
cufCudaMemcpy3D      = ( CUDAMEMCPY3D | CUDAMEMCPY3DASYNC ) + LPAR + cufCudaMemcpy3DArgs + RPAR
cufCudaMemcpyVariant = cufCudaMemcpy | cufCudaMemcpy2D | cufCudaMemcpy3D
# cublas/analysis
cublasOperationType = Regex("'[NTCntc]'")#.setParseAction(lambda tokens: "hipblas_op_"+tokens[0].strip("'").upper())
#cublasArgList       = Group(delimitedList(cublasOperationType | allocateRValue)) 
# TODO: Explicitly scan for allocateRValues in cublasArgList's arithmeticLogicalExpressions when transforming host code
cublasArgList       = Group(delimitedList(cublasOperationType | arithmeticLogicalExpression)) 
cublasCall          = CASELESS_LITERAL("cublas").suppress() + identifier + LPAR + cublasArgList + RPAR  # emits 2 tokens

# anchors; TODO(Dominic): Can be simplified
cudaAPI        = Regex(r"\b").suppress() + Combine(oneOf("cublas cufft cusparse cuda cusolver",caseless=CASELESS) + identifier)
FUNCTION_BREAK = Regex(",\s*\&").setParseAction(lambda tokens: False) # continues on next lines
FUNCTION_END   = Regex("\)").setParseAction(lambda tokens: True)      # finishes on this line
# cudaLibCall is used to detect any CUDA library calls; 
# they are then analysed and transformed using more specific constructs
cudaLibCall = ((identifier + EQ) | CALL).suppress() + cudaAPI + LPAR + Optional(argList,default=[]) + ( FUNCTION_BREAK | FUNCTION_END ) # emits 3 tokens -> *,
#Example: call ylmr2_gpu_kernel<<<grid,tBlock>>>(lmax, lmax2, ng, g_d, gg_d, ylm_d)
cudaKernelCall = CALL + identifier + kernelLaunchArgs + LPAR + Optional(argList,default=[])  + ( FUNCTION_BREAK | FUNCTION_END ) # emits 4 tokens -> *,[*],[*],False/True
callEnd = argList + FUNCTION_END.suppress() + Optional(comment).suppress() # emits 1 token -> [*]
