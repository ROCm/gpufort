# init shutdown
HIP_GCC_RT_ACC_INIT     = "acc_init({devicetype})"
HIP_GCC_RT_ACC_SHUTDOWN = "acc_shutdown({devicetype})"

# update host
HIP_GCC_RT_ACC_UPDATE_SELF         = "acc_update_self({var})"
HIP_GCC_RT_ACC_UPDATE_SELF_ASYNC   = "acc_update_self_async({var}{async})"
HIP_GCC_RT_ACC_UPDATE_DEVICE       = "acc_update_device({var})"
HIP_GCC_RT_ACC_UPDATE_DEVICE_ASYNC = "acc_update_device_async({var}{async})"
HIP_GCC_RT_ACC_UPDATE_MAP = { # [self][async]
  False: { False: HIP_GCC_RT_ACC_UPDATE_DEVICE, True: HIP_GCC_RT_ACC_UPDATE_DEVICE_ASYNC },
  True:  { False: HIP_GCC_RT_ACC_SELF,          True: HIP_GCC_RT_ACC_SELF_ASYNC          }
}
# wait
HIP_GCC_RT_ACC_WAIT_ALL          = "acc_wait_all()"
HIP_GCC_RT_ACC_WAIT_ALL_AYNC     = "acc_wait_all_async({async})"
HIP_GCC_RT_ACC_WAIT              = "acc_wait({arg})"
HIP_GCC_RT_ACC_WAIT_ASYNC        = "acc_wait_async({arg}{async})"
#HIP_GCC_RT_ACC_WAIT_DEVICE       = "call acc_wait_device({arg}{device})"
#HIP_GCC_RT_ACC_WAIT_DEVICE_ASYNC = "call acc_wait_device({arg}{async}{device})"
HIP_GCC_RT_ACC_WAIT_MAP = { # [arg][async]
  False: { False: HIP_GCC_RT_ACC_WAIT_ALL, True: HIP_GCC_RT_ACC_WAIT_ALL_ASYNC },
  True:  { False: HIP_GCC_RT_ACC_WAIT,     True: HIP_GCC_RT_ACC_WAIT_ASYNC     }
}
# delete
HIP_GCC_RT_ACC_DELETE                = "acc_delete({var})"
HIP_GCC_RT_ACC_DELETE_ASYNC          = "acc_delete_async({var}{async})"
HIP_GCC_RT_ACC_DELETE_FINALIZE       = "acc_delete_finalize({var})"
HIP_GCC_RT_ACC_DELETE_FINALIZE_ASYNC = "acc_delete_finalize_async({var}{async})"
HIP_GCC_RT_ACC_DELETE_MAP = { # [finalize][async]
  False: { False: HIP_GCC_RT_ACC_DELETE,          True: HIP_GCC_RT_ACC_DELETE_ASYNC          },
  True:  { False: HIP_GCC_RT_ACC_DELETE_FINALIZE, True: HIP_GCC_RT_ACC_DELETE_FINALIZE_ASYNC }
}
# acc_deviceptr
HIP_GCC_RT_ACC_DEVICEPTR         = "acc_deviceptr({var})" # usually not available in openacc.f90
# GCC LIBGOMP specific internal routines for /acc enter/exit data and acc data
HIP_GCC_RT_GOACC_ENTER_EXIT_DATA = "goacc_enter_exit_data({device}{mappings}{async}{wait})"
HIP_GCC_RT_GOACC_START_DATA      = "goacc_data_start({device}{mappings}{async})"
HIP_GCC_RT_GOACC_END_DATA        = "goacc_data_end()"
# GCC LIBGOMP specific helper functions
HIP_GCC_RT_MAP_CREATE            = "map_create({var})"
HIP_GCC_RT_MAP_NO_CREATE         = "map_no_create({var})"
HIP_GCC_RT_MAP_DELETE            = "map_delete({var})"
HIP_GCC_RT_MAP_COPYIN            = "map_copyin({var})"
HIP_GCC_RT_MAP_COPY              = "map_copy({var})"
HIP_GCC_RT_MAP_COPYOUT           = "map_copyout({var})"
HIP_GCC_RT_MAP_PRESENT           = "map_present({var})"

class Acc2HipGccRT:
    def createMappings(self,parseResult):
        mappings=[]
        for clause in translator.findAll(parseResult,translator.TTAccClausePresent):
            mappings += [HIP_GCC_RT_MAP_PRESENT.format(var=expr) for expr in clause.expressions()]
        for clause in translator.findAll(parseResult,TTAccClauseCreate):
            mappings += [HIP_GCC_RT_MAP_CREATE.format(var=expr) for expr in clause.expressions()]
        for clause in translator.findAll(parseResult,TTAccClauseNo_create):
            mappings += [HIP_GCC_RT_MAP_NO_CREATE.format(var=expr) for expr in clause.expressions()]
        for clause in translator.findAll(parseResult,TTAccClauseDelete):
            mappings += [HIP_GCC_RT_MAP_DELETE.format(var=expr) for expr in clause.expressions()]
        for clause in translator.findAll(parseResult,TTAccClauseCopy):
            mappings += [HIP_GCC_RT_MAP_COPY.format(var=expr) for expr in clause.expressions()]
        for clause in translator.findAll(parseResult,TTAccClauseCopyin):
            mappings += [HIP_GCC_RT_MAP_COPYIN.format(var=expr) for expr in clause.expressions()]
        for clause in translator.findAll(parseResult,TTAccClauseCopyout):
            mappings += [HIP_GCC_RT_MAP_COPYOUT.format(var=expr) for expr in clause.expressions()]
        for clause in translator.findAll(parseResult,TTAccClausePresent):
            mappings += [HIP_GCC_RT_MAP_PRESENT.format(var=expr) for expr in clause.expressions()]
        if len(mappings):
            return "mappings=["+",".join(mappings)+"]"
        else:
            return ""
    def handleAsync(self,parseResult,prefix="async="):
        clause = translator.findFirst(parseResult,translator.TTAccClauseAsync)
        if clause is not None:
            value = clause.expression()
            if str(value) == str(CLAUSE_VALUE_NOT_SPECIFIED):
                return prefix+"acc_async_noval"
            else:
                return prefix+value
        else:
            return ""
    def handleWait(self,parseResult,prefix="wait=",wrapInBrackets=True):
        clause = translator.findFirst(parseResult,translator.TTAccClauseWait)
        if clause is not None:
            result = ",".join(clause.expressions())
            if wrapInBrackets:
                result = "[" + result + "]"
            return prefix+result
        else:
            return ""
    def handleDevice(self,parseResult):
        clause = translator.findFirst(parseResult,translator.TTAccClauseDevice)
        if clause is not None:
            result = ",".join(clause.expressions())
            if wrapInBrackets:
                result = "[" + result + "]"
            return prefix+result
        else:
            return ""
    def gpufortFStr(self,indexHints=[]):
        fSnippet = "".join(self._lines)
        result = ""
        try:
           accDirective = translator.acc_data | translator.acc_enter_data | translator.acc_exit_data | translator.acc_update |\
             translator.acc_routine | translator.acc_declare | translator.ACC_END_DATA
           parseResult = accDirective.parseString(self._lines)[0]
           if   type(parseResult) is TTAccData:
              result = HIP_GCC_RT_GOACC_START_DATA.format(\
                device  = "acc_device_default",\
                mappings= self.createMappings(parseResult),\
                async   = self.handleAsync(parseResult))
           elif type(parseResult) is TTAccEnterData or\
                type(parseResult) is TTAccExitData: 
              result = HIP_GCC_RT_GOACC_ENTER_EXIT_DATA.format(\
                device   = "acc_device_default",\
                mappings = self.createMappings(parseResult),\
                async    = self.handleAsync(parseResult),\
                wait     = self.handleWait(parseResult))
           elif type(parseResult) is TTAccEndData: 
              result = HIP_GCC_RT_GOACC_END_DATA
           elif type(parseResult) is TTAccWait:
              arg   = self.handleWait(parseResult,"",False)
              async = self.handleAsync(parseResult,"")
              result = HIP_GCC_RT_ACC_WAIT_MAP[len(arg)][len(async)].format(\
                arg=arg,async=async)
              pass
           elif type(parseResult) is TTAccUpdate: 
              self   = self.handleSelf(parseResult)
              device = self.handleDevice(parseResult) 
              async = self.handleAsync(parseResult,"")
              result = HIP_GCC_RT_ACC_UPDATE_MAP[len(self)][len(async)].format(\
                arg=arg,async=async)
           elif type(parseResult) is TTAccRoutine: 
              pass
           elif type(parseResult) is TTAccDeclare:
              pass
           return "call "+result"\n", True 
        except Exception as e:
           print("failed: "+fSnippet) #TODO
           raise e
           return "", False 

class AccLoopKernel2HipGccRT:
    def gpufortFStr(self,indexHints=[]):
        #result = ""
        #if self.isParallelLoopDirective() or self.isKernelsLoopDirective():
        #    partialResult, _ = Acc2HipGccRT.gpufortFStr(self,indexHints,handleIf=False) 
        #    result = partialResult
        #partialResult, _ = STLoopKernel.gpufortFStr(self,indexHints) 
        #result += partialResult
        #if self.isParallelLoopDirective() or self.isKernelsLoopDirective():
        #   result += "\n"+HIP_GCC_RT_ACC_EXIT_REGION
       
        ## add wait call if necessary
        #queue = self._handleAsync(None,"")
        #if not len(queue):
        #    result += "\n" + HIP_GCC_RT_ACC_WAIT.format(queue=queue,async="")

        ## wrap in ifdef if necessary
        #condition = self._handleIf()
        #if len(condition):
        #    result = "if ( {condition} ) then\n{result}\nelse\n {original}\n endif".format(\
        #            condition=condition, result=result.rstrip("\n"), original="".join(self._lines).rstrip("\n"))
        return result, len(result)
        return "", False

registerAccBackend("hip-gcc-rt",AccLoopKernel2HipGccRT,AccLoopKernel2HipGccRT,"openacc_gomp")
