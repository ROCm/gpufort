# init shutdown
tAccInit     = "call gpufort_acc_init()\n"
tAccShutdown = "call gpufort_acc_shutdown()\n"
# regions
tAccEnterRegion = "call gpufort_acc_enter_region()\n"
tAccExitRegion = "call gpufort_acc_exit_region()\n"
# create
tAccCreate = "{devVar} = gpufort_acc_create({var})\n"
# no_create
tAccNoCreate = "{devVar} = gpufort_acc_no_create({var})\n"
# delete
tAccDelete = "call gpufort_acc_delete({var}{finalize})\n"
# copyin
tAccCopyin = "{devVar} = gpufort_acc_copyin({var}{async})\n"
# copy
tAccCopy = "{devVar} = gpufort_acc_copy({var}{async})\n"
# copyout
tAccCopyout = "{devVar} = gpufort_acc_copyout({var}{async})\n"
# update host
tAccUpdateHost = "call gpufort_acc_update_host({var}{async})\n"
# update device
tAccUpdateDevice = "call gpufort_acc_update_device({var}{async})\n"
# present
tAccPresent = "{devVar} = gpufort_acc_present({var})\n"
# wait
tAccWait = "call gpufort_acc_wait({queue}{async})\n"

def devVarName(var):
    #tokens = var.split("%")
    #tokens[-1] = ACC_DEV_PREFIX+tokens[-1]+ACC_DEV_SUFFIX
    #return "%".join(tokens)
    result = var.replace("%","_")
    result = result.replace("(","$")
    result = result.replace(")","$")
    result = "".join(c for c in result if c.isalnum() or c in "_$")
    result = result.replace("$$","")
    result = result.replace("$","_")
    return ACC_DEV_PREFIX + result + ACC_DEV_SUFFIX

class Acc2HipGpufortRT:
    # clauses 
    def _handleAsync(self,queue=None,prefix=",async="):
        """
        :return: Empty string if no queue was found
        :rtype: str
        """
        result = ""
        if queue is None:
            for parseResult in translator.acc_clause_async.searchString(queue,1):
                #print(parseResult)
                # TODO find ...
                result = parseResult[0].queue()
        if len(result):
           result = prefix + result
        return result
    def _handleFinalize(self):
        """
        :return: If a finalize clause is present
        :rtype: bool
        """
        return len(translator.acc_clause_finalize.searchString(self.singleLineStatement(),1))
    def _handleSimpleMapping(self,expression,template):
        """
        """
        result = ""
        tempVars = set()
        #
        for parseResult in expression.scanString(self.singleLineStatement()):
            clause = parseResult[0][0]
            varNames       = clause.varNames()
            varExpressions = clause.varExpressions()
            for i,varExpr in enumerate(varExpressions):
                deviceptr = devVarName(varNames[i])
                result += template.format(var=varExpr,devVar=deviceptr,async=self._handleAsync())
                tempVars.add(deviceptr)
        return result, len(result), tempVars
    def _handlePresent(self):
        return self._handleSimpleMapping(translator.acc_clause_present,tAccPresent)
    def _handleCreate(self):
        return self._handleSimpleMapping(translator.acc_clause_create,tAccCreate)
    def _handleNoCreate(self):
        return self._handleSimpleMapping(translator.acc_clause_no_create,tAccNoCreate)
    def _handleDelete(self):
        return self._handleSimpleMapping(translator.acc_clause_delete,tAccDelete)
    def _handleCopy(self):
        return self._handleSimpleMapping(translator.acc_clause_copy,tAccCopy)
    def _handleCopyin(self):
        return self._handleSimpleMapping(translator.acc_clause_copyin,tAccCopy)
    def _handleCopyout(self):
        return self._handleSimpleMapping(translator.acc_clause_copyout,tAccCopyout)
    def _handleDefault(self):
        """
        Emits a acc_clause_present command for every variable in the list
        """
        result = ""
        tempVars = set()
        template = tAccPresent
        for parseResult in translator.acc_clause_default.scanString(self.singleLineStatement(),1):
            value = str(parseResult[0][0]).lower()
            #print(value)
            if value == "present":
                for varExpr in self._defaultPresentVars:
                    deviceptr = devVarName(varExpr)
                    tempVars.add(deviceptr)
                    result += template.format(var=varExpr,devVar=deviceptr)
        return result, len(result), tempVars
    def _handleUpdate(self):
        """
        Emits a acc_clause_copy command for every variable in the list
        """
        result = ""
        tempVars = set()
        # update host
        #for parseResult in translator.acc_clause_update.scanString(self.singleLineStatement()):
        #    #print(parseResult[0][0])
        #    #print(parseResult[0][1])
        #    async=self._handleAsync(parseResult[0][1])
        #    #print(async)
        #    for dest in parseResult[0][0]:
        #        #print(dest)
        #        template = tAccUpdateHost
        #        if dest[0]: # -> device
        #           template = tAccUpdateDevice
        #        #print(dest[0])
        #        #print(dest[1])
        #        for rvalue in dest[1]:
        #            #print(rvalue)
        #            varExpr = rvalue.fStr()
        #            deviceptr = devVarName(varExpr)
        #            result += template.format(var=varExpr,devVar=deviceptr,async=async)
        return result, len(result), tempVars
    def _handleWait(self):
        """
        Emits a acc_clause_wait command for every variable in the list
        """
        result = ""
        tempVars = set()
        # wait
        template = tAccWait
        for parseResult in translator.acc_clause_wait.scanString(self.singleLineStatement()):
            queueList=[]
            asyncList=[]
            for rvalue in parseResult[0][0]: # queue ids
                queueList.append(rvalue.varName())
            for rvalue in parseResult[0][1]: # async queue ids
                asyncList.append(rvalue.varName())
            queue=""
            async=""
            if len(queueList):
                queue = ",[{}]".format(",".join(queueList))
            if len(asyncList):
                async = ",[{}]".format(",".join(asyncList))
            result += template.format(queue=queue,async=async)
        return result, len(result), tempVars
    def _handleIf(self):
        """
        :return: Empty string if no if was found
        :rtype: str
        """
        condition = ""
        for parseResult in translator.acc_clause_if.searchString(self.singleLineStatement(),1):
            condition = parseResult[0].condition()
        return condition
    def gpufortFStr(self,indexHints=[],handleIf=True):
        """
        :param line: An excerpt from a Fortran file, possibly multiple lines
        :type line: str
        :return: If the text was changed at all
        :rtype: bool
        """
        result = ""
        allTempVars = set()
        
        ## Init 
        if self.isInitDirective():
            result += tAccInit
        
        ## Enter region commands must come first
        emitEnterRegion = self.isEnterDirective()
        emitEnterRegion = emitEnterRegion or self.isDataDirective()
        emitEnterRegion = emitEnterRegion or self.isParallelDirective()
        emitEnterRegion = emitEnterRegion or self.isParallelLoopDirective() 
        emitEnterRegion = emitEnterRegion or self.isKernelsDirective()
        if emitEnterRegion:
            result += tAccEnterRegion 

        ## Other directives/clauses
        # create
        partialResult, transformed, tempVars = self._handleCreate()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # no_create
        partialResult, transformed, tempVars = self._handleNoCreate()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # present
        partialResult, transformed, tempVars = self._handlePresent()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # default
        partialResult, transformed, tempVars = self._handleDefault()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # delete
        partialResult, transformed, tempVars = self._handleDelete()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # copy
        partialResult, transformed, tempVars = self._handleCopy()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # copyin
        partialResult, transformed, tempVars = self._handleCopyin()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # copyout
        partialResult, transformed, tempVars = self._handleCopyout()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        
        # update directive
        partialResult, transformed, tempVars = self._handleUpdate()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        
        ## wait
        partialResult, transformed, _ = self._handleWait()
        if transformed:
            result += partialResult
        
        ## Exit region commands must come last
        emitExitRegion = self.isExitDirective()
        emitExitRegion = emitExitRegion or (self.isEndDirective() and self.findSubstring("kernels") and not self.findSubstring("loop"))
        emitExitRegion = emitExitRegion or (self.isEndDirective() and self.findSubstring("parallel") and not self.findSubstring("loop"))
        emitExitRegion = emitExitRegion or (self.isEndDirective() and self.findSubstring("data"))
        if emitExitRegion:
            result += tAccExitRegion
        if self.isShutdownDirective():
            result += tAccShutdown
       
        # _handle if 
        condition = self._handleIf()
        if len(condition) and handleIf:
            result = "if ( {condition} ) then\n{result}\n endif".format(\
                    condition=condition, result=result.rstrip("\n"))
       
        # introduce the new variables 
        if len(allTempVars):
            begin = self._parent.findLast(filter=lambda child : not child._included and type(child) in [STUseStatement,STDeclaration,STPlaceHolder])
            if not begin is None:
                indent = " "*(len(begin._lines[0]) - len(begin._lines[0].lstrip()))
                for var in allTempVars:
                     begin._epilog.add("{indent}type(c_ptr) :: {name}\n".format(indent=indent,name=var))
            else:
                indent = " "*(len(self._lines[0]) - len(self._lines[0].lstrip()))
                self._preamble.add("! TODO(gpufort): move declarations and use statement to appropriate place\n")
                for var in allTempVars:
                    self._preamble.add("{indent}type(c_ptr) :: {name}\n".format(indent=indent,name=var))

        return result, len(result)

class Acc2HipGpufortRTLoopKernel:
    def gpufortFStr(self,indexHints=[]):
        result = ""
        if self.isParallelLoopDirective() or self.isKernelsLoopDirective():
            partialResult, _ = Acc2HipGpufortRT.gpufortFStr(self,indexHints,handleIf=False) 
            result = partialResult
        partialResult, _ = STLoopKernel.gpufortFStr(self,indexHints) 
        result += partialResult
        if self.isParallelLoopDirective() or self.isKernelsLoopDirective():
           result += "\n"+tAccExitRegion
       
        # add wait call if necessary
        queue = self._handleAsync(None,"")
        if not len(queue):
            result += "\n" + tAccWait.format(queue=queue,async="")

        # wrap in ifdef if necessary
        condition = self._handleIf()
        if len(condition):
            result = "if ( {condition} ) then\n{result}\nelse\n {original}\n endif".format(\
                    condition=condition, result=result.rstrip("\n"), original="".join(self._lines).rstrip("\n"))
        return result, len(result)
