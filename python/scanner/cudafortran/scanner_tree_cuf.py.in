# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 Advanced Micro Devices, Inc. All rights reserved.
class CufBackendBase:
    def __init__(self,stnode):
        self._stnode = stnode

CUF_LOOP_KERNEL_BACKENDS = {} 

def register_cuf_backend(name,loop_kernel_generator_class,runtime_module_name):
    global SUPPORTED_DESTINATION_DIALECTS
    global RUNTIME_MODULE_NAMES
    global CUF_LOOP_KERNEL_BACKENDS
    
    if not name in SUPPORTED_DESTINATION_DIALECTS:
        SUPPORTED_DESTINATION_DIALECTS.append(name)
    RUNTIME_MODULE_NAMES[name]     = runtime_module_name
    CUF_LOOP_KERNEL_BACKENDS[name] = loop_kernel_generator_class

exec(open("{0}/cudafortran/scanner_tree_cuf2omp.py.in".format(scanner_dir)).read())
exec(open("{0}/cudafortran/scanner_tree_cuf2hip.py.in".format(scanner_dir)).read())

class STCufDirective(STDirective):
    """
    This class has the functionality of a kernel if the stored lines 
    contain a parallel or kernels directive.
    
    https://www.openacc.org/sites/default/files/inline-files/OpenCUF.2.7.pdf)
    """
    def __init__(self,parent,lineno,lines,directive_no):
        STDirective.__init__(self,parent,lineno,lines,directive_no,sentinel="!$cuf")
        self._default_present_vars = []
    def transform(self,joined_lines,joined_statements,statements_fully_cover_lines,index=[]):
        assert False, "Currently, there are only CUF parallel directives"

class STCufLoopKernel(STCufDirective,STLoopKernel):
    def __init__(self,parent,lineno,lines,directive_no):
        STCufDirective.__init__(self,parent,lineno,lines,directive_no)
        STLoopKernel.__init__(self,parent,lineno,lines)
    def transform(self,joined_lines,joined_statements,statements_fully_cover_lines,index=[],destination_dialect=""):
        """
        :param destination_dialect: allows to override default if this kernel
                                   should be translated via another backend.
        """
        checked_dialect = check_destination_dialect(\
            DESTINATION_DIALECT if not len(destination_dialect) else destination_dialect)
        return CUF_LOOP_KERNEL_BACKENDS[checked_dialect](self).transform(\
          joined_lines,joined_statements,statements_fully_cover_lines,index)

def handle_allocate_cuf(stallocate,joined_statements):
    indent = stallocate.first_line_indent()
    # CUF
    transformed       = False
    bytes_per_element = []
    array_qualifiers  = []
    for array_name in stallocate.parse_result.variable_names():
        ivar,_  = scoper.search_index_for_variable(index,stallocate._parent.tag(),\
          array_name)
        bytes_per_element.append(ivar["bytes_per_element"])
        qualifier, transformation_required = pinned_or_on_device(ivar)
        transformed |= transformation_required
        array_qualifiers.append(qualifier)
    subst = stallocate.parse_result.hip_f_str(bytes_per_element,array_qualifiers,indent=indent).lstrip(" ")
    return (subst, transformed)

def handle_deallocate_cuf(stdeallocate,joined_statements):
    indent = stdeallocate.first_line_indent()
    transformed      = False
    array_qualifiers = []
    for array_name in stdeallocate.parse_result.variable_names():
        ivar,_  = scoper.search_index_for_variable(index,stdeallocate._parent.tag(),\
          array_name)
        on_device   = index_variable_is_on_device(ivar)
        qualifier, transformed1 = pinned_or_on_device(ivar)
        transformed |= transformed1
        array_qualifiers.append(qualifier)
    subst = stdeallocate.parse_result.hip_f_str(array_qualifiers,indent=indent).lstrip(" ")
    return (subst, transformed)

def process_cuf(stree):
    """
    Add use statements as well as handles plus their creation and destruction for certain
    math libraries.
    """
    global LOG_PREFIX
    global CUBLAS_VERSION 
    utils.logging.log_enter_function(LOG_PREFIX,"postprocess_cuf")
    
    # cublas_v1 detection
    if CUBLAS_VERSION == 1:
        def has_cublas_call_(child):
            return type(child) is STCudaLibCall and child.has_cublas()
        cuf_cublas_calls = stree.find_all(filter=has_cublas_call_, recursively=True)
        #print(cuf_cublas_calls)
        for call in cuf_cublas_calls:
            begin = call._parent.find_last(filter=lambda child : type(child) in [STUseStatement,STDeclaration])
            indent = self.first_line_indent()
            begin.add_to_epilog("{0}type(c_ptr) :: hipblasHandle = c_null_ptr\n".format(indent))
            #print(begin._linemaps)       
 
            local_cublas_calls = call._parent.find_all(filter=has_cublas_call, recursively=False)
            first = local_cublas_calls[0]
            indent = self.first_line_indent()
            first.add_to_prolog("{0}hipblasCreate(hipblasHandle)\n".format(indent))
            last = local_cublas_calls[-1]
            indent = self.first_line_indent()
            last.add_to_epilog("{0}hipblasDestroy(hipblasHandle)\n".format(indent))
    
    utils.logging.log_leave_function(LOG_PREFIX,"postprocess_cuf")
