# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 Advanced Micro Devices, Inc. All rights reserved.
# init shutdown
HIP_GPUFORT_RT_ACC_INIT     = "{indent}call gpufort_acc_init()\n"
HIP_GPUFORT_RT_ACC_SHUTDOWN = "{indent}call gpufort_acc_shutdown()\n"
# regions
HIP_GPUFORT_RT_ACC_ENTER_REGION = "{indent}call gpufort_acc_enter_region({region_kind})\n"
HIP_GPUFORT_RT_ACC_EXIT_REGION = "{indent}call gpufort_acc_exit_region({region_kind})\n"
# create
HIP_GPUFORT_RT_ACC_CREATE = "{indent}{dev_var} = gpufort_acc_create({var})\n"
# no_create
HIP_GPUFORT_RT_ACC_NO_CREATE = "{indent}{dev_var} = gpufort_acc_no_create({var})\n"
# delete
HIP_GPUFORT_RT_ACC_DELETE = "{indent}call gpufort_acc_delete({var}{finalize})\n"
# copyin
HIP_GPUFORT_RT_ACC_COPYIN = "{indent}{dev_var} = gpufort_acc_copyin({var}{asyncr})\n"
# copy
HIP_GPUFORT_RT_ACC_COPY = "{indent}{dev_var} = gpufort_acc_copy({var}{asyncr})\n"
# copyout
HIP_GPUFORT_RT_ACC_COPYOUT = "{indent}{dev_var} = gpufort_acc_copyout({var}{asyncr})\n"
# update
HIP_GPUFORT_RT_ACC_UPDATE = "{indent}call gpufort_acc_update_{kind}({var}{asyncr})\n"
# present
HIP_GPUFORT_RT_ACC_PRESENT = "{indent}{dev_var} = gpufort_acc_present({var}{asyncr}{alloc})\n"
# wait
HIP_GPUFORT_RT_ACC_WAIT = "{indent}call gpufort_acc_wait({queue}{asyncr})\n"

MAPPING_CLAUSE_2_TEMPLATE_MAP = {
  "create": HIP_GPUFORT_RT_ACC_CREATE,
  "no_create": HIP_GPUFORT_RT_ACC_NO_CREATE,
  "delete": HIP_GPUFORT_RT_ACC_DELETE,
  "copyin": HIP_GPUFORT_RT_ACC_COPYIN,
  "copy": HIP_GPUFORT_RT_ACC_COPY,
  "copyout": HIP_GPUFORT_RT_ACC_COPYOUT,
  "present": HIP_GPUFORT_RT_ACC_PRESENT
}

HIP_GPUFORT_RT_CLAUSES_OMP2ACC={"alloc":"create","to":"copyin","tofrom":"copy"}

def dev_var_name(var):
    #tokens = var.split("%")
    #tokens[-1] = ACC_DEV_PREFIX+tokens[-1]+ACC_DEV_SUFFIX
    #return "%".join(tokens)
    result = var.replace("%","_")
    result = result.replace("(","$")
    result = result.replace(")","$")
    result = "".join(c for c in result if c.isalnum() or c in "_$")
    result = result.replace("$$","")
    result = result.replace("$","_")
    return ACC_DEV_PREFIX + result + ACC_DEV_SUFFIX

def add_device_vars_to_decl_list(stcontainer,temp_vars):
    # introduce the new variables 
    stcontainer.append_to_decl_list(["type(c_ptr) :: {var}\n".format(var=var) for var in temp_vars])

def add_implicit_region(stcontainer):
    last_decl_list_node = stcontainer.last_entry_in_decl_list()
    last_decl_list_node.add_to_epilog(HIP_GPUFORT_RT_ACC_ENTER_REGION.format(\
        indent=indent,region_kind="implicit_region=.TRUE."))
    last_decl_list_node.add_to_epilog(acc_present_calls)
    for stendorreturn in stcontainer.return_or_end_statements():
        stendorreturn.add_to_prolog(HIP_GPUFORT_RT_ACC_EXIT_REGION.format(\
            indent=indent,region_kind="implicit_region=.TRUE."))

class Acc2HipGpufortRT(AccBackendBase):
    # clauses 
    def _handle_async(self,queue=None,prefix=",asyncr="):
        """
        :return: Empty string if no queue was found
        :rtype: str
        """
        result = ""
        if queue is None:
            for parse_result in translator.acc_clause_async.searchString(queue,1):
                #print(parse_result)
                # TODO find ...
                result = parse_result[0].queue()
        if len(result):
           result = prefix + result
        return result
    def _handle_finalize(self):
        """
        :return: If a finalize clause is present
        :rtype: bool
        """
        return len(translator.acc_clause_finalize.searchString(self.single_line_statement(),1))
    def _handle_mapping_clauses(self):
        """
        """
        result = ""
        temp_vars = set()
        indent = self._stnode.first_line_indent()
        #
        for parse_result in translator.acc_mapping_clause.scanString(self._stnode.single_line_statement()):
            clause         = parse_result[0][0]
            if clause.kind in MAPPING_CLAUSE_2_TEMPLATE_MAP:
                var_names       = clause.var_names()
                var_expressions = clause.var_expressions()
                for i,var_expr in enumerate(var_expressions):
                    deviceptr = dev_var_name(var_names[i])
                    template = MAPPING_CLAUSE_2_TEMPLATE_MAP[clause.kind]
                    result += template.format(indent=indent,var=var_expr,dev_var=deviceptr,asyncr=self._handle_async(),alloc="")
                    temp_vars.add(deviceptr)
        return result, len(result), temp_vars
    def _handle_update(self):
        """
        Emits a acc_clause_update command for every variable in the list
        """
        result = ""
        indent = self._stnode.first_line_indent()
        # update host
        for parse_result in translator.acc_mapping_clause.scanString(self._stnode.single_line_statement()):
            clause = parse_result[0][0]
            if clause.kind in ["self","host","device"]:
                clause_kind = "host" if clause.kind=="self" else clause.kind
                var_expressions = clause.var_expressions()
                for i,var_expr in enumerate(var_expressions):
                    result += HIP_GPUFORT_RT_ACC_UPDATE.format(indent=indent,var=var_expr,asyncr=self._handle_async(),kind=clause_kind)
        return result, len(result)
    def _handle_wait(self):
        """
        Emits a acc_clause_wait command for every variable in the list
        """
        result = ""
        temp_vars = set()
        # wait
        indent = self._stnode.first_line_indent()
        template = HIP_GPUFORT_RT_ACC_WAIT
        for parse_result in translator.acc_clause_wait.scanString(self._stnode.single_line_statement()):
            queue_list=[]
            asyncr_list=[]
            for rvalue in parse_result[0][0]: # queue ids
                queue_list.append(rvalue.var_name())
            for rvalue in parse_result[0][1]: # asyncr queue ids
                asyncr_list.append(rvalue.var_name())
            queue=""
            asyncr=""
            if len(queue_list):
                queue = ",[{}]".format(",".join(queue_list))
            if len(asyncr_list):
                asyncr = ",[{}]".format(",".join(asyncr_list))
            result += template.format(indent=indent,queue=queue,asyncr=asyncr)
        return result, len(result), temp_vars
    def _handle_if(self):
        """
        :return: Empty string if no if was found
        :rtype: str
        """
        condition = ""
        for parse_result in translator.acc_clause_if.searchString(self._stnode.single_line_statement(),1):
            condition = parse_result[0].condition()
        return condition
    def transform(self,joined_lines,joined_statements,statements_fully_cover_lines,index=[],handle_if=True):
        """
        :param line: An excerpt from a Fortran file, possibly multiple lines
        :type line: str
        :return: If the text was changed at all
        :rtype: bool
        """
        result = ""
        all_temp_vars = set()
        
        ## Init 
        stnode = self._stnode
        indent = stnode.first_line_indent()
        if stnode.is_init_directive():
            result += HIP_GPUFORT_RT_ACC_INIT.format(indent=indent)
        elif stnode.is_update_directive():
            partial_result, transformed = self._handle_update()
            if transformed:
                result += partial_result
        elif stnode.is_shutdown_directive():
            result += HIP_GPUFORT_RT_ACC_SHUTDOWN.format(indent=indent)
        else: 
            ## Enter region commands must come first
            emit_enter_region = stnode.is_enter_data_directive()
            if emit_enter_region:
                region_kind="region_kind=.TRUE."
            else:
                region_kind=""
            emit_enter_region = emit_enter_region or stnode.is_data_directive()
            emit_enter_region = emit_enter_region or stnode.is_parallel_directive()
            emit_enter_region = emit_enter_region or stnode.is_parallel_loop_directive() 
            emit_enter_region = emit_enter_region or stnode.is_kernels_directive()
            emit_enter_region = emit_enter_region or stnode.is_kernels_loop_directive()
            if emit_enter_region:
                result += HIP_GPUFORT_RT_ACC_ENTER_REGION.format(indent=indent,region_kind=region_kind)

            ## Other directives/clauses
            partial_result, transformed, temp_vars = self._handle_mapping_clauses()
            if transformed:
                result += partial_result
                all_temp_vars.update(temp_vars)
            
            ## wait
            partial_result, transformed, _ = self._handle_wait()
            if transformed:
                result += partial_result
            
            ## Exit region commands must come last
            emit_exit_region = stnode.is_exit_data_directive()
            if emit_exit_region:
                region_kind="region_kind=.TRUE."
            else:
                region_kind=""
            emit_exit_region = emit_exit_region or (stnode.is_end_directive() and stnode.find_substring("kernels") and not stnode.find_substring("loop"))
            emit_exit_region = emit_exit_region or (stnode.is_end_directive() and stnode.find_substring("parallel") and not stnode.find_substring("loop"))
            emit_exit_region = emit_exit_region or (stnode.is_end_directive() and stnode.find_substring("data"))
            if emit_exit_region:
                result += HIP_GPUFORT_RT_ACC_EXIT_REGION.format(indent=indent,region_kind=region_kind)
       
        # _handle if 
        condition = self._handle_if()
        if len(condition) and handle_if:
            result = "if ( {condition} ) then\n{result}\n endif".format(\
                    condition=condition, result=result.rstrip("\n"))
       
        # introduce the new variables 
        add_device_vars_to_decl_list(stnode._parent,all_temp_vars)

        return result, len(result)

class AccLoopKernel2HipGpufortRT(Acc2HipGpufortRT):
    def _handle_default(self):
        """
        Emits a acc_clause_present command for every variable in the list
        """
        stloopkernel    = self._stnode
        ttloopkernel    = stloopkernel.parse_result
        unmapped_arrays = ttloopkernel.all_unmapped_arrays()
        
        result          = ""
        temp_vars       = []
        "{indent}{dev_var} = gpufort_acc_present({var}{asyncr}{alloc})\n"
        template        = HIP_GPUFORT_RT_ACC_PRESENT
        indent          = stloopkernel.first_line_indent()
        default_clauses = translator.acc_clause_default.searchString(stloopkernel.single_line_statement(),1)
        if len(default_clauses):
            value = str(default_clauses[0][0][0]).lower()
            #print(value)
            if value == "present":
                for var_expr in unmapped_arrays:
                    deviceptr = dev_var_name(var_expr)
                    temp_vars.append(deviceptr)
                    result += template.format(indent=indent,var=var_expr,asyncr="",alloc="",dev_var=deviceptr)
            elif value == "none" and len(unmapped_arrays):
                    utils.logging.log_warning(LOG_PREFIX,"AccLoopKernel2HipGpufortRT._handle_default","'default(none)' specified but no map for the following variables found: ".format(", ".join(unmapped_arrays)))
        else: # default strategy: present_or_copy
            for var_expr in unmapped_arrays:
                deviceptr = dev_var_name(var_expr)
                if not deviceptr in temp_vars: 
                    temp_vars.append(deviceptr)
                    result += template.format(indent=indent,var=var_expr,asyncr="",alloc=",copy=.TRUE.",dev_var=deviceptr)
               
        return result, len(result), temp_vars
    def transform(self,joined_lines,joined_statements,statements_fully_cover_lines,index=[]):
        result = ""
        stloopkernel   = self._stnode
        ttloopkernel   = stloopkernel.parse_result
        arrays_in_body = ttloopkernel.arrays_in_body()
        indent         = stloopkernel.first_line_indent()
        if stloopkernel.is_parallel_loop_directive() or stloopkernel.is_kernels_loop_directive():
            result, _ = Acc2HipGpufortRT.transform(self,joined_lines,joined_statements,statements_fully_cover_lines,index,handle_if=False) 
        partial_result, transformed, temp_vars = self._handle_default()
        if transformed:
            add_device_vars_to_decl_list(stloopkernel._parent,temp_vars)
            result = result.rstrip("\n") + "\n" + partial_result
        partial_result, _ = STLoopKernel.transform(stloopkernel,joined_lines,joined_statements,statements_fully_cover_lines,index) 
        result = result.rstrip("\n") + "\n" + partial_result
  
        # handle default
        self._handle_default()
        # add wait call if necessary
        queue = self._handle_async(None,"")
        if not len(queue):
            result = result.rstrip("\n") + "\n" + HIP_GPUFORT_RT_ACC_WAIT.format(indent=indent,queue=queue,asyncr="")
        #if stloopkernel.is_parallel_loop_directive() or stloopkernel.is_kernels_loop_directive():
        if stloopkernel.is_kernels_loop_directive() or stloopkernel.is_parallel_loop_directive():
            result = result.rstrip("\n") + "\n" + HIP_GPUFORT_RT_ACC_EXIT_REGION.format(indent=indent,region_kind="")
        # wrap in ifdef if necessary
        condition = self._handle_if()
        if len(condition):
            result = "if ( {condition} ) then\n{result}\nelse\n {original}\n endif".format(\
                    condition=condition, result=result.rstrip("\n"), original="".join(stloopkernel._lines).rstrip("\n"))
        return result, len(result)

class Acc2HipGpufortRTPostprocess(AccPostprocessBackendBase):
    def run(self,stree,index):
        """:param stree: the full scanner tree
           :param staccdirectives: All acc directive tree nodes."""
        utils.logging.log_enter_function(LOG_PREFIX,"Acc2HipGpufortRTPostprocess.run")
        
        # TODO check if there is any acc used in the 
        # construct at all
        # TODO handle directly via directives; only variables occuring
        # in directives need to be available on device
        containers = stree.find_all(\
          lambda node: type(node) in [STProgram,STProcedure],
          recursively=True)
        for stcontainer in containers:
            last_decl_list_node = stcontainer.last_entry_in_decl_list()
            allocates   = [] # look up STAllocate 
            deallocates = [] # look up STDeallocate
            indent = last_decl_list_node.first_line_indent()
            # todo find return statement or end of function
            scope      = scoper.create_scope(index,stcontainer.tag())
            scope_vars = scope["variables"]
            local_var_names, dummy_arg_names = stcontainer.local_and_dummy_variable_names(index)
            # TODO also process type members
            acc_present_calls = ""
            temp_vars         = []
            implicit_region   = False
            for ivar in scope_vars:
                host_var           = ivar["name"]
                dev_var            = dev_var_name(host_var)
                is_local_var       = host_var in local_var_names
                is_arg             = host_var in dummy_arg_names
                is_used_module_var = not is_local_var and not is_arg
                is_allocatable     = "allocatable" in ivar["qualifiers"]
                is_pointer         = "pointer" in ivar["qualifiers"]
                if not is_allocatable:
                    if not is_used_module_var: implicit_region = True  
                    global_var = ",global=.TRUE." if is_used_module_var else ""
                    cond       = "if (associated({var})) " if is_pointer else ""
                    acc_present_template = (cond+HIP_GPUFORT_RT_ACC_PRESENT)
                    # find return and end, emit 1 new implicit region for all
                    if ivar["declare_on_target"] in HIP_GPUFORT_RT_CLAUSES_OMP2ACC.keys():
                        map_kind=HIP_GPUFORT_RT_CLAUSES_OMP2ACC[ivar["declare_on_target"]]
                        acc_present_calls += acc_present_template.format(\
                            indent=indent,var=host_var,asyncr="",\
                            alloc=global_var+","+map_kind+"=.TRUE.",dev_var=dev_var)
                        temp_vars.append(dev_var)
            if len(acc_present_calls):
                add_device_vars_to_decl_list(stcontainer,temp_vars)
                if implicit_region: add_implicit_region(stcontainer)
                last_decl_list_node.add_to_epilog(acc_present_calls)
        
        utils.logging.log_leave_function(LOG_PREFIX,"Acc2HipGpufortRTPostprocess.run")

def AllocateHipGpufortRT(stallocate,index):
   stcontainer = stallocate._parent
   parent_tag  = stcontainer.tag()
   scope       = scoper.create_scope(index,parent_tag)
   scope_vars  = scope["variables"]
   indent      = stallocate.first_line_indent()
   local_var_names, dummy_arg_names = stcontainer.local_and_dummy_variable_names(index)
   acc_present_calls = "" 
   temp_vars         = []
   implicit_region   = False
   for var in stallocate.variable_names:
       ivar,_ = scoper.search_index_for_variable(index,parent_tag,var)
       host_var           = ivar["name"]
       dev_var            = dev_var_name(host_var)
       is_local_var       = host_var in local_var_names
       is_arg             = host_var in dummy_arg_names
       is_used_module_var = not is_local_var and not is_arg
       is_allocatable_or_pointer = "allocatable" in ivar["qualifiers"] or\
                            "pointer" in ivar["qualifiers"]
       assert is_allocatable_or_pointer
       global_var = ",global=.TRUE." if is_used_module_var else ""
       if not is_used_module_var: implicit_region = True  
       if ivar["declare_on_target"] in HIP_GPUFORT_RT_CLAUSES_OMP2ACC.keys():
           map_kind=HIP_GPUFORT_RT_CLAUSES_OMP2ACC[ivar["declare_on_target"]]
           acc_present_calls += acc_present_template.format(\
               indent=indent,var=host_var,asyncr="",\
               alloc=global_var+","+map_kind+"=.TRUE.",dev_var=dev_var)
           temp_vars.append(dev_var)

    if len(acc_present_calls):
        add_device_vars_to_decl_list(stcontainer,temp_vars)
        if implicit_region: add_implicit_region(stcontainer)
        stallocate.add_to_epilog(acc_present_calls)

def DeallocateHipGpufortRT(stdeallocate,index):
   stcontainer = stdeallocate._parent
   parent_tag  = stcontainer.tag()
   scope       = scoper.create_scope(index,parent_tag)
   scope_vars  = scope["variables"]
   indent      = stdeallocate.first_line_indent()
   local_var_names, dummy_arg_names = stcontainer.local_and_dummy_variable_names(index)
   acc_delete_calls = "" 
   temp_vars         = []
   implicit_region   = False
   for var in stdeallocate.variable_names:
       ivar,_ = scoper.search_index_for_variable(index,parent_tag,var)
       host_var           = ivar["name"]
       dev_var            = dev_var_name(host_var)
       is_local_var       = host_var in local_var_names
       is_arg             = host_var in dummy_arg_names
       is_used_module_var = not is_local_var and not is_arg
       is_allocatable_or_pointer = "allocatable" in ivar["qualifiers"] or\
                            "pointer" in ivar["qualifiers"]
       assert is_allocatable_or_pointer
       global_var = ",global=.TRUE." if is_used_module_var else ""
       if ivar["declare_on_target"] in ["alloc","to","tofrom"]:
           acc_delete_calls += HIP_GPUFORT_RT_ACC_DELETE.format(\
               indent=indent,var=host_var,asyncr="",alloc=global_var+",create=.TRUE.",dev_var=dev_var)
           temp_vars.append(dev_var)
    if len(acc_delete_calls):
        add_device_vars_to_decl_list(stcontainer,temp_vars)
        stdeallocate.add_to_epilog(acc_delete_calls)
        if implicit_region:
           add_implicit_region(stcontainer)

register_acc_backend("hip-gpufort-rt",\
  Acc2HipGpufortRT,\
  AccLoopKernel2HipGpufortRT,\
  Acc2HipGpufortRTPostprocess,\
  AllocateHipGpufortRT,\
  DeallocateHipGpufortRT,\
  "gpufort_acc_runtime")
