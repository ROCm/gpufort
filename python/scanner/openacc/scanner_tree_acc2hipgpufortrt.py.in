# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 Advanced Micro Devices, Inc. All rights reserved.
# init shutdown
HIP_GPUFORT_RT_ACC_INIT     = "{indent}call gpufort_acc_init()\n"
HIP_GPUFORT_RT_ACC_SHUTDOWN = "{indent}call gpufort_acc_shutdown()\n"
# regions
HIP_GPUFORT_RT_ACC_ENTER_REGION = "{indent}call gpufort_acc_enter_region({region_kind})\n"
HIP_GPUFORT_RT_ACC_EXIT_REGION = "{indent}call gpufort_acc_exit_region({region_kind})\n"
# create
HIP_GPUFORT_RT_ACC_CREATE = "{indent}{dev_var} = gpufort_acc_create({var})\n"
# no_create
HIP_GPUFORT_RT_ACC_NO_CREATE = "{indent}{dev_var} = gpufort_acc_no_create({var})\n"
# delete
HIP_GPUFORT_RT_ACC_DELETE = "{indent}call gpufort_acc_delete({var}{finalize})\n"
# copyin
HIP_GPUFORT_RT_ACC_COPYIN = "{indent}{dev_var} = gpufort_acc_copyin({var}{asyncr})\n"
# copy
HIP_GPUFORT_RT_ACC_COPY = "{indent}{dev_var} = gpufort_acc_copy({var}{asyncr})\n"
# copyout
HIP_GPUFORT_RT_ACC_COPYOUT = "{indent}{dev_var} = gpufort_acc_copyout({var}{asyncr})\n"
# update
HIP_GPUFORT_RT_ACC_UPDATE = "{indent}call gpufort_acc_update_{kind}({var}{asyncr})\n"
# present
HIP_GPUFORT_RT_ACC_PRESENT = "{indent}{dev_var} = gpufort_acc_present({var}{asyncr}{alloc})\n"
# wait
HIP_GPUFORT_RT_ACC_WAIT = "{indent}call gpufort_acc_wait({queue}{asyncr})\n"

MAPPING_CLAUSE_2_TEMPLATE_MAP = {
  "create": HIP_GPUFORT_RT_ACC_CREATE,
  "no_create": HIP_GPUFORT_RT_ACC_NO_CREATE,
  "delete": HIP_GPUFORT_RT_ACC_DELETE,
  "copyin": HIP_GPUFORT_RT_ACC_COPYIN,
  "copy": HIP_GPUFORT_RT_ACC_COPY,
  "copyout": HIP_GPUFORT_RT_ACC_COPYOUT,
  "present": HIP_GPUFORT_RT_ACC_PRESENT
}

def dev_var_name(var):
    #tokens = var.split("%")
    #tokens[-1] = ACC_DEV_PREFIX+tokens[-1]+ACC_DEV_SUFFIX
    #return "%".join(tokens)
    result = var.replace("%","_")
    result = result.replace("(","$")
    result = result.replace(")","$")
    result = "".join(c for c in result if c.isalnum() or c in "_$")
    result = result.replace("$$","")
    result = result.replace("$","_")
    return ACC_DEV_PREFIX + result + ACC_DEV_SUFFIX

def _intrnl_add_device_vars_to_decl_list(stnode,temp_vars):
    # introduce the new variables 
    if len(temp_vars):
        last_decl_list_node = stnode.last_entry_in_decl_list()
        indent              = last_decl_list_node.first_line_indent()
        if last_decl_list_node is None:
            last_decl_list_node = stnode
        for var in temp_vars:
            last_decl_list_node.add_to_epilog("{indent}type(c_ptr) :: {name}\n".format(indent=indent,name=var))

class Acc2HipGpufortRT(AccBackendBase):
    # clauses 
    def _handle_async(self,queue=None,prefix=",asyncr="):
        """
        :return: Empty string if no queue was found
        :rtype: str
        """
        result = ""
        if queue is None:
            for parse_result in translator.acc_clause_async.searchString(queue,1):
                #print(parse_result)
                # TODO find ...
                result = parse_result[0].queue()
        if len(result):
           result = prefix + result
        return result
    def _handle_finalize(self):
        """
        :return: If a finalize clause is present
        :rtype: bool
        """
        return len(translator.acc_clause_finalize.searchString(self.single_line_statement(),1))
    def _handle_mapping_clauses(self):
        """
        """
        result = ""
        temp_vars = set()
        indent = self._stnode.first_line_indent()
        #
        for parse_result in translator.acc_mapping_clause.scanString(self._stnode.single_line_statement()):
            clause         = parse_result[0][0]
            if clause.kind in MAPPING_CLAUSE_2_TEMPLATE_MAP:
                var_names       = clause.var_names()
                var_expressions = clause.var_expressions()
                for i,var_expr in enumerate(var_expressions):
                    deviceptr = dev_var_name(var_names[i])
                    template = MAPPING_CLAUSE_2_TEMPLATE_MAP[clause.kind]
                    result += template.format(indent=indent,var=var_expr,dev_var=deviceptr,asyncr=self._handle_async(),alloc="")
                    temp_vars.add(deviceptr)
        return result, len(result), temp_vars
    def _handle_update(self):
        """
        Emits a acc_clause_update command for every variable in the list
        """
        result = ""
        indent = self._stnode.first_line_indent()
        # update host
        for parse_result in translator.acc_mapping_clause.scanString(self._stnode.single_line_statement()):
            clause = parse_result[0][0]
            if clause.kind in ["self","host","device"]:
                clause_kind = "host" if clause.kind=="self" else clause.kind
                var_expressions = clause.var_expressions()
                for i,var_expr in enumerate(var_expressions):
                    result += HIP_GPUFORT_RT_ACC_UPDATE.format(indent=indent,var=var_expr,asyncr=self._handle_async(),kind=clause_kind)
        return result, len(result)
    def _handle_wait(self):
        """
        Emits a acc_clause_wait command for every variable in the list
        """
        result = ""
        temp_vars = set()
        # wait
        indent = self._stnode.first_line_indent()
        template = HIP_GPUFORT_RT_ACC_WAIT
        for parse_result in translator.acc_clause_wait.scanString(self._stnode.single_line_statement()):
            queue_list=[]
            asyncr_list=[]
            for rvalue in parse_result[0][0]: # queue ids
                queue_list.append(rvalue.var_name())
            for rvalue in parse_result[0][1]: # asyncr queue ids
                asyncr_list.append(rvalue.var_name())
            queue=""
            asyncr=""
            if len(queue_list):
                queue = ",[{}]".format(",".join(queue_list))
            if len(asyncr_list):
                asyncr = ",[{}]".format(",".join(asyncr_list))
            result += template.format(indent=indent,queue=queue,asyncr=asyncr)
        return result, len(result), temp_vars
    def _handle_if(self):
        """
        :return: Empty string if no if was found
        :rtype: str
        """
        condition = ""
        for parse_result in translator.acc_clause_if.searchString(self._stnode.single_line_statement(),1):
            condition = parse_result[0].condition()
        return condition
    def transform(self,joined_lines,joined_statements,statements_fully_cover_lines,index=[],handle_if=True):
        """
        :param line: An excerpt from a Fortran file, possibly multiple lines
        :type line: str
        :return: If the text was changed at all
        :rtype: bool
        """
        result = ""
        all_temp_vars = set()
        
        ## Init 
        stnode = self._stnode
        indent = stnode.first_line_indent()
        if stnode.is_init_directive():
            result += HIP_GPUFORT_RT_ACC_INIT.format(indent=indent)
        elif stnode.is_update_directive():
            partial_result, transformed = self._handle_update()
            if transformed:
                result += partial_result
        elif stnode.is_shutdown_directive():
            result += HIP_GPUFORT_RT_ACC_SHUTDOWN.format(indent=indent)
        else: 
            ## Enter region commands must come first
            emit_enter_region = stnode.is_enter_data_directive()
            if emit_enter_region:
                region_kind="region_kind=.TRUE."
            else:
                region_kind=""
            emit_enter_region = emit_enter_region or stnode.is_data_directive()
            emit_enter_region = emit_enter_region or stnode.is_parallel_directive()
            emit_enter_region = emit_enter_region or stnode.is_parallel_loop_directive() 
            emit_enter_region = emit_enter_region or stnode.is_kernels_directive()
            emit_enter_region = emit_enter_region or stnode.is_kernels_loop_directive()
            if emit_enter_region:
                result += HIP_GPUFORT_RT_ACC_ENTER_REGION.format(indent=indent,region_kind=region_kind)

            ## Other directives/clauses
            partial_result, transformed, temp_vars = self._handle_mapping_clauses()
            if transformed:
                result += partial_result
                all_temp_vars.update(temp_vars)
            
            ## wait
            partial_result, transformed, _ = self._handle_wait()
            if transformed:
                result += partial_result
            
            ## Exit region commands must come last
            emit_exit_region = stnode.is_exit_data_directive()
            if emit_exit_region:
                region_kind="region_kind=.TRUE."
            else:
                region_kind=""
            emit_exit_region = emit_exit_region or (stnode.is_end_directive() and stnode.find_substring("kernels") and not stnode.find_substring("loop"))
            emit_exit_region = emit_exit_region or (stnode.is_end_directive() and stnode.find_substring("parallel") and not stnode.find_substring("loop"))
            emit_exit_region = emit_exit_region or (stnode.is_end_directive() and stnode.find_substring("data"))
            if emit_exit_region:
                result += HIP_GPUFORT_RT_ACC_EXIT_REGION.format(indent=indent,region_kind=region_kind)
       
        # _handle if 
        condition = self._handle_if()
        if len(condition) and handle_if:
            result = "if ( {condition} ) then\n{result}\n endif".format(\
                    condition=condition, result=result.rstrip("\n"))
       
        # introduce the new variables 
        _intrnl_add_device_vars_to_decl_list(stnode._parent,all_temp_vars)

        return result, len(result)

class AccLoopKernel2HipGpufortRT(Acc2HipGpufortRT):
    def _handle_default(self):
        """
        Emits a acc_clause_present command for every variable in the list
        """
        stloopkernel    = self._stnode
        ttloopkernel    = stloopkernel.parse_result
        unmapped_arrays = ttloopkernel.all_unmapped_arrays()
        
        result          = ""
        temp_vars       = []
        "{indent}{dev_var} = gpufort_acc_present({var}{asyncr}{alloc})\n"
        template        = HIP_GPUFORT_RT_ACC_PRESENT
        indent          = stloopkernel.first_line_indent()
        default_clauses = translator.acc_clause_default.searchString(stloopkernel.single_line_statement(),1)
        if len(default_clauses):
            value = str(default_clauses[0][0][0]).lower()
            #print(value)
            if value == "present":
                for var_expr in unmapped_arrays:
                    deviceptr = dev_var_name(var_expr)
                    temp_vars.append(deviceptr)
                    result += template.format(indent=indent,var=var_expr,asyncr="",alloc="",dev_var=deviceptr)
            elif value == "none" and len(unmapped_arrays):
                    utils.logging.log_warning(LOG_PREFIX,"AccLoopKernel2HipGpufortRT._handle_default","'default(none)' specified but no map for the following variables found: ".format(", ".join(unmapped_arrays)))
        else: # default strategy: present_or_copy
            for var_expr in unmapped_arrays:
                deviceptr = dev_var_name(var_expr)
                if not deviceptr in temp_vars: 
                    temp_vars.append(deviceptr)
                    result += template.format(indent=indent,var=var_expr,asyncr="",alloc=",copy=.TRUE.",dev_var=deviceptr)
               
        return result, len(result), temp_vars
    def transform(self,joined_lines,joined_statements,statements_fully_cover_lines,index=[]):
        result = ""
        stloopkernel   = self._stnode
        ttloopkernel   = stloopkernel.parse_result
        arrays_in_body = ttloopkernel.arrays_in_body()
        indent         = stloopkernel.first_line_indent()
        if stloopkernel.is_parallel_loop_directive() or stloopkernel.is_kernels_loop_directive():
            result, _ = Acc2HipGpufortRT.transform(self,joined_lines,joined_statements,statements_fully_cover_lines,index,handle_if=False) 
        partial_result, transformed, temp_vars = self._handle_default()
        if transformed:
            _intrnl_add_device_vars_to_decl_list(stloopkernel._parent,temp_vars)
            result = result.rstrip("\n") + "\n" + partial_result
        partial_result, _ = STLoopKernel.transform(stloopkernel,joined_lines,joined_statements,statements_fully_cover_lines,index) 
        result = result.rstrip("\n") + "\n" + partial_result
  
        # handle default
        self._handle_default()
        # add wait call if necessary
        queue = self._handle_async(None,"")
        if not len(queue):
            result = result.rstrip("\n") + "\n" + HIP_GPUFORT_RT_ACC_WAIT.format(indent=indent,queue=queue,asyncr="")
        #if stloopkernel.is_parallel_loop_directive() or stloopkernel.is_kernels_loop_directive():
        if stloopkernel.is_kernels_loop_directive() or stloopkernel.is_parallel_loop_directive():
            result = result.rstrip("\n") + "\n" + HIP_GPUFORT_RT_ACC_EXIT_REGION.format(indent=indent,region_kind="")
        # wrap in ifdef if necessary
        condition = self._handle_if()
        if len(condition):
            result = "if ( {condition} ) then\n{result}\nelse\n {original}\n endif".format(\
                    condition=condition, result=result.rstrip("\n"), original="".join(stloopkernel._lines).rstrip("\n"))
        return result, len(result)

class Acc2HipGpufortRTPostprocess(AccPostprocessBackendBase):
    def run(self,stree,index):
        """:param stree: the full scanner tree
           :param staccdirectives: All acc directive tree nodes."""
        utils.logging.log_enter_function(LOG_PREFIX,"Acc2HipGpufortRTPostprocess.run")
        
        # TODO check if there is any acc used in the 
        # construct at all
        fortran_constructs = stree.find_all(\
                lambda node: type(node) in [STProgram,STProcedure],
                recursively=True)
        for stnode in fortran_constructs:
            last_decl_list_node = stnode.last_entry_in_decl_list()
            allocates   = [] # look up STAllocate 
            deallocates = [] # look up STDeallocate
            indent = last_decl_list_node.first_line_indent()
            # todo find return statement or end of function
            scope      = scoper.create_scope(index,stnode.tag())
            scope_vars = scope["variables"]
            if type(stnode) == STProgram:
                irecord = next((ientry for ientry in index if ientry["name"]==stnode.name),None)
                dummy_arg_names = []
            else:
                parent_tag = stnode._parent.tag()
                irecord, _ = scoper.search_index_for_subprogram(index,parent_tag,stnode.name)
                dummy_arg_names = irecord["dummy_args"] 
            local_var_names = [ivar["name"] for ivar in irecord["variables"] if ivar["name"] not in dummy_arg_names]
            # TODO also process type members
            acc_present_calls = ""
            temp_vars = []
            for ivar in scope_vars:
                host_var           = ivar["name"]
                dev_var            = dev_var_name(host_var)
                is_local_var       = host_var in local_var_names
                is_arg             = host_var in dummy_arg_names
                is_used_module_var = not is_local_var and not is_arg
                is_allocatable_or_pointer = "allocatable" in ivar["qualifiers"] or\
                                         "pointer" in ivar["qualifiers"]
                if (is_arg or is_local_var) and not is_allocatable_or_pointer:
                    # find return and end, emit 1 new implicit region for all
                    if ivar["declare_on_target"]=="alloc":
                        acc_present_calls += HIP_GPUFORT_RT_ACC_PRESENT.format(\
                            indent=indent,var=host_var,asyncr="",alloc=",create=.TRUE.",dev_var=dev_var)
                        temp_vars.append(dev_var)
                    if ivar["declare_on_target"]=="to":
                        acc_present_calls += HIP_GPUFORT_RT_ACC_PRESENT.format(\
                            indent=indent,var=host_var,asyncr="",alloc=",copyin=.TRUE.",dev_var=dev_var)
                        temp_vars.append(dev_var)
                elif (is_arg or is_local_var) and is_allocatable_or_pointer:
                    # find return and end, emit 1 new (un)structured region for all
                    # find allocate, deallocate with var as arg and write to epilog / prolog
                    pass
                elif is_used_module_var and not is_allocatable_or_pointer:
                    # ensure it is present in implicit region 0 / static data
                    pass
                elif is_used_module_var and is_allocatable_or_pointer:
                    # find allocate, deallocate and write to epilog / prolog -> append to implicit region 0 / static data
                    pass
            # first add the device variable declarations
            _intrnl_add_device_vars_to_decl_list(stnode,temp_vars)
            if len(acc_present_calls):
                last_decl_list_node.add_to_epilog(HIP_GPUFORT_RT_ACC_ENTER_REGION.format(\
                    indent=indent,region_kind="implicit_region=.TRUE."))
                last_decl_list_node.add_to_epilog(acc_present_calls)
                for stendorreturn in stnode.return_or_end_statements():
                    stendorreturn.add_to_prolog(HIP_GPUFORT_RT_ACC_EXIT_REGION.format(\
                        indent=indent,region_kind="implicit_region=.TRUE."))
        
        utils.logging.log_leave_function(LOG_PREFIX,"Acc2HipGpufortRTPostprocess.run")

register_acc_backend("hip-gpufort-rt",\
  Acc2HipGpufortRT,\
  AccLoopKernel2HipGpufortRT,\
  Acc2HipGpufortRTPostprocess,\
  "gpufort_acc_runtime")
