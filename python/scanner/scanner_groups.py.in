# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.
class STGroup():
    def __init__(self):
        self._objects = []
        self._minLineno = 10**20
        self._maxLineno = -1
        self._records = []
    def borders(self,stnode):
        """
        Check if a object tree node borders this `ObjectGroup`.
        :param stnode: an object tree node
        :return: `True` if this group is empty or if its max line number is exactly one smaller than the min line no of `otnode`. Returns `False` otherwise.
        :rtype: bool
        """
        assert stnode.minLineno() >= self._maxLineno, "{0} >= {1}: False, type of new node: {2}, code line: {3}".format(\
                stnode.minLineno(),self._maxLineno,type(stnode),"".join(stnode.lines()))
        return not len(self._objects) or (stnode.minLineno() - self._maxLineno <= 1)
    def lines(self):
        """
        :return: Original code lines associated with this group.
        :rtype: list
        """
        result = []
        for record in self._records:
            result.append(record["lines"]
        return result
    def expandedStatements(self):
        """
        :return: All statements extracted from the code lines associated with this groups.
                 Statements spreading over multiple lines are transformed into a single statement.
                 Multiple statements per source code line that are separated by ";" are converted to single
                 statements.
                 Single-line if statements are transformed to if-then-endif blocks.
                 Macros are expanded and the above transformations have been applied again.
        :rtype: list
        """
        result = []
        for record in self._records:
            for statement in record["expandedStatements"]:
                result.append(statement.rstrip("\n")).
        return result
    def add(self,stnode):
        """
        Add an object node to this object group.
        :note: Use the `borders` method to check if it makes sense to add this node to this group.
        :param stnode: an object tree node
        """
        assert stnode.minLineno() >= self._maxLineno
        assert self._maxLineno < 0 or stnode.minLineno() - self._maxLineno <= 1
        if not len(self._objects):
            self._minLineno = stnode.minLineno()
        for record in stnode._records:
            if record["lineo"] > self._maxLineno:
                self._records.append(record)
        # TODO(debug) keep a while for reference
        #for i in range(stnode.minLineno(),stnode.maxLineno()+1): # maxLineno is inclusive
        #    if i > self._maxLineno:
        #        self._lines.append(stnode.lines()[i-stnode.minLineno()])
        self._maxLineno = max(self._maxLineno, stnode.maxLineno())
        self._objects.append(stnode)
    def generateCode(self,indexHints,wrapInIfdef):
        """
        Generates code from all objects in the group.
        If the original code is modified,
        the code will be wrapped in an ifdef.
        """
        assert False

class MatchAllGroup(STGroup):
    def generateCode(self,indexHints,wrapInIfdef):
        """
        Generates code from all objects in the group.
        If the original code is modified,
        the code will be wrapped in an ifdef.
        """
        orginalLines = self.lines() # terminated by '\n'
        linesToSkip  = len(originalLines)-1
        performedTransformation = False

        result   = "\n".join(self.expandedStatements) # not terminated by '\n'
        preamble = ""
        epilog   = ""
        processedTypes = set()
        def typeHasAlreadyBeenProcessed(stnode):
            alreadyProcessed = type(stnode) in processedTypes
            processedTypes.add(type(stnode))
            return alreadyProcessed
        for stnode in self._objects:
            #print(stnode)
            if not typeHasAlreadyBeenProcessed(stnode):
                result, transformed = stnode.transformFSnippet(result,indexHints) # TODO
                performedTransformation |= transformed
                if len(stnode.preamble()): 
                    preamble += stnode.preamble().rstrip("\n")+"\n"
                if len(stnode.epilog()): 
                    epilog += stnode.epilog().rstrip("\n")+"\n"
        result = result.rstrip("\n")
        if performedTransformation or len(preamble) or len(epilog):
            if len(epilog):
                epilog = "\n" + epilog
            if wrapInIfdef:
                original = "".join(originalLines).rstrip("\n")
                return """#ifdef {0}
{1}{2}{3}
#else
{4}
#endif""".format(GPUFORT_IFDEF,preamble,result,epilog,original).split("\n"), linesToSkip
            else:
                return "{0}{1}{2}".format(preamble,result,epilog).split("\n"), linesToSkip
        else:
            return self._lines, linesToSkip

class OneByOneGroup(STGroup):
    def generateCode(self,indexHints,wrapInIfdef):
        """
        Generates code from all objects in the group.
        If the original code is modified,
        the code will be wrapped in an ifdef.
        """
        orginalLines = self.lines()
        linesToSkip  = len(originalLines)-1
        performedTransformation = False
        result = ""
        preamble = ""
        epilog   = ""
        for stnode in self._objects:
            fStr, transformed = stnode.gpufortFStr(indexHints) # TODO
            result += fStr.rstrip("\n")+"\n"
            performedTransformation |= transformed
            if len(stnode.preamble()): 
                preamble += stnode.preamble().rstrip("\n")+"\n"
            if len(stnode.epilog()): 
                epilog += stnode.epilog().rstrip("\n")+"\n"
            #print(stnode.lines())
        if performedTransformation or len(preamble) or len(epilog):
            if len(epilog):
                epilog = "\n" + epilog
            if wrapInIfdef:
                original = "".join(originalLines).strip("\n")
                result = result.rstrip("\n")
                return """#ifdef {0}
{1}{2}{3}
#else
{4}
#endif""".format(GPUFORT_IFDEF,preamble,result,epilog,original).split("\n"), linesToSkip
            else:
                return "{0}{1}{2}".format(preamble,result,epilog).split("\n"), linesToSkip
        else:
            return self._lines, linesToSkip
 
def groupObjects(stree,index):
    """ 
    Groups object tree nodes and puts each group into a map that is indexed by the line number of the first node in a group.
    :return: a dict mapping line numbers to groups
    :rtype: dict
    :note: Must be called before declarations from other modules are loaded T
    """ # TODO comment still valid?
    def transformOneByOne(stnode):
        return type(stnode) in  [STAttributes,STDeclaration,STUseStatement,STPlaceHolder,STProcedure,STAccDirective] or isinstance(stnode,STLoopKernel)
    groups = [ MatchAllGroup() ]
    def descend(curr):
        for stnode in curr._children:
            # TODO(cleanup)
            #utils.logging.logDebug3(LOG_PREFIX,"groupObjects","{}-{}: ".format(stnode._lineno,stnode._lineno+len(stnode.lines()))+str(stnode)))
            if stnode.considerInS2STranslation(index):
                # insert new group if necessary
                if not groups[-1].borders(stnode): 
                    if transformOneByOne(stnode): # TODO two groups. One contains data, the other can match anything
                        groups.append(OneByOneGroup())
                    else:
                        groups.append(MatchAllGroup())
                else:
                    if type(groups[-1]) is MatchAllGroup and transformOneByOne(stnode):
                        groups.append(OneByOneGroup())
                    elif type(groups[-1]) is OneByOneGroup and not transformOneByOne(stnode):
                        groups.append(MatchAllGroup())
                groups[-1].add(stnode)
            descend(stnode)
    descend(stree)      
    groupMap = {}
    for group in groups:
         groupMap[group._minLineno] = group
    return groupMap
