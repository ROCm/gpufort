# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.
class STGroup():
    def __init__(self):
        self._objects = []
        self._minLineno = 10**20
        self._maxLineno = -1
        self._lines = []
    def borders(self,stnode):
        """
        Check if a object tree node borders this `ObjectGroup`.
        :param stnode: an object tree node
        :return: `True` if this group is empty or if its max line number is exactly one smaller than the min line no of `otnode`. Returns `False` otherwise.
        :rtype: bool
        """
        #print(stnode.minLineno())
        #print("<<<"+"".join(stnode.lines()))
        assert stnode.minLineno() >= self._maxLineno, "{0} >= {1}: False, type of new node: {2}, code line: {3}".format(\
                stnode.minLineno(),self._maxLineno,type(stnode),"".join(stnode.lines()))
        return not len(self._objects) or (stnode.minLineno() - self._maxLineno <= 1)
    def add(self,stnode):
        """
        Add an object node to this object group.
        :note: Use the `borders` method to check if it makes sense to add this node to this group.
        :param stnode: an object tree node
        """
        #print("".join(stnode.lines()))
        assert stnode.minLineno() >= self._maxLineno
        assert self._maxLineno < 0 or stnode.minLineno() - self._maxLineno <= 1
        if not len(self._objects):
            self._minLineno = stnode.minLineno()
        for i in range(stnode.minLineno(),stnode.maxLineno()+1): # maxLineno is inclusive
            if i > self._maxLineno:
                self._lines.append(stnode.lines()[i-stnode.minLineno()])
        self._maxLineno = max(self._maxLineno, stnode.maxLineno())
        self._objects.append(stnode)
    def strippedContent(self):
        """
        :return: The stripped content of this object as text. The functions removes all
        comments and Fortran linebreak characters '&'.
        :rettype: str
        """
        result = "".join(self._lines)
        comment = Literal("!") + ~(~White()+Literal("$")) + restOfLine + Optional(Regex(r"\n")) # via pyparsing
        amperSand = Regex(r"&\n")
        comment.setParseAction(lambda tokens: "") # remove comments
        amperSand.setParseAction(lambda tokens: "") # remove &
        result2 = comment.transformString(result)
        result2 = amperSand.transformString(result)
        try:
           result = translator.singleLineIf.transformString(result2)
        except:
           result = result2
        return result
    def generateCode(self,indexHints,wrapInIfdef):
        """
        Generates code from all objects in the group.
        If the original code is modified,
        the code will be wrapped in an ifdef.
        """
        assert False

class MatchAllGroup(STGroup):
    def generateCode(self,indexHints,wrapInIfdef):
        """
        Generates code from all objects in the group.
        If the original code is modified,
        the code will be wrapped in an ifdef.
        """
        linesToSkip = len(self._lines)-1
        performedTransformation = False
        result = self.strippedContent()
        preamble = ""
        epilog   = ""
        processedTypes = set()
        def typeHasAlreadyBeenProcessed(stnode):
            alreadyProcessed = type(stnode) in processedTypes
            processedTypes.add(type(stnode))
            return alreadyProcessed
        for stnode in self._objects:
            #print(stnode)
            if not typeHasAlreadyBeenProcessed(stnode):
                result, transformed = stnode.transformFSnippet(result,indexHints) # TODO
                performedTransformation |= transformed
                if len(stnode.preamble()): 
                    preamble += stnode.preamble().rstrip("\n")+"\n"
                if len(stnode.epilog()): 
                    epilog += stnode.epilog().rstrip("\n")+"\n"
        result = result.rstrip("\n")
        if performedTransformation or len(preamble) or len(epilog):
            if len(epilog):
                epilog = "\n" + epilog
            if wrapInIfdef:
                original = "".join(self._lines).rstrip("\n")
                return """#ifdef {0}
{1}{2}{3}
#else
{4}
#endif""".format(GPUFORT_IFDEF,preamble,result,epilog,original).split("\n"), linesToSkip
            else:
                return "{0}{1}{2}".format(preamble,result,epilog).split("\n"), linesToSkip
        else:
            return self._lines, linesToSkip

class OneByOneGroup(STGroup):
    def generateCode(self,indexHints,wrapInIfdef):
        """
        Generates code from all objects in the group.
        If the original code is modified,
        the code will be wrapped in an ifdef.
        """
        linesToSkip = len(self._lines)-1
        performedTransformation = False
        result = ""
        preamble = ""
        epilog   = ""
        for stnode in self._objects:
            fStr, transformed = stnode.gpufortFStr(indexHints) # TODO
            result += fStr.rstrip("\n")+"\n"
            performedTransformation |= transformed
            if len(stnode.preamble()): 
                preamble += stnode.preamble().rstrip("\n")+"\n"
            if len(stnode.epilog()): 
                epilog += stnode.epilog().rstrip("\n")+"\n"
            #print(stnode.lines())
        if performedTransformation or len(preamble) or len(epilog):
            if len(epilog):
                epilog = "\n" + epilog
            if wrapInIfdef:
                original = "".join(self._lines).strip("\n")
                result = result.rstrip("\n")
                return """#ifdef {0}
{1}{2}{3}
#else
{4}
#endif""".format(GPUFORT_IFDEF,preamble,result,epilog,original).split("\n"), linesToSkip
            else:
                return "{0}{1}{2}".format(preamble,result,epilog).split("\n"), linesToSkip
        else:
            return self._lines, linesToSkip
 
def groupObjects(stree):
    """ 
    Groups object tree nodes and puts each group into a map that is indexed by the line number of the first node in a group.
    :return: a dict mapping line numbers to groups
    :rtype: dict
    :note: Must be called before declarations from other modules are loaded T
    """ # TODO comment still valid?
    def transformOneByOne(stnode):
        return type(stnode) in  [STDeclaration,STUseStatement,STPlaceHolder,STSubroutine,STAccDirective] or isinstance(stnode,STLoopKernel)
    groups = [ MatchAllGroup() ]
    def descend(curr):
        for stnode in curr._children:
            logging.getLogger("").debug("scanner:groubObjects(...):\t{0}".format("{}-{}: ".format(stnode._lineno,stnode._lineno+len(stnode.lines()))+str(stnode)))
            if stnode.considerInS2STranslation():
                # insert new group if necessary
                if not groups[-1].borders(stnode): 
                    if transformOneByOne(stnode): # TODO two groups. One contains data, the other can match anything
                        groups.append(OneByOneGroup())
                    else:
                        groups.append(MatchAllGroup())
                else:
                    if type(groups[-1]) is MatchAllGroup and transformOneByOne(stnode):
                        groups.append(OneByOneGroup())
                    elif type(groups[-1]) is OneByOneGroup and not transformOneByOne(stnode):
                        groups.append(MatchAllGroup())
                groups[-1].add(stnode)
            descend(stnode)
    descend(stree)      
    groupMap = {}
    for group in groups:
         groupMap[group._minLineno] = group
    return groupMap
