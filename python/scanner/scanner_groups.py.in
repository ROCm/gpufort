class STGroup():
    def __init__(self):
        self._objects = []
        self._minLineno = 10**20
        self._maxLineno = -1
        self._lines = []
    def borders(self,stnode):
        """
        Check if a object tree node borders this `ObjectGroup`.
        :param stnode: an object tree node
        :return: `True` if this group is empty or if its max line number is exactly one smaller than the min line no of `otnode`. Returns `False` otherwise.
        :rtype: bool
        """
        #print(stnode.minLineno())
        #print("<<<"+"".join(stnode.lines()))
        assert stnode.minLineno() >= self._maxLineno, "{0} >= {1}: False, type of new node: {2}, code line: {3}".format(\
                stnode.minLineno(),self._maxLineno,type(stnode),"".join(stnode.lines()))
        return not len(self._objects) or (stnode.minLineno() - self._maxLineno <= 1)
    def add(self,stnode):
        """
        Add an object node to this object group.
        :note: Use the `borders` method to check if it makes sense to add this node to this group.
        :param stnode: an object tree node
        """
        #print("".join(stnode.lines()))
        assert stnode.minLineno() >= self._maxLineno
        assert self._maxLineno < 0 or stnode.minLineno() - self._maxLineno <= 1
        if not len(self._objects):
            self._minLineno = stnode.minLineno()
        for i in range(stnode.minLineno(),stnode.maxLineno()+1): # maxLineno is inclusive
            if i > self._maxLineno:
                self._lines.append(stnode.lines()[i-stnode.minLineno()])
        self._maxLineno = max(self._maxLineno, stnode.maxLineno())
        self._objects.append(stnode)
    def strippedContent(self):
        """
        :return: The stripped content of this object as text. The functions removes all
        comments and Fortran linebreak characters '&'.
        :rettype: str
        """
        result = "".join(self._lines)
        comment = Literal("!") + ~(~White()+Literal("$")) + restOfLine + Optional(Regex(r"\n")) # via pyparsing
        amperSand = Regex(r"&\n")
        comment.setParseAction(lambda tokens: "") # remove comments
        amperSand.setParseAction(lambda tokens: "") # remove &
        result2 = comment.transformString(result)
        result2 = amperSand.transformString(result)
        try:
           result = translator.singleLineIf.transformString(result2)
        except:
           result = result2
        return result
    def generateCode(self,wrapInIfdef=False):
        """
        Generates code from all objects in the group.
        If the original code is modified,
        the code will be wrapped in an ifdef.
        """
        assert False

class MatchAllGroup(STGroup):
    def generateCode(self,wrapInIfdef=False):
        """
        Generates code from all objects in the group.
        If the original code is modified,
        the code will be wrapped in an ifdef.
        """
        linesToSkip = len(self._lines)-1
        performedTransformation = False
        result = self.strippedContent()
        preamble = ""
        epilog   = ""
        processedTypes = set()
        def typeHasAlreadyBeenProcessed(stnode):
            alreadyProcessed = type(stnode) in processedTypes
            processedTypes.add(type(stnode))
            return alreadyProcessed
        for stnode in self._objects:
            #print(stnode)
            if not typeHasAlreadyBeenProcessed(stnode):
                result, transformed = stnode.transformFSnippet(result) # TODO
                performedTransformation |= transformed
                if len(stnode.preamble()): 
                    preamble += stnode.preamble().rstrip("\n")+"\n"
                if len(stnode.epilog()): 
                    epilog += stnode.epilog().rstrip("\n")+"\n"
        result = result.rstrip("\n")
        if performedTransformation or len(preamble) or len(epilog):
            if len(epilog):
                epilog = "\n" + epilog
            if wrapInIfdef:
                original = "".join(self._lines).rstrip("\n")
                return """#ifdef {0}
{1}{2}{3}
#else
{4}
#endif""".format(HIP_IFDEF,preamble,result,epilog,original).split("\n"), linesToSkip
            else:
                return "{0}{1}{2}".format(preamble,result,epilog).split("\n"), linesToSkip
        else:
            return self._lines, linesToSkip

class OneByOneGroup(STGroup):
    def generateCode(self,wrapInIfdef=False):
        """
        Generates code from all objects in the group.
        If the original code is modified,
        the code will be wrapped in an ifdef.
        """
        linesToSkip = len(self._lines)-1
        performedTransformation = False
        result = ""
        preamble = ""
        epilog   = ""
        for stnode in self._objects:
            fStr, transformed = stnode.hipFStr() # TODO
            result += fStr.rstrip("\n")+"\n"
            performedTransformation |= transformed
            if len(stnode.preamble()): 
                preamble += stnode.preamble().rstrip("\n")+"\n"
            if len(stnode.epilog()): 
                epilog += stnode.epilog().rstrip("\n")+"\n"
            #print(stnode.lines())
        if performedTransformation or len(preamble) or len(epilog):
            if len(epilog):
                epilog = "\n" + epilog
            if wrapInIfdef:
                original = "".join(self._lines).strip("\n")
                result = result.rstrip("\n")
                return """#ifdef {0}
{1}{2}{3}
#else
{4}
#endif""".format(HIP_IFDEF,preamble,result,epilog,original).split("\n"), linesToSkip
            else:
                return "{0}{1}{2}".format(preamble,result,epilog).split("\n"), linesToSkip
        else:
            return self._lines, linesToSkip
