# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.
pAttributes = re.compile(r"attributes\s*\(\s*\w+\s*(,\s*\w+)?\s*\)\s*", flags=re.IGNORECASE)

def removeTypePrefix(varName):
    return varName.split("%")[-1]

def replaceIgnoreCase(key,subst,text):
    return re.sub(re.escape(key), subst, text, flags=re.IGNORECASE)

def flattenList(items):
    """Yield items from any nested iterable"""
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):
            for sub_x in flattenList(x):
                yield sub_x
        else:
            yield x

# Object representation

# We create an object tree because we want to preserve scope.

class Tagged:
    def tag(self):
        """
        Construct a tag that can be used to search the index.
        """
        result = self._name.lower()
        def recursiveParentLookup(curr):
            nonlocal result
            if type(curr) != STRoot:
                result = curr._name.lower() + ":" + result
                recursiveParentLookup(curr._parent)
        recursiveParentLookup(self._parent)        
        return result

class STNode:
    def __init__(self,parent,records,firstStatementIndex=0):
        self._records                = records
        self._firstStatementIndex    = firstStatementIndex
        self._lastStatementIndex     = firstStatementIndex
        self._name                   = None
        self._kind                   = None
        self._children               = []
        self._parent                 = parent
        self._ignoreInS2STranslation = False 
        # transformation
        self._preamble = set() 
        self._epilog   = set()
    def __getRecordContent(self,key,firstRecordFirstElem=0,lastRecordLastElem=-1):
        # TODO add docu
        result = []
        for i,record in enumerate(self._records):
            if i == 0: 
                result += self._records[key][firstRecordFirstElem:]
            elif i == len(self._records)-1: 
                result += self._records[key][:lastRecordLastElem]
            else:
                result += self._records[key]
        return result
    def removeComments(self,lines):
        """
        Remove comments but keep directives.
        """
        # TODO move somewhere else
        for line in list(lines): # shallow copy
            strippedLine = line.lstrip("\t ")
            if strippedLine[0] in ["*","c","C","!"] and not\
               strippedLine[1] == "$": 
                 lines.remove("line")
    def removeWhitespaces(self,lines):
        """
        Remove any whitespace and line continuation characters.
        """
        for i,line in enumerate(lines):
            lines[i] = line.replace(" ","").replace("\t","").replace("\n","").replace("&","")
    def lines(self):
        return self.__getRecordContent(self,"lines")
    def statements(self,includeNoneEntries=False):
        """
        Extract the statements associated with this node from the records associated with this node.
        :param bool includeNoneEntries: Also include entries that are None [default=False].
        """
        result = self.__getRecordContent(self,"expandedStatements",\
          self._firstStatementIndex,self._lastStatementIndex)
        if not includeNoneEntries:
            return [stmt for stmt in result if stmt != None]
    def minLineno(self):
        """
        :return: Inclusive first line number belonging to this object.
        """
        return self._records[0]["lineno"]
    def maxLineno(self):
        """
        :return: Inclusive last line number belonging to this object.
        """
        lastRecord = self._records[-1]
        return lastRecord["lineno"]+len(lastRecord["lines"])-1
    def firstLine(self):
        """
        :return: First line in first record.
        """
        return self._records[0]["lines"][0]
    def firstLineIndent(self):
        """Indent chars at beginning of first line."""
        firstLine      = self.firstLine()
        numIndentChars = len(firstLine) - len(firstLine.lstrip(" \t"))
        return firstLine[0:numIndentChars]
    def firstStatement(self):
        """
        :return: First line in first record.
        """
        return self._records[0]["expandedStatement"][0]
    def considerInS2STranslation(self,indexHints=[]):
        """
        Consider this object when transforming host code.
        :return: The default implementation returns False if the parent
                 of the object is a device subroutine.
        """
        return not self._ignoreInS2STranslation
    def append(self,child):
        self._children.append(child)
    def listOfParents(self):
        """
        Returns a list that contains all
        parents of a node plus the node itself._
        """
        result = []
        def recursiveParentLookup(curr):
            if curr != None:
                result.append(curr)
                recursiveParentLookup(curr._parent)

        recursiveParentLookup(self)        
        return result
    def findAll(self,filter=lambda child : True,recursively=False):
        result = []
        def descend(curr):
            for child in curr._children:
                if filter(child):
                    result.append(child) 
                elif recursively:
                    descend(child)
        descend(self)       
        return result
    def findFirst(self,filter=lambda child: True):
        for child in self._children:
            if filter(child):
                return child
        return None
    def findLast(self,filter=lambda child: True):
        for child in reversed(self._children):
            if filter(child):
                return child
        return None
    def extractFirst(self,text,expression):
        """
        Extract (first) part of the text that contains a given expression.
        :rtype: str
        :return: The first part of the text that matches the expression.
        """ 
        for tokens,start,end in expression.scanString(text):
             return text[start:end]
        return ""
    def extractAll(self,text,expression):
        """
        Extract all parts of the text that contain a given pyparsing expression.
        :rtype: list
        :return: All parts of the text that match the pyparsing expression
        """
        result = []
        for tokens,start,end in expression.scanString(text):
             result.append(text[start:end])
        return result
    def preamble(self):
        """
        Some node transformations may require additional definitions
        such as the definition of macros.
        They write these definitions to the preamble so that
        a higher-level function can use them and place
        them at an appropriate location.
        """
        return "\n".join([el.rstrip() for el in self._preamble])
    def epilog(self):
        """
        Some node transformations may require additional definitions
        such as the definition of macros.
        They write these definitions to the preamble so that
        a higher-level function can use them and place
        them at an appropriate location.
        """
        return "\n".join([el.rstrip() for el in self._epilog])
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        """
        :param line: An excerpt from a Fortran file, possibly multiple lines
        :type line: str
        :return: If the text was changed at all
        :rtype: bool
        """
        if statementsFullyCoverCodeLines:
            return joinedLines, False
        else:
            return joinedStatements, False
    def __modifyRecords(self,substitution):
        """
        Replaces first statement associated with node in first associated record by 'subst' argument.
        Replaces all other other statements in first and all other records associated
        with node by 'None'. Marks all records associated with this node as modified.
        :param str subst: The text that should be written in first associated statement in first
                          associated record.
        :note: Post processing working with the modified statements must ignore all 'None' statements.
        :note: We assume that the statements of an expression that spreads over multiples lines are only modified once.
        :note: We write 'None' entries into the statements instead of clipping them away because 
               if multiple statements per line are present and other nodes modify those, removing elements from the list
               of statements might mess with the indexing.
        """
        firstRecordFirstElem = self._firstStatementIndex
        lastRecordLastElem   = self._lastStatementIndex
        # write subst into first record first statement
        self._records[0]["modified"]                                 = True
        self._records[0]["expandedStatements"][firstRecordFirstElem] = subst
        assert len(self._records), "self._records should not be empty"
        if len(self._records) == 1:
            self._records[0]["expandedStatements"][firstRecordFirstElem:lastRecordLastElem] = None
        else:
            self._records[0]["expandedStatements"][firstRecordFirstElem:-1] = None
            self._records[-1]["expandedStatements"][0:lastRecordLastElem]   = None
            self._records[-1]["modified"]                                   = True
            for record in self._records[1:-1]: # upper bound exclusive
                record["expandedStatements"][:] = None
                record["modified"]              = True
    def transformStatements(self,indexHints=[]):
        """
        Replaces original statements by generated code. Modifies the 'expandedStatements' 
        entries of the associated records.
        :param list indexHints: TBA
        :note: When multiple records contain the expression associated with this note,
               the transformed code is written into the first associated statement in 
               the first record and the remaining associated statements in the first
               and all other records are replaced by None.
        :note: When prepending a preamble, it is assumed that the modified statement is the 
        first in the record/line and that this statement is only modified once.
        :note: When appending an epilog, it is assumed that the modified statement is the 
        last in the record/line and that this statement is only modified once.
        """
        haveFirstInFirstRecord    = self._firstStatementIndex == 0
        haveLastInLastRecord      = self._lastStatementIndex in [-1, len(self._records[-1]["expandedStatements"])-1]
        statementsFullyCoverLines = haveFirstInFirstRecord and haveLastInLastRecord

        joinedLines                 = "".join(self.lines)
        joinedStatements            = "\n".join(self.statements())
        transformedCode, modified  = self.transform(joinedLines,joinedStatements,statementsFullyCoverLines,indexHints)
        if modified or len(self._preamble) or len(self._epilog):
            assert not (len(self._preamble) and len(self._epilog))
            assert not len(self._preamble) or haveFirstInFirstRecord
            assert not len(self._epilog) or haveLastInLastRecord
            if modified:
                result = transformedCode
            else:
                result = joinedLines
            if len(self._preamble):
                result = self.preamble() + "\n" + result 
            if len(self._epilog):
                result += "\n" + self.epilog()
            self.__modifyRecords(result)

class STRoot(STNode):
    def __init__(self):
        STNode.__init__(self,None,-1)
    def considerInS2STranslation(self,indexHints=[]):
        return False

class STModule(STNode,Tagged):
    def __init__(self,name,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
        self._name = name.lower()
        self._kind = "module"
    def considerInS2STranslation(self,indexHints=[]):
        return False

class STProgram(STNode,Tagged):
    def __init__(self,name,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
        self._name = name.lower()
        self._kind = "program"
    def considerInS2STranslation(self,indexHints=[]):
        return False

class STUseStatement(STNode):
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        indent  = self.firstLineIndent() 
        snippet = joinedStatements
        useCuda = False
        for lib in HOST_MODULES:
            libLower = lib.lower()
            if libLower in snippet.lower():
                useCuda = True
                if libLower == "cudafor":
                    snippet = re.sub(r"\bcudafor\b",HIP_MODULE_NAME,snippet,re.IGNORECASE)
                    snippet = snippets.rstrip("\n")+"\n" + "{0}use iso_c_binding".format(indent) 
                snippet = re.sub(r"\bcu(\w+)\b",HIP_MATH_MODULE_PREFIX+r"hip\1",snippet,re.IGNORECASE)
        return snippet, useCuda
    def considerInS2STranslation(self,indexHints=[]):
        if not STNode.considerInS2STranslation(self):
            return False
        else:
            useCuda = False
            result = "".join(self._lines).lower()
            for lib in HOST_MODULES:
                 useCuda |= lib.lower() in result
            return useCuda or len(self._preamble) or len(self._epilog)

class STPlaceHolder(STNode):
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
        self._name = None
    def considerInS2STranslation(self,indexHints=[]):
        return STNode.considerInS2STranslation(self) and\
               (len(self._preamble) or len(self._epilog))

class STProcedure(STNode,Tagged):
    def __init__(self,name,kind,index,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
        self._name = name
        self._kind = kind
        # check attributes
        self._indexRecord,_ = scoper.searchIndexForSubprogram(index,self._parent.tag(),name)
        self._body          = self.__extractBody()
    def __extractBody(self):
        def beginOfBody_(stmts):
            """
            starts from the begin
            """
            stmtno = 0
            while(not "use" in stmts[stmtno].lower() and\
                  not "implicit" in stmts[stmtno].lower() and\
                  not "::" in stmts[stmtno].lower()):
                stmtno += 1
            return stmtno
        def endOfBody_(stmts):
            """
            starts from the end
            """
            stmtno = len(stmts)-1
            while(not "end" in stmts[stmtno].lower()):
                stmtno -= 1
            return stmtno
        
        allStatements = self.statements(self._firstStatementIndex,self._lastStatementIndex)    
        return "\n".join(allStatements[beginOfBody_(stmts):endOfBody_(stmts)])
    def __mustBeAvailableOnHost(self):
        return not len(self._indexRecord["attributes"]) or\
               "host" in self._indexRecord["attributes"]
    def __attributesPresent(self):
        return len(self._indexRecord["attributes"])
    def getBody(self):
        return self._body 
    def hasAttribute(self,attribute):
        return attribute in self._indexRecord["attributes"]
    def isKernelSubroutine(self):
        return self.hasAttribute("global")
    def mustBeAvailableOnDevice(self):
        return self.hasAttribute("device") or\
               self.hasAttribute("global")
    def keepRecording(self):
        """
        No recording if the function needs to be kept only on the host.
        """
        return self.mustBeAvailableOnDevice()
    def considerInS2STranslation(self,index=[]):
        return self.__attributesPresent() or\
               self.mustBeAvailableOnDevice()
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,index=[]):
        """
        Treats CUF and OpenACC subroutines/functions that carry CUF-specific attributes
        or require a device version as specified in a directive.

        :note: Removes 'attributes(...)' objects from the procedure header
        when encountering a CUF device procedure that
        needs to be kept on the host too.
        """
        attributesPresent       = self.__attributesPresent()
        mustBeAvailableOnDevice = self.mustBeAvailableOnDevice()
        mustBeAvailableOnHost   = self.__mustBeAvailableOnHost()

        original = "".join(self.lines())
        if attributesPresent: # CUF case
             if mustBeAvailableOnHost:
                 return pAttributes.sub("", original), True
             elif mustBeAvailableOnDevice: # and not mustBeAvailableOnHost
                 indent = self.firstLineIndent()
                 return "{0}! extracted to HIP C++ file".format(indent), True
        else: 
                 return original, False

class STDirective(STNode):
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement,directiveNo,sentinel="!$cuf"):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
        self._sentinel            = sentinel
        self._directiveNo         = directiveNo
    def singleLineStatement(self):
        """
        Express the statement as lower case single-line statement
        """
        return self._records[0]["expandedStatements"]

class STLoopKernel(STNode):
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
        self._doLoopCtrMemorised     = -1
        self._singleLineStatement    = None
        self.gridFStr               = None
        self.blockFStr              = None
        self._sharedMemFStr          = "0" # set from extraction routine
        self.streamFStr             = "c_null_ptr" # set from extraction routine
        self.kernelArgNames         = [] # set from extraction routine
        # compute hash; must be at creation time as based on statements
        statements = self.statements(self._firstStatementIndex,self._lastStatementIndex)
        self.removeComments(statements)
        self.removeWhitespaces(statements)
        snippet       = "".join(statements)
        self._hash    =  hashlib.md5(snippet.encode()).hexdigest()[0:6]
        # persist statements; will be modified later on
        self._snippet = "\n".join(self.statements())
    def kernelName(self):
        """
        Derive a name for the kernel.
        
        We hash the body because we will use different block sizes and shmem anyway in HIP.
        """
        return LOOP_KERNEL_NAME_TEMPLATE.format(parent=self._parent._name.lower(),lineno=self._lineno+1,hash=self.__hash)
    def kernelLauncherName(self):
        return "launch_{}".format(self.kernelName())
    def getSnippet(self):
        return self._snippet
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        indent = self.firstLineIndent()
        try:
            streamAsInt = int(self.streamFStr)
            stream = "c_null_ptr" if streamAsInt < 1 else self.streamFStr
        except:
            stream = self.streamFStr
        if self.gridFStr == None or self.blockFStr == None or LOOP_KERNEL_DEFAULT_LAUNCHER == "cpu": # use auto or cpu launcher 
            result="""{indent}! extracted to HIP C++ file
  {indent}CALL {0}_{launcher}({1},{2},{3})""".format(self.kernelLauncherName(),self._sharedMemFStr,stream,\
              ",".join(self.kernelArgNames),indent=indent,launcher=LOOP_KERNEL_DEFAULT_LAUNCHER)
        else:
            result="""{indent}! extracted to HIP C++ file
  {indent}CALL {0}({1},{2},{3},{4},{5})""".format(self.kernelLauncherName(),self.gridFStr,self.blockFStr,self.sharedMemFStr,stream,\
            ",".join(self.kernelArgNames),indent=indent)
        return result, True

class STDeclaration(STNode):
    """
    Works with Fortran declarations such as
    ```Fortran
    Complex(DP), allocatable, device :: devArray(:,:)
    ```
    """
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
        self._ttdeclaration   = translator.declaration.parseString(self.firstStatement())[0]
        self._vars            = [name.lower() for name in self._ttdeclaration.variableNames()]
    def createCodegenContext(self):
        return translator.createIndexRecordsFromDeclaration(self._ttdeclaration)
    def considerInS2STranslation(self,indexHints=[]):
        interestingQualifiers = ["device","pinned","managed"]
        if not self._ignoreInS2STranslation:
            if len(self._preamble) or len(self._epilog):
                return True
            for l in self.expandedStatements():
                lineLower = l.lower()
                for q in interestingQualifiers:
                    if q in lineLower:
                        return True
            if len(indexHints):
                for varName in self._vars:
                    indexVar,discovered = scoper.searchIndexForVariable(\
                      indexHints,self._parent.tag(),\
                        translator.createIndexSearchTagForVariable(varName))
                    if discovered:
                        for q in interestingQualifiers:
                            if indexVar[q] == True:
                                return True
        return False 
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        """
        if device and allocatable, remove device, add pointer
        if device and fixed size array, remove device, add pointer, replace fixed bounds by other bounds
           find first code line and add allocation to preamble if no dummy argument. Do similar things
           with deallocation -> double pass
        if pinned and allocatable, add pointer
        if pinned and fixed size array, remove pinned, add pointer, replace fixed bounds by other bounds
           find first code line and add allocation to preamble if no dummy argument -> double pass
        if integer with stream kind, 
        """
        if len(indexHints):
            index = indexHints
        else:
            index = copy.copy(scoper.EMPTY)
            index["variables"] = self.createCodegenContext()
        originalDatatype          = translator.makeFStr(self._ttdeclaration._datatype)
        originalQualifiers        = [translator.makeFStr(q).lower() for q in self._ttdeclaration._qualifiers]
        unchangedVariables        = []  
        newDevicePointerVariables = []
        newHostPointerVariables   = []
        
        indent = self.firstLineIndent()
        # argument names if declared in procedure
        if isinstance(self._parent, STProcedure):
            argNames = [makeFStr(n).lower() for n in self.parent._dummyArgs]
        else:
            argNames = []
        result = ""
        for varName in self._vars:
             indexVar,discovered = scoper.searchIndexForVariable(\
               index,self._parent.tag(),\
                 translator.createIndexSearchTagForVariable(varName))
             rank           = indexVar["rank"]
             hasDevice      = indexVar["device"] == True
             hasPinned      = indexVar["pinned"] == True
             hasAllocatable = indexVar["allocatable"] == True  
             # clean qualifiers
             newQualifiers = []
             for q in originalQualifiers:
                if not q in ["target","pinned","device","allocatable"] and not q.startswith("dimension"):
                    newQualifiers.append(q)
             if varName in argNames: 
                 newQualifiers.append("target")
             else:
                 newQualifiers.append("pointer")
             if rank > 0:
                 newQualifiers.append("dimension(:"+",:"*(rank-1)+")")
             if hasDevice and rank > 0:
                 newDevicePointerVariables.append(varName)
                 result += "\n" + indent + originalDatatype + "," + ",".join(newQualifiers) + " :: " + varName
             elif hasPinned:
                 newHostPointerVariables.append(varName)
                 result += "\n" + indent + originalDatatype + "," + ",".join(newQualifiers) + " :: " + varName

        # TODO handle side effects if no allocatable present
        if len(newDevicePointerVariables) + len(newHostPointerVariables) < len(self._ttdeclaration._rhs): 
            result = indent + self._ttdeclaration.fStr(extraIgnoreList=newDevicePointerVariables+newHostPointerVariables) +\
                     result
        if len(newDevicePointerVariables) or len(newHostPointerVariables):
            return result.lstrip("\n"), True
        else:
            return snippet, False

class STAttributes(STNode):
    """
    CUDA Fortran specific intrinsic that needs to be removed/commented out
    in any case.
    """
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
    def gpufortFStr(self,indexHints=[],indent=""):
        return "", True

class STNonZeroCheck(STNode):
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        result = snippet
        transformed = False
        for tokens,start,end in translator.nonZeroCheck.scanString(result):
            parseResult = tokens[0]
            lhsName     = parseResult.lhsFStr()
            indexVar,_  = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
              translator.createIndexSearchTagForVariable(lhsName))
            onDevice    = scoper.indexVariableIsOnDevice(indexVar)
            transformed |= onDevice
            if onDevice:
                subst = parseResult.fStr() # TODO backend specific
                result = result.replace(result[start:end],subst)
        return result, transformed

class STAllocated(STNode):
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        def repl(parseResult):
            varName    = parseResult.varName()
            indexVar,_ = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
              translator.createIndexSearchTagForVariable(varName))
            onDevice    = scoper.indexVariableIsOnDevice(indexVar)
            return (parseResult.fStr(), onDevice) # TODO backend specific
        result, transformed = utils.pyparsingutils.replaceAll(snippet,translator.allocated,repl)
        assert result != None
        return result, transformed

class STAllocate(STNode):
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        def repl(parseResult):
            transformed     = False
            bytesPerElement = []
            arrayQualifiers = []
            for arrayName in parseResult.variableNames():
                indexVar,_  = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
                  translator.createIndexSearchTagForVariable(arrayName))
                bytesPerElement.append(indexVar["bytesPerElement"])
                onDevice   = scoper.indexVariableIsOnDevice(indexVar)
                pinned     = indexVar["pinned"] == True
                if onDevice: 
                    arrayQualifiers.append("device")
                elif pinned: 
                    arrayQualifiers.append("pinned")
                else:
                    arrayQualifiers.append(None)
                transformed |= onDevice | pinned
            subst = parseResult.hipFStr(bytesPerElement,arrayQualifiers,indent="")
            return (subst, transformed)
        return utils.pyparsingutils.replaceAll(snippet,translator.allocate,repl)
             
class STDeallocate(STNode):
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        """
        :note: `wrapInIfDef` can be deactivated if a higher level function
        embeds the outcome already in an `ifdef`.
        """
        def repl(parseResult):
            transformed     = False
            arrayQualifiers = []
            for arrayName in parseResult.variableNames():
                indexVar,_  = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
                  translator.createIndexSearchTagForVariable(arrayName))
                onDevice   = scoper.indexVariableIsOnDevice(indexVar)
                pinned     = indexVar["pinned"] == True
                if onDevice: 
                    arrayQualifiers.append("device")
                elif pinned: 
                    arrayQualifiers.append("pinned")
                else:
                    arrayQualifiers.append(None)
                transformed |= onDevice | pinned
            subst = parseResult.hipFStr(arrayQualifiers,indent="")
            return (subst, transformed)
        return utils.pyparsingutils.replaceAll(snippet,translator.deallocate,repl)
         
class STMemcpy(STNode):
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        def replMemcpy(parseResult):
            destName = parseResult.destNameFStr()
            srcName  = parseResult.srcNameFStr()
            destIndexedVar,_ = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
              translator.createIndexSearchTagForVariable(destName))
            srcIndexedVar,_  = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
              translator.createIndexSearchTagForVariable(srcName))
            destOnDevice = scoper.indexVariableIsOnDevice(destIndexedVar)
            srcOnDevice  = scoper.indexVariableIsOnDevice(srcIndexedVar)
            bytesPerElement = destIndexedVar["bytesPerElement"]
            if destOnDevice or srcOnDevice:
                subst = parseResult.hipFStr(destOnDevice,srcOnDevice)
                return (subst,True)
            else:
                return ("",False) # no transformation; will not be considered
        snippet, transformed = utils.pyparsingutils.replaceAll(snippet,translator.memcpy,replMemcpy)
        return snippet, transformed

class STCudaLibCall(STNode):
    def __init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement):
        STNode.__init__(self,parent,records,firstRecordFirstStatement,lastRecordLastStatement)
        self._cudaApi = ""
        self._hasCublas = False
    def hasCublas(self):
        """
        :return: Scanned code lines contain a cublas call.
        :rtype: bool
        """
        return self._hasCublas
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        global CUBLAS_VERSION 
        global KEEP_CUDA_LIB_NAMES
        oldfSnippet = snippet
        indent = self.firstLineIndent()
        transformed = False
        if not KEEP_CUDA_LIB_NAMES:
            def replMemcpy(parseResult):
                destName = parseResult.destNameFStr()
                srcName  = parseResult.srcNameFStr()
                destIndexedVar,_ = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
                  translator.createIndexSearchTagForVariable(destName))
                srcIndexedVar ,_ = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
                  translator.createIndexSearchTagForVariable(srcName))
                destOnDevice = scoper.indexVariableIsOnDevice(destIndexedVar)
                srcOnDevice  = scoper.indexVariableIsOnDevice(srcIndexedVar)
                subst = parseResult.hipFStr(destOnDevice,srcOnDevice)
                return (subst, True)
            snippet,_ = utils.pyparsingutils.replaceAll(snippet,translator.cufCudaMemcpyVariant,replMemcpy)
        def replCublas(parseResult):
            subst = parseResult.fStr(indent)
            return (subst, True)
        snippet,haveCublas = utils.pyparsingutils.replaceAll(snippet,translator.cublasCall,replCublas)
        if haveCublas:
            self._hasCublas = True
        for elem in CUDA_RUNTIME_ENUMS:
             snippet = replaceIgnoreCase(elem,elem.replace("cuda","hip").replace("CUDA","HIP"),snippet)
        for elem in CUDA_LIB_ENUMS:
             snippet = replaceIgnoreCase(elem,elem.replace("cu","hip").replace("CU","HIP"),snippet)
        for elem in ALL_HOST_ROUTINES: # runtime routines
             snippet = replaceIgnoreCase(elem,elem.replace("cuda","hip"),snippet)
        for elem in CUDA_MATH_LIB_FUNCTIONS:
             snippet = replaceIgnoreCase(elem,elem.replace("cu","hip"),snippet)
        transformed = snippet.lower() != oldfSnippet 
        return snippet, transformed

class STCudaKernelCall(STNode):
    """TODO(gpufort): Fix
    Translates a CUDA kernel call to a call to a subroutine interface.
    """
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        for tokens,start,end in translator.cudaKernelCall.scanString(snippet):
            parseResult = tokens[0]
            kernelArgs  = []
            for ttexpr in parseResult._args:
                # expand array arguments
                maxRank = 0
                for rvalue in translator.findAll(ttexpr,translator.TTRValue):
                    # TODO lookup the subprogram first 
                    indexVar, discovered = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
                       translator.createIndexSearchTagForVariable(rvalue.name()))
                    if discovered:
                        maxRank = max(maxRank,indexVar["rank"])
                exprFStr = translator.makeFStr(ttexpr)
                if maxRank > 0:
                    kernelArgs.append("c_loc("+exprFStr+")")
                else:
                    kernelArgs.append(exprFStr)
                for rank in range(1,maxRank+1):
                    kernelArgs.append("size({0},{1})".format(exprFStr,rank))
                for rank in range(1,maxRank+1):
                    kernelArgs.append("lbound({0},{1})".format(exprFStr,rank))
            kernelLaunchInfo = translator.cudaKernelCall.parseString(self.firstStatement())[0]
            subst="CALL launch_{0}({1},{2},{3},{4},{5})".format(\
              kernelLaunchInfo.kernelNameFStr(),\
              kernelLaunchInfo.gridFStr(),
              kernelLaunchInfo.blockFStr(),\
              kernelLaunchInfo.sharedMemFStr(),
              kernelLaunchInfo.streamFStr(),\
              ",".join(kernelArgs)
            )
            snippet = snippet.replace(snippet[start:end],subst)
            break
        return snippet, True