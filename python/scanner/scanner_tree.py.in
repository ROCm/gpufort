# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.
pAttributes = re.compile(r"attributes\s*\(\s*\w+\s*(,\s*\w+)?\s*\)\s*", flags=re.IGNORECASE)

def removeTypePrefix(varName):
    return varName.split("%")[-1]

def replaceIgnoreCase(key,subst,text):
    return re.sub(re.escape(key), subst, text, flags=re.IGNORECASE)

def flattenList(items):
    """Yield items from any nested iterable"""
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):
            for sub_x in flattenList(x):
                yield sub_x
        else:
            yield x

# Object representation

# We create an object tree because we want to preserve scope.

class Tagged:
    def tag(self):
        """
        Construct a tag that can be used to search the index.
        """
        result = self.name.lower()
        def recursiveParentLookup(curr):
            nonlocal result
            if type(curr) != STRoot:
                result = curr.name.lower() + ":" + result
                recursiveParentLookup(curr._parent)
        recursiveParentLookup(self._parent)        
        return result

class STNode:
    def __init__(self,parent,firstRecord,firstStatementIndex=0):
        self.name                    = None
        self.kind                    = None
        self._records                = []
        if firstRecord != None:
            self._records.append(firstRecord)
        self._firstStatementIndex    = firstStatementIndex
        self._lastStatementIndex     = firstStatementIndex # inclusive
        self._children               = []
        self._parent                 = parent
        self._ignoreInS2STranslation = False 
    def __getRecordContent(self,key,firstRecordFirstElem=0,lastRecordLastElem=-1):
        """Collects entries for the given key from all records associated
        with this node."""
        result = []
        for i,record in enumerate(self._records):
            if i == 0: 
                result += record[key][firstRecordFirstElem:]
            elif i == len(self._records)-1:
                if lastRecordLastElem == -1:
                    result += record[key]
                else:
                    result += record[key][0:lastRecordLastElem+1]
            else:
                result += record[key]
        return result
    def addRecord(self,record):
        """Adds a record if it differs from the last record."""
        if not len(self._records) or self._records[-1]["lineno"] < record["lineno"]:
            self._records.append(record)
    def completeInit(self):
        """Complete the initialization
        
        This routine is called after all associated records have
        been added to this node.
        """
        pass
    def removeComments(self,lines):
        """Remove comments but keep directives."""
        # TODO move somewhere else
        for line in list(lines): # shallow copy
            strippedLine = line.lstrip("\t ")
            if strippedLine[0] in ["*","c","C","!"] and not\
               strippedLine[1] == "$": 
                 lines.remove(line)
    def removeWhitespaces(self,lines):
        """Remove any whitespace and line continuation characters."""
        for i,line in enumerate(lines):
            lines[i] = line.replace(" ","").replace("\t","").replace("\n","").replace("&","")
    def lines(self):
        return self.__getRecordContent("lines")
    def statements(self,includeNoneEntries=False):
        """
        Extract the statements associated with this node from the records associated with this node.
        :param bool includeNoneEntries: Also include entries that are None [default=False].
        :note: None entries might have been introduced by other nodes transforming the same record(s).
        """
        result = self.__getRecordContent("statements",\
          self._firstStatementIndex,self._lastStatementIndex)
        if not includeNoneEntries:
            return [stmt.rstrip("\n\t ;") for stmt in result if stmt != None]
    def minLineno(self):
        """
        :return: Inclusive first line number belonging to this object.
        """
        return self._records[0]["lineno"]
    def maxLineno(self):
        """
        :return: Inclusive last line number belonging to this object.
        """
        lastRecord = self._records[-1]
        return lastRecord["lineno"]+len(lastRecord["lines"])-1
    def firstLine(self):
        """
        :return: First line in first record.
        """
        return self._records[0]["lines"][0]
    def firstLineIndent(self):
        """Indent chars at beginning of first line."""
        firstLine      = self.firstLine()
        numIndentChars = len(firstLine) - len(firstLine.lstrip(" \t"))
        return firstLine[0:numIndentChars]
    def firstStatement(self):
        """
        :return: First line in first record.
        """
        return self._records[0]["statements"][0]
    def append(self,child):
        self._children.append(child)
    def listOfParents(self):
        """
        Returns a list that contains all
        parents of a node plus the node itself._
        """
        result = []
        def recursiveParentLookup(curr):
            if curr != None:
                result.append(curr)
                recursiveParentLookup(curr._parent)

        recursiveParentLookup(self)        
        return result
    def findAll(self,filter=lambda child : True,recursively=False):
        result = []
        def descend(curr):
            for child in curr._children:
                if filter(child):
                    result.append(child) 
                elif recursively:
                    descend(child)
        descend(self)       
        return result
    def findFirst(self,filter=lambda child: True):
        for child in self._children:
            if filter(child):
                return child
        return None
    def findLast(self,filter=lambda child: True):
        for child in reversed(self._children):
            if filter(child):
                return child
        return None
    def extractFirst(self,text,expression):
        """
        Extract (first) part of the text that contains a given expression.
        :rtype: str
        :return: The first part of the text that matches the expression.
        """ 
        for tokens,start,end in expression.scanString(text):
             return text[start:end]
        return ""
    def extractAll(self,text,expression):
        """Extract all parts of the text that contain a given pyparsing expression.
        :rtype: list
        :return: All parts of the text that match the pyparsing expression
        """
        result = []
        for tokens,start,end in expression.scanString(text):
             result.append(text[start:end])
        return result
    def addToProlog(self,line):
        """Add some prolog lines to the first record."""
        if not line in self._records[0]["prolog"]:
            self._records[0]["prolog"].append(line)
    def addToEpilog(self,line):
        """Add some epilog lines to the first record."""
        if not line in self._records[-1]["epilog"]:
            self._records[-1]["epilog"].append(line)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        """Transforms statements associated with underlying records (hook)
        :param line: An excerpt from a Fortran file, possibly multiple lines
        :type line: str
        :return: If the text was changed at all
        :rtype: bool
        """
        if statementsFullyCoverLines:
            return joinedLines, False
        else:
            return joinedStatements, False
    def __modifyRecords(self,substitution):
        """
        Replaces first statement associated with node in first associated record by 'subst' argument.
        Replaces all other other statements in first and all other records associated
        with node by 'None'. Marks all records associated with this node as modified.
        :param str subst: The text that should be written in first associated statement in first
                          associated record.
        :note: Post processing working with the modified statements must ignore all 'None' statements.
        :note: We assume that the statements of an expression that spreads over multiples lines are only modified once.
        :note: We write 'None' entries into the statements instead of clipping them away because 
               if multiple statements per line are present and other nodes modify those, removing elements from the list
               of statements might mess with the indexing.
        """
        firstRecordFirstElem = self._firstStatementIndex
        lastRecordLastElem   = self._lastStatementIndex
        # write subst into first record first statement
        self._records[0]["modified"]                         = True
        self._records[0]["statements"][firstRecordFirstElem] = substitution
        assert len(self._records), "self._records should not be empty"
        lastRecordUbound = lastRecordLastElem
        if lastRecordUbound != -1:
            lastRecordUbound += 1
        def assignNone_(statements,lbound=0,ubound=-1):
            if ubound == -1:
                ubound = len(statements)
            for i in range(lbound,ubound):
                statements[i] = None
        if len(self._records) == 1:
            assignNone_(self._records[0]["statements"],firstRecordFirstElem+1,lastRecordUbound)
        else:
            self._records[-1]["modified"] = True
            assignNone_(self._records[0]["statements"],firstRecordFirstElem+1)
            assignNone_(self._records[-1]["statements"],0,lastRecordUbound)
            for record in self._records[1:-1]: # upper bound exclusive
                record["modified"] = True
                assignNone_(record["statements"])
    def transformStatements(self,indexHints=[]):
        """
        Replaces original statements by generated code. Modifies the 'statements' 
        entries of the associated records.
        :param list indexHints: TBA
        :note: When multiple records contain the expression associated with this note,
               the transformed code is written into the first associated statement in 
               the first record and the remaining associated statements in the first
               and all other records are replaced by None.
        :note: When prepending a preamble, it is assumed that the modified statement is the 
        first in the record/line and that this statement is only modified once.
        :note: When appending an epilog, it is assumed that the modified statement is the 
        last in the record/line and that this statement is only modified once.
        """
        if not self._ignoreInS2STranslation:
            haveFirstInFirstRecord    = self._firstStatementIndex == 0
            haveLastInLastRecord      = self._lastStatementIndex  == -1 or\
                                        self._lastStatementIndex  == len(self._records[-1]["statements"])-1
            statementsFullyCoverLines = haveFirstInFirstRecord and haveLastInLastRecord
        
            joinedLines                = "".join(self.lines())
            joinedStatements           = "\n".join(self.statements())
            transformedCode, modified  = self.transform(joinedLines,joinedStatements,statementsFullyCoverLines,indexHints)
            if modified:
                self.__modifyRecords(transformedCode)

class STEndOrReturn(STNode):
    pass

class STRoot(STNode):
    def __init__(self):
        STNode.__init__(self,None,None,-1)

class STModule(STNode,Tagged):
    def __init__(self,name,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
        self.name = name.lower()
        self.kind = "module"

class STProgram(STNode,Tagged):
    def __init__(self,name,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
        self.name = name.lower()
        self.kind = "program"

class STUseStatement(STNode):
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        # TODO clean
        indent  = self.firstLineIndent() 
        snippet = joinedStatements
        useCuda = False
        for lib in HOST_MODULES:
            libLower = lib.lower()
            if libLower in snippet.lower():
                useCuda = True
                if libLower == "cudafor":
                    snippet = re.sub(r"\bcudafor\b",HIP_MODULE_NAME,snippet,re.IGNORECASE)
                    snippet = snippet.rstrip("\n")+"\n" + "{0}use hipfort_check".format(indent) 
                snippet = re.sub(r"\bcu(\w+)\b",HIP_MATH_MODULE_PREFIX+r"hip\1",snippet,re.IGNORECASE)
        return snippet, useCuda

class STPlaceHolder(STNode):
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
        self.name = None

class STProcedure(STNode,Tagged):
    def __init__(self,name,kind,parent,firstRecord,firstRecordFirstStatement,index):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
        self.name = name
        self.kind = kind
        # check attributes
        self._indexRecord, _ = scoper.searchIndexForSubprogram(index,self._parent.tag(),name)
    def __extractBody(self):
        def beginOfBody_(stmts):
            """
            starts from the begin
            """
            stmtno = 0
            while(not "use" in stmts[stmtno].lower() and\
                  not "implicit" in stmts[stmtno].lower() and\
                  not "::" in stmts[stmtno].lower()):
                stmtno += 1
            return stmtno
        def endOfBody_(stmts):
            """
            starts from the end
            """
            stmtno = len(stmts)-1
            while(not "end" in stmts[stmtno].lower()):
                stmtno -= 1
            return stmtno
        
        allStatements = self.statements()    
        return "\n".join(allStatements[beginOfBody_(allStatements):endOfBody_(allStatements)])
    def __mustBeAvailableOnHost(self):
        return not len(self._indexRecord["attributes"]) or\
               "host" in self._indexRecord["attributes"]
    def __attributesPresent(self):
        return len(self._indexRecord["attributes"])
    def completeInit(self):
        self._body = self.__extractBody()
    def getBody(self):
        return self._body 
    def hasAttribute(self,attribute):
        return attribute in self._indexRecord["attributes"]
    def isKernelSubroutine(self):
        return self.hasAttribute("global")
    def mustBeAvailableOnDevice(self):
        return self.hasAttribute("device") or\
               self.hasAttribute("global")
    def keepRecording(self):
        """
        No recording if the function needs to be kept only on the host.
        """
        return self.mustBeAvailableOnDevice()
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,index=[]):
        """
        Treats CUF and OpenACC subroutines/functions that carry CUF-specific attributes
        or require a device version as specified in a directive.

        :note: Removes 'attributes(...)' objects from the procedure header
        when encountering a CUF device procedure that
        needs to be kept on the host too.
        """
        attributesPresent       = self.__attributesPresent()
        mustBeAvailableOnDevice = self.mustBeAvailableOnDevice()
        mustBeAvailableOnHost   = self.__mustBeAvailableOnHost()

        original = joinedLines
        if attributesPresent: # CUF case
            if mustBeAvailableOnHost:
                return pAttributes.sub("", original), True
            elif mustBeAvailableOnDevice: # and not mustBeAvailableOnHost
                indent = self.firstLineIndent()
                return "{0}! extracted to HIP C++ file".format(indent), True
        else: 
            return original, False

class STDirective(STNode):
    def __init__(self,parent,firstRecord,firstRecordFirstStatement,directiveNo,sentinel="!$cuf"):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
        self._sentinel        = sentinel
        self._directiveNo     = directiveNo
        self._firstDirective  = self._records[0]["statements"][0]
    def singleLineStatement(self):
        """
        Express the statement as lower case single-line statement
        """
        return self._firstDirective

class STLoopKernel(STNode):
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
        self.gridFStr             = None
        self.blockFStr            = None
        self.sharedMemFStr        = "0" # set from extraction routine
        self.streamFStr           = "c_null_ptr" # set from extraction routine
        self.kernelArgNames       = [] # set from extraction routine
        self._doLoopCtrMemorised  = -1
        self.__originalStatements = []
    def __hash(self):
        """Compute hash code for this kernel. Must be done before any transformations are performed."""
        statements    = list(self.__originalStatements) # copy
        self.removeComments(statements)
        self.removeWhitespaces(statements)
        snippet       = "".join(statements)
        return hashlib.md5(snippet.encode()).hexdigest()[0:6]
    def completeInit(self):
        """Complete the initialization
        
        This routine is called after all associated records have
        been added to this node.
        """
        self.__originalStatements = self.statements()
    def kernelName(self):
        """Derive a name for the kernel"""
        return LOOP_KERNEL_NAME_TEMPLATE.format(parent=self._parent.name.lower(),lineno=self.minLineno(),hash=self.__hash())
    def kernelLauncherName(self):
        return "launch_{}".format(self.kernelName())
    def getSnippet(self,separator):
        """Creates a snippet from the (original) statements associated with this node
        :param str separator: character that is placed between the statements ('\n' or ';')
        """
        return separator.join([stmt.rstrip("\n") for stmt in self.__originalStatements])
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        indent = self.firstLineIndent()
        try:
            streamAsInt = int(self.streamFStr)
            stream = "c_null_ptr" if streamAsInt < 1 else self.streamFStr
        except:
            stream = self.streamFStr
        if self.gridFStr == None or self.blockFStr == None or LOOP_KERNEL_DEFAULT_LAUNCHER == "cpu": # use auto or cpu launcher 
            result="{indent}! extracted to HIP C++ file\n{indent}call {0}_{launcher}({1},{2},{3})".format(\
              self.kernelLauncherName(),self.sharedMemFStr,stream,\
                ",".join(self.kernelArgNames),indent=indent,launcher=LOOP_KERNEL_DEFAULT_LAUNCHER)
        else:
            result="{indent}! extracted to HIP C++ file\n{indent}call {0}({1},{2},{3},{4},{5})".format(\
              self.kernelLauncherName(),self.gridFStr,self.blockFStr,self.sharedMemFStr,stream,\
                ",".join(self.kernelArgNames),indent=indent)
        return result, True

class STDeclaration(STNode):
    """
    Works with Fortran declarations such as
    ```Fortran
    Complex(DP), allocatable, device :: devArray(:,:)
    ```
    """
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
        self._ttdeclaration   = translator.declaration.parseString(self.firstStatement())[0]
        self._vars            = [name.lower() for name in self._ttdeclaration.variableNames()]
    def createCodegenContext(self):
        return translator.createIndexRecordsFromDeclaration(self._ttdeclaration)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        """
        if device and allocatable, remove device, add pointer
        if device and fixed size array, remove device, add pointer, replace fixed bounds by other bounds
           find first code line and add allocation to preamble if no dummy argument. Do similar things
           with deallocation -> double pass
        if pinned and allocatable, add pointer
        if pinned and fixed size array, remove pinned, add pointer, replace fixed bounds by other bounds
           find first code line and add allocation to preamble if no dummy argument -> double pass
        if integer with stream kind, 
        """
        if len(indexHints):
            index = indexHints
        else:
            index = copy.copy(scoper.EMPTY)
            index["variables"] = self.createCodegenContext()
        originalDatatype          = translator.makeFStr(self._ttdeclaration._datatype)
        originalQualifiers        = [translator.makeFStr(q).lower() for q in self._ttdeclaration._qualifiers]
        unchangedVariables        = []  
        newDevicePointerVariables = []
        newHostPointerVariables   = []
        
        indent = self.firstLineIndent()
        # argument names if declared in procedure
        if isinstance(self._parent, STProcedure):
            argNames = list(self._parent._indexRecord["dummyArgs"])
        else:
            argNames = []
        result = ""
        for varName in self._vars:
             indexVar,discovered = scoper.searchIndexForVariable(\
               index,self._parent.tag(),\
                 translator.createIndexSearchTagForVariable(varName))
             rank           = indexVar["rank"]
             hasDevice      = indexVar["device"] == True
             hasPinned      = indexVar["pinned"] == True
             hasAllocatable = indexVar["allocatable"] == True  
             # clean qualifiers
             newQualifiers = []
             for q in originalQualifiers:
                if not q in ["target","pinned","device","allocatable"] and not q.startswith("dimension"):
                    newQualifiers.append(q)
             if varName in argNames: 
                 newQualifiers.append("target")
             else:
                 newQualifiers.append("pointer")
             if rank > 0:
                 newQualifiers.append("dimension(:"+",:"*(rank-1)+")")
             if hasDevice and rank > 0:
                 newDevicePointerVariables.append(varName)
                 result += "\n" + indent + originalDatatype + "," + ",".join(newQualifiers) + " :: " + varName
             elif hasPinned:
                 newHostPointerVariables.append(varName)
                 result += "\n" + indent + originalDatatype + "," + ",".join(newQualifiers) + " :: " + varName

        # TODO handle side effects if no allocatable present
        if len(newDevicePointerVariables) + len(newHostPointerVariables) < len(self._ttdeclaration._rhs): 
            result = indent + self._ttdeclaration.fStr(extraIgnoreList=newDevicePointerVariables+newHostPointerVariables) +\
                     result
        if len(newDevicePointerVariables) or len(newHostPointerVariables):
            return result.lstrip("\n"), True
        else:
            return "", False
            

class STAttributes(STNode):
    """
    CUDA Fortran specific intrinsic that needs to be removed/commented out
    in any case.
    """
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        return "", True

class STNonZeroCheck(STNode):
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        result = snippet
        transformed = False
        for tokens,start,end in translator.nonZeroCheck.scanString(result):
            parseResult = tokens[0]
            lhsName     = parseResult.lhsFStr()
            indexVar,_  = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
              translator.createIndexSearchTagForVariable(lhsName))
            onDevice    = scoper.indexVariableIsOnDevice(indexVar)
            transformed |= onDevice
            if onDevice:
                subst = parseResult.fStr() # TODO backend specific
                result = result.replace(result[start:end],subst)
        return result, transformed

class STAllocated(STNode):
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        def repl(parseResult):
            varName    = parseResult.varName()
            indexVar,_ = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
              translator.createIndexSearchTagForVariable(varName))
            onDevice    = scoper.indexVariableIsOnDevice(indexVar)
            return (parseResult.fStr(), onDevice) # TODO backend specific
        result, transformed = utils.pyparsingutils.replaceAll(snippet,translator.allocated,repl)
        assert result != None
        return result, transformed

class STAllocate(STNode):
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        indent = self.firstLineIndent()
        def repl(parseResult):
            nonlocal indent
            transformed     = False
            bytesPerElement = []
            arrayQualifiers = []
            for arrayName in parseResult.variableNames():
                indexVar,_  = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
                  translator.createIndexSearchTagForVariable(arrayName))
                bytesPerElement.append(indexVar["bytesPerElement"])
                onDevice   = scoper.indexVariableIsOnDevice(indexVar)
                pinned     = indexVar["pinned"] == True
                if onDevice: 
                    arrayQualifiers.append("device")
                elif pinned: 
                    arrayQualifiers.append("pinned")
                else:
                    arrayQualifiers.append(None)
                transformed |= onDevice | pinned
            subst = parseResult.hipFStr(bytesPerElement,arrayQualifiers,indent=indent).lstrip(" ")
            return (subst, transformed)
        return utils.pyparsingutils.replaceAll(joinedStatements,translator.allocate,repl)
             
class STDeallocate(STNode):
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        """
        :note: `wrapInIfDef` can be deactivated if a higher level function
        embeds the outcome already in an `ifdef`.
        """
        indent = self.firstLineIndent()
        def repl(parseResult):
            nonlocal indent
            transformed     = False
            arrayQualifiers = []
            for arrayName in parseResult.variableNames():
                indexVar,_  = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
                  translator.createIndexSearchTagForVariable(arrayName))
                onDevice   = scoper.indexVariableIsOnDevice(indexVar)
                pinned     = indexVar["pinned"] == True
                if onDevice: 
                    arrayQualifiers.append("device")
                elif pinned: 
                    arrayQualifiers.append("pinned")
                else:
                    arrayQualifiers.append(None)
                transformed |= onDevice | pinned
            subst = parseResult.hipFStr(arrayQualifiers,indent=indent).lstrip(" ")
            return (subst, transformed)
        return utils.pyparsingutils.replaceAll(joinedStatements,translator.deallocate,repl)
         
class STMemcpy(STNode):
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]): # TODO
        def replMemcpy(parseResult):
            destName = parseResult.destNameFStr()
            srcName  = parseResult.srcNameFStr()
            destIndexedVar,_ = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
              translator.createIndexSearchTagForVariable(destName))
            srcIndexedVar,_  = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
              translator.createIndexSearchTagForVariable(srcName))
            destOnDevice = scoper.indexVariableIsOnDevice(destIndexedVar)
            srcOnDevice  = scoper.indexVariableIsOnDevice(srcIndexedVar)
            bytesPerElement = destIndexedVar["bytesPerElement"]
            if destOnDevice or srcOnDevice:
                subst = parseResult.hipFStr(destOnDevice,srcOnDevice)
                return (subst,True)
            else:
                return ("",False) # no transformation; will not be considered
        return utils.pyparsingutils.replaceAll(joinedStatements,translator.memcpy,replMemcpy)

class STCudaLibCall(STNode):
    def __init__(self,parent,firstRecord,firstRecordFirstStatement):
        STNode.__init__(self,parent,firstRecord,firstRecordFirstStatement)
        self._cudaApi = ""
        self._hasCublas = False
    def hasCublas(self):
        """
        :return: Scanned code lines contain a cublas call.
        :rtype: bool
        """
        return self._hasCublas
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        global CUBLAS_VERSION 
        global KEEP_CUDA_LIB_NAMES
        snippet     = joinedStatements
        oldfSnippet = snippet
        indent      = self.firstLineIndent()
        transformed = False
        if not KEEP_CUDA_LIB_NAMES:
            def replMemcpy(parseResult):
                destName = parseResult.destNameFStr()
                srcName  = parseResult.srcNameFStr()
                destIndexedVar,_ = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
                  translator.createIndexSearchTagForVariable(destName))
                srcIndexedVar ,_ = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
                  translator.createIndexSearchTagForVariable(srcName))
                destOnDevice = scoper.indexVariableIsOnDevice(destIndexedVar)
                srcOnDevice  = scoper.indexVariableIsOnDevice(srcIndexedVar)
                subst = parseResult.hipFStr(destOnDevice,srcOnDevice)
                return (subst, True)
            snippet,_ = utils.pyparsingutils.replaceAll(snippet,translator.cufCudaMemcpyVariant,replMemcpy)
        def replCublas(parseResult):
            subst = parseResult.fStr(indent)
            return (subst, True)
        snippet,haveCublas = utils.pyparsingutils.replaceAll(snippet,translator.cublasCall,replCublas)
        if haveCublas:
            self._hasCublas = True
        for elem in CUDA_RUNTIME_ENUMS:
             snippet = replaceIgnoreCase(elem,elem.replace("cuda","hip").replace("CUDA","HIP"),snippet)
        for elem in CUDA_LIB_ENUMS:
             snippet = replaceIgnoreCase(elem,elem.replace("cu","hip").replace("CU","HIP"),snippet)
        for elem in ALL_HOST_ROUTINES: # runtime routines
             snippet = replaceIgnoreCase(elem,elem.replace("cuda","hip"),snippet)
        for elem in CUDA_MATH_LIB_FUNCTIONS:
             snippet = replaceIgnoreCase(elem,elem.replace("cu","hip"),snippet)
        transformed = snippet.lower() != oldfSnippet 
        return snippet, transformed

class STCudaKernelCall(STNode):
    """TODO(gpufort): Fix
    Translates a CUDA kernel call to a call to a subroutine interface.
    """
    def transform(self,joinedLines,joinedStatements,statementsFullyCoverLines,indexHints=[]):
        snippet = joinedStatements
        for tokens,start,end in translator.cudaKernelCall.scanString(snippet):
            parseResult = tokens[0]
            kernelArgs  = []
            for ttexpr in parseResult._args:
                # expand array arguments
                maxRank = 0
                for rvalue in translator.findAll(ttexpr,translator.TTRValue):
                    # TODO lookup the subprogram first 
                    indexVar, discovered = scoper.searchIndexForVariable(indexHints,self._parent.tag(),\
                       translator.createIndexSearchTagForVariable(rvalue.name()))
                    if discovered:
                        maxRank = max(maxRank,indexVar["rank"])
                exprFStr = translator.makeFStr(ttexpr)
                if maxRank > 0:
                    kernelArgs.append("c_loc("+exprFStr+")")
                else:
                    kernelArgs.append(exprFStr)
                for rank in range(1,maxRank+1):
                    kernelArgs.append("size({0},{1})".format(exprFStr,rank))
                for rank in range(1,maxRank+1):
                    kernelArgs.append("lbound({0},{1})".format(exprFStr,rank))
            kernelLaunchInfo = translator.cudaKernelCall.parseString(self.firstStatement())[0]
            subst="call launch_{0}({1},{2},{3},{4},{5})".format(\
              kernelLaunchInfo.kernelNameFStr(),\
              kernelLaunchInfo.gridFStr(),
              kernelLaunchInfo.blockFStr(),\
              kernelLaunchInfo.sharedMemFStr(),
              kernelLaunchInfo.streamFStr(),\
              ",".join(kernelArgs)
            )
            snippet = snippet.replace(snippet[start:end],subst)
            break
        return snippet, True
