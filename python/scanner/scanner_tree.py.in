# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.
def removeTypePrefix(varName):
    return varName.split("%")[-1]

def replaceIgnoreCase(key,subst,text):
    return re.sub(re.escape(key), subst, text, flags=re.IGNORECASE)

def flattenList(items):
    """Yield items from any nested iterable"""
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):
            for sub_x in flattenList(x):
                yield sub_x
        else:
            yield x

# Object representation

# We create an object tree because we want to preserve scope.

class Tagged:
    def tag(self):
        """
        Construct a tag that can be used to search the index.
        """
        result = self._name.lower()
        def recursiveParentLookup(curr):
            nonlocal result
            if type(curr) != STRoot:
                result = curr._name.lower() + ":" + result
                recursiveParentLookup(curr._parent)
        recursiveParentLookup(self._parent)        
        return result

class STNode:
    def __init__(self,parent,lineno,lines=[]):
        self._lineno                 = lineno
        self._lines                  = lines
        self._name                   = None
        self._children               = []
        self._parent                 = parent
        self._ignoreInS2STranslation = False 
        # transformation
        self._preamble = set() 
        self._epilog = set()
    def lines(self):
        return self._lines
    def minLineno(self):
        """
        :return: Inclusive first line number belonging to this object.
        """
        return self._lineno
    def maxLineno(self):
        """
        :return: Inclusive last line number belonging to this object.
        """
        return self._lineno + len(self._lines) - 1
    def strippedContent(self):
        """
        :return: The stripped content of this object as text. The functions removes all
        comments and Fortran linebreak characters '&'.
        :rettype: str
        """
        result = "".join(self._lines)
        comment = Literal("!") + ~(~White()+Literal("$")) + restOfLine + Optional(Regex(r"\n")) # via pyparsing
        amperSand = Regex(r"&\n")
        comment.setParseAction(lambda tokens: "") # remove comments
        amperSand.setParseAction(lambda tokens: "") # remove &
        result = commentCopy.transformString(result)
        result = amperSand.transformString(result)
        return result
    def considerInS2STranslation(self,indexHints=[]):
        """
        Consider this object when transforming host code.
        :return: The default implementation returns False if the parent
                 of the object is a device subroutine.
        """
        return not self._ignoreInS2STranslation
    def append(self,child):
        self._children.append(child)
    def listOfParents(self):
        """
        Returns a list that contains all
        parents of a node plus the node itself._
        """
        result = []
        def recursiveParentLookup(curr):
            if curr != None:
                result.append(curr)
                recursiveParentLookup(curr._parent)

        recursiveParentLookup(self)        
        return result
    def findAll(self,filter=lambda child : True,recursively=False):
        result = []
        def descend(curr):
            for child in curr._children:
                if filter(child):
                    result.append(child) 
                elif recursively:
                    descend(child)
        descend(self)       
        return result
    def findFirst(self,filter=lambda child: True):
        for child in self._children:
            if filter(child):
                return child
        return None
    def findLast(self,filter=lambda child: True):
        for child in reversed(self._children):
            if filter(child):
                return child
        return None
    def extractFirst(self,text,expression):
        """
        Extract (first) part of the text that contains a given expression.
        :rtype: str
        :return: The first part of the text that matches the expression.
        """ 
        for tokens,start,end in expression.scanString(text):
             return text[start:end]
        return ""
    def extractAll(self,text,expression):
        """
        Extract all parts of the text that contain a given pyparsing expression.
        :rtype: list
        :return: All parts of the text that match the pyparsing expression
        """
        result = []
        for tokens,start,end in expression.scanString(text):
             result.append(text[start:end])
        return result
    def preamble(self):
        """
        Some node transformations may require additional definitions
        such as the definition of macros.
        They write these definitions to the preamble so that
        a higher-level function can use them and place
        them at an appropriate location.
        """
        return "\n".join([el.rstrip() for el in self._preamble])
    def epilog(self):
        """
        Some node transformations may require additional definitions
        such as the definition of macros.
        They write these definitions to the preamble so that
        a higher-level function can use them and place
        them at an appropriate location.
        """
        return "\n".join([el.rstrip() for el in self._epilog])
    def transformFSnippet(self,fSnippet,indexHints=[]):
        """
        :param line: An excerpt from a Fortran file, possibly multiple lines
        :type line: str
        :return: If the text was changed at all
        :rtype: bool
        """
        return fSnippet, False

class STRoot(STNode):
    def __init__(self):
        STNode.__init__(self,None,-1)
    def considerInS2STranslation(self,indexHints=[]):
        return False

class STModule(STNode,Tagged):
    def __init__(self,name,parent,lineno):
        STNode.__init__(self,parent,lineno)
        self._name = name.lower()
    def considerInS2STranslation(self,indexHints=[]):
        return False

class STProgram(STNode,Tagged):
    def __init__(self,name,parent,lineno):
        STNode.__init__(self,parent,lineno)
        self._name = name.lower()
    def considerInS2STranslation(self,indexHints=[]):
        return False

class STUseStatement(STNode):
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
        self._name = None
    def name(self):
        return self._name
    def gpufortFStr(self,indexHints=[],indent=""):
        indent = " "*(len(self._lines[0]) - len(self._lines[0].lstrip()))
        result = "".join(self._lines).lower()
        useCuda = False
        for lib in HOST_MODULES:
            libLower = lib.lower()
            if libLower in result:
                useCuda = True
                result = result.replace(lib,lib.replace("cudafor",HIP_MODULE_NAME).replace("cu",HIP_MATH_MODULE_PREFIX+"hip"))
                if libLower == "cudafor":
                    result = result.rstrip("\n")+"\n" + "{0}use iso_c_binding".format(indent) 
        return result, useCuda
    def considerInS2STranslation(self,indexHints=[]):
        if not STNode.considerInS2STranslation(self):
            return False
        else:
            useCuda = False
            result = "".join(self._lines).lower()
            for lib in HOST_MODULES:
                 useCuda |= lib.lower() in result
            return useCuda or len(self._preamble) or len(self._epilog)

class STPlaceHolder(STNode):
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
        self._name = None
    def gpufortFStr(self,indexHints=[],indent=""):
        return self._lines[0], False
    def considerInS2STranslation(self,indexHints=[]):
        return STNode.considerInS2STranslation(self) and\
               (len(self._preamble) or len(self._epilog))

class STProcedure(STNode,Tagged):
    def __init__(self,qualifier,name,dummyArgs,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
        self._qualifier = qualifier
        self._name = name
        self._dummyArgs = dummyArgs
        self._lines = []
    def dummyArgumentNames(self):
        """
        :return: the list of procedure arguments.
        """
        return self._dummyArgs

class STSubroutine(STProcedure):
    def isAcceleratorRoutine(self):
        for keyword in ["device","global"]:
             if keyword in self._qualifier.lower():
                 return True
        return False
    def declarationsInBody(self):
        return self.findAll(filter=lambda child : type(child) is STDeclaration, recursively=False)
    def considerInS2STranslation(self,indexHints=[]):
        return STNode.considerInS2STranslation(self) and self.isAcceleratorRoutine()
    def transformFSnippet(self,fSnippet,indexHints=[]):
        indent = " "*(len(self._lines[0]) - len(self._lines[0].lstrip()))
        return "{0}! extracted to HIP C++ file".format(indent), True
    def gpufortFStr(self,indexHints=[]):
        return self.transformFSnippet("")

class STFunction(STProcedure):
    def considerInS2STranslation(self,indexHints=[]):
        return False

class STDirective(STNode):
    def __init__(self,parent,lineno,lines,directiveNo,sentinel="!$cuf"):
        STNode.__init__(self,parent,lineno,lines)
        self._sentinel            = sentinel
        self._singleLineStatement = None
        self._directiveNo         = directiveNo
    def singleLineStatement(self):
        """
        Express the statement as lower case single-line statement
        """
        assert len(self._lines)
        if self._singleLineStatement is None:
            _genericPragma = genericPragma.copy().setParseAction(lambda tokens: "") # do not overwrite existing parse action if any
            self._singleLineStatement = self._sentinel + " " + _genericPragma.transformString(" ".join(self._lines)).rstrip("\n").replace("&","").lower()
            # remove whitespaces
            self._singleLineStatement = White().setParseAction(lambda tokens: " ").transformString(self._singleLineStatement)
        return self._singleLineStatement

class STLoopKernel(STNode):
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
        self._doLoopCtrMemorised     = -1
        self._singleLineStatement    = None
        self._gridFStr               = None
        self._blockFStr              = None
        self._sharedMemFStr          = "0" # set from extraction routine
        self._streamFStr             = "c_null_ptr" # set from extraction routine
        self._kernelArgNames         = [] # set from extraction routine
    def stripLines(self,lines):
        """Remove whitespace characters and comments."""
        result = ""
        for line in lines:
             result += line.split("!")[0]
        result = result.replace(" ","")
        result = result.replace("&","")
        return result.lower()
    def hashSnippet(self):
        snippet = self.stripLines(self._lines) 
        return hashlib.md5(snippet.encode()).hexdigest()[0:6]
    def hashBody(self):
        snippet = self.stripLines(self._lines[1:]) 
        return hashlib.md5(snippet.encode()).hexdigest()[0:6]
    def kernelName(self):
        """
        Derive a name for the kernel.
        
        We hash the body because we will use different block sizes and shmem anyway in HIP.
        """
        return LOOP_KERNEL_NAME_TEMPLATE.format(parent=self._parent._name.lower(),lineno=self._lineno+1,hash=self.hashBody())
    def kernelLauncherName(self):
        return "launch_{}".format(self.kernelName())
    def transformFSnippet(self,fSnippet,indexHints=[]):
        indent = " "*(len(self._lines[0]) - len(self._lines[0].lstrip()))
        try:
          streamAsInt = int(self._streamFStr)
          stream = "c_null_ptr" if streamAsInt < 1 else self._streamFStr
        except:
          stream = self._streamFStr
        if self._gridFStr == None or self._blockFStr == None or LOOP_KERNEL_DEFAULT_LAUNCHER == "cpu": # use auto or cpu launcher 
          result="""{indent}! extracted to HIP C++ file
  {indent}CALL {0}_{launcher}({1},{2},{3})""".format(self.kernelLauncherName(),self._sharedMemFStr,stream,\
            ",".join(self._kernelArgNames),indent=indent,launcher=LOOP_KERNEL_DEFAULT_LAUNCHER)
        else:
          result="""{indent}! extracted to HIP C++ file
  {indent}CALL {0}({1},{2},{3},{4},{5})""".format(self.kernelLauncherName(),self._gridFStr,self._blockFStr,self._sharedMemFStr,stream,\
            ",".join(self._kernelArgNames),indent=indent)
          
        return result, True
    def gpufortFStr(self,indexHints=[]):
        return self.transformFSnippet("".join(self._lines),indexHints)

class STDeclaration(STNode):
    """
    Works with Fortran declarations such as
    ```Fortran
    Complex(DP), allocatable, device :: devArray(:,:)
    ```
    """
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
        self._ttdeclaration   = translator.declaration.parseString(self._lines[0])[0]
        self._vars            = [name.lower() for name in self._ttdeclaration.variableNames()]
    def createCodegenContext(self):
        return translator.createCodegenContextFromDeclaration(self._ttdeclaration)
    def considerInS2STranslation(self,indexHints=[]):
        interestingQualifiers = ["device","pinned","managed"]
        if not self._ignoreInS2STranslation:
            if len(self._preamble) or len(self._epilog):
                return True
            for l in self._lines:
                lineLower = l.lower()
                for q in interestingQualifiers:
                    if q in lineLower:
                        return True
            if len(indexHints):
                filteredIndex = indexertools.filterIndexByTag(indexHints,self._parent.tag())
                for varName in self._vars:
                    indexedVar,discovered = indexertools.searchIndexForVariable(filteredIndex,varName)
                    if discovered:
                        for q in interestingQualifiers:
                            if indexedVar[q] == True:
                                return True
        return False 
    def gpufortFStr(self,indexHints=[]):
        """
        if device and allocatable, remove device, add pointer
        if device and fixed size array, remove device, add pointer, replace fixed bounds by other bounds
           find first code line and add allocation to preamble if no dummy argument. Do similar things
           with deallocation -> double pass
        if pinned and allocatable, add pointer
        if pinned and fixed size array, remove pinned, add pointer, replace fixed bounds by other bounds
           find first code line and add allocation to preamble if no dummy argument -> double pass
        if integer with stream kind, 
        """
        if len(indexHints):
            filteredIndex = indexertools.filterIndexByTag(indexHints,self._parent.tag())
        else:
            filteredIndex = indexertools.EMPTY
            filteredIndex["variables"] = self.createCodegenContext()
        originalDatatype          = translator.makeFStr(self._ttdeclaration._datatype)
        originalQualifiers        = [translator.makeFStr(q).lower() for q in self._ttdeclaration._qualifiers]
        unchangedVariables        = []  
        newDevicePointerVariables = []
        newHostPointerVariables   = []
        
        indent = " "*(len(self._lines[0]) - len(self._lines[0].lstrip()))
        # argument names if declared in procedure
        if isinstance(self._parent, STProcedure):
            argNames = [makeFStr(n).lower() for n in self.parent._dummyArgs]
        else:
            argNames = []
        result = ""
        for varName in self._vars:
             indexedVar,discovered = indexertools.searchIndexForVariable(filteredIndex,varName)
             rank           = indexedVar["rank"]
             hasDevice      = indexedVar["device"] == True
             hasPinned      = indexedVar["pinned"] == True
             hasAllocatable = indexedVar["allocatable"] == True  
             # clean qualifiers
             newQualifiers = []
             for q in originalQualifiers:
                if not q in ["target","pinned","device","allocatable"] and not q.startswith("dimension"):
                    newQualifiers.append(q)
             if varName in argNames: 
                 newQualifiers.append("target")
             else:
                 newQualifiers.append("pointer")
             if rank > 0:
                 newQualifiers.append("dimension(:"+",:"*(rank-1)+")")
             if hasDevice and rank > 0:
                 newDevicePointerVariables.append(varName)
                 result += "\n" + indent + originalDatatype + "," + ",".join(newQualifiers) + " :: " + varName
             elif hasPinned:
                 newHostPointerVariables.append(varName)
                 result += "\n" + indent + originalDatatype + "," + ",".join(newQualifiers) + " :: " + varName

        # TODO handle side effects if no allocatable present
        if len(newDevicePointerVariables) + len(newHostPointerVariables) < len(self._ttdeclaration._rhs): 
            result = indent + self._ttdeclaration.fStr(extraIgnoreList=newDevicePointerVariables+newHostPointerVariables) +\
                     result
        if len(newDevicePointerVariables) or len(newHostPointerVariables):
            return result.lstrip("\n"), True
        else:
            return "".join(self._lines), False

class STAttributes(STNode):
    """
    CUDA Fortran specific intrinsic that needs to be removed/commented out
    in any case.
    """
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
    def gpufortFStr(self,indexHints=[],indent=""):
        return "", True

class STNonZeroCheck(STNode):
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
    def transformFSnippet(self,fSnippet,indexHints=[]): # TODO
        result = fSnippet
        transformed = False
        for tokens,start,end in translator.nonZeroCheck.scanString(result):
            parseResult = tokens[0]
            lhsName     = parseResult.lhsFStr()
            indexedVar  = indexertools.searchIndexForVariable(indexHints,lhsName)
            onDevice    = indexedVar["device"] == True or indexedVar["declaredOnTarget"] == True
            transformed |= onDevice
            if onDevice:
                subst = parseResult.fStr() # TODO backend specific
                result = result.replace(result[start:end],subst)
        return result, transformed

class STAllocated(STNode):
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
    def transformFSnippet(self,fSnippet,indexHints=[]): # TODO
        def repl(parseResult):
            varName = parseResult.varName()
            indexedVar  = indexertools.searchIndexForVariable(indexHints,varName)
            onDevice    = indexedVar["device"] == True or indexedVar["declaredOnTarget"] == True
            return (parseResult.fStr(), onDevice) # TODO backend specific
        result, transformed = pyparsingtools.replaceAll(fSnippet,translator.allocated,repl)
        assert result != None
        return result, transformed

class STAllocate(STNode):
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
    def transformFSnippet(self,fSnippet,indexHints=[]): # TODO
        def repl(parseResult):
            transformed     = False
            bytesPerElement = []
            arrayQualifiers = []
            for arrayName in parseResult.variableNames():
                indexedVar = indexertools.searchIndexForVariable(indexHints,arrayName)[0]
                bytesPerElement.append(indexedVar["bytesPerElement"])
                onDevice   = indexedVar["device"] == True or indexedVar["declaredOnTarget"] == True
                pinned     = indexedVar["pinned"] == True
                if onDevice: 
                    arrayQualifiers.append("device")
                elif pinned: 
                    arrayQualifiers.append("pinned")
                else:
                    arrayQualifiers.append(None)
                transformed |= onDevice | pinned
            subst = parseResult.hipFStr(bytesPerElement,arrayQualifiers,indent="")
            return (subst, transformed)
        return pyparsingtools.replaceAll(fSnippet,translator.allocate,repl)
             
class STDeallocate(STNode):
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
    def transformFSnippet(self,fSnippet,indexHints=[]): # TODO
        """
        :note: `wrapInIfDef` can be deactivated if a higher level function
        embeds the outcome already in an `ifdef`.
        """
        def repl(parseResult):
            transformed     = False
            arrayQualifiers = []
            for arrayName in parseResult.variableNames():
                indexedVar = indexertools.searchIndexForVariable(indexHints,arrayName)[0]
                onDevice   = indexedVar["device"] == True or indexedVar["declaredOnTarget"] == True
                pinned     = indexedVar["pinned"] == True
                if onDevice: 
                    arrayQualifiers.append("device")
                elif pinned: 
                    arrayQualifiers.append("pinned")
                else:
                    arrayQualifiers.append(None)
                transformed |= onDevice | pinned
            subst = parseResult.hipFStr(arrayQualifiers,indent="")
            return (subst, transformed)
        return pyparsingtools.replaceAll(fSnippet,translator.deallocate,repl)
         
class STMemcpy(STNode):
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
    def transformFSnippet(self,fSnippet,indexHints=[]): # TODO
        def replMemcpy(parseResult):
            destName = parseResult.destNameFStr()
            srcName  = parseResult.srcNameFStr()
            destIndexedVar = indexertools.searchIndexForVariable(indexHints,destName)[0]
            srcIndexedVar  = indexertools.searchIndexForVariable(indexHints,srcName)[0]
            destOnDevice = destIndexedVar["device"] == True or destIndexedVar["declaredOnTarget"] == True
            srcOnDevice  = srcIndexedVar["device"] == True or srcIndexedVar["declaredOnTarget"] == True
            bytesPerElement = destIndexedVar["bytesPerElement"]
            if destOnDevice or srcOnDevice:
                subst = parseResult.hipFStr(destOnDevice,srcOnDevice)
                return (subst,True)
            else:
                return ("",False) # no transformation; will not be considered
        fSnippet, transformed = pyparsingtools.replaceAll(fSnippet,translator.memcpy,replMemcpy)
        return fSnippet, transformed

class STCudaLibCall(STNode):
    def __init__(self,parent,lineno,lines):
        STNode.__init__(self,parent,lineno,lines)
        self._cudaApi = ""
        self._hasCublas = False
    def hasCublas(self):
        """
        :return: Scanned code lines contain a cublas call.
        :rtype: bool
        """
        return self._hasCublas
    def transformFSnippet(self,fSnippet,indexHints=[]):
        global CUBLAS_VERSION 
        global KEEP_CUDA_LIB_NAMES
        oldfSnippet = fSnippet
        indent = ""#" "*(len(self._lines[0]) - len(self._lines[0].lstrip()))
        transformed = False
        if not KEEP_CUDA_LIB_NAMES:
            def replMemcpy(parseResult):
                destName = parseResult.destNameFStr()
                srcName  = parseResult.srcNameFStr()
                destIndexedVar = indexertools.searchIndexForVariable(indexHints,destName)[0]
                srcIndexedVar  = indexertools.searchIndexForVariable(indexHints,srcName)[0]
                destOnDevice = destIndexedVar["device"] == True or destIndexedVar["declaredOnTarget"] == True
                srcOnDevice  = srcIndexedVar["device"] == True or srcIndexedVar["declaredOnTarget"] == True
                subst = parseResult.hipFStr(destOnDevice,srcOnDevice)
                return (subst, True)
            fSnippet,_ = pyparsingtools.replaceAll(fSnippet,translator.cufCudaMemcpyVariant,replMemcpy)
        def replCublas(parseResult):
            subst = parseResult.fStr(indent)
            return (subst, True)
        fSnippet,haveCublas = pyparsingtools.replaceAll(fSnippet,translator.cublasCall,replCublas)
        if haveCublas:
            self._hasCublas = True
        for elem in CUDA_RUNTIME_ENUMS:
             fSnippet = replaceIgnoreCase(elem,elem.replace("cuda","hip").replace("CUDA","HIP"),fSnippet)
        for elem in CUDA_LIB_ENUMS:
             fSnippet = replaceIgnoreCase(elem,elem.replace("cu","hip").replace("CU","HIP"),fSnippet)
        for elem in ALL_HOST_ROUTINES: # runtime routines
             fSnippet = replaceIgnoreCase(elem,elem.replace("cuda","hip"),fSnippet)
        for elem in CUDA_MATH_LIB_FUNCTIONS:
             fSnippet = replaceIgnoreCase(elem,elem.replace("cu","hip"),fSnippet)
        transformed = fSnippet.lower() != oldfSnippet 
        return fSnippet, transformed

class STCudaKernelCall(STNode):
    """TODO(gpufort): Fix
    """
    def transformFSnippet(self,fSnippet,indexHints=[]):
        #TODO(gpufort): Check variables, check which ones are array variables and replace with additional information such as size per dimension and lower bound,  _ni and _lbi.
        for tokens,start,end in translator.cudaKernelCall.scanString(fSnippet):
            parseResult = tokens[0]
            kernelArgs = self._lines[0].split("(")[1]
            kernelLaunchInfo = translator.cudaKernelCall.parseString(self._lines[0])[0]
            subst="CALL launch_{0}({1},{2},{3},{4},{5}".format(\
              kernelLaunchInfo.kernelNameFStr(),\
              kernelLaunchInfo.gridFStr(),
              kernelLaunchInfo.blockFStr(),\
              kernelLaunchInfo.sharedMemFStr(),
              kernelLaunchInfo.streamFStr(),\
              kernelArgs
            )
            fSnippet = fSnippet.replace(fSnippet[start:end],subst)
            break
        return fSnippet, True
