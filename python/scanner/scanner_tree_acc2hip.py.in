ACC_DEV_PREFIX="dev_"
ACC_DEV_SUFFIX=""

# init shutdown
tAccInit     = "call gpufort_acc_init()\n"
tAccShutdown = "call gpufort_acc_shutdown()\n"
# regions
tAccEnterRegion = "call gpufort_acc_enter_region()\n"
tAccExitRegion = "call gpufort_acc_exit_region()\n"
# create
tAccCreate = "{devVar} = gpufort_acc_create({var})\n"
# no_create
tAccNoCreate = "{devVar} = gpufort_acc_no_create({var})\n"
# delete
tAccDelete = "call gpufort_acc_delete({var}{finalize})\n"
# copyin
tAccCopyin = "{devVar} = gpufort_acc_copyin({var}{async})\n"
# copy
tAccCopy = "{devVar} = gpufort_acc_copy({var}{async})\n"
# copyout
tAccCopyout = "{devVar} = gpufort_acc_copyout({var}{async})\n"
# update host
tAccUpdateHost = "call gpufort_acc_update_host({var}{async})\n"
# update device
tAccUpdateDevice = "call gpufort_acc_update_device({var}{async})\n"
# present
tAccPresent = "{devVar} = gpufort_acc_present({var})\n"
# wait
tAccWait = "call gpufort_acc_wait({queue}{async})\n"

def devVarName(var):
    #tokens = var.split("%")
    #tokens[-1] = ACC_DEV_PREFIX+tokens[-1]+ACC_DEV_SUFFIX
    #return "%".join(tokens)
    result = var.replace("%","_")
    result = result.replace("(","$")
    result = result.replace(")","$")
    result = "".join(c for c in result if c.isalnum() or c in "_$")
    result = result.replace("$$","")
    result = result.replace("$","_")
    return ACC_DEV_PREFIX + result + ACC_DEV_SUFFIX

class Acc2Hip:
    # clauses 
    def handleAsync(self,queue=None,prefix=",async="):
        """
        :return: Empty string if no queue was found
        :rtype: str
        """
        result = ""
        if queue is None:
            for parseResult in translator.acc_async.searchString(queue,1):
                #print(parseResult)
                # TODO find ...
                result = parseResult[0].queue()
        if len(result):
           result = prefix + result
        return result
    def handleFinalize(self):
        """
        :return: If a finalize clause is present
        :rtype: bool
        """
        return len(translator.acc_finalize.searchString(self.singleLineStatement(),1))
    def handlePresent(self):
        """
        Emits a acc_present command for every variable in the list
        """
        result = ""
        tempVars = set()
        template = tAccPresent
        for parseResult in translator.acc_present.scanString(self.singleLineStatement()):
            for rvalue in parseResult[0][0]:
                varExpr = rvalue.varName()
                deviceptr = devVarName(varExpr)
                tempVars.add(deviceptr)
                result += template.format(var=varExpr,devVar=deviceptr)
        return result, len(result), tempVars
    def handleDefault(self):
        """
        Emits a acc_present command for every variable in the list
        """
        result = ""
        tempVars = set()
        template = tAccPresent
        for parseResult in translator.acc_default.scanString(self.singleLineStatement(),1):
            value = str(parseResult[0][0]).lower()
            #print(value)
            if value == "present":
                for varExpr in self._defaultPresentVars:
                    deviceptr = devVarName(varExpr)
                    tempVars.add(deviceptr)
                    result += template.format(var=varExpr,devVar=deviceptr)
        return result, len(result), tempVars
    def handleCreate(self):
        """
        Emits a acc_create command for every variable in the list
        """
        result = ""
        tempVars = set()
        # create
        template = tAccCreate
        for parseResult in translator.acc_create.scanString(self.singleLineStatement()):
            for rvalue in parseResult[0][0]:
                varExpr = rvalue.varName()
                deviceptr = devVarName(varExpr)
                tempVars.add(deviceptr)
                result += template.format(var=varExpr,devVar=deviceptr)
        return result, len(result), tempVars
    def handleNoCreate(self):
        """
        Emits a acc_no_create command for every variable in the list
        """
        result = ""
        tempVars = set()
        # no_create
        template = tAccNoCreate
        for parseResult in translator.acc_no_create.scanString(self.singleLineStatement()):
            for rvalue in parseResult[0][0]:
                varExpr = rvalue.varName()
                deviceptr = devVarName(varExpr)
                tempVars.add(deviceptr)
                result += template.format(var=varExpr,devVar=deviceptr)
        return result, len(result), tempVars
    def handleDelete(self):
        """
        Emits a acc_delete command for every variable in the list
        """
        result = ""
        tempVars = set()
        # delete
        template = tAccDelete
        for parseResult in translator.acc_delete.scanString(self.singleLineStatement()):
            for rvalue in parseResult[0][0]:
                varExpr = rvalue.varName()
                deviceptr = devVarName(varExpr)
                finalize = ""
                if self.handleFinalize():
                    finalize = ".TRUE."
                result += template.format(var=varExpr,devVar=deviceptr,finalize=finalize)
        return result, len(result), tempVars
    def handleCopy(self):
        """
        Emits a acc_copy command for every variable in the list
        """
        result = ""
        tempVars = set()

        # copy
        template = tAccCopy
        for parseResult in translator.acc_copy.scanString(self.singleLineStatement()):
            for rvalue in parseResult[0][0]:
                varExpr = rvalue.varName()
                deviceptr = devVarName(varExpr)
                tempVars.add(deviceptr)
                result += template.format(var=varExpr,devVar=deviceptr,async=self.handleAsync())
        return result, len(result), tempVars
    def handleCopyin(self):
        """
        Emits a acc_copyin command for every variable in the list
        """
        result = ""
        tempVars = set()
        # copyin
        template = tAccCopyin
        for parseResult in translator.acc_copyin.scanString(self.singleLineStatement()):
            for rvalue in parseResult[0][0]:
                varExpr = rvalue.varName()
                deviceptr = devVarName(varExpr)
                tempVars.add(deviceptr)
                result += template.format(var=varExpr,devVar=deviceptr,async=self.handleAsync())
        return result, len(result), tempVars
    def handleCopyout(self):
        """
        Emits a acc_copyout command for every variable in the list
        """
        result = ""
        tempVars = set()
        # copyout
        template = tAccCopyout
        for parseResult in translator.acc_copyout.scanString(self.singleLineStatement()):
            for rvalue in parseResult[0][0]:
                varExpr = rvalue.varName()
                deviceptr = devVarName(varExpr)
                tempVars.add(deviceptr)
                result += template.format(var=varExpr,devVar=deviceptr,async=self.handleAsync())
        return result, len(result), tempVars
    def handleUpdate(self):
        """
        Emits a acc_copy command for every variable in the list
        """
        result = ""
        tempVars = set()
        # update host
        #for parseResult in translator.acc_update.scanString(self.singleLineStatement()):
        #    #print(parseResult[0][0])
        #    #print(parseResult[0][1])
        #    async=self.handleAsync(parseResult[0][1])
        #    #print(async)
        #    for dest in parseResult[0][0]:
        #        #print(dest)
        #        template = tAccUpdateHost
        #        if dest[0]: # -> device
        #           template = tAccUpdateDevice
        #        #print(dest[0])
        #        #print(dest[1])
        #        for rvalue in dest[1]:
        #            #print(rvalue)
        #            varExpr = rvalue.fStr()
        #            deviceptr = devVarName(varExpr)
        #            result += template.format(var=varExpr,devVar=deviceptr,async=async)
        return result, len(result), tempVars
    def handleWait(self):
        """
        Emits a acc_wait command for every variable in the list
        """
        result = ""
        tempVars = set()
        # wait
        template = tAccWait
        for parseResult in translator.acc_wait.scanString(self.singleLineStatement()):
            queueList=[]
            asyncList=[]
            for rvalue in parseResult[0][0]: # queue ids
                queueList.append(rvalue.varName())
            for rvalue in parseResult[0][1]: # async queue ids
                asyncList.append(rvalue.varName())
            queue=""
            async=""
            if len(queueList):
                queue = ",[{}]".format(",".join(queueList))
            if len(asyncList):
                async = ",[{}]".format(",".join(asyncList))
            result += template.format(queue=queue,async=async)
        return result, len(result), tempVars
    def handleIf(self):
        """
        :return: Empty string if no if was found
        :rtype: str
        """
        condition = ""
        for parseResult in translator.acc_if.searchString(self.singleLineStatement(),1):
            condition = parseResult[0].condition()
        return condition
    def hipFStr(self,handleIf=True):
        """
        :param line: An excerpt from a Fortran file, possibly multiple lines
        :type line: str
        :return: If the text was changed at all
        :rtype: bool
        """
        result = ""
        allTempVars = set()
        
        ## Init 
        if self.isInitDirective():
            result += tAccInit
        
        ## Enter region commands must come first
        emitEnterRegion = self.isEnterDirective()
        emitEnterRegion = emitEnterRegion or self.isDataDirective()
        emitEnterRegion = emitEnterRegion or self.isParallelDirective()
        emitEnterRegion = emitEnterRegion or self.isParallelLoopDirective() 
        emitEnterRegion = emitEnterRegion or self.isKernelsDirective()
        if emitEnterRegion:
            result += tAccEnterRegion 

        ## Other directives/clauses
        # create
        partialResult, transformed, tempVars = self.handleCreate()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # no_create
        partialResult, transformed, tempVars = self.handleNoCreate()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # present
        partialResult, transformed, tempVars = self.handlePresent()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # default
        partialResult, transformed, tempVars = self.handleDefault()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # delete
        partialResult, transformed, tempVars = self.handleDelete()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # copy
        partialResult, transformed, tempVars = self.handleCopy()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # copyin
        partialResult, transformed, tempVars = self.handleCopyin()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        # copyout
        partialResult, transformed, tempVars = self.handleCopyout()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        
        # update directive
        partialResult, transformed, tempVars = self.handleUpdate()
        if transformed:
            result += partialResult
            allTempVars.update(tempVars)
        
        ## wait
        partialResult, transformed, _ = self.handleWait()
        if transformed:
            result += partialResult
        
        ## Exit region commands must come last
        emitExitRegion = self.isExitDirective()
        emitExitRegion = emitExitRegion or (self.isEndDirective() and self.findSubstring("kernels") and not self.findSubstring("loop"))
        emitExitRegion = emitExitRegion or (self.isEndDirective() and self.findSubstring("parallel") and not self.findSubstring("loop"))
        emitExitRegion = emitExitRegion or (self.isEndDirective() and self.findSubstring("data"))
        if emitExitRegion:
            result += tAccExitRegion
        if self.isShutdownDirective():
            result += tAccShutdown
       
        # handle if 
        condition = self.handleIf()
        if len(condition) and handleIf:
            result = "if ( {condition} ) then\n{result}\n endif".format(\
                    condition=condition, result=result.rstrip("\n"))
       
        # introduce the new variables 
        if len(allTempVars):
            begin = self._parent.findLast(filter=lambda child : not child._included and type(child) in [STUseStatement,STDeclaration,STPlaceHolder])
            if not begin is None:
                indent = " "*(len(begin._lines[0]) - len(begin._lines[0].lstrip()))
                for var in allTempVars:
                     begin._epilog.add("{indent}type(c_ptr) :: {name}\n".format(indent=indent,name=var))
            else:
                indent = " "*(len(self._lines[0]) - len(self._lines[0].lstrip()))
                self._preamble.add("! TODO(gpufort): move declarations and use statement to appropriate place\n")
                for var in allTempVars:
                    self._preamble.add("{indent}type(c_ptr) :: {name}\n".format(indent=indent,name=var))

        return result, len(result)

class Acc2HipLoopKernel:
    def hipFStr(self):
        result = ""
        if self.isParallelLoopDirective() or self.isKernelsLoopDirective():
            partialResult, _ = STAccDirective.hipFStr(self,handleIf=False) 
            result = partialResult
        partialResult, _ = STLoopKernel.hipFStr(self) 
        result += partialResult
        if self.isParallelLoopDirective() or self.isKernelsLoopDirective():
           result += "\n"+tAccExitRegion
       
        # add wait call if necessary
        queue = self.handleAsync(None,"")
        if not len(queue):
            result += "\n" + tAccWait.format(queue=queue,async="")

        # wrap in ifdef if necessary
        condition = self.handleIf()
        if len(condition):
            result = "if ( {condition} ) then\n{result}\nelse\n {original}\n endif".format(\
                    condition=condition, result=result.rstrip("\n"), original="".join(self._lines).rstrip("\n"))
        return result, len(result)
