module etat0_dcmip2016_supercell_mod
use icosa
subroutine getin_etat0
use mpipara, only : is_mpi_root
use tracer_mod
use dcmip2016_supercell_mod, only : supercell_init, supercell_test
end subroutine getin_etat0
subroutine compute_etat0(ngrid,lon,lat, phis,ps,temp,ulon,ulat,q)
use icosa
use disvert_mod
use omp_para
use dcmip2016_supercell_mod, only : supercell_init, supercell_test, supercell_z
use terminator, only: initial_value_terminator
integer, intent(in) :: ngrid
real(rstd),intent(in) :: lon(ngrid)
real(rstd),intent(in) :: lat(ngrid)
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: ps(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm)
real(rstd),intent(out) :: ulon(ngrid,llm)
real(rstd),intent(out) :: ulat(ngrid,llm)
real(rstd),intent(out) :: q(ngrid,llm,nqtot)
integer :: l,ij
integer,parameter :: perturbation = 1
real(rstd) :: p,z, thetav,rho
end subroutine compute_etat0
end module etat0_dcmip2016_supercell_mod
module etat0_heldsz_mod
use icosa
type(t_field),pointer :: f_theta_eq(:)
type(t_field),pointer :: f_theta(:)
real(rstd),allocatable :: knewt_t(:),kfrict(:)
logical :: done=.false.
real(rstd) :: p0,teta0,ttp,delt_y,delt_z,eps
real(rstd) :: knewt_g, k_f,k_c_a,k_c_s
subroutine test_etat0_heldsz
use kinetic_mod
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
type(t_field),pointer :: f_ki(:)
end subroutine test_etat0_heldsz
subroutine init_etat0
end subroutine init_etat0
subroutine etat0(f_ps,f_phis,f_theta_rhodz,f_u, f_q)
use theta2theta_rhodz_mod
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
real(rstd),pointer :: ps(:)
real(rstd),pointer :: phis(:)
real(rstd),pointer :: theta_rhodz(:,:,:)
real(rstd),pointer :: u(:,:)
real(rstd),pointer :: q(:,:,:)
real(rstd),pointer :: theta_eq(:,:)
real(rstd),pointer :: theta(:,:)
integer :: ind
end subroutine etat0
subroutine init_teq
use abort_mod
use disvert_mod, only : ap,bp
real(rstd),pointer :: theta_eq(:,:)
real(rstd) :: zsig
integer :: ind, l
end subroutine init_teq
subroutine compute_teq(lat,theta_eq)
use disvert_mod
real(rstd),intent(in) :: lat(iim*jjm)
real(rstd),intent(out) :: theta_eq(iim*jjm,llm)
real(rstd) :: zsig, ddsin, tetastrat, tetajl
integer :: i,j,l,ij
end subroutine compute_teq
subroutine compute_etat0_heldsz(theta_eq, theta)
use disvert_mod
real(rstd),intent(in) :: theta_eq(iim*jjm,llm)
real(rstd),intent(out) :: theta(iim*jjm,llm)
real(rstd) :: r  ! random number
integer :: i,j,l,ij
end subroutine compute_etat0_heldsz
subroutine held_suarez(f_ps,f_theta_rhodz,f_u)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_ps(:)
real(rstd),pointer :: theta_rhodz(:,:,:)
real(rstd),pointer :: u(:,:)
real(rstd),pointer :: ps(:)
real(rstd),pointer :: theta_eq(:,:)
real(rstd),pointer :: theta(:,:)
integer::ind
end subroutine held_suarez
subroutine compute_heldsz(ps,theta_eq,lat, theta_rhodz,u, theta)
use theta2theta_rhodz_mod
use omp_para
real(rstd),intent(in)    :: ps(iim*jjm)
real(rstd),intent(in)    :: theta_eq(iim*jjm,llm)
real(rstd),intent(in)    :: lat(iim*jjm)
real(rstd),intent(inout) :: theta_rhodz(iim*jjm,llm)
real(rstd),intent(inout) :: u(3*iim*jjm,llm)
real(rstd),intent(out)   :: theta(iim*jjm,llm)
integer :: i,j,l,ij
end subroutine compute_heldsz
end module etat0_heldsz_mod
module etat0_bubble_mod
use icosa
real(rstd), parameter :: latc=0., lonc=0.,         width        = 0.3, & ! width of mountain (radian)
real(rstd), save :: t0 ! adiabatic atmosphere at theta=t0 (default 300k)
real(rstd), save :: ztop ! mountain top (default 0.)
real(rstd), save :: delta_t ! bubble extra temperature (default 5k)
subroutine getin_etat0
end subroutine getin_etat0
subroutine compute_etat0(ngrid,lon,lat, phis,ps,temp,ulon,ulat,geopot,q)
use icosa
use disvert_mod
use omp_para
integer, intent(in) :: ngrid
real(rstd),intent(in) :: lon(ngrid)
real(rstd),intent(in) :: lat(ngrid)
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: ps(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm)
real(rstd),intent(out) :: ulon(ngrid,llm)
real(rstd),intent(out) :: ulat(ngrid,llm)
real(rstd),intent(out) :: geopot(ngrid,llm+1)
real(rstd),intent(out) :: q(ngrid,llm,nqtot)
integer :: l,ij
real(rstd) :: sinlat, coslat, k, ts, p_ij, t_ij, z_ij
end subroutine compute_etat0
end module etat0_bubble_mod
module etat0_dcmip3_mod
subroutine compute_etat0(ngrid,lon,lat, phis,ps,temp,ulon,ulat,geopot,q)
use dcmip_initial_conditions_test_1_2_3
use disvert_mod
use omp_para
integer, intent(in) :: ngrid
real(rstd), intent(in) :: lon(ngrid)
real(rstd), intent(in) :: lat(ngrid)
real(rstd), intent(out) :: phis(ngrid)
real(rstd), intent(out) :: ps(ngrid)
real(rstd), intent(out) :: ulon(ngrid,llm)
real(rstd), intent(out) :: ulat(ngrid,llm)
real(rstd), intent(out) :: temp(ngrid,llm)
real(rstd), intent(out) :: geopot(ngrid,llm+1)
real(rstd), intent(out) :: q(ngrid,llm,nqtot)
real(rstd),parameter :: peq=1e5        ! reference surface pressure at the equator (hpa)
real(rstd) :: dummy_z, dummy_u, dummy_v, dummy_w, dummy_t, dummy_phis, dummy_ps, dummy_rho, dummy_q
real(rstd) :: pp, zz
integer :: l,ij
end subroutine compute_etat0
end module etat0_dcmip3_mod
module etat0_start_file_mod
subroutine init_etat0
use xios_mod
use omp_para
use time_mod
use restart_mod
end subroutine init_etat0
subroutine etat0(f_ps,f_phis,f_theta_rhodz,f_u, f_q)
use icosa
use restart_mod
use wind_mod
use write_field_mod
use time_mod
use transfert_mod
use omp_para
use checksum_mod
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
type(t_field),pointer,save :: f_ulon(:)
type(t_field),pointer,save :: f_ulat(:)
type(t_field),pointer,save :: f_theta_rhodz_1d(:)
real(rstd), pointer :: theta_rhodz(:,:,:),theta_rhodz_1d(:,:)
logical :: etat0_start_file_colocated=.false.
integer :: ind
logical :: raz
end subroutine etat0
end module etat0_start_file_mod
module etat0_dcmip2016_cyclone_mod
use icosa
subroutine getin_etat0
use mpipara, only : is_mpi_root
end subroutine getin_etat0
subroutine compute_etat0(ngrid,lon,lat, phis, ps, temp, ulon, ulat, q)
use disvert_mod
use omp_para
use dcmip2016_cyclone_mod, only : tropical_cyclone_test
use terminator, only: initial_value_terminator
integer, intent(in)    :: ngrid
real(rstd),intent(in)  :: lon(ngrid)
real(rstd),intent(in)  :: lat(ngrid)
real(rstd),intent(out) :: ps(ngrid)
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm)
real(rstd),intent(out) :: ulon(ngrid,llm)
real(rstd),intent(out) :: ulat(ngrid,llm)
real(rstd),intent(out) :: q(ngrid,llm,nqtot)
integer :: zcoords
real :: p,z
real :: rho, thetav
integer :: l,ij
end subroutine compute_etat0
end module etat0_dcmip2016_cyclone_mod
module etat0_jablonowsky06_mod
use icosa
real(rstd),parameter :: eta0=0.252
real(rstd),parameter :: etat=0.2
real(rstd),parameter :: ps0=1e5
real(rstd),parameter :: u0=35
real(rstd),parameter :: t0=288
real(rstd),parameter :: deltat=4.8e5
real(rstd),parameter :: rd=287
real(rstd),parameter :: gamma=0.005
real(rstd),parameter :: up0=1
subroutine compute_etat0(ngrid,lon,lat, phis, ps, temp, ulon, ulat)
use disvert_mod
integer, intent(in) :: ngrid
real(rstd),intent(in) :: lat(ngrid)
real(rstd),intent(in) :: lon(ngrid)
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: ps(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm)
real(rstd),intent(out) :: ulon(ngrid,llm)
real(rstd),intent(out) :: ulat(ngrid,llm)
integer :: l,ij
real(rstd) :: eta(llm)
real(rstd) :: etav(llm)
real(rstd) :: etas, etavs, tave, phis_ave, r2
end subroutine compute_etat0
end module etat0_jablonowsky06_mod
module etat0_dcmip4_mod
use icosa
real(rstd),parameter :: eta0=0.252
real(rstd),parameter :: etat=0.2
real(rstd),parameter :: ps0=1e5
real(rstd),parameter :: u0=35
real(rstd),parameter :: t0=288
real(rstd),parameter :: deltat=4.8e5
real(rstd),parameter :: rd=287
real(rstd),parameter :: gamma=0.005
real(rstd),parameter :: up0=1
real(rstd),parameter :: lonc=pi/9, latc=2*pi/9, latw=2*pi/9
real(rstd),parameter :: pw=34000
real(rstd),parameter :: q0=0.021
integer,save :: testcase
subroutine getin_etat0
use mpipara, only : is_mpi_root
end subroutine getin_etat0
subroutine compute_etat0(ngrid,lon,lat, phis,ps,temp,ulon,ulat,q)
use icosa
use disvert_mod
use omp_para
integer, intent(in) :: ngrid
real(rstd),intent(in) :: lon(ngrid)
real(rstd),intent(in) :: lat(ngrid)
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: ps(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm)
real(rstd),intent(out) :: ulon(ngrid,llm)
real(rstd),intent(out) :: ulat(ngrid,llm)
real(rstd),intent(out) :: q(ngrid,llm,nqtot)
integer :: l,ij
real(rstd) :: etal, etavl, etas, etavs, sinlat, coslat,           y, tave, t, phis_ave, vort, utot,           dthetaodeta_ave, dthetaodeta, dthetaodlat, duodeta, k, r
end subroutine compute_etat0
end module etat0_dcmip4_mod
module etat0_dcmip5_mod
use icosa
real(rstd),parameter :: zt=15000
real(rstd),parameter :: q0=0.021
real(rstd),parameter :: qt=1e-11
real(rstd),parameter :: t0=302.15
real(rstd),parameter :: ts=302.15
real(rstd),parameter :: zq1=3000
real(rstd),parameter :: zq2=8000
real(rstd),parameter :: gamma=0.007
real(rstd),parameter :: pb=101500
real(rstd),parameter :: deltap=1115
real(rstd),parameter :: rp=282000
real(rstd),parameter :: zp=7000
real(rstd),parameter :: epsilon=1e-25
real(rstd),parameter :: rd=287
real(rstd), parameter :: lonc=pi, latc=pi/18,         tv0=t0*(1+0.608*q0), tvt=tv0-gamma*zt
integer, save :: dcmip5_testcase
subroutine getin_etat0
use mpipara, only : is_mpi_root
end subroutine getin_etat0
subroutine compute_etat0(ngrid,lon,lat, phis, ps, temp, ulon, ulat, q)
use disvert_mod
use omp_para
integer, intent(in)    :: ngrid
real(rstd),intent(in)  :: lon(ngrid)
real(rstd),intent(in)  :: lat(ngrid)
real(rstd),intent(out) :: ps(ngrid)
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm)
real(rstd),intent(out) :: ulon(ngrid,llm)
real(rstd),intent(out) :: ulat(ngrid,llm)
real(rstd),intent(out) :: q(ngrid,llm,nqtot)
integer :: l,ij
real(rstd) :: r, d, d1,d2, zz, tave, tp, vt, aa, bb
end subroutine compute_etat0
subroutine compute_z(pmodel,ps,r,z)
use icosa
real(rstd),parameter   :: epsilon0=2e-13
real(rstd),intent(in)  :: pmodel
real(rstd),intent(in)  :: ps
real(rstd),intent(in)  :: r
real(rstd),intent(out) :: z
real(rstd) :: pt, pave, pp, dpdz
real(rstd) :: znp1
real(rstd) :: epsilon
real(rstd) :: p
integer  :: n
end subroutine compute_z
end module etat0_dcmip5_mod
module etat0_mod
use icosa
use omp_para
real(rstd) :: etat0_temp
subroutine init_etat0
use etat0_database_mod, only: init_etat0_database => init_etat0
use etat0_start_file_mod, only: init_etat0_start_file => init_etat0
use etat0_heldsz_mod, only: init_etat0_held_suarez => init_etat0
end select
end subroutine init_etat0
subroutine etat0(f_ps,f_mass,f_phis,f_theta_rhodz,f_u, f_geopot,f_w, f_q)
use disvert_mod
use etat0_dcmip1_mod, only : getin_etat0_dcmip1=>getin_etat0
use etat0_dcmip2_mod, only : getin_etat0_dcmip2=>getin_etat0
use etat0_dcmip4_mod, only : getin_etat0_dcmip4=>getin_etat0
use etat0_dcmip5_mod, only : getin_etat0_dcmip5=>getin_etat0
use etat0_bubble_mod, only : getin_etat0_bubble=>getin_etat0
use etat0_williamson_mod, only : getin_etat0_williamson=>getin_etat0
use etat0_temperature_mod, only: getin_etat0_temperature=>getin_etat0
use etat0_dcmip2016_baroclinic_wave_mod, only : getin_etat0_dcmip2016_baroclinic_wave=>getin_etat0
use etat0_dcmip2016_cyclone_mod, only : getin_etat0_dcmip2016_cyclone=>getin_etat0
use etat0_dcmip2016_supercell_mod, only : getin_etat0_dcmip2016_supercell=>getin_etat0
use etat0_academic_mod, only : etat0_academic=>etat0
use etat0_heldsz_mod, only : etat0_heldsz=>etat0
use etat0_venus_mod,  only : etat0_venus=>etat0
use etat0_database_mod, only : etat0_database=>etat0
use etat0_start_file_mod, only : etat0_start_file=>etat0
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_mass(:)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_geopot(:)
type(t_field),pointer :: f_w(:)
type(t_field),pointer :: f_q(:)
real(rstd),pointer :: ps(:), mass(:,:)
real    :: etat0_ps_white_noise
real    :: etat0_theta_rhodz_white_noise
real    :: etat0_u_white_noise
real    :: etat0_q_white_noise
logical :: autoinit_mass, collocated
integer :: ind
end select
end select
end subroutine etat0
subroutine add_white_noise(field, factor)
use icosa
type(t_field),pointer :: field(:)   ! inout
real,intent(in) :: factor
integer,allocatable :: seed(:)
real,allocatable :: random2d(:)
real,allocatable :: random3d(:,:)
real,allocatable :: random4d(:,:,:)
real,pointer :: field2d(:)
real,pointer :: field3d(:,:)
real,pointer :: field4d(:,:,:)
integer :: ind
integer :: m
end subroutine
subroutine etat0_collocated(f_phis,f_ps,f_mass,f_theta_rhodz,f_u, f_geopot,f_w, f_q)
use theta2theta_rhodz_mod
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_mass(:)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_geopot(:)
type(t_field),pointer :: f_w(:)
type(t_field),pointer :: f_q(:)
type(t_field),pointer,save :: f_temp(:)
real(rstd),pointer :: ps(:)
real(rstd),pointer :: mass(:,:)
real(rstd),pointer :: phis(:)
real(rstd),pointer :: theta_rhodz(:,:,:)
real(rstd),pointer :: temp(:,:)
real(rstd),pointer :: u(:,:)
real(rstd),pointer :: geopot(:,:)
real(rstd),pointer :: w(:,:)
real(rstd),pointer :: q(:,:,:)
integer :: ind
end subroutine etat0_collocated
subroutine compute_temperature2entropy(ps,temp,q,theta_rhodz,offset)
use icosa
use pression_mod
use exner_mod
use omp_para
real(rstd),intent(in)  :: ps(iim*jjm)
real(rstd),intent(in)  :: temp(iim*jjm,llm)
real(rstd),intent(in)  :: q(iim*jjm,llm,nqtot)
real(rstd),intent(out) :: theta_rhodz(iim*jjm,llm)
integer,intent(in) :: offset
real(rstd) :: p(iim*jjm,llm+1)
real(rstd) :: cppd,rd, mass, p_ij, chi,nu, entropy, theta
integer :: i,j,ij,l
end select
end subroutine compute_temperature2entropy
subroutine compute_etat0_collocated(ps,mass,phis,temp_i,u, geopot,w, q)
use wind_mod
use disvert_mod
use etat0_jablonowsky06_mod, only : compute_jablonowsky06 => compute_etat0
use etat0_dcmip1_mod, only : compute_dcmip1 => compute_etat0
use etat0_dcmip2_mod, only : compute_dcmip2 => compute_etat0
use etat0_dcmip3_mod, only : compute_dcmip3 => compute_etat0
use etat0_dcmip4_mod, only : compute_dcmip4 => compute_etat0
use etat0_dcmip5_mod, only : compute_dcmip5 => compute_etat0
use etat0_bubble_mod, only : compute_bubble => compute_etat0
use etat0_williamson_mod, only : compute_w91_6 => compute_etat0
use etat0_temperature_mod, only: compute_etat0_temperature => compute_etat0
use etat0_dcmip2016_baroclinic_wave_mod, only : compute_dcmip2016_baroclinic_wave => compute_etat0
use etat0_dcmip2016_cyclone_mod, only : compute_dcmip2016_cyclone => compute_etat0
use etat0_dcmip2016_supercell_mod, only : compute_dcmip2016_supercell => compute_etat0
real(rstd),intent(inout) :: ps(iim*jjm)
real(rstd),intent(inout) :: mass(iim*jjm,llm)
real(rstd),intent(out) :: phis(iim*jjm)
real(rstd),intent(out) :: temp_i(iim*jjm,llm)
real(rstd),intent(out) :: u(3*iim*jjm,llm)
real(rstd),intent(out) :: w(iim*jjm,llm+1)
real(rstd),intent(out) :: geopot(iim*jjm,llm+1)
real(rstd),intent(out) :: q(iim*jjm,llm,nqtot)
real(rstd) :: ulon_i(iim*jjm,llm)
real(rstd) :: ulat_i(iim*jjm,llm)
real(rstd) :: ps_e(3*iim*jjm)
real(rstd) :: mass_e(3*iim*jjm,llm)
real(rstd) :: phis_e(3*iim*jjm)
real(rstd) :: temp_e(3*iim*jjm,llm)
real(rstd) :: geopot_e(3*iim*jjm,llm+1)
real(rstd) :: ulon_e(3*iim*jjm,llm)
real(rstd) :: ulat_e(3*iim*jjm,llm)
real(rstd) :: q_e(3*iim*jjm,llm,nqtot)
integer :: l,ij
real :: p_ik, v_ik, mass_ik
logical :: autoinit_mass, autoinit_nh
end select
end subroutine compute_etat0_collocated
subroutine getin_etat0_isothermal
end subroutine getin_etat0_isothermal
subroutine compute_etat0_isothermal(ngrid, phis, ps, temp, ulon, ulat, q)
integer, intent(in)    :: ngrid
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: ps(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm)
real(rstd),intent(out) :: ulon(ngrid,llm)
real(rstd),intent(out) :: ulat(ngrid,llm)
real(rstd),intent(out) :: q(ngrid,llm,nqtot)
end subroutine compute_etat0_isothermal
end module etat0_mod
module etat0_venus_mod
use icosa
type(t_field),pointer :: f_temp_eq( :)
type(t_field),pointer :: f_temp(:) ! buffer used for physics
real(rstd), save :: kfrict
subroutine init_physics
use getin_mod
real(rstd),pointer :: temp(:,:)
real(rstd) :: friction_time
integer :: ind
end subroutine init_physics
subroutine physics(f_ps,f_theta_rhodz,f_u)
use icosa
use theta2theta_rhodz_mod
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_ps(:)
real(rstd),pointer :: temp(:,:)
real(rstd),pointer :: temp_eq(:,:)
real(rstd),pointer :: u(:,:)
integer :: ind
end subroutine physics
subroutine compute_physics(temp_eq, temp, u)
use icosa
use theta2theta_rhodz_mod
real(rstd),intent(in)    :: temp_eq(iim*jjm,llm)
real(rstd),intent(inout) :: temp(iim*jjm,llm)
real(rstd),intent(inout) :: u(3*iim*jjm,llm)
real(rstd), parameter :: tauclee=86400*25 ! 25 earth days, cf lebonnois 2012
integer :: i,j,l,ij
end subroutine compute_physics
subroutine etat0(f_ps,f_phis,f_theta_rhodz,f_u, f_q)
use icosa
use theta2theta_rhodz_mod
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
type(t_field),pointer :: f_temp(:)
real(rstd),pointer :: temp(:,:)
real(rstd),pointer :: ps(:)
real(rstd),pointer :: phis(:)
real(rstd),pointer :: u(:,:)
real(rstd),pointer :: q(:,:,:)
integer :: ind
end subroutine etat0
subroutine compute_temp_ref(theta_eq, gradient)
use icosa
use disvert_mod
use omp_para
use math_const
real(rstd), intent(out) :: theta_eq(iim*jjm,llm)
logical, intent(in) :: gradient
real(rstd)  :: clat(iim*jjm)        ! latitude
integer :: level
real ::  pressclee(31), tempclee(31), dt_epclee(31), etaclee(31)
real(rstd) ::  lon,lat, pplay, ztemp,zdt,fact
integer :: i,j,ij, l,ll
end subroutine compute_temp_ref
end module etat0_venus_mod
module etat0_dcmip2016_baroclinic_wave_mod
use icosa
integer :: perturbation
subroutine getin_etat0
use mpipara, only : is_mpi_root
use tracer_mod
end subroutine getin_etat0
subroutine compute_etat0(ngrid,lon,lat, phis,ps,temp,ulon,ulat,q)
use icosa
use disvert_mod
use omp_para
use dcmip2016_baroclinic_wave_mod, only : baroclinic_wave_test
use earth_const
use terminator, only: initial_value_terminator
integer, intent(in) :: ngrid
real(rstd),intent(in) :: lon(ngrid)
real(rstd),intent(in) :: lat(ngrid)
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: ps(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm)
real(rstd),intent(out) :: ulon(ngrid,llm)
real(rstd),intent(out) :: ulat(ngrid,llm)
real(rstd),intent(out) :: q(ngrid,llm,nqtot)
integer :: deep=0
integer :: zcoords
real :: p,z
real :: rho, thetav
integer :: ij,l
integer :: moist
end subroutine compute_etat0
end module etat0_dcmip2016_baroclinic_wave_mod
module etat0_temperature_mod
use prec
use icosa, only: llm,nqtot
real(rstd), save, allocatable :: t_profile(:)
subroutine getin_etat0
use getin_mod, only: getin
use mpipara, only: is_mpi_root
use omp_para, only: omp_in_parallel
use transfert_omp_mod, only: bcast_omp
use free_unit_mod, only : free_unit
use abort_mod
integer :: unit,ok
integer :: l
end subroutine getin_etat0
subroutine compute_etat0(ngrid, phis, ps, temp, ulon, ulat, q)
use earth_const, only: preff
integer, intent(in)    :: ngrid
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: ps(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm)
real(rstd),intent(out) :: ulon(ngrid,llm)
real(rstd),intent(out) :: ulat(ngrid,llm)
real(rstd),intent(out) :: q(ngrid,llm,nqtot)
integer :: l
end subroutine compute_etat0
end module etat0_temperature_mod
module etat0_williamson_mod
use icosa
real(rstd), parameter :: h0=8.e3
real(rstd), parameter :: r0=4
real(rstd), parameter :: k0=7.848e-6
real(rstd), parameter :: omega0=k0
subroutine getin_etat0
use mpipara, only : is_mpi_root
use disvert_mod, only : caldyn_eta, eta_lag
end subroutine getin_etat0
subroutine compute_etat0(ngrid,lon,lat, phis,mass,rhodz,ulon,ulat)
integer, intent(in)    :: ngrid
real(rstd),intent(in)  :: lon(ngrid)
real(rstd),intent(in)  :: lat(ngrid)
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: mass(ngrid)
real(rstd),intent(out) :: rhodz(ngrid)
real(rstd),intent(out) :: ulon(ngrid)
real(rstd),intent(out) :: ulat(ngrid)
real(rstd) :: coslat,sinlat, a,b,c
integer :: ij
end subroutine compute_etat0
end module etat0_williamson_mod
module etat0_dcmip2_mod
use icosa
integer, save :: testcase
integer, parameter :: mountain=0, schaer_noshear=1, schaer_shear=2
subroutine getin_etat0
end select
end subroutine getin_etat0
subroutine compute_etat0(ngrid,lon,lat, phis, ps, temp, ulon, ulat)
use disvert_mod
use omp_para
integer, intent(in)    :: ngrid
real(rstd),intent(in)  :: lon(ngrid)
real(rstd),intent(in)  :: lat(ngrid)
real(rstd),intent(out) :: ps(ngrid)
real(rstd),intent(out) :: phis(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm)
real(rstd),intent(out) :: ulon(ngrid,llm)
real(rstd),intent(out) :: ulat(ngrid,llm)
integer :: l,ij
real(rstd) :: hyam, hybm
end subroutine compute_etat0
subroutine comp_all(hyam,hybm,lon,lat, psj,phisj,tempj, ulonj,ulatj)
use dcmip_initial_conditions_test_1_2_3
real(rstd), intent(in) :: hyam, hybm, lon, lat
real(rstd), intent(out) :: psj,phisj,tempj,ulonj,ulatj
real :: dummy_p, dummy_z, dummy_w, dummy_rho, dummy_q
end select
end subroutine comp_all
end module etat0_dcmip2_mod
module etat0_dcmip1_mod
use icosa
integer, parameter :: const=1, cos_bell=2, slotted_cyl=3,         dbl_cos_bell_q1=4, dbl_cos_bell_q2=5, complement=6, hadley=7,         dcmip11=-1
integer, save :: shape
real(rstd), save  :: h0=1.
real(rstd), save  :: lon0=3*pi/2
real(rstd), save  :: lat0=0.0
real(rstd), save  :: r0
real(rstd), save  :: latc1=0.
real(rstd), save  :: latc2=0.
real(rstd), save  :: lonc1=5*pi/6
real(rstd), save  :: lonc2=7*pi/6
real(rstd), save  :: zt=1000.0
real(rstd), save  :: rt
real(rstd), save  :: zc=5000.0
subroutine getin_etat0
end select
end subroutine getin_etat0
subroutine compute_etat0(ngrid,lon,lat, phis,ps,temp,ulon,ulat,q)
integer, intent(in) :: ngrid
real(rstd),intent(in) :: lon(ngrid),lat(ngrid)
real(rstd),intent(out) :: ps(ngrid),phis(ngrid)
real(rstd),intent(out) :: temp(ngrid,llm),ulon(ngrid,llm),ulat(ngrid,llm)
real(rstd),intent(out) :: q(ngrid,llm,nqtot)
end select
end subroutine compute_etat0
subroutine compute_etat0_ncar(icase,ngrid,lon,lat, q)
use disvert_mod
use omp_para
integer, intent(in) :: icase, ngrid
real(rstd),intent(in) :: lon(ngrid),lat(ngrid)
real(rstd),intent(out) :: q(ngrid,llm)
real(rstd) :: zr(llm+1), zrl(llm), qxt1(ngrid,llm)
real(rstd) :: pr
integer :: l
end select
subroutine cosine_bell_1(hx)
real(rstd) :: hx(ngrid,llm)
real(rstd) :: rr1
integer :: n,l
end subroutine cosine_bell_1
subroutine cosine_bell_2(hx)
real(rstd) :: hx(ngrid,llm)
real(rstd) :: rr1,rr2,dd1,dd2,dd1t1,dd1t2,dd2t1
integer :: n,l
end subroutine cosine_bell_2
subroutine slotted_cylinders(hx)
real(rstd) :: hx(ngrid,llm)
real(rstd) :: rr1,rr2,dd1,dd2,dd1t1,dd1t2,dd2t1
integer :: n,l
end subroutine slotted_cylinders
subroutine hadleyq(hx)
real(rstd)::hx(ngrid,llm)
real(rstd),parameter:: zz1=2000.,zz2=5000.,zz0=0.5*(zz1+zz2)
integer :: l
end subroutine hadleyq
end subroutine compute_etat0_ncar
end module etat0_dcmip1_mod
module etat0_academic_mod
use icosa
subroutine test_etat0_academic
use icosa
use kinetic_mod
type(t_field),pointer,save :: f_ps(:)
type(t_field),pointer,save :: f_phis(:)
type(t_field),pointer,save :: f_theta_rhodz(:)
type(t_field),pointer,save :: f_u(:)
type(t_field),pointer,save :: f_q(:)
type(t_field),pointer,save :: f_ki(:)
type(t_field),pointer,save :: f_temp(:)
end subroutine test_etat0_academic
subroutine etat0(f_ps,f_phis,f_theta_rhodz,f_u, f_q)
use icosa
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
real(rstd),pointer :: ps(:)
real(rstd),pointer :: phis(:)
real(rstd),pointer :: theta_rhodz(:,:)
real(rstd),pointer :: u(:,:)
integer :: ind
end subroutine etat0
subroutine compute_etat0_academic(ps, phis, theta_rhodz, u)
use icosa
use disvert_mod
use pression_mod
use exner_mod
use geopotential_mod
use theta2theta_rhodz_mod
real(rstd),intent(out) :: ps(iim*jjm)
real(rstd),intent(out) :: phis(iim*jjm)
real(rstd),intent(out) :: theta_rhodz(iim*jjm,llm)
real(rstd),intent(out) :: u(3*iim*jjm,llm)
integer :: i,j,l,ij
real(rstd) :: r
real(rstd) :: theta(iim*jjm,llm)
real(rstd) :: zsig
integer    :: lsup
real(rstd) :: ddsin
real(rstd) :: thetarappel
real(rstd) :: lat
real(rstd) :: p(iim*jjm,llm+1)
real(rstd) :: phi(iim*jjm,llm)
real(rstd) :: x
real(rstd) :: fact(3*iim*jjm)
real(rstd) :: ut(3*iim*jjm,llm)
end subroutine compute_etat0_academic
end module etat0_academic_mod
module qsat_mod
subroutine qsat(f_temp,f_p,f_qs)
use icosa
type(t_field), pointer :: f_temp(:)  ! in    : temperature
type(t_field), pointer :: f_p(:)     ! in    : pressure at mid-levels
type(t_field), pointer :: f_qs(:)    ! out   : vapeur d'eau saturante en kg/kg
real(rstd),pointer :: temp(:,:),  p(:,:), qs(:,:)
integer :: ind
end subroutine qsat
subroutine compute_qsat(temp,p,qsat)
use icosa
use omp_para
real,intent(in)  :: temp(iim*jjm,llm)
real,intent(in)  :: p   (iim*jjm,llm+1)
real,intent(out) :: qsat(iim*jjm,llm)
real, parameter  ::  r2es=611.14 *18.0153/28.9644
real :: r3es
real, parameter ::  r3les=17.269
real, parameter ::  r3ies=21.875
real :: r4es
real, parameter :: r4les=35.86
real, parameter :: r4ies=7.66
real, parameter :: rtt=273.16
real, parameter :: retv=28.9644/18.0153 - 1.0
real :: zqsat, pmid
integer :: l,i,j,ij
end subroutine compute_qsat
end module qsat_mod
module etat0_database_mod
subroutine init_etat0
use xios_mod
use omp_para
end subroutine init_etat0
subroutine etat0(f_ps,f_phis,f_theta_rhodz,f_u, f_q)
use icosa
use restart_mod
use wind_mod
use write_field_mod
use time_mod
use transfert_mod
use xios_mod
use write_field_mod
use vertical_remap_mod
use theta2theta_rhodz_mod
use qsat_mod
use pression_mod
use omp_para
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
type(t_field),pointer,save :: f_ulon_reg(:)
type(t_field),pointer,save :: f_ulat_reg(:)
type(t_field),pointer,save :: f_temp_reg(:)
type(t_field),pointer,save :: f_q_reg(:)
type(t_field),pointer,save :: f_ts(:)
type(t_field),pointer,save :: f_z(:)
type(t_field),pointer,save :: f_ulon(:)
type(t_field),pointer,save :: f_ulat(:)
type(t_field),pointer,save :: f_temp(:)
type(t_field),pointer,save :: f_q1(:)
type(t_field),pointer,save :: f_qsat(:)
type(t_field),pointer,save :: f_p(:)
integer :: nb_level
real,allocatable:: levels(:)
integer :: ind
end subroutine etat0
end module etat0_database_mod
module caldyn_adv_mod
use icosa
subroutine init_caldyn
end subroutine init_caldyn
subroutine check_mass_conservation(f_ps,f_dps)
use icosa
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_dps(:)
real(rstd),pointer :: ps(:)
real(rstd),pointer :: dps(:)
real(rstd) :: mass_tot,dmass_tot
integer :: ind,i,j,ij
end subroutine check_mass_conservation
subroutine caldyn(write_out,f_phis, f_ps, f_theta_rhodz, f_u, f_q,         f_hflux, f_wflux, f_dps, f_dtheta_rhodz, f_du)
use icosa
use output_field_mod
use vorticity_mod
use kinetic_mod
use theta2theta_rhodz_mod
logical,intent(in)    :: write_out
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
type(t_field),pointer :: f_hflux(:), f_wflux(:)
type(t_field) :: f_dps(:)
type(t_field) :: f_dtheta_rhodz(:)
type(t_field) :: f_du(:)
real(rstd),pointer :: ps(:)
real(rstd),pointer :: u(:,:)
real(rstd),pointer :: dps(:)
real(rstd),pointer :: hflux(:,:), wflux(:,:)
real(rstd),pointer :: dtheta_rhodz(:,:), du(:,:)  ! set to 0
integer :: ind
end subroutine caldyn
subroutine compute_caldyn(ps,u, hflux,wflux,dps, dtheta_rhodz,du)
use icosa
use disvert_mod
real(rstd),intent(in)  :: ps(iim*jjm)
real(rstd),intent(in)  :: u(iim*3*jjm,llm)
real(rstd),intent(out) :: du(iim*3*jjm,llm), hflux(iim*3*jjm,llm) ! hflux in kg/s
real(rstd),intent(out) :: dtheta_rhodz(iim*jjm,llm)
real(rstd),intent(out) :: dps(iim*jjm)
real(rstd),intent(out) :: wflux(iim*jjm,llm+1) ! vertical mass flux (kg/m2/s)
real(rstd),allocatable :: rhodz(:,:)
real(rstd),allocatable :: divm(:,:)  ! mass flux divergence
integer :: i,j,ij,l
end subroutine compute_caldyn
end module caldyn_adv_mod
module caldyn_kernels_mod
use icosa
use transfert_mod
use caldyn_kernels_base_mod
subroutine compute_planetvel(planetvel)
use wind_mod
real(rstd),intent(out)  :: planetvel(iim*3*jjm)
real(rstd) :: ulon(iim*3*jjm)
real(rstd) :: ulat(iim*3*jjm)
integer :: ij
end subroutine compute_planetvel
subroutine compute_pvort(ps,u,theta_rhodz, rhodz,theta,qu,qv)
use icosa
use disvert_mod, only : mass_dak, mass_dbk, caldyn_eta, eta_mass, ptop
use trace
use omp_para
real(rstd),intent(in)  :: u(iim*3*jjm,llm)
real(rstd),intent(in)  :: ps(iim*jjm)
real(rstd),intent(in)  :: theta_rhodz(iim*jjm,llm)
real(rstd),intent(inout) :: rhodz(iim*jjm,llm)
real(rstd),intent(out) :: theta(iim*jjm,llm)
real(rstd),intent(out) :: qu(iim*3*jjm,llm)
real(rstd),intent(out) :: qv(iim*2*jjm,llm)
integer :: ij,l
real(rstd) :: etav,hv, m
end subroutine compute_pvort
subroutine compute_caldyn_horiz(u,rhodz,qu,theta,pk,geopot, hflux,convm, dtheta_rhodz, du)
use icosa
use disvert_mod
use trace
use omp_para
real(rstd),intent(in)  :: u(iim*3*jjm,llm)    ! prognostic "velocity"
real(rstd),intent(in)  :: rhodz(iim*jjm,llm)
real(rstd),intent(in)  :: qu(iim*3*jjm,llm)
real(rstd),intent(in)  :: theta(iim*jjm,llm)  ! potential temperature
real(rstd),intent(inout) :: pk(iim*jjm,llm) ! exner function
real(rstd),intent(in)  :: geopot(iim*jjm,llm+1)    ! geopotential
real(rstd),intent(out) :: hflux(iim*3*jjm,llm) ! hflux in kg/s
real(rstd),intent(out) :: convm(iim*jjm,llm)  ! mass flux convergence
real(rstd),intent(out) :: dtheta_rhodz(iim*jjm,llm)
real(rstd),intent(out) :: du(iim*3*jjm,llm)
real(rstd) :: ftheta(3*iim*jjm,llm) ! theta flux
real(rstd) :: berni(iim*jjm,llm)  ! bernoulli function
real(rstd) :: uu_right, uu_lup, uu_ldown
integer :: ij,l
real(rstd) :: uu
end select
end subroutine compute_caldyn_horiz
end module caldyn_kernels_mod
module caldyn_hevi_mod
use icosa
use transfert_mod
use caldyn_kernels_base_mod
use caldyn_kernels_hevi_mod
use caldyn_gcm_mod
subroutine caldyn_hevi(write_out,tau, f_phis, f_ps, f_mass, f_theta_rhodz, f_u, f_q,         f_w, f_geopot, f_hflux, f_wflux, f_dps, f_dmass, f_dtheta_rhodz,         f_du_slow, f_du_fast, f_dphi_slow, f_dphi_fast, f_dw_slow, f_dw_fast)
use icosa
use observable_mod
use disvert_mod, only : caldyn_eta, eta_mass, bp, mass_dak, mass_dbk
use vorticity_mod
use kinetic_mod
use theta2theta_rhodz_mod
use wind_mod
use mpipara
use trace
use omp_para
use output_field_mod
use checksum_mod
use abort_mod
logical,intent(in)    :: write_out
real(rstd), intent(in) :: tau
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_mass(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
type(t_field),pointer :: f_w(:)
type(t_field),pointer :: f_geopot(:)
type(t_field),pointer :: f_hflux(:), f_wflux(:)
type(t_field) :: f_dps(:)
type(t_field) :: f_dmass(:)
type(t_field) :: f_dtheta_rhodz(:)
type(t_field) :: f_du_slow(:)
type(t_field) :: f_du_fast(:)
type(t_field) :: f_dw_slow(:)
type(t_field) :: f_dw_fast(:)
type(t_field) :: f_dphi_slow(:)
type(t_field) :: f_dphi_fast(:)
real(rstd),pointer :: ps(:), dps(:), phis(:)
real(rstd),pointer :: mass(:,:), theta_rhodz(:,:,:), dtheta_rhodz(:,:,:)
real(rstd),pointer :: du(:,:), dw(:,:), dphi(:,:), hflux(:,:), wflux(:,:)
real(rstd),pointer :: u(:,:), w(:,:), qu(:,:), qv(:,:)
real(rstd),pointer  :: theta(:,:,:)
real(rstd),pointer  :: pk(:,:)
real(rstd),pointer  :: geopot(:,:)
real(rstd),pointer  :: convm(:,:)
real(rstd),pointer  :: wwuu(:,:)
real(rstd),pointer  :: f_el(:,:), gradphi2(:,:), w_il(:,:) , w_etadot(:,:), pres(:,:), m_il(:,:)
integer :: ind
logical,save :: first=.true.
end subroutine caldyn_hevi
end module caldyn_hevi_mod
module caldyn_kernels_hevi_mod
use icosa
use trace
use omp_para
use disvert_mod
use transfert_mod
use caldyn_kernels_base_mod
use abort_mod
real(rstd), parameter :: pbot=1e5, rho_bot=1e6
logical, save :: debug_hevi_solver = .false.
subroutine compute_theta(ps,theta_rhodz, rhodz,theta, mass_dak, mass_dbk)
real(rstd),intent(in)    :: ps(iim*jjm)
real(rstd),intent(in)    :: theta_rhodz(iim*jjm,llm,nqdyn)
real(rstd),intent(inout) :: rhodz(iim*jjm,llm)
real(rstd),intent(out)   :: theta(iim*jjm,llm,nqdyn)
real(rstd),intent(in)    :: mass_dak(llm)
real(rstd),intent(in)    :: mass_dbk(llm)
integer :: ij,l,iq
real(rstd) :: m
end subroutine compute_theta
subroutine compute_pvort_only(u,rhodz,qu,qv,av,riv2,fv)
real(rstd),intent(in)  :: u(iim*3*jjm,llm)
real(rstd),intent(inout) :: rhodz(iim*jjm,llm)
real(rstd),intent(out) :: qu(iim*3*jjm,llm)
real(rstd),intent(out) :: qv(iim*2*jjm,llm)
real(rstd),intent(in)  :: av(2*iim*jjm)
real(rstd),intent(in)  :: riv2(iim*jjm,6)
real(rstd),intent(in)  :: fv(2*iim*jjm)
integer :: ij,l
real(rstd) :: etav,hv,radius_m2
end subroutine compute_pvort_only
subroutine compute_nh_geopot(tau, phis, m_ik, m_il, theta, w_il, phi_il)
real(rstd),intent(in)    :: tau ! solve phi-tau*dphi/dt = phi_rhs
real(rstd),intent(in)    :: phis(iim*jjm)
real(rstd),intent(in)    :: m_ik(iim*jjm,llm)
real(rstd),intent(in)    :: m_il(iim*jjm,llm+1)
real(rstd),intent(in)    :: theta(iim*jjm,llm)
real(rstd),intent(in)    :: w_il(iim*jjm,llm+1)   ! vertical momentum
real(rstd),intent(inout) :: phi_il(iim*jjm,llm+1) ! geopotential
real(rstd) :: phi_star_il(iim*jjm,llm+1)
real(rstd) :: p_ik(iim*jjm,llm)      ! pressure
real(rstd) :: r_il(iim*jjm,llm+1)    ! rhs of tridiag problem
real(rstd) :: x_il(iim*jjm,llm+1)    ! solution of tridiag problem
real(rstd) :: a_ik(iim*jjm,llm)      ! off-diagonal coefficients of tridiag problem
real(rstd) :: b_il(iim*jjm,llm+1)    ! diagonal coefficients of tridiag problem
real(rstd) :: c_ik(iim*jjm,llm)      ! thomas algorithm
real(rstd) :: d_il(iim*jjm,llm+1)    ! thomas algorithm
real(rstd) :: gamma, rho_ij, x_ij
real(rstd) :: tau2_g, g2, gm2, ml_g2, c2_mik
integer    :: iter, ij, l, ij_omp_begin_ext, ij_omp_end_ext
end select
end subroutine compute_nh_geopot
subroutine compute_caldyn_solver(tau,phis, rhodz,theta,pk, geopot,w, m_il,pres, dphi,dw,du)
real(rstd),intent(in) :: tau ! "solve" phi-tau*dphi/dt = phi_rhs
real(rstd),intent(in)    :: phis(iim*jjm)
real(rstd),intent(in)    :: rhodz(iim*jjm,llm)
real(rstd),intent(in)    :: theta(iim*jjm,llm,nqdyn)
real(rstd),intent(out)   :: pk(iim*jjm,llm)
real(rstd),intent(inout) :: geopot(iim*jjm,llm+1)
real(rstd),intent(inout) :: w(iim*jjm,llm+1) ! out if tau>0
real(rstd),intent(out)   :: m_il(iim*jjm,llm+1)        ! rhodz averaged to interfaces
real(rstd),intent(out)   :: pres(iim*jjm,llm)          ! pressure
real(rstd),intent(out)   :: dw(iim*jjm,llm+1)
real(rstd),intent(out)   :: dphi(iim*jjm,llm+1)
real(rstd),intent(out)   :: du(3*iim*jjm,llm)
real(rstd) :: berni(iim*jjm,llm)         ! (w/m_il)^2
real(rstd) :: berni1(iim*jjm)         ! (w/m_il)^2
real(rstd) :: gamma, rho_ij, t_ij, x_ij, vreff, rd, cvd
integer    :: ij, l
end select
end subroutine compute_caldyn_solver
subroutine compute_caldyn_fast(tau,u,rhodz,theta,pk,geopot,du)
real(rstd),intent(in)    :: tau                ! "solve" u-tau*du/dt = rhs
real(rstd),intent(inout) :: u(iim*3*jjm,llm)   ! out if tau>0
real(rstd),intent(in)    :: rhodz(iim*jjm,llm)
real(rstd),intent(in)    :: theta(iim*jjm,llm,nqdyn)
real(rstd),intent(inout) :: pk(iim*jjm,llm)
real(rstd),intent(inout) :: geopot(iim*jjm,llm+1)
real(rstd),intent(inout)   :: du(iim*3*jjm,llm)
real(rstd) :: berni(iim*jjm,llm)  ! bernoulli function
real(rstd) :: berniv(iim*jjm,llm)  ! moist bernoulli function
integer :: ij,l
real(rstd) :: rd, qv, temp, chi, nu, due, due_right, due_lup, due_ldown
end select
end select
end subroutine compute_caldyn_fast
subroutine compute_caldyn_coriolis(hflux,theta,qu, convm,dtheta_rhodz,du,ai,wee)
real(rstd),intent(in)  :: hflux(3*iim*jjm,llm)  ! hflux in kg/s
real(rstd),intent(in)  :: theta(iim*jjm,llm,nqdyn) ! active scalars
real(rstd),intent(in)  :: qu(3*iim*jjm,llm)
real(rstd),intent(out) :: convm(iim*jjm,llm)  ! mass flux convergence
real(rstd),intent(out) :: dtheta_rhodz(iim*jjm,llm,nqdyn)
real(rstd),intent(inout) :: du(3*iim*jjm,llm)
real(rstd),intent(in)  :: ai(iim*jjm)
real(rstd),intent(in)  :: wee(3*iim*jjm,5,2)
real(rstd) :: ftheta(3*iim*jjm,llm)  ! potential temperature flux
real(rstd) :: uu_right, uu_lup, uu_ldown, du_trisk, divf
integer :: ij,iq,l
end select
end subroutine compute_caldyn_coriolis
subroutine compute_caldyn_slow_hydro(u,rhodz,hflux,du,ai,le_de,zero)
logical, intent(in) :: zero
real(rstd),intent(in)  :: u(3*iim*jjm,llm)    ! prognostic "velocity"
real(rstd),intent(in)  :: rhodz(iim*jjm,llm)
real(rstd),intent(out) :: hflux(3*iim*jjm,llm) ! hflux in kg/s
real(rstd),intent(inout) :: du(3*iim*jjm,llm)
real(rstd),intent(in)  :: ai(iim*jjm)
real(rstd),intent(in)  :: le_de(3*iim*jjm)
real(rstd) :: berni(iim*jjm,llm)  ! bernoulli function
real(rstd) :: uu_right, uu_lup, uu_ldown, ke, uu
integer :: ij,l
end subroutine compute_caldyn_slow_hydro
subroutine compute_caldyn_slow_nh(u,rhodz,phi,w, f_el,gradphi2,w_il, hflux,du,dphi,dw)
real(rstd),intent(in)  :: u(3*iim*jjm,llm)    ! prognostic "velocity"
real(rstd),intent(in)  :: rhodz(iim*jjm,llm)  ! rho*dz
real(rstd),intent(in)  :: phi(iim*jjm,llm+1)  ! prognostic geopotential
real(rstd),intent(in)  :: w(iim*jjm,llm+1)    ! prognostic vertical momentum
real(rstd),intent(out) :: hflux(3*iim*jjm,llm) ! hflux in kg/s
real(rstd),intent(out) :: du(3*iim*jjm,llm)
real(rstd),intent(out) :: dw(iim*jjm,llm+1)
real(rstd),intent(out) :: dphi(iim*jjm,llm+1)
real(rstd) :: w_il(iim*jjm,llm+1) ! wil/mil
real(rstd) :: f_el(3*iim*jjm,llm+1) ! nh mass flux
real(rstd) :: gradphi2(iim*jjm,llm+1) ! grad_phi**2
real(rstd) :: dephil(3*iim*jjm,llm+1) ! grad(phi)
integer :: ij,l,kdown,kup
real(rstd) :: w_el, w2_el, uu_right, uu_lup, uu_ldown, gphi2, dp, divg, u2, uu
real(rstd) :: berni(iim*jjm,llm)  ! bernoulli function
real(rstd) :: g_el(3*iim*jjm,llm+1) ! horizontal flux of w
real(rstd) :: v_el(3*iim*jjm,llm+1)
real(rstd) :: berni1(iim*jjm)  ! bernoulli function
real(rstd) :: g_el1(3*iim*jjm) ! horizontal flux of w
real(rstd) :: v_el1(3*iim*jjm)
end subroutine compute_caldyn_slow_nh
end module caldyn_kernels_hevi_mod
module caldyn_kernels_base_mod
use icosa
use transfert_mod
use disvert_mod
use omp_para
use trace
use abort_mod
integer, parameter,public :: energy=1, enstrophy=2
type(t_field),pointer,public :: f_out_u(:), f_qu(:), f_qv(:)
type(t_field),pointer,public :: f_pk(:),f_wwuu(:),f_planetvel(:),                                    f_fel(:), f_gradphi2(:), f_wil(:), f_wetadot(:)
integer, public :: caldyn_conserv
type(t_message),public :: req_ps, req_mass, req_theta_rhodz, req_u, req_qu, req_geopot, req_w
subroutine compute_geopot(rhodz,theta, ps,pk,geopot)
real(rstd),intent(in)    :: rhodz(iim*jjm,llm)
real(rstd),intent(in)    :: theta(iim*jjm,llm,nqdyn) ! active scalars : theta/entropy, moisture, ...
real(rstd),intent(inout) :: ps(iim*jjm)
real(rstd),intent(out)   :: pk(iim*jjm,llm)       ! exner function (compressible) /lagrange multiplier (boussinesq)
real(rstd),intent(inout) :: geopot(iim*jjm,llm+1) ! geopotential
integer :: ij,l
real(rstd) :: rd, p_ik, exner_ik, temp_ik, qv, chi, rmix, gv
integer    :: ij_omp_begin_ext, ij_omp_end_ext
end select
end select
end select
end subroutine compute_geopot
subroutine compute_caldyn_vert(u, theta, rhodz, convm, wflux, wwuu, dps, dtheta_rhodz, du, bp)
real(rstd),intent(in)  :: u(iim*3*jjm,llm)
real(rstd),intent(in)  :: theta(iim*jjm,llm,nqdyn)
real(rstd),intent(in)  :: rhodz(iim*jjm,llm)
real(rstd),intent(inout)  :: convm(iim*jjm,llm)  ! mass flux convergence
real(rstd),intent(inout) :: wflux(iim*jjm,llm+1) ! vertical mass flux (kg/m2/s)
real(rstd),intent(inout) :: wwuu(iim*3*jjm,llm+1)
real(rstd),intent(inout) :: du(iim*3*jjm,llm)
real(rstd),intent(inout) :: dtheta_rhodz(iim*jjm,llm,nqdyn)
real(rstd),intent(out) :: dps(iim*jjm)
real(rstd),intent(in)  :: bp(llm)
integer ::ij,l,iq
integer    :: ij_omp_begin, ij_omp_end
end subroutine compute_caldyn_vert
subroutine compute_caldyn_vert_nh(mass,geopot,w,wflux, w_etadot, du,dphi,dw)
real(rstd),intent(in) :: mass(iim*jjm,llm)
real(rstd),intent(in) :: geopot(iim*jjm,llm+1)
real(rstd),intent(in) :: w(iim*jjm,llm+1)
real(rstd),intent(in) :: wflux(iim*jjm,llm+1)
real(rstd),intent(inout) :: du(iim*3*jjm,llm)
real(rstd),intent(inout) :: dphi(iim*jjm,llm+1)
real(rstd),intent(inout) :: dw(iim*jjm,llm+1)
real(rstd) :: w_etadot(iim*jjm,llm) ! vertical flux of vertical momentum
real(rstd) :: eta_dot(iim*jjm, llm) ! eta_dot in full layers
real(rstd) :: wcov(iim*jjm,llm) ! covariant vertical momentum in full layers
integer    :: ij, l
real(rstd) :: wflux_ij, w_ij
end subroutine compute_caldyn_vert_nh
end module caldyn_kernels_base_mod
module caldyn_gcm_mod
use icosa
use transfert_mod
use caldyn_kernels_hevi_mod
use caldyn_kernels_base_mod
use caldyn_kernels_mod
use omp_para
use mpipara
subroutine init_caldyn
use abort_mod
integer            :: ind
real(rstd),pointer :: planetvel(:)
end select
end select
end select
end select
end subroutine init_caldyn
subroutine allocate_caldyn
end subroutine allocate_caldyn
subroutine caldyn_bc(f_phis, f_geopot, f_wflux)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_geopot(:)
type(t_field),pointer :: f_wflux(:)
real(rstd),pointer  :: phis(:)
real(rstd),pointer  :: wflux(:,:)
real(rstd),pointer  :: geopot(:,:)
real(rstd),pointer  :: wwuu(:,:)
integer :: ind,ij
end subroutine caldyn_bc
subroutine caldyn(write_out,f_phis, f_ps, f_mass, f_theta_rhodz, f_u, f_q,         f_geopot, f_hflux, f_wflux, f_dps, f_dmass, f_dtheta_rhodz, f_du)
use observable_mod
use disvert_mod, only : caldyn_eta, eta_mass, bp
use trace
logical,intent(in)    :: write_out
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_mass(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
type(t_field),pointer :: f_geopot(:)
type(t_field),pointer :: f_hflux(:), f_wflux(:)
type(t_field) :: f_dps(:)
type(t_field) :: f_dmass(:)
type(t_field) :: f_dtheta_rhodz(:)
type(t_field) :: f_du(:)
real(rstd),pointer :: ps(:), dps(:)
real(rstd),pointer :: mass(:,:), theta_rhodz(:,:,:), dtheta_rhodz(:,:,:)
real(rstd),pointer :: u(:,:), du(:,:), hflux(:,:), wflux(:,:)
real(rstd),pointer :: qu(:,:)
real(rstd),pointer :: qv(:,:)
real(rstd),pointer  :: theta(:,:,:)
real(rstd),pointer  :: pk(:,:)
real(rstd),pointer  :: geopot(:,:)
real(rstd),pointer  :: convm(:,:)
real(rstd),pointer  :: wwuu(:,:)
integer :: ind
logical,save :: first=.true.
end select
end subroutine caldyn
subroutine check_mass_conservation(f_ps,f_dps)
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_dps(:)
real(rstd),pointer :: ps(:)
real(rstd),pointer :: dps(:)
real(rstd) :: mass_tot,dmass_tot
integer :: ind,i,j,ij
end subroutine check_mass_conservation
end module caldyn_gcm_mod
module caldyn_mod
use icosa
subroutine init_caldyn
use icosa
use caldyn_gcm_mod, only : init_caldyn_gcm=>init_caldyn
use caldyn_adv_mod, only : init_caldyn_adv=>init_caldyn
end select
end subroutine init_caldyn
subroutine caldyn_bc(f_phis, f_geopot, f_wflux)
use caldyn_gcm_mod, only : caldyn_gcm_bc=>caldyn_bc
type(t_field), pointer :: f_phis(:), f_geopot(:), f_wflux(:)
end select
end subroutine caldyn_bc
subroutine caldyn(write_out,f_phis, f_ps, f_mass, f_theta_rhodz, f_u, f_q,         f_geopot, f_hflux, f_wflux, f_dps, f_dmass, f_dtheta_rhodz, f_du)
use icosa
use caldyn_gcm_mod, only : caldyn_gcm=>caldyn
use caldyn_adv_mod, only : caldyn_adv=>caldyn
logical,intent(in)    :: write_out
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_mass(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
type(t_field),pointer :: f_geopot(:)
type(t_field),pointer :: f_hflux(:)
type(t_field),pointer :: f_wflux(:)
type(t_field) :: f_dps(:)
type(t_field) :: f_dmass(:)
type(t_field) :: f_dtheta_rhodz(:)
type(t_field) :: f_du(:)
end select
end subroutine caldyn
end module caldyn_mod
module icosa_init_mod
subroutine icosa_init
use icosa
use timeloop_gcm_mod
use disvert_mod
use etat0_mod
use wind_mod
use mpipara
use omp_para
use vertical_interp_mod
use trace
use output_field_mod
use xios_mod
use write_field_mod
use physics_mod
use tracer_mod
use restart_mod
use etat0_mod
use diagflux_mod
use profiling_mod
use read_metric_mod
subroutine check_total_area
type(t_field),pointer,save :: sum_ne(:)
real(rstd),pointer :: pt_sum_ne(:)
integer :: ind,i,j,k,n
real(rstd) :: tot_sum=0
end subroutine check_total_area
end subroutine icosa_init
end module icosa_init_mod
module transfert_request_mod
use abort_mod
use field_mod, only : t_field, field_t, field_u, field_z
use domain_mod, only : ndomain, ndomain_glo, domain, domain_glo, domloc_glo_ind, domglo_rank, domglo_loc_ind
type t_points
integer, allocatable :: i(:), j(:)
integer, allocatable :: elt(:) ! element : cell edge or cell point
integer :: npoints
end type
type t_request
integer :: field_type
type(t_points), allocatable :: points_btoh(:) ! req(local_ind)%points_btoh(remote_ind) are the points of
type(t_points), allocatable :: points_htob(:) ! req(local_ind)%points_htob(remote_ind) are the points of
logical :: vector = .false. ! is a vector request (true if sign change needed)
end type t_request
type(t_request),save,pointer :: req_i1(:) ! halos for t fields
type(t_request),save,pointer :: req_e1_scal(:) ! halos for u fields
type(t_request),save,pointer :: req_e1_vect(:) ! halos for u fields (with sign change)
type(t_request),save,pointer :: req_z1_scal(:) ! halos for z fields
type(t_request),save,pointer :: req_i0(:) ! duplicated cells for t fields
type(t_request),save,pointer :: req_e0_scal(:)
type(t_request),save,pointer :: req_e0_vect(:)
subroutine init_all_requests
use dimensions, only : swap_dimensions, ii_begin, ii_end, jj_begin, jj_end
use metric, only : right, rdown, ldown, left, lup, rup, vdown, vlup, vrdown, vrup, vup
integer :: ind, i, j
subroutine points_init(points, has_elt)
type(t_points):: points
logical :: has_elt
integer, parameter :: initial_alloc_size = 10
end subroutine
subroutine points_append(points, i, j, elt)
type(t_points), intent(inout):: points
integer, intent(in) :: i, j
integer, intent(in), optional :: elt
integer :: begin_size
end subroutine
subroutine array_append( a, a_size, elt )
integer, allocatable, intent(inout) :: a(:)
integer, intent(inout) :: a_size
integer, intent(in) :: elt
integer, allocatable :: a_tmp(:)
integer, parameter :: grow_factor = 2
end subroutine
subroutine points_sort( points )
use dimensions, only : iim, jjm
type(t_points):: points
integer :: displs(points%npoints)
integer :: k, i, last, i_min, tmp
end subroutine
subroutine request_init( request, field_type )
type(t_request), pointer, intent(out) :: request(:)
integer, intent(in) :: field_type
integer :: ind, remote_ind_glo
end subroutine
subroutine request_add_point(req, ind, i, j, elt)
type(t_request), intent(inout) :: req(:)
integer :: ind, i, j
integer, optional :: elt
end subroutine
subroutine request_exchange(req)
use mpi_mod
use dimensions, only : swap_dimensions
use mpipara, only : comm_icosa
type(t_request), target, intent(in) :: req(:)
type(t_points) :: points_send(ndomain,ndomain_glo)
type(t_points), pointer :: points
integer :: ind_loc, remote_ind_glo, k
integer :: i, j, elt
integer :: reqs(ndomain, ndomain_glo, 2), reqs2(ndomain, ndomain_glo, 2), reqs3(ndomain, ndomain_glo, 3), ierr
end subroutine
subroutine waitall(reqs, size)
use mpi_mod
integer :: size, reqs(size), ierr
end subroutine
end subroutine
end module
module domain_param
integer :: nsplit_i
integer :: nsplit_j
integer :: halo=1
integer, parameter :: default_nsplit_i=1
integer, parameter :: default_nsplit_j=1
subroutine init_domain_param
use ioipsl
end subroutine init_domain_param
end module domain_param
module domain_mod
use domain_param
type t_domain
integer :: face
integer :: iim
integer :: jjm
integer :: ii_begin
integer :: jj_begin
integer :: ii_end
integer :: jj_end
integer :: ii_nb
integer :: jj_nb
integer :: ii_begin_glo
integer :: jj_begin_glo
integer :: ii_end_glo
integer :: jj_end_glo
integer,pointer  :: assign_domain(:,:)
integer,pointer  :: assign_cell_glo(:,:)
integer,pointer  :: assign_i(:,:)
integer,pointer  :: assign_j(:,:)
integer,pointer  :: edge_assign_domain(:,:,:)
integer,pointer  :: edge_assign_i(:,:,:)
integer,pointer  :: edge_assign_j(:,:,:)
integer,pointer  :: edge_assign_pos(:,:,:)
integer,pointer  :: edge_assign_sign(:,:,:)
integer,pointer  :: vertex_assign_domain(:,:,:)
integer,pointer  :: vertex_assign_i(:,:,:)
integer,pointer  :: vertex_assign_j(:,:,:)
integer,pointer  :: vertex_assign_pos(:,:,:)
real,pointer     :: xyz(:,:,:)
real,pointer     :: neighbour(:,:,:,:)
integer,pointer  :: delta(:,:)
real,pointer     :: vertex(:,:,:,:)
logical,pointer  :: own(:,:)
integer,pointer  :: ne(:,:,:)
integer :: t_right
integer :: t_rup
integer :: t_lup
integer :: t_left
integer :: t_ldown
integer :: t_rdown
integer :: u_right
integer :: u_rup
integer :: u_lup
integer :: u_left
integer :: u_ldown
integer :: u_rdown
integer :: z_rup
integer :: z_up
integer :: z_lup
integer :: z_ldown
integer :: z_down
integer :: z_rdown
integer :: t_pos(6)
integer :: u_pos(6)
integer :: z_pos(6)
end type t_domain
integer,save :: ndomain
integer,save :: ndomain_glo
type(t_domain),save,allocatable,target :: domain(:)
type(t_domain),save,allocatable,target :: domain_glo(:)
integer,allocatable,save :: domglo_rank(:)  ! size : ndomain_glo : mpi rank assigned to a domain
integer,allocatable,save :: domglo_loc_ind(:) ! size : ndomain_glo : corresponding local indice for a global domain indice
integer,allocatable,save :: domloc_glo_ind(:) ! size : ndomain : corresponding global indice for a local domain indice
logical, allocatable, save :: assigned_domain(:) ! size : ndomain : is an omp task is assigned to this domain
subroutine create_domain
use grid_param
use mpipara
use ioipsl
integer :: ind,nf,ni,nj
integer :: quotient, rest
integer :: halo_i,halo_j
type(t_domain),pointer :: d
end subroutine create_domain
subroutine copy_domain(d1,d2)
type(t_domain),target,intent(in) :: d1
type(t_domain), intent(out) :: d2
end subroutine copy_domain
subroutine assign_cell
use metric
use mpipara
use ioipsl
integer :: ind_d,ind,ind2,e,v
integer :: nf,nf2
integer :: i,j,k,ii,jj
type(t_domain),pointer :: d
integer :: delta
integer :: nbp, nn, m
real :: rn
integer, allocatable :: nb_own(:)
integer :: mean_own, side
subroutine assign_edge(ind_d,ind,i,j,delta,k)
integer :: ind_d,ind,i,j,delta,k
integer :: e
end  subroutine assign_edge
subroutine assign_vertex(ind_d,ind,i,j,delta,k)
integer :: ind_d,ind,i,j,delta,k
integer :: e
end  subroutine assign_vertex
end subroutine assign_cell
subroutine compute_boundary
use spherical_geom_mod
integer :: ind_d
integer :: i,j,k
type(t_domain),pointer :: d
real(rstd) :: ng1(3),ng2(3)
end subroutine compute_boundary
subroutine set_neighbour_indice
use metric
integer :: ind_d
type(t_domain),pointer :: d
end subroutine set_neighbour_indice
subroutine assign_domain
use mpipara
use grid_param
integer :: nb_domain(0:mpi_size-1)
integer :: rank, ind,ind_glo
integer :: block_j,jb,i,j,nd_glo,n,nf
logical :: exit
end subroutine  assign_domain
subroutine assign_domain_omp
use omp_para
use mpipara
integer :: nb_domain
integer :: rank, ind, i
end subroutine assign_domain_omp
subroutine compute_domain
end subroutine compute_domain
end module domain_mod
module transfert_omp_mod
real,parameter :: grow_factor=1.5
integer,parameter :: size_min=1024
integer,save,allocatable,dimension(:)   :: buffer_i
integer,save                            :: size_i=0
real,save,allocatable,dimension(:)      :: buffer_r
integer,save                            :: size_r=0
logical,save,allocatable,dimension(:)   :: buffer_l
integer,save                            :: size_l=0
interface bcast_omp
module procedure bcast_omp_c,                                                                           bcast_omp_i,bcast_omp_i1,bcast_omp_i2,bcast_omp_i3,bcast_omp_i4,                       bcast_omp_r,bcast_omp_r1,bcast_omp_r2,bcast_omp_r3,bcast_omp_r4,  		     bcast_omp_l,bcast_omp_l1,bcast_omp_l2,bcast_omp_l3,bcast_omp_l4
end interface
interface reduce_sum_omp
module procedure reduce_sum_omp_i,reduce_sum_omp_i1,reduce_sum_omp_i2,reduce_sum_omp_i3,reduce_sum_omp_i4,                       reduce_sum_omp_r,reduce_sum_omp_r1,reduce_sum_omp_r2,reduce_sum_omp_r3,reduce_sum_omp_r4
end interface
interface allreduce_sum_omp
module procedure allreduce_sum_omp_i,allreduce_sum_omp_i1,allreduce_sum_omp_i2,allreduce_sum_omp_i3,allreduce_sum_omp_i4,                       allreduce_sum_omp_r,allreduce_sum_omp_r1,allreduce_sum_omp_r2,allreduce_sum_omp_r3,allreduce_sum_omp_r4
end interface
interface reduce_max_omp
module procedure reduce_max_omp_i,reduce_max_omp_i1,reduce_max_omp_i2,reduce_max_omp_i3,reduce_max_omp_i4,                       reduce_max_omp_r,reduce_max_omp_r1,reduce_max_omp_r2,reduce_max_omp_r3,reduce_max_omp_r4
end interface
interface allreduce_max_omp
module procedure allreduce_max_omp_i,allreduce_max_omp_i1,allreduce_max_omp_i2,allreduce_max_omp_i3,allreduce_max_omp_i4,                       allreduce_max_omp_r,allreduce_max_omp_r1,allreduce_max_omp_r2,allreduce_max_omp_r3,allreduce_max_omp_r4
end interface
subroutine check_buffer_i(buff_size)
integer :: buff_size
end subroutine check_buffer_i
subroutine check_buffer_r(buff_size)
integer :: buff_size
end subroutine check_buffer_r
subroutine check_buffer_l(buff_size)
integer :: buff_size
end subroutine check_buffer_l
subroutine bcast_omp_c(var)
integer :: lenvar
end subroutine bcast_omp_c
subroutine bcast_omp_i(var)
integer,intent(inout) :: var
integer :: var_tmp(1)
end subroutine bcast_omp_i
subroutine bcast_omp_i1(var)
integer,intent(inout) :: var(:)
end subroutine bcast_omp_i1
subroutine bcast_omp_i2(var)
integer,intent(inout) :: var(:,:)
end subroutine bcast_omp_i2
subroutine bcast_omp_i3(var)
integer,intent(inout) :: var(:,:,:)
end subroutine bcast_omp_i3
subroutine bcast_omp_i4(var)
integer,intent(inout) :: var(:,:,:,:)
end subroutine bcast_omp_i4
subroutine bcast_omp_r(var)
real,intent(inout) :: var
real :: var_tmp(1)
end subroutine bcast_omp_r
subroutine bcast_omp_r1(var)
real,intent(inout) :: var(:)
end subroutine bcast_omp_r1
subroutine bcast_omp_r2(var)
real,intent(inout) :: var(:,:)
end subroutine bcast_omp_r2
subroutine bcast_omp_r3(var)
real,intent(inout) :: var(:,:,:)
end subroutine bcast_omp_r3
subroutine bcast_omp_r4(var)
real,intent(inout) :: var(:,:,:,:)
end subroutine bcast_omp_r4
subroutine bcast_omp_l(var)
logical,intent(inout) :: var
logical :: var_tmp(1)
end subroutine bcast_omp_l
subroutine bcast_omp_l1(var)
logical,intent(inout) :: var(:)
end subroutine bcast_omp_l1
subroutine bcast_omp_l2(var)
logical,intent(inout) :: var(:,:)
end subroutine bcast_omp_l2
subroutine bcast_omp_l3(var)
logical,intent(inout) :: var(:,:,:)
end subroutine bcast_omp_l3
subroutine bcast_omp_l4(var)
logical,intent(inout) :: var(:,:,:,:)
end subroutine bcast_omp_l4
subroutine reduce_sum_omp_i(varin, varout)
integer,intent(in)  :: varin
integer,intent(out) :: varout
integer             :: varin_tmp(1)
integer             :: varout_tmp(1)
end subroutine reduce_sum_omp_i
subroutine reduce_sum_omp_i1(varin, varout)
integer,intent(in),dimension(:)  :: varin
integer,intent(out),dimension(:) :: varout
end subroutine reduce_sum_omp_i1
subroutine reduce_sum_omp_i2(varin, varout)
integer,intent(in),dimension(:,:)  :: varin
integer,intent(out),dimension(:,:) :: varout
end subroutine reduce_sum_omp_i2
subroutine reduce_sum_omp_i3(varin, varout)
integer,intent(in),dimension(:,:,:)  :: varin
integer,intent(out),dimension(:,:,:) :: varout
end subroutine reduce_sum_omp_i3
subroutine reduce_sum_omp_i4(varin, varout)
integer,intent(in),dimension(:,:,:,:)  :: varin
integer,intent(out),dimension(:,:,:,:) :: varout
end subroutine reduce_sum_omp_i4
subroutine reduce_sum_omp_r(varin, varout)
real,intent(in)  :: varin
real,intent(out) :: varout
real             :: varin_tmp(1)
real             :: varout_tmp(1)
end subroutine reduce_sum_omp_r
subroutine reduce_sum_omp_r1(varin, varout)
real,intent(in),dimension(:)  :: varin
real,intent(out),dimension(:) :: varout
end subroutine reduce_sum_omp_r1
subroutine reduce_sum_omp_r2(varin, varout)
real,intent(in),dimension(:,:)  :: varin
real,intent(out),dimension(:,:) :: varout
end subroutine reduce_sum_omp_r2
subroutine reduce_sum_omp_r3(varin, varout)
real,intent(in),dimension(:,:,:)  :: varin
real,intent(out),dimension(:,:,:) :: varout
end subroutine reduce_sum_omp_r3
subroutine reduce_sum_omp_r4(varin, varout)
real,intent(in),dimension(:,:,:,:)  :: varin
real,intent(out),dimension(:,:,:,:) :: varout
end subroutine reduce_sum_omp_r4
subroutine allreduce_sum_omp_i(varin, varout)
integer,intent(in)  :: varin
integer,intent(out) :: varout
integer             :: varin_tmp(1)
integer             :: varout_tmp(1)
end subroutine allreduce_sum_omp_i
subroutine allreduce_sum_omp_i1(varin, varout)
integer,intent(in),dimension(:)  :: varin
integer,intent(out),dimension(:) :: varout
end subroutine allreduce_sum_omp_i1
subroutine allreduce_sum_omp_i2(varin, varout)
integer,intent(in),dimension(:,:)  :: varin
integer,intent(out),dimension(:,:) :: varout
end subroutine allreduce_sum_omp_i2
subroutine allreduce_sum_omp_i3(varin, varout)
integer,intent(in),dimension(:,:,:)  :: varin
integer,intent(out),dimension(:,:,:) :: varout
end subroutine allreduce_sum_omp_i3
subroutine allreduce_sum_omp_i4(varin, varout)
integer,intent(in),dimension(:,:,:,:)  :: varin
integer,intent(out),dimension(:,:,:,:) :: varout
end subroutine allreduce_sum_omp_i4
subroutine allreduce_sum_omp_r(varin, varout)
real,intent(in)  :: varin
real,intent(out) :: varout
real             :: varin_tmp(1)
real             :: varout_tmp(1)
end subroutine allreduce_sum_omp_r
subroutine allreduce_sum_omp_r1(varin, varout)
real,intent(in),dimension(:)  :: varin
real,intent(out),dimension(:) :: varout
end subroutine allreduce_sum_omp_r1
subroutine allreduce_sum_omp_r2(varin, varout)
real,intent(in),dimension(:,:)  :: varin
real,intent(out),dimension(:,:) :: varout
end subroutine allreduce_sum_omp_r2
subroutine allreduce_sum_omp_r3(varin, varout)
real,intent(in),dimension(:,:,:)  :: varin
real,intent(out),dimension(:,:,:) :: varout
end subroutine allreduce_sum_omp_r3
subroutine allreduce_sum_omp_r4(varin, varout)
real,intent(in),dimension(:,:,:,:)  :: varin
real,intent(out),dimension(:,:,:,:) :: varout
end subroutine allreduce_sum_omp_r4
subroutine reduce_max_omp_i(varin, varout)
integer,intent(in)  :: varin
integer,intent(out) :: varout
integer             :: varin_tmp(1)
integer             :: varout_tmp(1)
end subroutine reduce_max_omp_i
subroutine reduce_max_omp_i1(varin, varout)
integer,intent(in),dimension(:)  :: varin
integer,intent(out),dimension(:) :: varout
end subroutine reduce_max_omp_i1
subroutine reduce_max_omp_i2(varin, varout)
integer,intent(in),dimension(:,:)  :: varin
integer,intent(out),dimension(:,:) :: varout
end subroutine reduce_max_omp_i2
subroutine reduce_max_omp_i3(varin, varout)
integer,intent(in),dimension(:,:,:)  :: varin
integer,intent(out),dimension(:,:,:) :: varout
end subroutine reduce_max_omp_i3
subroutine reduce_max_omp_i4(varin, varout)
integer,intent(in),dimension(:,:,:,:)  :: varin
integer,intent(out),dimension(:,:,:,:) :: varout
end subroutine reduce_max_omp_i4
subroutine reduce_max_omp_r(varin, varout)
real,intent(in)  :: varin
real,intent(out) :: varout
real             :: varin_tmp(1)
real             :: varout_tmp(1)
end subroutine reduce_max_omp_r
subroutine reduce_max_omp_r1(varin, varout)
real,intent(in),dimension(:)  :: varin
real,intent(out),dimension(:) :: varout
end subroutine reduce_max_omp_r1
subroutine reduce_max_omp_r2(varin, varout)
real,intent(in),dimension(:,:)  :: varin
real,intent(out),dimension(:,:) :: varout
end subroutine reduce_max_omp_r2
subroutine reduce_max_omp_r3(varin, varout)
real,intent(in),dimension(:,:,:)  :: varin
real,intent(out),dimension(:,:,:) :: varout
end subroutine reduce_max_omp_r3
subroutine reduce_max_omp_r4(varin, varout)
real,intent(in),dimension(:,:,:,:)  :: varin
real,intent(out),dimension(:,:,:,:) :: varout
end subroutine reduce_max_omp_r4
subroutine allreduce_max_omp_i(varin, varout)
integer,intent(in)  :: varin
integer,intent(out) :: varout
integer             :: varin_tmp(1)
integer             :: varout_tmp(1)
end subroutine allreduce_max_omp_i
subroutine allreduce_max_omp_i1(varin, varout)
integer,intent(in),dimension(:)  :: varin
integer,intent(out),dimension(:) :: varout
end subroutine allreduce_max_omp_i1
subroutine allreduce_max_omp_i2(varin, varout)
integer,intent(in),dimension(:,:)  :: varin
integer,intent(out),dimension(:,:) :: varout
end subroutine allreduce_max_omp_i2
subroutine allreduce_max_omp_i3(varin, varout)
integer,intent(in),dimension(:,:,:)  :: varin
integer,intent(out),dimension(:,:,:) :: varout
end subroutine allreduce_max_omp_i3
subroutine allreduce_max_omp_i4(varin, varout)
integer,intent(in),dimension(:,:,:,:)  :: varin
integer,intent(out),dimension(:,:,:,:) :: varout
end subroutine allreduce_max_omp_i4
subroutine allreduce_max_omp_r(varin, varout)
real,intent(in)  :: varin
real,intent(out) :: varout
real             :: varin_tmp(1)
real             :: varout_tmp(1)
end subroutine allreduce_max_omp_r
subroutine allreduce_max_omp_r1(varin, varout)
real,intent(in),dimension(:)  :: varin
real,intent(out),dimension(:) :: varout
end subroutine allreduce_max_omp_r1
subroutine allreduce_max_omp_r2(varin, varout)
real,intent(in),dimension(:,:)  :: varin
real,intent(out),dimension(:,:) :: varout
end subroutine allreduce_max_omp_r2
subroutine allreduce_max_omp_r3(varin, varout)
real,intent(in),dimension(:,:,:)  :: varin
real,intent(out),dimension(:,:,:) :: varout
end subroutine allreduce_max_omp_r3
subroutine allreduce_max_omp_r4(varin, varout)
real,intent(in),dimension(:,:,:,:)  :: varin
real,intent(out),dimension(:,:,:,:) :: varout
end subroutine allreduce_max_omp_r4
subroutine bcast_omp_cgen(var,nb,buff)
integer,intent(in) :: nb
integer :: i
end subroutine bcast_omp_cgen
subroutine bcast_omp_igen(var,nb,buff)
integer,intent(in) :: nb
integer,dimension(nb),intent(inout) :: var
integer,dimension(nb),intent(inout) :: buff
integer :: i
end subroutine bcast_omp_igen
subroutine bcast_omp_rgen(var,nb,buff)
integer,intent(in) :: nb
real,dimension(nb),intent(inout) :: var
real,dimension(nb),intent(inout) :: buff
integer :: i
end subroutine bcast_omp_rgen
subroutine bcast_omp_lgen(var,nb,buff)
integer,intent(in) :: nb
logical,dimension(nb),intent(inout) :: var
logical,dimension(nb),intent(inout) :: buff
integer :: i
end subroutine bcast_omp_lgen
subroutine reduce_sum_omp_igen(varin,varout,dimsize,buff)
integer,intent(in) :: dimsize
integer,intent(in),dimension(dimsize) :: varin
integer,intent(out),dimension(dimsize) :: varout
integer,intent(inout),dimension(dimsize) :: buff
integer :: i
end subroutine reduce_sum_omp_igen
subroutine reduce_sum_omp_rgen(varin,varout,dimsize,buff)
integer,intent(in) :: dimsize
real,intent(in),dimension(dimsize) :: varin
real,intent(out),dimension(dimsize) :: varout
real,intent(inout),dimension(dimsize) :: buff
integer :: i
end subroutine reduce_sum_omp_rgen
subroutine allreduce_sum_omp_igen(varin,varout,dimsize,buff)
integer,intent(in) :: dimsize
integer,intent(in),dimension(dimsize) :: varin
integer,intent(out),dimension(dimsize) :: varout
integer,intent(inout),dimension(dimsize) :: buff
integer :: i
end subroutine allreduce_sum_omp_igen
subroutine allreduce_sum_omp_rgen(varin,varout,dimsize,buff)
integer,intent(in) :: dimsize
real,intent(in),dimension(dimsize) :: varin
real,intent(out),dimension(dimsize) :: varout
real,intent(inout),dimension(dimsize) :: buff
integer :: i
end subroutine allreduce_sum_omp_rgen
subroutine reduce_max_omp_igen(varin,varout,dimsize,buff)
integer,intent(in) :: dimsize
integer,intent(in),dimension(dimsize) :: varin
integer,intent(out),dimension(dimsize) :: varout
integer,intent(inout),dimension(dimsize) :: buff
integer :: i
end subroutine reduce_max_omp_igen
subroutine reduce_max_omp_rgen(varin,varout,dimsize,buff)
integer,intent(in) :: dimsize
real,intent(in),dimension(dimsize) :: varin
real,intent(out),dimension(dimsize) :: varout
real,intent(inout),dimension(dimsize) :: buff
integer :: i
end subroutine reduce_max_omp_rgen
subroutine allreduce_max_omp_igen(varin,varout,dimsize,buff)
integer,intent(in) :: dimsize
integer,intent(in),dimension(dimsize) :: varin
integer,intent(out),dimension(dimsize) :: varout
integer,intent(inout),dimension(dimsize) :: buff
integer :: i
end subroutine allreduce_max_omp_igen
subroutine allreduce_max_omp_rgen(varin,varout,dimsize,buff)
integer,intent(in) :: dimsize
real,intent(in),dimension(dimsize) :: varin
real,intent(out),dimension(dimsize) :: varout
real,intent(inout),dimension(dimsize) :: buff
integer :: i
end subroutine allreduce_max_omp_rgen
end module transfert_omp_mod
module mpi_mod
integer :: mpi_comm_world
integer :: mpi_real8
integer :: mpi_integer
integer :: mpi_character
integer :: mpi_logical
integer :: mpi_any_source
integer :: mpi_max
integer :: mpi_info_null
integer :: mpi_status_size
integer :: mpi_sum
integer :: mpi_thread_single, mpi_thread_funneled
integer :: mpi_thread_serialized, mpi_thread_multiple
integer,parameter :: mpi_address_kind=kind(integer)
end module mpi_mod
subroutine  mpi_init
end
subroutine  mpi_init_thread
end
subroutine  mpi_comm_size
end
subroutine  mpi_comm_rank
end
subroutine mpi_finalize
end
subroutine mpi_allreduce
end
subroutine mpi_reduce
end
subroutine mpi_alltoall
end
subroutine mpi_isend
end
subroutine mpi_issend
end
subroutine mpi_irecv
end
subroutine mpi_waitall
end
subroutine mpi_testall
end
subroutine mpi_barrier
end
subroutine mpi_allgather
end
subroutine mpi_type_extent
end
subroutine mpi_alloc_mem
end
subroutine mpi_free_mem
end
subroutine mpi_bcast
end
subroutine mpi_gather
end
subroutine mpi_abort(comm, err, ierr)
integer :: comm, err, ierr
end
module transfert_mpi_mod
use abort_mod, only : dynamico_abort, abort_acc
use profiling_mod, only : enter_profile, exit_profile, register_id
use domain_mod, only : ndomain, ndomain_glo, domain, domain_glo, domloc_glo_ind, domglo_rank, domglo_loc_ind
use field_mod, only : t_field, field_t, field_u, field_z
use transfert_request_mod
type t_local_submessage
integer :: src_ind_loc, dest_ind_loc ! index of local and remote domain
integer :: npoints ! number of cells to transfer (dim12)
integer, allocatable :: displ_src(:) ! list of indexes to copy from domain src_ind_loc
integer, allocatable :: displ_dest(:) ! list of indexes to copy to domain dest_ind_loc
integer, allocatable :: sign(:) ! sign change to be applied for vector requests
end type
type t_submessage
integer :: ind_loc, remote_ind_glo, remote_rank ! index of local and remote domain
integer :: npoints ! number of cells to transfer (dim12)
integer, allocatable :: displs(:) ! list of indexes to copy from field to buffer for each level
integer, allocatable :: sign(:) ! sign change to be applied for vector requests
integer :: mpi_buffer_displ = -1
end type
type t_compact_submessages
integer :: npoints
integer, allocatable, dimension(:) :: field_ind, field_displ, sign, remote_rank, mpi_displ, level_offset
end type
type t_compact_local_submessages
integer :: npoints
integer, allocatable, dimension(:) :: field_ind_src, field_displ_src, sign, field_ind_dest, field_displ_dest
end type
type mpi_buffer_t
integer :: n
real, allocatable :: buff(:)
end type
type t_message
type (t_field), pointer :: field(:) => null() ! field to exchange
type (t_request), pointer :: request(:) => null() ! type of message to send
type (t_local_submessage), pointer :: message_local(:) ! local halo copies
type (t_submessage), pointer :: message_in(:) ! messages to recieve from remote ranks and to copy back to the field
type (t_submessage), pointer :: message_out(:) ! halos to copy to mpi buffer and to send to remote ranks
type (mpi_buffer_t), pointer :: mpi_buffer_in(:)
type (mpi_buffer_t), pointer :: mpi_buffer_out(:)
type (t_compact_submessages), pointer :: message_in_compact
type (t_compact_submessages), pointer :: message_out_compact
type (t_compact_local_submessages), pointer  :: message_local_compact
integer, pointer :: mpi_requests_in(:) ! mpi requests used for message_in.
integer, pointer :: mpi_requests_out(:) ! mpi requests used for message_out.
integer :: send_seq ! sequence number : send_seq is incremented each time send_message is called
integer :: wait_seq ! sequence number : wait_seq is incremented each time wait_message is called
logical :: ondevice ! ready to transfer ondevice field
end type t_message
integer :: profile_mpi, profile_mpi_copies, profile_mpi_waitall, profile_mpi_barrier
subroutine init_transfert
use mpi_mod, only : mpi_thread_single, mpi_thread_funneled
use mpipara, only : mpi_threading_mode
use profiling_mod, only : register_id
logical, parameter :: profile_mpi_detail = .true.
end subroutine
subroutine init_message(field, request, message, name)
use mpi_mod
use mpipara
type(t_field), pointer, intent(in) :: field(:)
type(t_request),pointer, intent(in) :: request(:)
type(t_message), target, intent(out) :: message ! needs intent out for call to finalize_message
integer, parameter :: initial_alloc_size = 10, grow_factor = 2
type(t_submessage) :: submessage_in, submessage_out
type(t_local_submessage) :: submessage_local
integer :: dim3, dim4, npoints, last_point
integer :: ind, ind_loc, remote_ind_glo, loc_ind_glo, i, k, remote_rank
integer :: message_in_size, message_out_size, message_local_size, buffer_in_size, buffer_out_size
type(t_local_submessage), allocatable :: message_local_tmp(:)
type(t_submessage), allocatable :: message_in_tmp(:), message_out_tmp(:)
integer :: field_type
function make_submessage(field_type, points, ind_loc, remote_ind_glo, dim3, dim4, vector) result(submessage)
use dimensions, only : swap_dimensions, iim, u_pos, z_pos
integer, intent(in) :: field_type
type(t_points), intent(in) :: points
integer, intent(in) :: ind_loc, remote_ind_glo, dim3, dim4
logical, intent(in) :: vector
integer :: k
type(t_submessage) :: submessage
end function
subroutine array_append_submessage( a, a_size, elt )
type(t_submessage), allocatable, intent(inout) :: a(:)
integer, intent(inout) :: a_size
type(t_submessage), intent(in) :: elt
type(t_submessage), allocatable :: a_tmp(:)
integer, parameter :: grow_factor = 2
end subroutine
subroutine array_append_local_submessage( a, a_size, elt )
type(t_local_submessage), allocatable, intent(inout) :: a(:)
integer, intent(inout) :: a_size
type(t_local_submessage), intent(in) :: elt
type(t_local_submessage), allocatable :: a_tmp(:)
integer, parameter :: grow_factor = 2
end subroutine
end subroutine
subroutine message_create_ondevice(message)
use mpi_mod
use mpipara, only : mpi_size, comm_icosa
type(t_message), intent(inout) :: message
integer :: i, ierr
end subroutine
subroutine message_delete_ondevice(message)
use mpipara, only : mpi_size
type(t_message), intent(inout) :: message
integer :: i
end subroutine
subroutine finalize_message(message)
use mpi_mod
use mpipara, only : mpi_size
type(t_message), intent(inout) :: message
integer :: i, ierr
end subroutine
subroutine copy_htob(message)
use domain_mod, only : assigned_domain
use omp_para, only : distrib_level
type(t_message), intent(inout) :: message
integer :: dim3, dim4, d3_begin, d3_end
integer :: k, d3, d4, i
integer :: local_displ
end subroutine
subroutine copy_htoh(message)
use domain_mod, only : assigned_domain
use omp_para, only : distrib_level
type(t_message), intent(inout) :: message
integer :: dim3, dim4, d3_begin, d3_end
integer :: k, d3, d4, i
end subroutine
subroutine copy_btoh(message)
use domain_mod, only : assigned_domain
use omp_para, only : distrib_level
type(t_message), intent(inout) :: message
integer :: dim3, dim4, d3_begin, d3_end
integer :: k, d3, d4, i
integer :: last_point
end subroutine
subroutine send_message(field, message)
use mpi_mod
use mpipara , only : mpi_size
type(t_field),pointer :: field(:)
type(t_message), target :: message
integer :: ierr, i
end subroutine
subroutine test_message(message)
use mpi_mod
type(t_message) :: message
integer :: ierr
logical :: completed
end subroutine
subroutine wait_message(message)
use mpi_mod
type(t_message), target :: message
integer :: ierr
end subroutine
end module
module transfert_mpi_legacy_mod
use genmod
use field_mod
type array
integer,pointer :: value(:)=>null()
integer,pointer :: sign(:)=>null()
integer         :: domain
integer         :: rank
integer         :: tag
integer         :: size
integer         :: offset
integer         :: ireq
integer,pointer :: buffer(:)=>null()
real,pointer    :: buffer_r(:)=>null()
integer,pointer :: src_value(:)=>null()
end type array
type t_buffer
real,pointer    :: r(:)
integer         :: size
integer         :: rank
end type t_buffer
type t_request
integer :: type_field
integer :: max_size
integer :: size
logical :: vector
integer,pointer :: src_domain(:)
integer,pointer :: src_i(:)
integer,pointer :: src_j(:)
integer,pointer :: src_ind(:)
integer,pointer :: target_ind(:)
integer,pointer :: target_i(:)
integer,pointer :: target_j(:)
integer,pointer :: target_sign(:)
integer :: nrecv
type(array),pointer :: recv(:)
integer :: nsend
integer :: nreq_mpi
integer :: nreq_send
integer :: nreq_recv
type(array),pointer :: send(:)
end type t_request
type(t_request),save,pointer :: req_i1(:)
type(t_request),save,pointer :: req_e1_scal(:)
type(t_request),save,pointer :: req_e1_vect(:)
type(t_request),save,pointer :: req_z1_scal(:)
type(t_request),save,pointer :: req_i0(:)
type(t_request),save,pointer :: req_e0_scal(:)
type(t_request),save,pointer :: req_e0_vect(:)
type t_reorder
integer :: ind
integer :: rank
integer :: tag
integer :: isend
end type t_reorder
type t_message
type(t_request), pointer :: request(:)
integer :: nreq
integer :: nreq_send
integer :: nreq_recv
type(t_reorder), pointer :: reorder(:)
integer, pointer :: mpi_req(:)
integer, pointer :: status(:,:)
type(t_buffer),pointer :: buffers(:)
type(t_field),pointer :: field(:)
logical :: completed
logical :: pending
logical :: open      ! for debug
integer :: number
logical :: ondevice=.false. !<ready to transfer ondevice field
end type t_message
integer :: profile_mpi_copies, profile_mpi_waitall, profile_mpi_omp_barrier
subroutine init_transfert
use profiling_mod
use domain_mod
use dimensions
use field_mod
use metric
use mpipara
use mpi_mod
integer :: ind,i,j
end subroutine init_transfert
subroutine create_request(type_field,request,vector)
use domain_mod
use field_mod
integer :: type_field
type(t_request),pointer :: request(:)
logical,optional :: vector
type(t_request),pointer :: req
type(t_domain),pointer :: d
integer :: ind
integer :: max_size
end subroutine create_request
subroutine reallocate_request(req)
type(t_request),pointer :: req
integer,pointer :: src_domain(:)
integer,pointer :: src_ind(:)
integer,pointer :: target_ind(:)
integer,pointer :: src_i(:)
integer,pointer :: src_j(:)
integer,pointer :: target_i(:)
integer,pointer :: target_j(:)
integer,pointer :: target_sign(:)
end subroutine reallocate_request
subroutine request_add_point(ind,i,j,request,pos)
use domain_mod
use field_mod
integer,intent(in)            ::  ind
integer,intent(in)            :: i
integer,intent(in)            :: j
type(t_request),pointer :: request(:)
integer,intent(in),optional  :: pos
integer :: src_domain
integer :: src_iim,src_i,src_j,src_n,src_pos,src_delta
type(t_request),pointer :: req
type(t_domain),pointer :: d
end subroutine request_add_point
subroutine finalize_request(request)
use mpipara
use domain_mod
use mpi_mod
type(t_request),pointer :: request(:)
type(t_request),pointer :: req, req_src
integer :: nb_domain_recv(0:mpi_size-1)
integer :: nb_domain_send(0:mpi_size-1)
integer :: tag_rank(0:mpi_size-1)
integer :: nb_data_domain_recv(ndomain_glo)
integer :: list_domain_recv(ndomain_glo)
integer,allocatable :: list_domain_send(:)
integer             :: list_domain(ndomain)
integer :: rank,i,j,pos
integer :: size_,ind_glo,ind_loc
integer :: isend, irecv, ireq, nreq, nsend, nrecv
integer, allocatable :: mpi_req(:)
integer, allocatable :: status(:,:)
integer, allocatable :: rank_list(:)
integer, allocatable :: offset(:)
logical,parameter :: debug = .false.
end subroutine finalize_request
subroutine init_message_seq(field, request, message, name)
use field_mod
use domain_mod
use mpi_mod
use mpipara
use mpi_mod
type(t_field),pointer :: field(:)
type(t_request),pointer :: request(:)
type(t_message) :: message
end subroutine init_message_seq
subroutine send_message_seq(field,message)
use field_mod
use domain_mod
use mpi_mod
use mpipara
use omp_para
use trace
type(t_field),pointer :: field(:)
type(t_message) :: message
end subroutine send_message_seq
subroutine test_message_seq(message)
type(t_message) :: message
end subroutine  test_message_seq
subroutine wait_message_seq(message)
type(t_message) :: message
end subroutine wait_message_seq
subroutine init_message_mpi(field,request, message, name)
use field_mod
use domain_mod
use mpi_mod
use mpipara
use mpi_mod
type(t_field),pointer :: field(:)
type(t_request),pointer :: request(:)
type(t_message) :: message
type(t_request),pointer :: req
integer :: irecv,isend
integer :: ireq,nreq
integer :: ind
integer :: dim3,dim4
integer,save :: message_number=0
end subroutine init_message_mpi
subroutine finalize_message_mpi(message)
use field_mod
use domain_mod
use mpi_mod
use mpipara
use mpi_mod
type(t_message) :: message
integer :: ireq, ibuff
end subroutine finalize_message_mpi
subroutine update_device_message_mpi(message)
use domain_mod
type(t_message), intent(inout) :: message
integer :: ireq, ibuff
end subroutine
subroutine send_message_mpi(field,message)
use abort_mod
use profiling_mod
use field_mod
use domain_mod
use mpi_mod
use mpipara
use omp_para
use trace
use abort_mod
type(t_field),pointer :: field(:)
type(t_message) :: message
real(rstd),pointer :: rval2d(:), src_rval2d(:)
real(rstd),pointer :: rval3d(:,:), src_rval3d(:,:)
real(rstd),pointer :: rval4d(:,:,:), src_rval4d(:,:,:)
real(rstd),pointer :: buffer_r(:)
integer,pointer :: value(:)
integer,pointer :: sgn(:)
type(array),pointer :: recv,send
type(t_request),pointer :: req
integer :: irecv,isend
integer :: ireq
integer :: ind,n
integer :: dim3,dim4,d3,d4
integer,pointer :: src_value(:)
integer :: offset,msize,moffset,rank
integer :: lbegin, lend
integer :: max_req
end subroutine send_message_mpi
subroutine test_message_mpi(message)
type(t_message) :: message
integer :: ierr
end subroutine  test_message_mpi
subroutine wait_message_mpi(message)
use profiling_mod
use field_mod
use domain_mod
use mpi_mod
use mpipara
use omp_para
use trace
type(t_message) :: message
type(t_field),pointer :: field(:)
real(rstd),pointer :: rval2d(:)
real(rstd),pointer :: rval3d(:,:)
real(rstd),pointer :: rval4d(:,:,:)
real(rstd),pointer :: buffer_r(:)
integer,pointer :: value(:)
integer,pointer :: sgn(:)
type(array),pointer :: recv
type(t_request),pointer :: req
integer :: irecv
integer :: ireq,nreq
integer :: ind,n
integer :: dim3,dim4,d3,d4,lbegin,lend
integer :: offset, msize, moffset
end subroutine wait_message_mpi
subroutine transfert_request_seq(field,request)
use field_mod
use domain_mod
type(t_field),pointer :: field(:)
type(t_request),pointer :: request(:)
real(rstd),pointer :: rval2d(:)
real(rstd),pointer :: rval3d(:,:)
real(rstd),pointer :: rval4d(:,:,:)
integer :: ind
type(t_request),pointer :: req
integer :: n
end subroutine transfert_request_seq
end module transfert_mpi_legacy_mod
module transfert_mod
use transfert_mpi_legacy_mod, only :  t_message, t_request,                                          req_i1, req_e1_scal, req_e1_vect,                                          req_i0, req_e0_scal, req_e0_vect,                                          req_z1_scal,                                          init_transfert,                                          init_message=>init_message_seq,                                          finalize_message => finalize_message_seq,                                          send_message => send_message_seq,                                          wait_message => wait_message_seq,                                          test_message => test_message_seq
use transfert_mpi_collectives_mod, only : gather_field, scatter_field, bcast_field, bcast_mpi
use transfert_omp_mod, only : bcast_omp
interface bcast
module procedure  bcast_c,                                                            bcast_i,bcast_i1,bcast_i2,bcast_i3,bcast_i4,                        bcast_r,bcast_r1,bcast_r2,bcast_r3,bcast_r4,                        bcast_l,bcast_l1,bcast_l2,bcast_l3,bcast_l4
end interface
subroutine transfert_message(field, message)
use field_mod, only : t_field
type(t_field), pointer :: field(:)
type(t_message) :: message
end subroutine
subroutine transfert_request(field, request)
use field_mod, only : t_field
type(t_field),pointer :: field(:)
type(t_request),pointer :: request(:)
type(t_message), save :: message ! save because shared between threads
end subroutine
subroutine bcast_c(var)
end subroutine bcast_c
subroutine bcast_i(var)
integer,intent(inout) :: var
end subroutine bcast_i
subroutine bcast_i1(var)
integer,intent(inout) :: var(:)
end subroutine bcast_i1
subroutine bcast_i2(var)
integer,intent(inout) :: var(:,:)
end subroutine bcast_i2
subroutine bcast_i3(var)
integer,intent(inout) :: var(:,:,:)
end subroutine bcast_i3
subroutine bcast_i4(var)
integer,intent(inout) :: var(:,:,:,:)
end subroutine bcast_i4
subroutine bcast_r(var)
real,intent(inout) :: var
end subroutine bcast_r
subroutine bcast_r1(var)
real,intent(inout) :: var(:)
end subroutine bcast_r1
subroutine bcast_r2(var)
real,intent(inout) :: var(:,:)
end subroutine bcast_r2
subroutine bcast_r3(var)
real,intent(inout) :: var(:,:,:)
end subroutine bcast_r3
subroutine bcast_r4(var)
real,intent(inout) :: var(:,:,:,:)
end subroutine bcast_r4
subroutine bcast_l(var)
logical,intent(inout) :: var
end subroutine bcast_l
subroutine bcast_l1(var)
logical,intent(inout) :: var(:)
end subroutine bcast_l1
subroutine bcast_l2(var)
logical,intent(inout) :: var(:,:)
end subroutine bcast_l2
subroutine bcast_l3(var)
logical,intent(inout) :: var(:,:,:)
end subroutine bcast_l3
subroutine bcast_l4(var)
logical,intent(inout) :: var(:,:,:,:)
end subroutine bcast_l4
end module transfert_mod
module mpipara
integer,save :: mpi_rank
integer,save :: mpi_size
integer,save :: mpi_threading_mode
integer,save :: comm_icosa
integer,save :: ierr
logical,save :: using_mpi
logical,save :: is_mpi_root
logical,save :: is_mpi_master
integer,save :: mpi_master
integer,save :: id_mpi ! id for profiling
interface allocate_mpi_buffer
module procedure allocate_mpi_buffer_r2, allocate_mpi_buffer_r3,allocate_mpi_buffer_r4
end interface allocate_mpi_buffer
interface free_mpi_buffer
module procedure free_mpi_buffer_r2, free_mpi_buffer_r3, free_mpi_buffer_r4
end interface free_mpi_buffer
subroutine getin(name,value) ! copied from getin.f90 to avoid circular dependency
use ioipsl, only : getin_=>getin
use transfert_omp_mod
use omp_para
end subroutine getin
subroutine init_mpipara
use mpi_mod
use abort_mod
use openacc_mod
integer :: required_mode
end select
end subroutine  init_mpipara
subroutine finalize_mpipara
use mpi_mod
end subroutine  finalize_mpipara
subroutine allocate_mpi_buffer_r2(buffer,length)
use iso_c_binding
use mpi_mod
use prec
real(rstd), pointer :: buffer(:)
integer,intent(in)  :: length
type(c_ptr)         :: base_ptr
integer(kind=mpi_address_kind) :: real_size,lb,size
integer :: ierr
end subroutine allocate_mpi_buffer_r2
subroutine free_mpi_buffer_r2(buffer)
use iso_c_binding
use mpi_mod
use prec
real(rstd), pointer :: buffer(:)
end subroutine free_mpi_buffer_r2
subroutine allocate_mpi_buffer_r3(buffer,length,dim3)
use iso_c_binding
use mpi_mod
use prec
real(rstd), pointer :: buffer(:,:)
integer,intent(in)  :: length
integer,intent(in)  :: dim3
type(c_ptr)         :: base_ptr
integer(kind=mpi_address_kind) :: real_size,lb,size
integer :: ierr
end subroutine allocate_mpi_buffer_r3
subroutine free_mpi_buffer_r3(buffer)
use iso_c_binding
use mpi_mod
use prec
real(rstd), pointer :: buffer(:,:)
end subroutine free_mpi_buffer_r3
subroutine allocate_mpi_buffer_r4(buffer,length,dim3,dim4)
use iso_c_binding
use mpi_mod
use prec
real(rstd), pointer :: buffer(:,:,:)
integer,intent(in)  :: length
integer,intent(in)  :: dim3
integer,intent(in)  :: dim4
type(c_ptr)         :: base_ptr
integer(kind=mpi_address_kind) :: real_size,lb,size
integer :: ierr
end subroutine allocate_mpi_buffer_r4
subroutine free_mpi_buffer_r4(buffer)
use iso_c_binding
use mpi_mod
use prec
real(rstd), pointer :: buffer(:,:,:)
end subroutine free_mpi_buffer_r4
end module mpipara
module transfert_mpi_collectives_mod
interface bcast_mpi
module procedure bcast_mpi_c,                                                                           bcast_mpi_i,bcast_mpi_i1,bcast_mpi_i2,bcast_mpi_i3,bcast_mpi_i4,                       bcast_mpi_r,bcast_mpi_r1,bcast_mpi_r2,bcast_mpi_r3,bcast_mpi_r4,  		     bcast_mpi_l,bcast_mpi_l1,bcast_mpi_l2,bcast_mpi_l3,bcast_mpi_l4
end interface
subroutine gather_field(field_loc,field_glo)
use field_mod
use domain_mod
use mpi_mod
use mpipara
type(t_field),pointer :: field_loc(:)
type(t_field),pointer :: field_glo(:)
integer, allocatable :: mpi_req(:)
integer, allocatable :: status(:,:)
integer :: ireq,nreq
integer :: ind_glo,ind_loc
end subroutine gather_field
subroutine bcast_field(field_glo)
use field_mod
use domain_mod
use mpi_mod
use mpipara
type(t_field),pointer :: field_glo(:)
integer :: ind_glo
end subroutine bcast_field
subroutine scatter_field(field_glo,field_loc)
use field_mod
use domain_mod
use mpi_mod
use mpipara
type(t_field),pointer :: field_glo(:)
type(t_field),pointer :: field_loc(:)
integer, allocatable :: mpi_req(:)
integer, allocatable :: status(:,:)
integer :: ireq,nreq
integer :: ind_glo,ind_loc
end subroutine scatter_field
subroutine bcast_mpi_c(var1)
end subroutine bcast_mpi_c
subroutine bcast_mpi_i(var)
use mpipara
integer,intent(inout) :: var
integer               :: var_tmp(1)
end subroutine bcast_mpi_i
subroutine bcast_mpi_i1(var)
integer,intent(inout) :: var(:)
end subroutine bcast_mpi_i1
subroutine bcast_mpi_i2(var)
integer,intent(inout) :: var(:,:)
end subroutine bcast_mpi_i2
subroutine bcast_mpi_i3(var)
integer,intent(inout) :: var(:,:,:)
end subroutine bcast_mpi_i3
subroutine bcast_mpi_i4(var)
integer,intent(inout) :: var(:,:,:,:)
end subroutine bcast_mpi_i4
subroutine bcast_mpi_r(var)
use mpipara
real,intent(inout) :: var
real               :: var_tmp(1)
end subroutine bcast_mpi_r
subroutine bcast_mpi_r1(var)
real,intent(inout) :: var(:)
end subroutine bcast_mpi_r1
subroutine bcast_mpi_r2(var)
real,intent(inout) :: var(:,:)
end subroutine bcast_mpi_r2
subroutine bcast_mpi_r3(var)
real,intent(inout) :: var(:,:,:)
end subroutine bcast_mpi_r3
subroutine bcast_mpi_r4(var)
real,intent(inout) :: var(:,:,:,:)
end subroutine bcast_mpi_r4
subroutine bcast_mpi_l(var)
use mpipara
logical,intent(inout) :: var
logical               :: var_tmp(1)
end subroutine bcast_mpi_l
subroutine bcast_mpi_l1(var)
logical,intent(inout) :: var(:)
end subroutine bcast_mpi_l1
subroutine bcast_mpi_l2(var)
logical,intent(inout) :: var(:,:)
end subroutine bcast_mpi_l2
subroutine bcast_mpi_l3(var)
logical,intent(inout) :: var(:,:,:)
end subroutine bcast_mpi_l3
subroutine bcast_mpi_l4(var)
logical,intent(inout) :: var(:,:,:,:)
end subroutine bcast_mpi_l4
subroutine bcast_mpi_cgen(var,nb)
use mpi_mod
use mpipara
integer,intent(in) :: nb
end subroutine bcast_mpi_cgen
subroutine bcast_mpi_igen(var,nb)
use mpi_mod
use mpipara
integer,intent(in) :: nb
integer,dimension(nb),intent(inout) :: var
end subroutine bcast_mpi_igen
subroutine bcast_mpi_rgen(var,nb)
use mpi_mod
use mpipara
integer,intent(in) :: nb
real,dimension(nb),intent(inout) :: var
end subroutine bcast_mpi_rgen
subroutine bcast_mpi_lgen(var,nb)
use mpi_mod
use mpipara
integer,intent(in) :: nb
logical,dimension(nb),intent(inout) :: var
end subroutine bcast_mpi_lgen
end module transfert_mpi_collectives_mod
module openacc_mod
logical,save :: openacc_initialized=.false.
integer,save :: openacc_device_id=-1
interface set_openacc_device
module procedure set_device_manual, set_device_mpi
end interface
subroutine set_device_manual()
end subroutine set_device_manual
subroutine set_device_mpi(nprocs, myrank)
integer, intent(in) :: nprocs, myrank
end subroutine set_device_mpi
end module openacc_mod
module omp_para
integer,save :: omp_size
integer,save :: omp_rank
logical,save :: is_omp_first_level
logical,save :: is_omp_last_level
logical,save :: is_omp_master
integer,save :: ll_begin
integer,save :: ll_beginp1
integer,save :: ll_end
integer,save :: ll_endm1
integer,save :: ll_endp1
logical,save :: using_openmp
integer,save :: omp_domain_size
integer,save :: omp_domain_rank
integer,save :: omp_level_size
integer,save :: omp_level_rank
logical,save :: is_omp_domain_master
logical,save :: is_omp_level_master
logical,parameter :: omp_by_domain=.true.
logical,save :: is_master
logical,save :: is_omp_first_level_full
logical,save :: is_omp_last_level_full
integer,save :: ll_begin_full
integer,save :: ll_beginp1_full
integer,save :: ll_end_full
integer,save :: ll_endm1_full
integer,save :: ll_endp1_full
logical,save :: is_omp_first_level_distrib
logical,save :: is_omp_last_level_distrib
integer,save :: ll_begin_distrib
integer,save :: ll_beginp1_distrib
integer,save :: ll_end_distrib
integer,save :: ll_endm1_distrib
integer,save :: ll_endp1_distrib
function get_omp_size() result(omp_size)
integer :: omp_size
end function
subroutine init_omp_para(is_mpi_master)
use grid_param
use ioipsl, only : getin
logical, intent(in) :: is_mpi_master
integer :: ll_nb,i,llb,lle
end subroutine init_omp_para
subroutine distrib_level(ibegin,iend, lbegin,lend)
integer,intent(in)  :: ibegin,iend
integer,intent(out) :: lbegin
integer,intent(out) :: lend
integer :: size,div,rest
end subroutine distrib_level
subroutine switch_omp_distrib_level
end subroutine switch_omp_distrib_level
subroutine switch_omp_no_distrib_level
end subroutine switch_omp_no_distrib_level
function omp_in_parallel()
logical :: omp_in_parallel
end function  omp_in_parallel
end module omp_para
module checksum_mod
subroutine checksum(field)
use mpi_mod
use mpipara
use field_mod
use domain_mod
use dimensions
type(t_field) :: field(:)
integer :: intval(2)
integer :: ind,i,j,ij,l,k
integer :: tot_sum
integer :: tot_sum_mpi(mpi_size)
end subroutine checksum
end module checksum_mod
module output_field_mod
use genmod
use xios_mod
use profiling_mod
logical :: xios_output
logical :: enable_io
integer :: id_output
subroutine output_field_init
use getin_mod
end subroutine output_field_init
subroutine output_field(name_in,field)
use field_mod
use write_field_mod
type(t_field),pointer :: field(:)
end subroutine output_field
subroutine output_field_finalize
use ioipsl
end subroutine output_field_finalize
end module output_field_mod
module write_etat0_mod
subroutine write_etat0(it,f_ps,f_phis,f_theta_rhodz,f_u, f_q, f_geopot, f_w)
use icosa
use restart_mod
use wind_mod
use write_field_mod
use domain_mod
use omp_para
use xios_mod
use checksum_mod
integer,intent(in)    :: it
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
type(t_field),pointer, optional :: f_geopot(:)
type(t_field),pointer, optional :: f_w(:)
type(t_field),pointer,save :: f_ulon(:)
type(t_field),pointer,save :: f_ulat(:)
type(t_field),pointer,save :: f_theta_rhodz_1d(:)
type(t_field),pointer,save :: f_xcell(:),f_ycell(:),f_zcell(:)
real(rstd), pointer :: theta_rhodz(:,:,:),theta_rhodz_1d(:,:)
real(rstd), pointer :: xcell(:), ycell(:), zcell(:)
integer :: ind,n,i,j
end subroutine write_etat0
end module write_etat0_mod
module restart_mod
use field_mod
type t_field_array
type(t_field),pointer :: field(:)
end type t_field_array
logical,save :: write_start=.true.
subroutine init_restart
use xios_mod
use icosa
use time_mod
use omp_para
end subroutine init_restart
subroutine write_restart(it,field0 ,field1 ,field2 ,field3 ,field4 ,field5 ,field6 ,field7 ,field8 ,field9,                               field10,field11,field12,field13,field14,field15,field16,field17,field18,field19 )
use prec
use metric
use field_mod
use domain_mod
use netcdf_mod
use mpipara
use omp_para
use getin_mod
use spherical_geom_mod
use transfert_mod
use disvert_mod
use xios_mod
integer,intent(in)     :: it
type(t_field),pointer,optional,dimension(:) :: field0 ,field1 ,field2 ,field3 ,field4 ,field5 ,field6 ,field7 ,field8 ,field9
type(t_field),pointer,optional,dimension(:) :: field10,field11,field12,field13,field14,field15,field16,field17,field18,field19
type(t_field_array) :: field_array(20)
integer             :: nfield
integer             :: fieldid(20)
type(t_domain),pointer :: d
type(t_field),pointer :: field(:)
integer,parameter  :: nvert=6
integer    ::  ncid, cellid, levid, edgeid,  vertid, lonid, latid, bounds_lonid, bounds_latid, nqid, levaxisid
integer    :: ind,ind_glo,i,j,k,nf
integer    :: status
real(rstd),allocatable :: lon(:),lat(:),bounds_lon(:,:),bounds_lat(:,:)
end subroutine write_restart
subroutine write_restart_field(field,fieldid,ncid)
use prec
use metric
use field_mod
use domain_mod
use netcdf_mod
use mpipara
use getin_mod
use spherical_geom_mod
use transfert_mod
use xios_mod
type(t_field),pointer :: field(:)
integer,intent(in)     :: fieldid
integer,intent(in)     :: ncid
type(t_domain),pointer :: d
type(t_field),pointer :: field_glo(:)
real(rstd),allocatable :: global_field2d(:)
real(rstd),allocatable :: global_field3d(:,:)
real(rstd),allocatable :: global_field4d(:,:,:)
integer :: i,j,ij,k,e,ind,ind_glo
integer :: ndim, field_type
integer :: status
end subroutine write_restart_field
subroutine read_start(it,field0 ,field1 ,field2 ,field3 ,field4 ,field5 ,field6 ,field7 ,field8 ,field9,                               field10,field11,field12,field13,field14,field15,field16,field17,field18,field19 )
use prec
use metric
use field_mod
use domain_mod
use netcdf_mod
use mpipara
use getin_mod
use spherical_geom_mod
use transfert_mod
use xios_mod
integer, intent(out)  :: it
type(t_field),pointer,optional,dimension(:) :: field0 ,field1 ,field2 ,field3 ,field4 ,field5 ,field6 ,field7 ,field8 ,field9
type(t_field),pointer,optional,dimension(:) :: field10,field11,field12,field13,field14,field15,field16,field17,field18,field19
type(t_field_array) :: field_array(20)
integer             :: nfield
integer             :: fieldid(20)
type(t_field),pointer :: field(:)
integer,parameter  :: nvert=6
integer    ::  ncid
integer    :: nf
integer    :: status
real(rstd) :: it_real
end subroutine read_start
subroutine read_start_field(field,fieldid,ncid)
use prec
use metric
use field_mod
use domain_mod
use netcdf_mod
use mpipara
use getin_mod
use spherical_geom_mod
use transfert_mod
type(t_field),pointer :: field(:)
integer,intent(in)     :: fieldid
integer,intent(in)     :: ncid
type(t_domain),pointer :: d
type(t_field),pointer :: field_glo(:)
real(rstd),allocatable :: global_field2d(:)
real(rstd),allocatable :: global_field3d(:,:)
real(rstd),allocatable :: global_field4d(:,:,:)
integer :: i,j,ij,k,e,ind,ind_glo
integer :: ndim, field_type
integer :: status
end subroutine read_start_field
end module restart_mod
module netcdf_mod
use netcdf
logical,parameter :: no_io = .false.
integer ::  nf90_netcdf4
integer ::  nf90_mpiio
integer ::  nf90_chunked
integer,external :: nf90_create_par
integer,external :: nf90_def_var_chunking
end module netcdf_mod
subroutine nf90_create_par
end
subroutine nf90_def_var_chunking
end
module write_field_mod
use genmod
integer,save :: ncprec
type ncvar
integer :: size
integer,pointer :: nc_id(:)
integer :: displ
end type ncvar
integer, parameter :: maxwritefield = 1000
integer, dimension(maxwritefield),save :: fieldid
type(ncvar), dimension(maxwritefield),save :: fieldvarid
integer, dimension(maxwritefield),save :: fieldindex
integer,save :: nbfield = 0
subroutine init_writefield
use ioipsl
use netcdf_mod
end select
end subroutine init_writefield
function getfieldindex(name)
integer          :: getfieldindex
integer            :: i
end function getfieldindex
subroutine writefield(name_in,field,nind,once)
use domain_mod
use field_mod
use transfert_mod
use dimensions
use mpipara
use netcdf_mod
type(t_field),pointer :: field(:)
integer,optional,intent(in) :: nind
logical,optional,intent(in) :: once
logical                     :: once_
type(t_field),pointer :: field_glo(:)
end subroutine writefield
subroutine writefield_gen(name_in, field, domain_type, ind_b_in, ind_e_in,once )
use netcdf_mod
use domain_mod
use field_mod
type(t_field), pointer :: field(:)
type(t_domain),intent(in),target :: domain_type(:)
integer,optional,intent(in) :: ind_b_in
integer,optional,intent(in) :: ind_e_in
real(r8),allocatable :: field_val2d(:)
real(r8),allocatable :: field_val3d(:,:)
logical, intent(in) :: once
type(t_domain),pointer :: d
integer :: index
integer :: ind,i,j,k,n,ncell,q
integer :: status
integer :: ind_b,ind_e
integer :: halo_size
logical :: single
end subroutine writefield_gen
subroutine writefield_mpi(name_in,field,nind)
use netcdf_mod
use domain_mod
use field_mod
use dimensions
use geometry
type(t_field),pointer :: field(:)
integer,optional,intent(in) :: nind
real(r8),allocatable :: field_val2d(:)
real(r8),allocatable :: field_val3d(:,:)
type(t_domain),pointer :: d
integer :: index
integer :: ind,i,j,l,k,n,ncell,q
integer :: status
integer :: ind_b,ind_e
integer :: halo_size
logical :: single
integer :: displ
end subroutine writefield_mpi
subroutine create_header_gen(name_in,field,domain_type,ind_b_in,ind_e_in,once)
use netcdf_mod
use field_mod
use domain_mod
use metric
use spherical_geom_mod
type(t_field),pointer :: field(:)
type(t_domain),intent(in),target :: domain_type(:)
integer,optional,intent(in) :: ind_b_in
integer,optional,intent(in) :: ind_e_in
logical,intent(in) :: once
integer :: ncell
integer :: nvert
real(rstd),allocatable :: lon(:),lat(:),bounds_lon(:,:),bounds_lat(:,:)
type(t_domain),pointer :: d
integer :: nvertid,ncid,lonid,latid,bounds_lonid,bounds_latid,timeid,ncellid
integer :: dim3id
integer :: status
integer :: ind,i,j,k,n,q
integer :: ind_b,ind_e
integer :: halo_size
logical :: single
integer :: nij
integer :: l,level_size, levid
end subroutine create_header_gen
subroutine create_header_mpi(name,field,nind)
use netcdf_mod
use field_mod
use domain_mod
use spherical_geom_mod
use dimensions
use geometry
use mpi_mod
use mpipara
type(t_field),pointer :: field(:)
integer,optional,intent(in) :: nind
integer :: ncell
integer :: nvert
real(rstd),allocatable :: lon(:),lat(:),bounds_lon(:,:),bounds_lat(:,:)
type(t_domain),pointer :: d
integer :: nvertid,ncid,lonid,latid,bounds_lonid,bounds_latid,timeid,ncellid
integer :: dim3id
integer :: status
integer :: ind,i,j,k,n,q
integer :: ind_b,ind_e
integer :: halo_size
logical :: single
integer :: nij
integer :: ncell_glo(0:mpi_size-1)
integer :: displ, ncell_tot
end subroutine create_header_mpi
subroutine close_files
use netcdf_mod
integer :: i,status
end subroutine  close_files
function int2str(int)
integer, parameter :: maxlen=10
integer,intent(in) :: int
logical :: flag
integer :: i
end function int2str
end module write_field_mod
module xios_mod
logical,save :: using_xios
interface xios_send_field
module procedure xios_send_field_scalar, xios_send_field_1d
end interface  xios_send_field
integer,parameter :: xios_timestep=1
subroutine xios_init
end subroutine xios_init
subroutine xios_send_field_scalar(name,field)
real,intent(in) :: field
end subroutine xios_send_field_scalar
subroutine xios_send_field_1d(name,field)
real,intent(in) :: field(:)
end subroutine xios_send_field_1d
subroutine xios_write_field(name,field)
use field_mod
type(t_field), pointer :: field(:)
end subroutine xios_write_field
subroutine xios_init_write_field_input
end subroutine
subroutine xios_read_field(name,field)
use field_mod
type(t_field), pointer :: field(:)
end subroutine xios_read_field
subroutine xios_read_var(name,field)
use prec
real(rstd), intent(out) :: field
end subroutine
subroutine xios_update_calendar(step)
integer, intent(in):: step
end subroutine xios_update_calendar
subroutine xios_write_field_finalize
end subroutine xios_write_field_finalize
subroutine xios_init_write_field
end subroutine xios_init_write_field
subroutine xios_set_context
end subroutine xios_set_context
subroutine xios_set_context_input
end subroutine xios_set_context_input
subroutine xios_set_fieldgroup_attr(name,enabled,freq_op)
logical,optional          :: enabled
integer,optional          :: freq_op
end subroutine xios_set_fieldgroup_attr
subroutine xios_set_filegroup_attr(name,enabled)
logical,optional          :: enabled
end subroutine xios_set_filegroup_attr
subroutine xios_set_file_attr(id,name,mode,enabled, output_freq)
logical,optional          :: enabled
integer,optional          :: output_freq
end subroutine xios_set_file_attr
subroutine xios_get_axis_attr(name,n_glo,value)
integer,optional          :: n_glo
real,optional             :: value(:)
end subroutine xios_get_axis_attr
subroutine xios_set_axis_attr(id,n_glo,value)
integer,optional          :: n_glo
real,optional             :: value(:)
end subroutine xios_set_axis_attr
end module xios_mod
module free_unit_mod
integer, parameter :: start_unit=1000
function free_unit()
integer :: free_unit
logical :: out
end function free_unit
end module free_unit_mod
module disvert_apbp_mod
use icosa
real(rstd), save, allocatable,target :: ap(:)
real(rstd), save, allocatable,target :: bp(:)
real(rstd), save, allocatable,target :: presnivs(:)
subroutine init_disvert
end subroutine init_disvert
subroutine disvert(ap,bp,presnivs)
use abort_mod
use mpipara, only: is_mpi_root
use omp_para, only: omp_in_parallel
use transfert_omp_mod, only: bcast_omp
use free_unit_mod, only : free_unit
real(rstd),intent(out) :: ap(:)
real(rstd),intent(out) :: bp(:)
real(rstd),intent(out) :: presnivs(:)
integer :: unit
integer :: l,ok
end subroutine disvert
end module disvert_apbp_mod
module disvert_std_mod
use icosa
real(rstd), save, allocatable,target :: ap(:)
real(rstd), save, allocatable,target :: bp(:)
real(rstd), save, allocatable,target :: presnivs(:)
subroutine init_disvert
end subroutine init_disvert
subroutine disvert(ap,bp,presnivs)
use mpipara
real(rstd),intent(out) :: ap(:)
real(rstd),intent(out) :: bp(:)
real(rstd),intent(out) :: presnivs(:)
real(rstd) :: dsig(llm)
real(rstd) :: sig(llm+1)
real(rstd) :: snorm
integer :: l
end subroutine disvert
end module disvert_std_mod
module disvert_dcmip200_mod
use icosa
real(rstd), save, allocatable,target :: ap(:)
real(rstd), save, allocatable,target :: bp(:)
real(rstd), save, allocatable,target :: presnivs(:)
subroutine init_disvert
use icosa
use mpipara
end subroutine init_disvert
subroutine disvert(ap,bp,presnivs)
use icosa
use mpipara
real(rstd),intent(out) :: ap(:)
real(rstd),intent(out) :: bp(:)
real(rstd),intent(out) :: presnivs(:)
integer :: l,cindx
real(rstd) ::  eta_top, eta
real(rstd),parameter :: n=0.01         ! brunt-vaisala frequency (s-1)
real(rstd),parameter :: t0=300.       ! surface temperature at the equator (k)
real(rstd) :: rd
real(rstd), parameter :: gamma=0.0065
end subroutine disvert
end  module disvert_dcmip200_mod
module disvert_ncar_mod
use icosa
real(rstd), save, allocatable,target :: ap(:)
real(rstd), save, allocatable,target :: bp(:)
real(rstd), save, allocatable,target :: presnivs(:)
subroutine init_disvert
use icosa
end subroutine init_disvert
subroutine disvert(ap,bp,presnivs)
use icosa
use mpipara
real(rstd),intent(out) :: ap(:)
real(rstd),intent(out) :: bp(:)
real(rstd),intent(out) :: presnivs(:)
integer :: l,cindx
real(rstd) :: h, eta_top, eta
end subroutine disvert
end  module disvert_ncar_mod
module disvert_mod
use icosa
use abort_mod
real(rstd), save, pointer :: ap(:)
real(rstd), save, pointer :: bp(:)
real(rstd), save, pointer :: presnivs(:)
real(rstd), save, pointer :: mass_al(:), mass_bl(:), mass_ak(:), mass_bk(:), mass_dak(:), mass_dbk(:)
real(rstd) :: ptop ! pressure at top of atmosphere l=llm+1
integer, save :: caldyn_eta
integer, parameter :: eta_mass=1, eta_lag=2
logical,save :: ap_bp_present
subroutine init_disvert
use disvert_std_mod, only: ap_std=>ap, bp_std=>bp, presnivs_std=>presnivs, init_disvert_std=>init_disvert
use disvert_strato_mod, only: ap_strato=>ap, bp_strato=>bp, presnivs_strato=>presnivs, init_disvert_strato=>init_disvert, init_disvert_strato_custom
use disvert_apbp_mod, only: ap_apbp=>ap, bp_apbp=>bp, presnivs_apbp=>presnivs, init_disvert_apbp=>init_disvert
use disvert_ncar_mod, only: ap_ncar=>ap, bp_ncar=>bp, presnivs_ncar=>presnivs, init_disvert_ncar=>init_disvert
use disvert_ncarl30_mod, only: ap_ncarl30=>ap, bp_ncarl30=>bp, presnivs_ncarl30=>presnivs, init_disvert_ncarl30=>init_disvert
use disvert_dcmip31_mod, only: ap_dcmip31=>ap, bp_dcmip31=>bp, presnivs_dcmip31=>presnivs, init_disvert_dcmip31=>init_disvert
use disvert_dcmip200_mod, only: ap_dcmip200=>ap, bp_dcmip200=>bp, presnivs_dcmip200=>presnivs, init_disvert_dcmip200=>init_disvert
use icosa
use mpipara
integer :: l
end select
end select
end subroutine init_disvert
subroutine compute_rhodz(comp, ps, rhodz, ondevice)
use icosa
use omp_para
logical, intent(in) :: comp ! .true. to compute, .false. to check
real(rstd), intent(in) :: ps(iim*jjm)
real(rstd), intent(inout) :: rhodz(iim*jjm,llm)
logical, intent(in), optional :: ondevice ! .true. compute on device, .false. stay on host
real(rstd) :: m, err
integer :: l,i,j,ij,dd
logical :: ondevice_
end subroutine compute_rhodz
subroutine write_apbp
use icosa
use netcdf_mod
real(rstd) :: val(llm)
integer :: status
integer :: lev,ilev
integer :: ncid,levid,ilevid,hyaiid,hybiid,hyamid,hybmid,p0id
integer :: l
end subroutine write_apbp
end module disvert_mod
module disvert_dcmip31_mod
use icosa
real(rstd), save, allocatable,target :: ap(:)
real(rstd), save, allocatable,target :: bp(:)
real(rstd), save, allocatable,target :: presnivs(:)
subroutine init_disvert
end subroutine init_disvert
subroutine disvert(ap,bp,presnivs)
use mpipara
real(rstd),intent(out) :: ap(:)
real(rstd),intent(out) :: bp(:)
real(rstd),intent(out) :: presnivs(:)
integer :: l,cindx
real(rstd) :: gg, eta_top, eta
real(rstd),parameter :: n=0.01         ! brunt-vaisala frequency (s-1)
real(rstd),parameter :: teq=300.       ! surface temperature at the equator (k)
real(rstd),parameter :: peq=1e5        ! reference surface pressure at the equator (hpa)
end subroutine disvert
end  module disvert_dcmip31_mod
module vertical_interp_mod
use icosa
subroutine init_vertical_interp
use icosa
end subroutine init_vertical_interp
subroutine vertical_interp(f_pmid,f_in,f_out,pval)
use icosa
use pression_mod
use omp_para
type(t_field),pointer :: f_pmid(:)
type(t_field),pointer :: f_in(:)
type(t_field),pointer :: f_out(:)
real(rstd),intent(in) :: pval
real(rstd),pointer :: in(:,:)
real(rstd),pointer :: out(:)
real(rstd),pointer :: pmid(:,:)
integer :: ind
end subroutine  vertical_interp
subroutine compute_vertical_interp(pmid,in,out,pval)
use omp_para
real(rstd),intent(in) :: pmid(iim*jjm,llm)
real(rstd),intent(in) :: in(iim*jjm,llm)
real(rstd),intent(out) :: out(iim*jjm)
real(rstd) :: pval, coeff
integer :: i,j,ij,l
end subroutine compute_vertical_interp
end module vertical_interp_mod
module vertical_remap_mod
use icosa
subroutine vertical_remap(pressure_level,field_in,f_ps,field_out)
use icosa
use pression_mod
use omp_para
real(rstd), intent(in) :: pressure_level(:)
type(t_field),pointer :: field_in(:)
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: field_out(:)
type(t_field),pointer,save :: f_p(:)
real(rstd),pointer :: in(:,:)
real(rstd),pointer :: out(:,:)
real(rstd),pointer :: p(:,:)
integer :: ind
end subroutine  vertical_remap
subroutine compute_vertical_remap(pressure_level,in,p,out)
use omp_para
real(rstd),intent(in)  :: pressure_level(:)
real(rstd),intent(in)  :: in(:,:)
real(rstd),intent(in)  :: p(iim*jjm,llm+1)
real(rstd),intent(out) :: out(iim*jjm,llm)
real(rstd) :: coeff, pmid
integer :: i,j,ij,l,n,nb_level
integer :: a
integer :: b
logical :: positive
end subroutine compute_vertical_remap
end module vertical_remap_mod
module disvert_ncarl30_mod
use icosa
real(rstd), save, allocatable,target :: ap(:)
real(rstd), save, allocatable,target :: bp(:)
real(rstd), save, allocatable,target :: presnivs(:)
subroutine init_disvert
use icosa
use mpipara
end subroutine init_disvert
subroutine disvert(ap,bp,presnivs)
use icosa
use mpipara
real(rstd),intent(out) :: ap(:)
real(rstd),intent(out) :: bp(:)
real(rstd),intent(out) :: presnivs(:)
integer :: l
real(rstd) :: a(31)=(/ 0.00225523952394724,                           0.00503169186413288,                           0.0101579474285245 ,                           0.0185553170740604 ,                           0.0306691229343414 ,                           0.0458674766123295 ,                           0.0633234828710556 ,                           0.0807014182209969 ,                           0.0949410423636436 ,                           0.11169321089983   ,                           0.131401270627975  ,                           0.154586806893349  ,                           0.181863352656364  ,                           0.17459799349308   ,                           0.166050657629967  ,                           0.155995160341263  ,                           0.14416541159153   ,                           0.130248308181763  ,                           0.113875567913055  ,                           0.0946138575673103 ,                           0.0753444507718086 ,                           0.0576589405536652 ,                           0.0427346378564835 ,                           0.0316426791250706 ,                           0.0252212174236774 ,                           0.0191967375576496 ,                           0.0136180268600583 ,                           0.00853108894079924,                           0.00397881818935275,                           0.                 ,                           0. /)
real(rstd) :: b(31)=(/ 0.                 ,                           0.                 ,                           0.                 ,                           0.                 ,                           0.                 ,                           0.                 ,                           0.                 ,                           0.                 ,                           0.                 ,                           0.                 ,                           0.                 ,                           0.                 ,                           0.                 ,                           0.0393548272550106 ,                           0.0856537595391273 ,                           0.140122056007385  ,                           0.204201176762581  ,                           0.279586911201477  ,                           0.368274360895157  ,                           0.47261056303978   ,                           0.576988518238068  ,                           0.672786951065063  ,                           0.753628432750702  ,                           0.813710987567902  ,                           0.848494648933411  ,                           0.881127893924713  ,                           0.911346435546875  ,                           0.938901245594025  ,                           0.963559806346893  ,                           0.985112190246582  ,                           1. /)
end subroutine disvert
end module disvert_ncarl30_mod
module disvert_strato_mod
use icosa
use mpipara
use getin_mod
use earth_const
real(rstd), save, allocatable,target :: ap(:)
real(rstd), save, allocatable,target :: bp(:)
real(rstd), save, allocatable,target :: presnivs(:)
subroutine init_disvert
real(rstd) :: dsigmin, snorm, x, dsig(llm),  sig(llm+1)
integer :: l
end subroutine init_disvert
subroutine init_disvert_strato_custom
real(rstd) :: vert_scale,vert_dzmin,vert_dzlow,vert_z0low,vert_dzmid,vert_z0mid,vert_h_mid,vert_dzhig,vert_z0hig,vert_h_hig
real(rstd) :: z, sig(llm+1), sig0(llm+1), zz(llm+1)
integer :: l
function racinesig(sig) result(sg)
real, intent(in)  :: sig(:)
real(rstd)        :: sg(size(sig))
integer      :: it, ns, maxit
real(rstd)   :: c1, c2, f1
end function racinesig
end subroutine init_disvert_strato_custom
end module disvert_strato_mod
module dcmip2016_kessler_physic_mod
subroutine kessler(theta, qv, qc, qr, rho, pk, dt, z, nz, precl)
integer, intent(in) :: nz ! number of thermodynamic levels in the column
real(8), dimension(nz), intent(inout) ::              theta   ,     & ! potential temperature (k)
real(8), dimension(nz), intent(in) ::              rho             ! dry air density (not mean state as in kw) (kg/m^3)
real(8), intent(out) ::              precl          ! precipitation rate (m_water / s)
real(8), dimension(nz), intent(in) ::              z       ,     & ! heights of thermo. levels in the grid column (m)
real(8), intent(in) ::              dt              ! time step (s)
real, dimension(nz) :: r, rhalf, velqr, sed, pc
real(8) :: f5, f2x, xk, ern, qrprod, prod, qvs, psl, rhoqr, dt_max, dt0
integer :: k, rainsplit, nt
end subroutine kessler
end module dcmip2016_kessler_physic_mod
module dcmip2016_simple_physics_mod
subroutine simple_physics(pcols, pver, dtime, lat, t, q, u, v, pmid, pint, pdel, rpdel, ps, precl, test, rj2012_precip, tc_pbl_mod)
integer, parameter :: r8 = selected_real_kind(12)
integer, intent(in)  :: pcols        ! set number of atmospheric columns
integer, intent(in)  :: pver         ! set number of model levels
real(r8), intent(in) :: dtime        ! set model physics timestep
real(r8), intent(in) :: lat(pcols)   ! latitude
integer, intent(in)  :: test         ! test number
logical, intent(in)  :: rj2012_precip
logical, intent(in)  :: tc_pbl_mod
real(r8), intent(inout) :: t(pcols,pver)      ! temperature at full-model level (k)
real(r8), intent(inout) :: q(pcols,pver)      ! specific humidity at full-model level (kg/kg)
real(r8), intent(inout) :: u(pcols,pver)      ! zonal wind at full-model level (m/s)
real(r8), intent(inout) :: v(pcols,pver)      ! meridional wind at full-model level (m/s)
real(r8), intent(inout) :: pmid(pcols,pver)   ! pressure is full-model level (pa)
real(r8), intent(inout) :: pint(pcols,pver+1) ! pressure at model interfaces (pa)
real(r8), intent(inout) :: pdel(pcols,pver)   ! layer thickness (pa)
real(r8), intent(in   ) :: rpdel(pcols,pver)  ! reciprocal of layer thickness (1/pa)
real(r8), intent(inout) :: ps(pcols)          ! surface pressue (pa)
real(r8), intent(out) :: precl(pcols)         ! precipitation rate (m_water / s)
integer  i,k                         ! longitude, level indices
real(r8) gravit                      ! gravity
real(r8) rair                        ! gas constant for dry air
real(r8) cpair                       ! specific heat of dry air
real(r8) latvap                      ! latent heat of vaporization
real(r8) rh2o                        ! gas constant for water vapor
real(r8) epsilo                      ! ratio of gas constant for dry air to that for vapor
real(r8) zvir                        ! constant for virtual temp. calc. =(rh2o/rair) - 1
real(r8) a                           ! reference earth's radius (m)
real(r8) omega                       ! reference rotation rate of the earth (s^-1)
real(r8) pi                          ! pi
real(r8) tsurf(pcols)                ! sea surface temperature (constant for tropical cyclone)
real(r8) sst_tc                      ! sea surface temperature for tropical cyclone test
real(r8) t0                          ! control temp for calculation of qsat
real(r8) e0                          ! saturation vapor pressure at t0 for calculation of qsat
real(r8) rhow                        ! density of liquid water
real(r8) p0                          ! constant for calculation of potential temperature
real(r8) cd0                         ! constant for calculating cd from smith and vogl 2008
real(r8) cd1                         ! constant for calculating cd from smith and vogl 2008
real(r8) cm                          ! constant for calculating cd from smith and vogl 2008
real(r8) v20                         ! threshold wind speed for calculating cd from smith and vogl 2008
real(r8) c                           ! drag coefficient for sensible heat and evaporation
real(r8) t00                         ! horizontal mean t at surface for moist baro test
real(r8) u0                          ! zonal wind constant for moist baro test
real(r8) latw                        ! halfwidth for  for baro test
real(r8) eta0                        ! center of jets (hybrid) for baro test
real(r8) etav                        ! auxiliary variable for baro test
real(r8) q0                          ! maximum specific humidity for baro test
real(r8) kappa                       ! von karman constant
real(r8) dtdt(pcols,pver)             ! temperature tendency
real(r8) dqdt(pcols,pver)             ! specific humidity tendency
real(r8) dudt(pcols,pver)             ! zonal wind tendency
real(r8) dvdt(pcols,pver)             ! meridional wind tendency
real(r8) tmp                         ! temporary
real(r8) qsat                        ! saturation vapor pressure
real(r8) qsats                       ! saturation vapor pressure of sst
real(r8) wind(pcols)                 ! magnitude of wind
real(r8) cd(pcols)                   ! drag coefficient for momentum
real(r8) km(pcols,pver+1)            ! eddy diffusivity for boundary layer calculations
real(r8) ke(pcols,pver+1)            ! eddy diffusivity for boundary layer calculations
real(r8) rho                         ! density at lower/upper interface
real(r8) za(pcols)                   ! heights at midpoints of first model level
real(r8) zi(pcols,pver+1)            ! heights at model interfaces
real(r8) dlnpint                     ! used for calculation of heights
real(r8) pbltop                      ! top of boundary layer
real(r8) zpbltop                     ! top of boundary layer for george bryan modifcation
real(r8) pblconst                    ! constant for the calculation of the decay of diffusivity
real(r8) ca(pcols,pver)              ! matrix coefficents for pbl scheme
real(r8) cc(pcols,pver)              ! matrix coefficents for pbl scheme
real(r8) ce(pcols,pver+1)            ! matrix coefficents for pbl scheme
real(r8) cam(pcols,pver)             ! matrix coefficents for pbl scheme
real(r8) ccm(pcols,pver)             ! matrix coefficents for pbl scheme
real(r8) cem(pcols,pver+1)           ! matrix coefficents for pbl scheme
real(r8) cfu(pcols,pver+1)           ! matrix coefficents for pbl scheme
real(r8) cfv(pcols,pver+1)           ! matrix coefficents for pbl scheme
real(r8) cft(pcols,pver+1)           ! matrix coefficents for pbl scheme
real(r8) cfq(pcols,pver+1)           ! matrix coefficents for pbl scheme
real(r8) qini(pcols,pver)            ! initial specific humidity
end subroutine simple_physics
end module dcmip2016_simple_physics_mod
module guided_ncar_mod
use icosa
integer,save :: case_wind
real(rstd), parameter :: alpha=0.0 ! tilt of solid-body rotation
real(rstd), parameter :: tau_hadley=daysec, tau = 12*daysec ! 12 days               ! see p. 16
real(rstd), parameter :: w0_deform = 23000*pi/tau, b=0.2, ptop=25494.4  ! see p. 16
real(rstd), parameter :: u0_hadley=40.,w0_hadley=0.15 ,ztop= 12000.
integer, parameter    :: k_hadley=5
subroutine init_guided
end select
end subroutine init_guided
subroutine guided(tt, f_ps, f_theta_rhodz, f_u, f_q)
use icosa
real(rstd), intent(in):: tt
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
real(rstd),pointer :: ue(:,:)
integer :: ind
end subroutine guided
subroutine wind_profile(tt,ue)
use icosa
use disvert_mod
real(rstd),intent(in)  :: tt ! current time
real(rstd),intent(out) :: ue(iim*3*jjm,llm)
real(rstd) :: nx(3),n_norm,velocity(3,llm)
integer :: i,j,n,l
real(rstd) :: pitbytau,kk, pr, zr, u0, u1, v0
subroutine compute_velocity(x,l,velocity)
real(rstd),intent(in)  :: x(3)
integer,intent(in)::l
real(rstd),intent(out) :: velocity(3)
real(rstd) :: e_lat(3), e_lon(3)
real(rstd) :: lon,lat
real(rstd) :: u,v
end select
end subroutine compute_velocity
end subroutine  wind_profile
end module guided_ncar_mod
module dcmip_initial_conditions_test_1_2_3
use prec
real(rstd), parameter ::	        a	= 6371220.0d0,	&	! earth's radius (m)
real(rstd), parameter ::	p0	= 100000.d0		! reference pressure (pa)
subroutine test1_advection_deformation (lon,lat,p,z,zcoords,u,v,w,t,phis,ps,rho,q,q1,q2,q3,q4)
real(rstd), intent(in)  :: lon, &		! longitude (radians)
real(rstd), intent(inout) :: p		! pressure  (pa)
integer,  intent(in) :: zcoords 	! 0 or 1 see below
real(rstd), intent(out) :: u, & 		! zonal wind (m s^-1)
real(rstd), parameter :: 	tau     = 12.d0 * 86400.d0,	&	! period of motion 12 days
real(rstd) :: height							! the height of the model levels
real(rstd) :: ptop							! model top in p
real(rstd) :: sin_tmp, cos_tmp, sin_tmp2, cos_tmp2			! calculate great circle distances
real(rstd) :: d1, d2, r, r2					! for tracer calculations
real(rstd) :: s, bs							! shape function, and parameter
real(rstd) :: lonp							! translational longitude, depends on time
real(rstd) :: ud							! divergent part of u
real(rstd) :: time							! initially set to zero seconds, needs
end subroutine test1_advection_deformation
subroutine test1_advection_hadley (lon,lat,p,z,zcoords,u,v,w,t,phis,ps,rho,q,q1)
real(rstd), intent(in)  :: lon, &		! longitude (radians)
real(rstd), intent(inout) :: p		! pressure  (pa)
integer,  intent(in) :: zcoords 	! 0 or 1 see below
real(rstd), intent(out) :: u, & 		! zonal wind (m s^-1)
real(rstd), parameter :: 	tau     = 1.d0 * 86400.d0,	&	! period of motion 1 day (in s)
real(rstd) :: rho0							! reference density at z=0 m
real(rstd) :: height							! model level heights
real(rstd) :: time							! initially set to zero seconds, needs
end subroutine test1_advection_hadley
subroutine test1_advection_orography (lon,lat,p,z,zcoords,cfv,hybrid_eta,hyam,hybm,gc,u,v,w,t,phis,ps,rho,q,q1,q2,q3,q4)
real(rstd), intent(in)  :: lon, &		! longitude (radians)
logical, intent(in)  :: hybrid_eta      ! flag to indicate whether the hybrid sigma-p (eta) coordinate is used
real(rstd), intent(inout) :: p		! pressure  (pa)
integer,  intent(in) :: zcoords 	! 0 or 1 see below
integer,  intent(in) :: cfv 		! 0, 1 or 2 see below
real(rstd), intent(out) :: u, & 		! zonal wind (m s^-1)
real(rstd), parameter :: 	tau     = 12.d0 * 86400.d0,	&	! period of motion 12 days (s)
real(rstd) :: height							! model level heights (m)
real(rstd) :: r							! great circle distance (radians)
real(rstd) :: rz							! height differences
real(rstd) :: zs							! surface elevation (m)
subroutine test1_advection_orograph_hybrid_eta_velocity(w)
real(rstd), intent(out) ::	w
real(rstd) :: 	press, &		! hyam *p0 + hybm *ps
end subroutine test1_advection_orograph_hybrid_eta_velocity
subroutine test1_advection_orograph_gal_chen_velocity(w)
real(rstd), intent(out) ::	w
real(rstd) :: 	r, &			! great circle distance
end subroutine test1_advection_orograph_gal_chen_velocity
end subroutine test1_advection_orography
subroutine test2_steady_state_mountain (lon,lat,p,z,zcoords,hybrid_eta,hyam,hybm,u,v,w,t,phis,ps,rho,q)
real(rstd), intent(in)  :: lon, &		! longitude (radians)
logical, intent(in)  :: hybrid_eta      ! flag to indicate whether the hybrid sigma-p (eta) coordinate is used
real(rstd), intent(inout) :: p		! pressure  (pa)
integer,  intent(in) :: zcoords 	! 0 or 1 see below
real(rstd), intent(out) :: u, & 		! zonal wind (m s^-1)
real(rstd), parameter :: 	t0      = 300.d0,		&	! temperature (k)
real(rstd) :: height							! model level heights (m)
real(rstd) :: r							! great circle distance (radians)
real(rstd) :: zs							! surface elevation (m)
real(rstd) :: exponent                                               ! exponent: g/(rd * gamma)
real(rstd) :: exponent_rev                                           ! reversed exponent
end subroutine test2_steady_state_mountain
subroutine test2_schaer_mountain (lon,lat,p,z,zcoords,hybrid_eta,hyam,hybm,shear,u,v,w,t,phis,ps,rho,q)
real(rstd), intent(in)  :: lon, &		! longitude (radians)
logical, intent(in)  :: hybrid_eta      ! flag to indicate whether the hybrid sigma-p (eta) coordinate is used
real(rstd), intent(inout) :: p		! pressure  (pa)
integer,  intent(in) :: zcoords, &	! 0 or 1 see below
real(rstd), intent(out) :: u, & 		! zonal wind (m s^-1)
real(rstd), parameter :: 	x       = 500.d0,		&	! reduced earth reduction factor
real(rstd) :: height							! model level heights
real(rstd) :: sin_tmp, cos_tmp					! calculation of great circle distance
real(rstd) :: r							! great circle distance
real(rstd) :: zs							! surface height
real(rstd) :: c							! shear
end subroutine test2_schaer_mountain
subroutine test3_gravity_wave (x,lon,lat,p,z,zcoords,u,v,w,t,phis,ps,rho,q)
real(rstd), intent(in)  :: lon, &	! longitude (radians)
real(rstd), intent(inout) :: p, &	! pressure  (pa)
integer,  intent(in) :: zcoords 	! 0 or 1 see below
real(rstd), intent(out) :: u, & 	! zonal wind (m s^-1)
real(rstd), parameter :: 	 			    	om      = 0.d0,			&	! rotation rate of earth
real(rstd) :: as                                                  ! new radius of small earth
real(rstd) :: height							! model level height
real(rstd) :: sin_tmp, cos_tmp					! calculation of great circle distance
real(rstd) :: r, s							! shape of perturbation
real(rstd) :: ts 							! surface temperature
real(rstd) :: t_mean, t_pert						! mean and pert parts of temperature
real(rstd) :: theta_pert						! pot-temp perturbation
end subroutine test3_gravity_wave
end module dcmip_initial_conditions_test_1_2_3
module dcmip2016_cyclone_mod
real(8), parameter ::                       a     = 6371220.0d0,           & ! reference earth's radius (m)
real(8), parameter ::                 rp         = 282000.d0,  & ! radius for calculation of ps
subroutine tropical_cyclone_test(lon,lat,p,z,zcoords,u,v,t,thetav,phis,ps,rho,q)      bind(c, name = "tropical_cyclone_test")
use iso_c_binding
real(kind=c_double), intent(in) ::                    lon,             &     ! longitude (radians)
real(kind=c_double), intent(inout) ::                 p,               &     ! pressure (pa)
integer(kind=c_int32_t), intent(in) :: zcoords     ! 1 if z coordinates are specified
real(kind=c_double), intent(out) ::                   u,               &     ! zonal wind (m s^-1)
real(8)  :: d1, d2, d, vfac, ufac, height, zhere, gr, f, zn
integer  n
end subroutine tropical_cyclone_test
real(8) function fpif(phere, gr, zhere)
real(8), intent(in) :: phere, gr, zhere
end function fpif
real(8) function fpidfdz(gr, zhere)
real(8), intent(in) :: gr, zhere
end function fpidfdz
end module dcmip2016_cyclone_mod
module dcmip2016_supercell_mod
real(8), parameter ::                       a     = 6371220.0d0,           & ! reference earth's radius (m)
integer(4), parameter ::                    nz         = 30         ,      & ! number of vertical levels in init
real(8), parameter ::                       z1         = 0.0d0      ,      & ! lower sample altitude
real(8), parameter ::                       x          = 120.d0     ,      & ! earth reduction factor
real(8), parameter ::                       us         = 30.d0      ,      & ! maximum zonal wind velocity
real(8), parameter ::                       pert_dtheta = 3.d0         ,   & ! perturbation magnitude
integer(4)                  :: initialized = 0
real(8), dimension(nphi)    :: phicoord
real(8), dimension(nz)      :: zcoord
real(8), dimension(nphi,nz) :: thetavyz
real(8), dimension(nphi,nz) :: exneryz
real(8), dimension(nz)      :: qveq
subroutine supercell_init()      bind(c, name = "supercell_init")
real(8), dimension(nphi,nphi) :: ddphi, intphi
real(8), dimension(nz, nz) :: ddz, intz
real(8), dimension(nphi,nphi) :: ddphibak
real(8), dimension(nphi,nphi) :: svdpu, svdpvt
real(8), dimension(nphi)      :: svdps
real(8), dimension(5*nphi)    :: pwork
real(8), dimension(nz, nz) :: ddzbak
real(8), dimension(nz, nz) :: svdzu, svdzvt
real(8), dimension(nz)     :: svdzs
real(8), dimension(5*nz)   :: zwork
integer(4) :: lwork, info
real(8), dimension(nphi, nz) :: ueq2, dueq2
real(8), dimension(nphi, nz) :: phicoordmat, dztheta, rhs, irhs
real(8), dimension(nz) :: thetaeq
real(8), dimension(nz) :: exnereq, h
real(8) :: exnereqs, p, t, qvs
integer(4) :: i, k, iter
end subroutine supercell_init
subroutine supercell_test(lon,lat,p,z,zcoords,u,v,t,thetav,ps,rho,q,pert)      bind(c, name = "supercell_test")
use iso_c_binding
real(kind=c_double), intent(in)  ::                  lon,        & ! longitude (radians)
real(kind=c_double), intent(inout) ::                  p,            & ! pressure (pa)
integer(kind=c_int32_t), intent(in) :: zcoords     ! 1 if z coordinates are specified
real(kind=c_double), intent(out) ::                  u,          & ! zonal wind (m s^-1)
integer(kind=c_int32_t), intent(in) :: pert  ! 1 if perturbation should be included
real(8) :: nh_lat
end subroutine supercell_test
subroutine supercell_z(lon, lat, z, p, thetav, rho, q, pert)
real(8), intent(in)  ::                  lon,        & ! longitude (radians)
integer, intent(in) :: pert  ! 1 if perturbation should be included
real(8), intent(out) :: p, thetav, rho, q
real(8) :: nh_lat
real(8) :: exner
real(8), dimension(nz) :: varcol
real(8), dimension(nphi) :: fitphi
real(8), dimension(nz)   :: fitz
integer(4) :: k
end subroutine supercell_z
subroutine supercell_p(lon, lat, p, z, thetav, rho, q, pert)
real(8), intent(in)  ::                  lon,        & ! longitude (radians)
integer, intent(in) :: pert  ! 1 if perturbation should be included
real(8), intent(out) :: z, thetav, rho, q
real(8) :: za, zb, zc, pa, pb, pc
integer(4) :: iter
end subroutine supercell_p
real(8) function thermal_perturbation(lon, lat, z)
real(8), intent(in)  ::                  lon,        & ! longitude (radians)
real(8) :: gr
real(8) :: rtheta
end function thermal_perturbation
real(8) function zonal_velocity(z, lat)
real(8), intent(in) :: z, lat
end function zonal_velocity
real(8) function equator_theta(z)
real(8), intent(in) :: z
end function equator_theta
real(8) function equator_relative_humidity(z)
real(8), intent(in) :: z
end function equator_relative_humidity
real(8) function saturation_mixing_ratio(p, t)
real(8), intent(in)  ::                  p,        & ! pressure in pa
end function saturation_mixing_ratio
subroutine lagrangian_polynomial_coeffs(npts, x, coeffs, xs)
integer(4), intent(in) :: npts
real(8), dimension(npts), intent(in) :: x
real(8), dimension(npts), intent(out) :: coeffs
real(8), intent(in) :: xs
integer(4) :: i, j
end subroutine lagrangian_polynomial_coeffs
subroutine diff_lagrangian_polynomial_coeffs(npts, x, coeffs, xs)
integer(4), intent(in) :: npts
real(8), dimension(npts), intent(in) :: x
real(8), dimension(npts), intent(out) :: coeffs
real(8), intent(in) :: xs
integer(4) :: i, j, imatch
real(8) :: coeffsum, differential
end subroutine
end module dcmip2016_supercell_mod
module terminator
real(8), parameter :: cly_constant = 4.e-6_8
real(8), parameter :: pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164_8
real(8), parameter :: half_pi = pi*0.5_8
real(8), parameter :: degrees_to_radians = pi/180.0_8
real(8), parameter :: k1_lat_center =   20.d0*degrees_to_radians
real(8), parameter :: k1_lon_center =  300.d0*degrees_to_radians
subroutine k_vals( lat, lon, k1, k2 )
real(8), intent(in)    :: lat, lon  ! latitude and longitude, radians
real(8), intent(out)   :: k1, k2    ! reaction rates
end subroutine k_vals
subroutine tendency_terminator( lat, lon, cl, cl2, dt, cl_f, cl2_f )
real(8), intent(in)    :: lat, lon  ! latitude and longitude, degrees
real(8), intent(in)    :: cl, cl2   ! molar mixing ratio of cl and cl2
real(8), intent(in)    :: dt        ! size of physics time step
real(8), intent(out)   :: cl_f, cl2_f  ! time rate of change of cl and cl2
real(8) :: r, det, expdt, el ! useful algebaic quantities used in the computation
real(8) :: k1, k2            ! reaction rates
real(8) :: cly               ! quantity that should be conseved
end subroutine tendency_terminator
subroutine initial_value_terminator( lat, lon, cl, cl2 )
real(8), intent(in)  :: lat, lon  ! latitude and longitude, degrees
real(8), intent(out) :: cl, cl2   ! molar mixing ratio of cl and cl2
real(8) :: r, det  ! useful algebraic forms
real(8) :: k1, k2  ! reaction rates
end subroutine initial_value_terminator
end module terminator
module physics_dcmip2016_mod
use icosa
integer,save :: testcase
type(t_field),save,pointer  :: f_precl(:)
real(rstd),save,allocatable :: precl_packed(:)
type(t_field),save,pointer  :: f_q1(:)
type(t_field),save,pointer  :: f_q2(:)
type(t_field),save,pointer  :: f_ps(:)
type(t_field),save,pointer  :: f_rhodz(:)
type(t_field),save,pointer  :: f_q1_col_int(:)
type(t_field),save,pointer  :: f_q2_col_int(:)
integer, parameter :: dry_baroclinic=0
integer, parameter :: moist_baroclinic_full=1
integer, parameter :: moist_baroclinic_kessler=2
integer, parameter :: cyclone=3
integer, parameter :: supercell=4
logical,save :: pbl   !  boundary layer
subroutine init_physics
use physics_interface_mod
use omp_para
integer :: ngrid
end select
end subroutine init_physics
subroutine full_physics
use physics_interface_mod
end subroutine full_physics
subroutine write_physics
use output_field_mod
use physics_interface_mod
use disvert_mod
real(rstd), pointer :: q1(:,:)
real(rstd), pointer :: q2(:,:)
real(rstd), pointer :: ps(:)
real(rstd), pointer :: rhodz(:,:)
real(rstd), pointer :: q1_col_int(:)
real(rstd), pointer :: q2_col_int(:)
end subroutine write_physics
subroutine compute_physics(ngrid,dt_phys,lon, lat, p, pk, temp,u,v,q, dtemp,du,dv,dq, precl)
use icosa
use dcmip2016_simple_physics_mod
use dcmip2016_kessler_physic_mod
use earth_const
use terminator
integer    :: ngrid
real(rstd) :: lat(ngrid)
real(rstd) :: lon(ngrid)
real(rstd) :: ps(ngrid)
real(rstd) :: precl(ngrid)
real(rstd) :: p(ngrid,llm+1)
real(rstd) :: pk(ngrid,llm)
real(rstd) :: temp(ngrid,llm)
real(rstd) :: u(ngrid,llm)
real(rstd) :: v(ngrid,llm)
real(rstd) :: q(ngrid,llm,5)
real(rstd) :: dtemp(ngrid,llm)
real(rstd) :: du(ngrid,llm)
real(rstd) :: dv(ngrid,llm)
real(rstd) :: dq(ngrid,llm,5)
real(rstd) :: pint(ngrid,llm+1)
real(rstd) :: pmid(ngrid,llm)
real(rstd) :: pdel(ngrid,llm)
real(rstd) :: tfi(ngrid,llm)
real(rstd) :: ufi(ngrid,llm)
real(rstd) :: vfi(ngrid,llm)
real(rstd) :: qfi(ngrid,llm,5)
real(rstd)  :: rho(llm), z(llm), theta(llm), qv(llm),qc(llm),qr(llm)
real(rstd)  :: lastz
real(rstd)  :: dcl1,dcl2
integer :: l,ll,ij
real(rstd) :: dt_phys, inv_dt
integer :: simple_physic_testcase
end subroutine compute_physics
end module physics_dcmip2016_mod
module dcmip2016_baroclinic_wave_mod
real(8), parameter ::                       a     = 6371220.0d0,           & ! reference earth's radius (m)
real(8), parameter ::                       t0e        = 310.d0     ,      & ! temperature at equatorial surface (k)
real(8), parameter ::                       pertu0     = 0.5d0      ,      & ! sf perturbation wind velocity (m/s)
real(8), parameter ::                       moistqlat  = 2.d0*pi/9.d0,     & ! humidity latitudinal width
subroutine baroclinic_wave_test(deep,moist,pertt,x,lon,lat,p,z,zcoords,u,v,t,thetav,phis,ps,rho,q)      bind(c, name = "baroclinic_wave_test")
use iso_c_binding
integer(kind=c_int32_t), intent(in)  ::                  deep,       & ! deep (1) or shallow (0) test case
real(kind=c_double), intent(in)  ::                  lon,        & ! longitude (radians)
real(kind=c_double), intent(inout) ::                  p,            & ! pressure (pa)
integer(kind=c_int32_t), intent(in) :: zcoords     ! 1 if z coordinates are specified
real(kind=c_double), intent(out) ::                  u,          & ! zonal wind (m s^-1)
real(8) :: aref, omegaref
real(8) :: t0, consth, constc, scaledz, inttau2, rratio
real(8) :: inttermu, bigu, rcoslat, omegarcoslat
real(8) :: eta
end subroutine baroclinic_wave_test
subroutine evaluate_pressure_temperature(deep, x, lon, lat, z, p, t)
integer, intent(in)  :: deep ! deep (1) or shallow (0) test case
real(8), intent(in)  ::                  x,          & ! earth scaling ratio
real(8), intent(out) ::                  p,          & ! pressure (pa)
real(8) :: aref, omegaref
real(8) :: t0, consta, constb, constc, consth, scaledz
real(8) :: tau1, tau2, inttau1, inttau2
real(8) :: rratio, inttermt
end subroutine evaluate_pressure_temperature
subroutine evaluate_z_temperature(deep, x, lon, lat, p, z, t)
integer, intent(in)  :: deep ! deep (1) or shallow (0) test case
real(8), intent(in)  ::                  x,          & ! earth scaling ratio
real(8), intent(out) ::                  z,          & ! altitude (m)
integer :: ix
real(8) :: z0, z1, z2
real(8) :: p0, p1, p2
end subroutine evaluate_z_temperature
real(8) function evaluate_exponential(lon, lat, z)
real(8), intent(in)  ::                  lon,        & ! longitude (radians)
real(8) :: greatcircler, perttaper
end function evaluate_exponential
real(8) function evaluate_streamfunction(lon, lat, z)
real(8), intent(in)  ::                  lon,        & ! longitude (radians)
real(8) :: greatcircler, perttaper, cospert
end function evaluate_streamfunction
end module dcmip2016_baroclinic_wave_mod
module physics_dcmip_mod
use icosa
integer,save :: testcase
type(t_field),pointer  :: f_precl(:)
real(rstd),allocatable :: precl_packed(:)
subroutine init_physics
use physics_interface_mod
integer :: ngrid
end subroutine init_physics
subroutine full_physics
use physics_interface_mod
end subroutine full_physics
subroutine write_physics
use output_field_mod
use physics_interface_mod
end subroutine write_physics
subroutine compute_physics(ngrid,dt_phys,lat, p,temp,u,v,q, dtemp,du,dv,dq, precl)
use icosa
integer    :: ngrid
real(rstd) :: lat(ngrid)
real(rstd) :: ps(ngrid)
real(rstd) :: precl(ngrid)
real(rstd) :: p(ngrid,llm+1)
real(rstd) :: temp(ngrid,llm)
real(rstd) :: u(ngrid,llm)
real(rstd) :: v(ngrid,llm)
real(rstd) :: q(ngrid,llm)
real(rstd) :: dtemp(ngrid,llm)
real(rstd) :: du(ngrid,llm)
real(rstd) :: dv(ngrid,llm)
real(rstd) :: dq(ngrid,llm)
real(rstd) :: pint(ngrid,llm+1)
real(rstd) :: pmid(ngrid,llm)
real(rstd) :: pdel(ngrid,llm)
real(rstd) :: tfi(ngrid,llm)
real(rstd) :: ufi(ngrid,llm)
real(rstd) :: vfi(ngrid,llm)
real(rstd) :: qfi(ngrid,llm)
integer :: l,ll,ij
real(rstd) :: dt_phys, inv_dt
end subroutine compute_physics
end module physics_dcmip_mod
subroutine simple_physics (pcols, pver, dtime, lat, t, q, u, v, pmid, pint, pdel, rpdel, ps, precl, test)
integer, parameter :: r8 = selected_real_kind(12)
integer, intent(in)  :: pcols        ! set number of atmospheric columns
integer, intent(in)  :: pver         ! set number of model levels
real(r8), intent(in) :: dtime        ! set model physics timestep
real(r8), intent(in) :: lat(pcols)   ! latitude
integer, intent(in)  :: test         ! test number
real(r8), intent(inout) :: t(pcols,pver)      ! temperature at full-model level (k)
real(r8), intent(inout) :: q(pcols,pver)      ! specific humidity at full-model level (kg/kg)
real(r8), intent(inout) :: u(pcols,pver)      ! zonal wind at full-model level (m/s)
real(r8), intent(inout) :: v(pcols,pver)      ! meridional wind at full-model level (m/s)
real(r8), intent(inout) :: pmid(pcols,pver)   ! pressure is full-model level (pa)
real(r8), intent(inout) :: pint(pcols,pver+1) ! pressure at model interfaces (pa)
real(r8), intent(inout) :: pdel(pcols,pver)   ! layer thickness (pa)
real(r8), intent(in) :: rpdel(pcols,pver)  ! reciprocal of layer thickness (1/pa)
real(r8), intent(inout) :: ps(pcols)          ! surface pressue (pa)
real(r8), intent(out) :: precl(pcols)         ! precipitation rate (m_water / s)
integer  i,k                         ! longitude, level indices
real(r8) gravit                      ! gravity
real(r8) rair                        ! gas constant for dry air
real(r8) cpair                       ! specific heat of dry air
real(r8) latvap                      ! latent heat of vaporization
real(r8) rh2o                        ! gas constant for water vapor
real(r8) epsilo                      ! ratio of gas constant for dry air to that for vapor
real(r8) zvir                        ! constant for virtual temp. calc. =(rh2o/rair) - 1
real(r8) a                           ! reference earth's radius (m)
real(r8) omega                       ! reference rotation rate of the earth (s^-1)
real(r8) pi                          ! pi
real(r8) tsurf(pcols)                ! sea surface temperature (constant for tropical cyclone)
real(r8) sst_tc                      ! sea surface temperature for tropical cyclone test
real(r8) t0                          ! control temp for calculation of qsat
real(r8) e0                          ! saturation vapor pressure at t0 for calculation of qsat
real(r8) rhow                        ! density of liquid water
real(r8) p0                          ! constant for calculation of potential temperature
real(r8) cd0                         ! constant for calculating cd from smith and vogl 2008
real(r8) cd1                         ! constant for calculating cd from smith and vogl 2008
real(r8) cm                          ! constant for calculating cd from smith and vogl 2008
real(r8) v20                         ! threshold wind speed for calculating cd from smith and vogl 2008
real(r8) c                           ! drag coefficient for sensible heat and evaporation
real(r8) t00                         ! horizontal mean t at surface for moist baro test
real(r8) u0                          ! zonal wind constant for moist baro test
real(r8) latw                        ! halfwidth for  for baro test
real(r8) eta0                        ! center of jets (hybrid) for baro test
real(r8) etav                        ! auxiliary variable for baro test
real(r8) q0                          ! maximum specific humidity for baro test
real(r8) dtdt(pcols,pver)             ! temperature tendency
real(r8) dqdt(pcols,pver)             ! specific humidity tendency
real(r8) dudt(pcols,pver)             ! zonal wind tendency
real(r8) dvdt(pcols,pver)             ! meridional wind tendency
real(r8) tmp                         ! temporary
real(r8) qsat                        ! saturation vapor pressure
real(r8) qsats                       ! saturation vapor pressure of sst
real(r8) wind(pcols)                 ! magnitude of wind
real(r8) cd(pcols)                   ! drag coefficient for momentum
real(r8) km(pcols,pver+1)            ! eddy diffusivity for boundary layer calculations
real(r8) ke(pcols,pver+1)            ! eddy diffusivity for boundary layer calculations
real(r8) rho                         ! density at lower/upper interface
real(r8) za(pcols)                   ! heights at midpoints of first model level
real(r8) dlnpint                     ! used for calculation of heights
real(r8) pbltop                      ! top of boundary layer
real(r8) pblconst                    ! constant for the calculation of the decay of diffusivity
real(r8) ca(pcols,pver)              ! matrix coefficents for pbl scheme
real(r8) cc(pcols,pver)              ! matrix coefficents for pbl scheme
real(r8) ce(pcols,pver+1)            ! matrix coefficents for pbl scheme
real(r8) cam(pcols,pver)             ! matrix coefficents for pbl scheme
real(r8) ccm(pcols,pver)             ! matrix coefficents for pbl scheme
real(r8) cem(pcols,pver+1)           ! matrix coefficents for pbl scheme
real(r8) cfu(pcols,pver+1)           ! matrix coefficents for pbl scheme
real(r8) cfv(pcols,pver+1)           ! matrix coefficents for pbl scheme
real(r8) cft(pcols,pver+1)           ! matrix coefficents for pbl scheme
real(r8) cfq(pcols,pver+1)           ! matrix coefficents for pbl scheme
real(r8) qini(pcols,pver)            ! initial specific humidity
end subroutine simple_physics
module read_metric_mod
subroutine read_metric
use icosa
use xios_mod
use omp_para
use checksum_mod
type(t_field),pointer,save :: f_xcell(:),f_ycell(:),f_zcell(:)
real(rstd), pointer :: xcell(:), ycell(:), zcell(:)
type(t_domain),pointer :: d
integer :: ind,i,j,n
logical :: read_metric_=.false.
end subroutine read_metric
end module read_metric_mod
module vector
use genmod
function norm(v)
real(rstd)            :: norm
real(rstd),intent(in) :: v(3)
end function norm
function dot_product_3d(v1,v2) result(dot_product)
real(rstd)       :: dot_product
real(rstd),intent(in) :: v1(3)
real(rstd),intent(in) :: v2(3)
end function dot_product_3d
function cross_product(va,vb)
real(rstd)     ::cross_product(3)
real(rstd),intent(in) :: va(3)
real(rstd),intent(in) :: vb(3)
real(rstd) :: v1(3),v2(3)
end function cross_product
subroutine cross_product2(v1,v2,cross_product_res)
real(rstd),intent(out):: cross_product_res(3)
real(rstd),intent(in) :: v1(3), v2(3)
end subroutine cross_product2
function arc(lon,lat, lonc,latc)
real(rstd) :: lon,lat, lonc,latc, arc
end function arc
end module vector
module spherical_geom_mod
use genmod
subroutine lonlat2xyz(lon,lat,xyz)
real(rstd),intent(in) :: lon
real(rstd),intent(in) :: lat
real(rstd),intent(out) :: xyz(3)
end subroutine lonlat2xyz
subroutine xyz2lonlat(xyz,lon,lat)
real(rstd),intent(in) :: xyz(3)
real(rstd),intent(out) :: lon
real(rstd),intent(out) :: lat
real(rstd) :: xyzn(3)
end subroutine xyz2lonlat
subroutine lonlat2xyz_relative(lon,lat,lon0,lat0, xyz)
real(rstd),intent(in) :: lon0, lat0, lon,lat
real(rstd),intent(out) :: xyz(3)
real(rstd) :: xx,yy,zz
end subroutine lonlat2xyz_relative
subroutine xyz2lonlat_relative(xyz,lon0,lat0, lon,lat)
real(rstd),intent(in) :: xyz(3), lon0, lat0
real(rstd),intent(out) :: lon,lat
real(rstd) :: xx,yy,zz
end subroutine xyz2lonlat_relative
subroutine schmidt_transform(xyz,cc, lon0, lat0)
real(rstd),intent(inout) :: xyz(3)
real(rstd), intent(in) :: cc, lon0, lat0  ! stretching factor>0, lon/lat of zoomed area
real(rstd) :: lat,lon,mu
end subroutine schmidt_transform
subroutine dist_cart(a,b,d)
use vector
real(rstd),intent(in)  :: a(3)
real(rstd),intent(in)  :: b(3)
real(rstd),intent(out) :: d
real(rstd)  :: n(3)
end subroutine dist_cart
subroutine dist_lonlat(lona,lata,lonb,latb,d)
real(rstd),intent(in)  :: lona
real(rstd),intent(in)  :: lata
real(rstd),intent(in)  :: lonb
real(rstd),intent(in)  :: latb
real(rstd),intent(out) :: d
end subroutine dist_lonlat
subroutine surf_triangle(a,b,c,surf)
real(rstd),intent(in)  :: a(3)
real(rstd),intent(in)  :: b(3)
real(rstd),intent(in)  :: c(3)
real(rstd),intent(out) :: surf
real(rstd)  :: ab,ac,bc
real(rstd)  :: s,x
end subroutine surf_triangle
subroutine div_arc(a,b,frac,c)
real(rstd),intent(in)  :: a(3)
real(rstd),intent(in)  :: b(3)
real(rstd),intent(in)  :: frac
real(rstd),intent(out)  :: c(3)
real(rstd) :: d
real(rstd) :: m(3,3)
real(rstd) :: xa,xb,xc
real(rstd) :: ya,yb,yc
real(rstd) :: za,zb,zc
end subroutine div_arc
subroutine div_arc_bis(a,b,frac,c)
real(rstd),intent(in)  :: a(3)
real(rstd),intent(in)  :: b(3)
real(rstd),intent(in)  :: frac
real(rstd),intent(out)  :: c(3)
end subroutine div_arc_bis
subroutine circumcenter(a0,b0,c0,center)
use vector
real(rstd), intent(in)  :: a0(3),b0(3),c0(3)
real(rstd), intent(out) :: center(3)
real(rstd)  :: a(3),b(3),c(3), ac(3), ab(3), p1(3), q(3), p2(3)
end subroutine circumcenter
subroutine compute_centroid(points,n,centr)
use vector
integer :: n
real(rstd), intent(in)  :: points(3,n)
real(rstd), intent(out) :: centr(3)
real(rstd) :: p1(3),p2(3),cross(3), cc(3)
real(rstd) :: norm_cross, area
integer :: i,j
end subroutine compute_centroid
end module spherical_geom_mod
module geometry
use field_mod
type t_geometry
type(t_field),pointer :: centroid(:)
type(t_field),pointer :: xyz_i(:)
type(t_field),pointer :: xyz_e(:)
type(t_field),pointer :: xyz_v(:)
type(t_field),pointer :: lon_i(:)
type(t_field),pointer :: lon_e(:)
type(t_field),pointer :: lat_i(:)
type(t_field),pointer :: lat_e(:)
type(t_field),pointer :: ep_e(:)
type(t_field),pointer :: et_e(:)
type(t_field),pointer :: elon_i(:)
type(t_field),pointer :: elat_i(:)
type(t_field),pointer :: elon_e(:)
type(t_field),pointer :: elat_e(:)
type(t_field),pointer :: ai(:)
type(t_field),pointer :: av(:)
type(t_field),pointer :: de(:)
type(t_field),pointer :: le(:)
type(t_field),pointer :: le_de(:) ! le/de, 0. if de=0.
type(t_field),pointer :: riv(:)
type(t_field),pointer :: s1(:)
type(t_field),pointer :: s2(:)
type(t_field),pointer :: riv2(:)
type(t_field),pointer :: ne(:)
type(t_field),pointer :: wee(:)
type(t_field),pointer :: bi(:)
type(t_field),pointer :: fv(:)
end type t_geometry
type(t_geometry),save,target :: geom
real(rstd),pointer :: ai(:)          ! area of a cell
real(rstd),pointer :: centroid(:,:)  ! coordinate of the centroid of the cell
real(rstd),pointer :: xyz_i(:,:)     ! coordinate of the center of the cell (voronoi)
real(rstd),pointer :: xyz_e(:,:)     ! coordinate of a wind point on the cell on a edge
real(rstd),pointer :: xyz_v(:,:)     ! coordinate of a vertex (center of the dual mesh)
real(rstd),pointer :: lon_i(:)       ! longitude of the center of the cell (voronoi)
real(rstd),pointer :: lon_e(:)       ! longitude of a wind point on the cell on a edge
real(rstd),pointer :: lat_i(:)       ! latitude of the center of the cell (voronoi)
real(rstd),pointer :: lat_e(:)       ! latitude of a wind point on the cell on a edge
real(rstd),pointer :: ep_e(:,:)      ! perpendicular unit vector of a edge (outsider)
real(rstd),pointer :: et_e(:,:)      ! tangeantial unit vector of a edge
real(rstd),pointer :: elon_i(:,:)    ! unit longitude vector on the center
real(rstd),pointer :: elat_i(:,:)    ! unit latitude vector on the center
real(rstd),pointer :: elon_e(:,:)    ! unit longitude vector on a wind point
real(rstd),pointer :: elat_e(:,:)    ! unit latitude vector on a wind point
real(rstd),pointer :: av(:)          ! area of dual mesk cell
real(rstd),pointer :: de(:)          ! distance from a neighbour == lenght of an edge of the dual mesh
real(rstd),pointer :: le(:)          ! lenght of a edge
real(rstd),pointer :: le_de(:)       ! le/de
real(rstd),pointer :: s1(:,:)        ! area of sub-triangle
real(rstd),pointer :: s2(:,:)        ! area of sub-tirangle
real(rstd),pointer :: riv(:,:)       ! weight
real(rstd),pointer :: riv2(:,:)      ! weight
integer,pointer    :: ne(:,:)        ! convention for the way on the normal wind on an edge
real(rstd),pointer :: wee(:,:,:)     ! weight
real(rstd),pointer :: bi(:)          ! orographie
real(rstd),pointer :: fv(:)          ! coriolis (evaluted on a vertex)
integer, parameter :: ne_right=1
integer, parameter :: ne_rup=-1
integer, parameter :: ne_lup=1
integer, parameter :: ne_left=-1
integer, parameter :: ne_ldown=1
integer, parameter :: ne_rdown=-1
subroutine allocate_geometry
use field_mod
end subroutine allocate_geometry
subroutine swap_geometry(ind)
use field_mod
integer,intent(in) :: ind
end subroutine swap_geometry
subroutine update_circumcenters
use domain_mod
use dimensions
use spherical_geom_mod
use vector
use transfert_mod
use omp_para
real(rstd) :: x1(3),x2(3)
integer :: ind,i,j,n,k
type(t_message),save :: message0, message1
logical, save :: first=.true.
end subroutine update_circumcenters
subroutine remap_schmidt_loc
use spherical_geom_mod
use getin_mod
use omp_para
use domain_mod
use dimensions
integer :: ind,i,j,n
real(rstd) :: schmidt_factor, schmidt_lon, schmidt_lat
logical :: read_metric=.false.
end subroutine remap_schmidt_loc
subroutine optimize_geometry
use metric
use spherical_geom_mod
use domain_mod
use dimensions
use transfert_mod
use vector
use getin_mod
use omp_para
use checksum_mod
integer :: nb_it=0
type(t_domain),pointer :: d
integer :: ind,it,i,j,n
real(rstd) :: vect(3,6)
real(rstd) :: centr(3)
real(rstd) :: sum
logical    :: check
logical :: read_metric=.false.
end subroutine optimize_geometry
subroutine update_domain
use omp_para
use dimensions
use domain_mod
use transfert_mod
integer :: ind,i,j,k,n
type(t_domain),pointer :: d
type(t_field),pointer,save :: xyz_glo(:), xyz_loc(:), vertex_glo(:), vertex_loc(:)
real(rstd), pointer :: xyz(:,:), vertex(:,:)
end subroutine update_domain
subroutine set_geometry
use metric
use vector
use spherical_geom_mod
use domain_mod
use dimensions
use transfert_mod
use getin_mod
use omp_para
use checksum_mod
real(rstd) :: surf(6)
real(rstd) :: surf_v(6)
real(rstd) :: vect(3,6)
real(rstd) :: centr(3)
real(rstd) :: vet(3),vep(3)
integer :: ind,i,j,k,n
type(t_domain),pointer :: d
real(rstd) ::  s12
real(rstd) :: w(6)
real(rstd) :: lon,lat
integer :: ii_glo,jj_glo
end subroutine set_geometry
subroutine compute_wee(n,pos,w)
integer,intent(in) :: n
integer,intent(in) :: pos
real(rstd),intent(out) ::w(6)
real(rstd) :: ne_(0:5)
real(rstd) :: riv_(6)
integer    :: k
end subroutine compute_wee
subroutine compute_geometry
end subroutine compute_geometry
end module geometry
module metric
use genmod
use grid_param
use domain_param
type t_cell_glo
integer :: neighbour(0:5)
integer :: edge(0:5)
integer :: vertex(0:5)
integer :: assign_face
integer :: assign_i
integer :: assign_j
integer :: assign_domain
real(rstd) :: xyz(3)
end type t_cell_glo
type t_vertex_glo
real(rstd) :: xyz(3)
integer    :: neighbour(0:5)
integer    :: ne(0:5)
integer    :: ind
integer    :: delta
end type t_vertex_glo
type t_edge_glo
integer :: e1
integer :: e2
integer :: assign_domain
integer :: assign_i
integer :: assign_j
integer :: assign_pos
integer :: assign_delta
end type t_edge_glo
type t_vertices_glo
integer :: assign_domain
integer :: assign_i
integer :: assign_j
integer :: assign_pos
integer :: assign_delta
end type t_vertices_glo
type(t_vertex_glo),allocatable,save :: vertex_glo(:,:,:)
type(t_cell_glo),allocatable,save :: cell_glo(:)
type(t_edge_glo),allocatable,save :: edge_glo(:)
type(t_vertices_glo),allocatable,save :: vertices_glo(:)
integer :: ncell_glo
integer,allocatable,save :: tab_index(:,:,:)
integer,parameter :: right=1
integer,parameter :: rup=2
integer,parameter :: lup=3
integer,parameter :: left=4
integer,parameter :: ldown=5
integer,parameter :: rdown=6
integer,parameter :: vrup=1
integer,parameter :: vup=2
integer,parameter :: vlup=3
integer,parameter :: vldown=4
integer,parameter :: vdown=5
integer,parameter :: vrdown=6
subroutine remap_schmidt_glo ! fixme : not called any more
use spherical_geom_mod
use getin_mod
integer :: nf,i,j
real(rstd) :: schmidt_factor, schmidt_lon, schmidt_lat
end subroutine remap_schmidt_glo
subroutine allocate_metric
integer :: ind
end subroutine allocate_metric
subroutine compute_face
use spherical_geom_mod
real(rstd) :: len_edge
real(rstd) :: rot=0.
integer :: nf,i,j
real(rstd),dimension(3) :: p1
real(rstd) :: d1,d2,d3
end subroutine compute_face
subroutine compute_face_projection
use spherical_geom_mod
real(rstd) :: len_edge
real(rstd) :: rot=0.
integer :: nf,i,j
end subroutine compute_face_projection
subroutine compute_extended_face_bis
integer :: nf
integer :: i,j
integer :: delta
integer :: ind
integer :: k,ng
subroutine set_neighbour(i,j,nf,neighbour)
integer :: i,j,nf,neighbour
integer :: in,jn
integer :: k,ng
integer :: delta
integer :: ind,ind2
end select
end subroutine set_neighbour
end subroutine compute_extended_face_bis
subroutine compute_extended_face
integer :: nf,nf2
integer :: ind,ind2
integer :: i,j,h
end subroutine compute_extended_face
subroutine set_index
integer :: delta
integer :: n1,n2,i
end subroutine set_index
subroutine set_cell
integer :: ind,ind2
integer :: nf,nf2,nfm1,nfp1
integer :: i,j
end subroutine set_cell
subroutine set_cell_edge
integer :: ind,k,ind2,ng,ne
end subroutine  set_cell_edge
subroutine set_cell_vertex
integer :: k,k2
integer :: ind,ind1,ind2
integer :: ng1,ng2
integer :: ne
end subroutine set_cell_vertex
subroutine set_vertex_edge
integer :: nf
integer :: i,j
integer :: ind,ind2
integer :: ne
integer :: k,l
end subroutine set_vertex_edge
subroutine compute_metric
end subroutine compute_metric
end module metric
module getin_mod
interface getin
module procedure getin_c , getin_l, getin_i, getin_r
end interface getin
subroutine getin_c(name,value)
use ioipsl, only : getin_=>getin
use transfert_omp_mod
use omp_para
use mpipara
end subroutine getin_c
subroutine getin_l(name,value)
use ioipsl, only : getin_=>getin
use transfert_omp_mod
use omp_para
use mpipara
logical          :: value
end subroutine getin_l
subroutine getin_i(name,value)
use ioipsl, only : getin_=>getin
use transfert_omp_mod
use omp_para
use mpipara
integer          :: value
end subroutine getin_i
subroutine getin_r(name,value)
use ioipsl, only : getin_=>getin
use omp_para
use mpipara
use transfert_omp_mod
real             :: value
end subroutine getin_r
end module getin_mod
module earth_const
use prec
use math_const
real(rstd),save :: radius=6.37122e6
real(rstd),save :: g=9.80616
real(rstd),parameter :: daysec=86400
real(rstd),save :: omega=7.292e-5
real(rstd),save :: kappa=0.2857143
real(rstd),save :: cpp=1004.70885
real(rstd),save :: cppv=1860.
real(rstd),save :: rv=461.5
real(rstd),save :: treff=273.
real(rstd),save :: preff=101325.
real(rstd),save :: pa=50000. ! default value set to preff/2 by disvert_std
real(rstd),save :: scale_height=8000. ! atmospheric scale height (m)
real(rstd),save :: scale_factor=1.
real(rstd),save :: gas_constant = 8.3144621
real(rstd),save :: mu                 ! molar mass of the atmosphere
integer, parameter,public :: thermo_none=-99, thermo_theta=1, thermo_entropy=2,         thermo_moist=3, thermo_boussinesq=4, thermo_dry=10, thermo_fake_moist=11, thermo_moist_debug=100
integer, public :: caldyn_thermo, physics_thermo
logical, save :: boussinesq, hydrostatic
logical :: dysl, dysl_geopot, dysl_pvort_only, dysl_caldyn_fast, dysl_caldyn_coriolis, dysl_slow_hydro
subroutine init_earth_const
use getin_mod
end subroutine init_earth_const
end module earth_const
module profiling_mod
use omp_para, only : omp_size, omp_rank
logical, parameter :: check_accuracy = .true.
integer, parameter :: max_id=20, max_depth=10
integer :: nb_id ! number of timers
integer :: id_profile
integer, allocatable :: depth(:)!(omp_size) ! number of current nested timers
integer, allocatable :: current_id(:,:)!(omp_size, max_depth) ! current nested timer ids
real, allocatable :: chrono(:,:)!(omp_size, max_depth) ! last timer start time
real, allocatable :: elapsed(:,:)!(omp_size, max_id) ! cumulative time for each timer
subroutine init_profiling
use omp_para, only : get_omp_size
integer :: omp_size
end subroutine init_profiling
subroutine reset_profiling
use abort_mod
end subroutine
subroutine register_id(thename, id)
use abort_mod
integer, intent(out) :: id
end subroutine register_id
function get_elapsed(start)
integer(kind=8) :: count, count_rate
real :: start,get_elapsed
end function get_elapsed
subroutine enter_profile(id)
integer, intent(in) :: id
end subroutine enter_profile
subroutine exit_profile(id)
use abort_mod
integer, intent(in) :: id
integer :: parent_id
real :: my_elapsed
end subroutine exit_profile
subroutine print_profile
use mpi_mod
use mpipara
use omp_para
integer :: i
real :: mean_total, min_total, max_total, mean_total_local, min_total_local, max_total_local
real :: omp_mean_time_local, omp_min_time_local, omp_max_time_local
real :: mean_time, max_process, min_process, percent
function inbalance( mean, min, max )
real :: mean, min, max
real :: inbalance
end function
end subroutine print_profile
end module profiling_mod
module trace
integer,save :: markid
subroutine init_trace
end subroutine init_trace
subroutine trace_on
end subroutine trace_on
subroutine trace_off
end subroutine trace_off
subroutine trace_start(name)
end subroutine trace_start
subroutine trace_end(name)
end subroutine trace_end
subroutine trace_start2(name)
end subroutine trace_start2
subroutine trace_end2(name)
end subroutine trace_end2
subroutine marker(name)
end subroutine marker
end module trace
module abort_mod
subroutine dynamico_abort( message )
use mpi_mod
integer :: ierr
end subroutine
subroutine abort_acc( message )
use mpi_mod
end subroutine
end module
module dimensions
integer,save :: iim
integer,save :: jjm
integer,save :: ii_begin
integer,save :: jj_begin
integer,save :: ii_end
integer,save :: jj_end
integer,save :: ii_nb
integer,save :: jj_nb
integer,save :: ij_begin
integer,save :: ij_end
integer,save :: ij_begin_ext
integer,save :: ij_end_ext
integer,save :: t_right
integer,save :: t_rup
integer,save :: t_lup
integer,save :: t_left
integer,save :: t_ldown
integer,save :: t_rdown
integer,save :: u_right
integer,save :: u_rup
integer,save :: u_lup
integer,save :: u_left
integer,save :: u_ldown
integer,save :: u_rdown
integer,save :: z_rup
integer,save :: z_up
integer,save :: z_lup
integer,save :: z_ldown
integer,save :: z_down
integer,save :: z_rdown
integer,save :: t_pos(6)
integer,save :: u_pos(6)
integer,save :: z_pos(6)
subroutine swap_dimensions(ind)
use domain_mod
integer,intent(in) :: ind
type(t_domain),pointer :: d
end subroutine swap_dimensions
end module dimensions
module math_const
use prec
real(rstd),parameter :: pi=acos(-1._rstd)
end module math_const
module prec
integer, parameter :: i4=selected_int_kind(10)
integer, parameter :: i8=selected_int_kind(18)
integer, parameter :: r4=selected_real_kind(7)
integer, parameter :: r8=selected_real_kind(15)
integer, parameter :: c4=r4
integer, parameter :: c8=r8
integer, parameter :: istd=i4
integer, parameter :: rstd=r8
integer, parameter :: cstd=c8
end module prec
module grid_param
integer  :: iim_glo=40
integer  :: jjm_glo
integer,parameter  :: nb_face=10
integer  :: llm=19
integer  :: nqtot ! number of tracers handled by advection scheme
integer  :: nqdyn ! number of dynamical tracers : 1 if dry, more if moist
subroutine init_grid_param(is_mpi_root)
use ioipsl
logical :: is_mpi_root
end subroutine  init_grid_param
end module grid_param
module field_mod
use genmod
integer,parameter :: field_t=1
integer,parameter :: field_u=2
integer,parameter :: field_z=3
integer,parameter :: type_integer=1
integer,parameter :: type_real=2
integer,parameter :: type_logical=3
type t_field
real(rstd),pointer, contiguous :: rval2d(:) => null()
real(rstd),pointer, contiguous :: rval3d(:,:) => null()
real(rstd),pointer, contiguous :: rval4d(:,:,:) => null()
integer,pointer :: ival2d(:)
integer,pointer :: ival3d(:,:)
integer,pointer :: ival4d(:,:,:)
logical,pointer :: lval2d(:)
logical,pointer :: lval3d(:,:)
logical,pointer :: lval4d(:,:,:)
integer :: ndim
integer :: field_type
integer :: data_type
integer :: dim3
integer :: dim4
logical :: ondevice !< flag if field is allocated on device as well
end type t_field
interface get_val
module procedure getval_r2d,getval_r3d,getval_r4d,                       getval_i2d,getval_i3d,getval_i4d,                       getval_l2d,getval_l3d,getval_l4d
end interface
interface assignment(=)
module procedure getval_r2d,getval_r3d,getval_r4d,                       getval_i2d,getval_i3d,getval_i4d,                       getval_l2d,getval_l3d,getval_l4d
end interface
subroutine allocate_field(field,field_type,data_type,dim1,dim2,name,ondevice)
use domain_mod
use omp_para
type(t_field),pointer :: field(:)
integer,intent(in) :: field_type
integer,intent(in) :: data_type
integer,optional :: dim1,dim2
logical, intent(in), optional :: ondevice
end subroutine allocate_field
subroutine allocate_fields(nfield,field,field_type,data_type,dim1,dim2,name, ondevice)
use domain_mod
use omp_para
integer,intent(in) :: nfield
type(t_field),pointer :: field(:,:)
integer,intent(in) :: field_type
integer,intent(in) :: data_type
integer,optional :: dim1,dim2
logical, intent(in), optional :: ondevice
integer :: i
end subroutine allocate_fields
subroutine allocate_field_(field,field_type,data_type,dim1,dim2,name,ondevice)
use domain_mod
use omp_para
type(t_field) :: field(:)
integer,intent(in) :: field_type
integer,intent(in) :: data_type
integer,optional :: dim1,dim2
logical, intent(in), optional :: ondevice
integer :: ind
integer :: ii_size,jj_size
end subroutine allocate_field_
subroutine allocate_field_glo(field,field_type,data_type,dim1,dim2,name)
use domain_mod
type(t_field),pointer :: field(:)
integer,intent(in) :: field_type
integer,intent(in) :: data_type
integer,optional :: dim1,dim2
integer :: ind
integer :: ii_size,jj_size
end subroutine allocate_field_glo
subroutine deallocate_field(field)
use domain_mod
use omp_para
type(t_field),pointer :: field(:)
end subroutine deallocate_field
subroutine deallocate_fields(field)
use domain_mod
use omp_para
type(t_field),pointer :: field(:,:)
integer :: i
end subroutine deallocate_fields
subroutine deallocate_field_(field)
use domain_mod
use omp_para
type(t_field) :: field(:)
integer :: data_type
integer :: ind
end subroutine deallocate_field_
subroutine deallocate_field_glo(field)
use domain_mod
type(t_field),pointer :: field(:)
integer :: data_type
integer :: ind
end subroutine deallocate_field_glo
subroutine extract_slice(field_in, field_out, l)
use domain_mod
use omp_para
type(t_field) :: field_in(:)
type(t_field) :: field_out(:)
integer,intent(in) :: l
integer :: ind
integer :: data_type
end  subroutine extract_slice
subroutine insert_slice(field_in, field_out, l)
use domain_mod
use omp_para
type(t_field) :: field_in(:)
type(t_field) :: field_out(:)
integer,intent(in) :: l
integer :: ind
integer :: data_type
end subroutine insert_slice
subroutine getval_r2d(field_pt,field)
real(rstd),pointer,intent(inout) :: field_pt(:)
type(t_field),intent(in) :: field
end subroutine  getval_r2d
subroutine getval_r3d(field_pt,field)
real(rstd),pointer,intent(inout) :: field_pt(:,:)
type(t_field),intent(in) :: field
end subroutine  getval_r3d
subroutine getval_r4d(field_pt,field)
real(rstd),pointer,intent(inout) :: field_pt(:,:,:)
type(t_field),intent(in) :: field
end subroutine  getval_r4d
subroutine getval_i2d(field_pt,field)
integer,pointer,intent(inout) :: field_pt(:)
type(t_field),intent(in) :: field
end subroutine  getval_i2d
subroutine getval_i3d(field_pt,field)
integer,pointer,intent(inout) :: field_pt(:,:)
type(t_field),intent(in) :: field
end subroutine  getval_i3d
subroutine getval_i4d(field_pt,field)
integer,pointer,intent(inout) :: field_pt(:,:,:)
type(t_field),intent(in) :: field
end subroutine  getval_i4d
subroutine getval_l2d(field_pt,field)
logical,pointer,intent(inout) :: field_pt(:)
type(t_field),intent(in) :: field
end subroutine  getval_l2d
subroutine getval_l3d(field_pt,field)
logical,pointer,intent(inout) :: field_pt(:,:)
type(t_field),intent(in) :: field
end subroutine  getval_l3d
subroutine getval_l4d(field_pt,field)
logical,pointer,intent(inout) :: field_pt(:,:,:)
type(t_field),intent(in) :: field
end subroutine  getval_l4d
subroutine update_device_field(field)
use domain_mod
use omp_para
type(t_field) :: field(:)
integer :: ind
end subroutine update_device_field
subroutine update_host_field(field)
use domain_mod
use omp_para
type(t_field) :: field(:)
integer :: ind
end subroutine update_host_field
subroutine create_device_field(field)
type(t_field) :: field
end subroutine create_device_field
end module field_mod
module genmod
use prec
use math_const
use earth_const
end module genmod
module dimphys_mod
use icosa
integer::nsoilmx=10,offset
integer::ngridmx,nlayermx
logical::callrad,calldifv,calladj,callcond,callsoil
logical::season,diurnal,lverbose
integer:: iradia
real:: period_sort,timeperi
real:: aphelie,periheli,year_day,peri_day,obliquit
real::e_elips,p_elips,unitastr
real:: coefvis,coefir
real,allocatable:: albedo(:),emissiv(:),inertie(:)
real,allocatable:: tsurf(:),tsoil(:,:)
real,allocatable:: z0(:),rnatur(:)
real,allocatable:: dtrad(:,:) ,fluxrad(:)
real,allocatable:: capcal(:)  ,fluxgrd(:)
real,allocatable:: q2(:,:),q2l(:,:)
end module dimphys_mod
module physics_mod
use icosa
use field_mod
use physics_interface_mod
use omp_para
integer, parameter :: phys_none=0, phys_hs94=1, phys_dcmip=2, phys_lmdz_generic=3, phys_lb2012=4, phys_external=5,                         phys_dcmip2016=6
integer :: phys_type
type(t_field),pointer,save :: f_dulon(:), f_dulat(:)
type(t_field),pointer,save :: f_ulon(:), f_ulat(:)
type(t_field),pointer,save :: f_p(:), f_pk(:)
type(t_field),pointer,save :: f_temp(:)
type(t_field),pointer,save :: f_du_phys(:)
type(t_message),save :: req_theta0, req_ue0, req_q0
subroutine init_physics
use mpipara
use abort_mod
use etat0_mod
use physics_dcmip_mod, only : init_physics_dcmip=>init_physics
use physics_dcmip2016_mod, only : init_physics_dcmip2016=>init_physics
use etat0_venus_mod, only : init_phys_venus=>init_physics
use physics_lmdz_generic_mod, only : init_physics_lmdz_generic=>init_physics
use physics_external_mod, only : init_physics_external=>init_physics
end select
end subroutine init_physics
subroutine zero_du_phys()
use abort_mod
real(rstd), dimension(:,:), pointer :: du
integer :: ind
end subroutine zero_du_phys
subroutine add_du_phys(coef, f_u)
real(rstd), intent(in) :: coef  ! -1 before physics, +1 after physics
type(t_field),pointer :: f_u(:) ! velocity field before/after call to physics
real(rstd), dimension(:,:), pointer :: u, du
integer :: ind
end subroutine add_du_phys
subroutine physics(it,f_phis, f_ps, f_theta_rhodz, f_ue, f_wflux, f_q)
use physics_lmdz_generic_mod, only : physics_lmdz_generic => physics
use physics_external_mod, only : physics_external => physics
use physics_dcmip_mod, only : write_physics_dcmip => write_physics
use physics_dcmip2016_mod, only : write_physics_dcmip2016 => write_physics
use etat0_heldsz_mod
use etat0_venus_mod, only : phys_venus => physics
use abort_mod
integer, intent(in)   :: it
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_ue(:)
type(t_field),pointer :: f_wflux(:)
type(t_field),pointer :: f_q(:)
logical,save :: first=.true.
end select
end select
end subroutine physics
subroutine write_physics_tendencies
use observable_mod, only : f_buf_ulon, f_buf_ulat
use wind_mod
use output_field_mod
end subroutine write_physics_tendencies
subroutine physics_column(it, f_phis, f_ps, f_theta_rhodz, f_ue, f_q)
use physics_dcmip_mod, only : full_physics_dcmip => full_physics
use physics_dcmip2016_mod, only : full_physics_dcmip2016 => full_physics
use theta2theta_rhodz_mod
use mpipara
use checksum_mod
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_ue(:)
type(t_field),pointer :: f_q(:)
real(rstd),pointer :: phis(:)
real(rstd),pointer :: ps(:)
real(rstd),pointer :: temp(:,:)
real(rstd),pointer :: ue(:,:)
real(rstd),pointer :: dulon(:,:)
real(rstd),pointer :: dulat(:,:)
real(rstd),pointer :: q(:,:,:)
real(rstd),pointer :: p(:,:)
real(rstd),pointer :: pk(:,:)
real(rstd),pointer :: ulon(:,:)
real(rstd),pointer :: ulat(:,:)
integer :: it, ind
end select
end subroutine physics_column
subroutine pack_physics(info, phis, ps, temp, ue, q, p, pk, ulon, ulat )
use wind_mod
use pression_mod
use theta2theta_rhodz_mod
use exner_mod
type(t_pack_info) :: info
real(rstd) :: phis(iim*jjm)
real(rstd) :: ps(iim*jjm)
real(rstd) :: temp(iim*jjm,llm)
real(rstd) :: pks(iim*jjm)
real(rstd) :: pk(iim*jjm,llm)
real(rstd) :: ue(3*iim*jjm,llm)
real(rstd) :: q(iim*jjm,llm,nqtot)
real(rstd) :: p(iim*jjm,llm+1)
real(rstd) :: uc(iim*jjm,llm,3)
real(rstd) :: ulon(iim*jjm,llm)
real(rstd) :: ulat(iim*jjm,llm)
end subroutine pack_physics
subroutine unpack_physics(info, ps,temp, q, dulon, dulat)
use theta2theta_rhodz_mod
type(t_pack_info) :: info
real(rstd) :: ps(iim*jjm)
real(rstd) :: temp(iim*jjm,llm)
real(rstd) :: q(iim*jjm,llm,nqtot)
real(rstd) :: dulon(iim*jjm,llm)
real(rstd) :: dulat(iim*jjm,llm)
real(rstd) :: dq(iim*jjm,llm,nqtot)
real(rstd) :: dtemp(iim*jjm,llm)
end subroutine unpack_physics
subroutine compute_update_velocity(dulon, dulat, ue)
use wind_mod
real(rstd) :: dulon(iim*jjm,llm)
real(rstd) :: dulat(iim*jjm,llm)
real(rstd) :: ue(3*iim*jjm,llm)
real(rstd) :: duc(iim*jjm,llm,3)
real(rstd) :: dt2, due
integer :: i,j,ij,l
end subroutine compute_update_velocity
end module physics_mod
module physics_lmdz_generic_mod
use field_mod
use transfert_mod
integer,save :: nbp_phys
type(t_message) :: req_u
type(t_field),pointer :: f_p(:)
type(t_field),pointer :: f_pks(:)
type(t_field),pointer :: f_pk(:)
type(t_field),pointer :: f_p_layer(:)
type(t_field),pointer :: f_theta(:)
type(t_field),pointer :: f_phi(:)
type(t_field),pointer :: f_temp(:)
type(t_field),pointer :: f_ulon(:)
type(t_field),pointer :: f_ulat(:)
type(t_field),pointer :: f_dulon(:)
type(t_field),pointer :: f_dulat(:)
type(t_field),pointer :: f_dtemp(:)
type(t_field),pointer :: f_dq(:)
type(t_field),pointer :: f_dps(:)
type(t_field),pointer :: f_duc(:)
integer :: start_clock
integer :: stop_clock
integer :: count_clock=0
real :: start_day
real :: day_length
real :: year_length
integer,allocatable,save :: domain_offset(:)
subroutine init_physics
use icosa
use domain_mod
use dimensions
use mpi_mod
use mpipara
use disvert_mod
use xios_mod
integer  :: distrib(0:mpi_size-1)
integer  :: ind,i,j,ij,pos
real(rstd),allocatable :: latfi(:)
real(rstd),allocatable :: lonfi(:)
real(rstd),allocatable :: airefi(:)
real(rstd),allocatable :: bounds_latfi(:,:)
real(rstd),allocatable :: bounds_lonfi(:,:)
end subroutine init_physics
subroutine physics(it,f_phis, f_ps, f_theta_rhodz, f_u, f_wflux, f_q)
use icosa
use time_mod
use disvert_mod
use transfert_mod
use mpipara
use xios_mod
use trace
integer,intent(in)    :: it
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_wflux(:)
type(t_field),pointer :: f_q(:)
real(rstd),pointer :: phis(:)
real(rstd),pointer :: ps(:)
real(rstd),pointer :: theta_rhodz(:,:)
real(rstd),pointer :: u(:,:)
real(rstd),pointer :: wflux(:,:)
real(rstd),pointer :: q(:,:,:)
real(rstd),pointer :: p(:,:)
real(rstd),pointer :: pks(:)
real(rstd),pointer :: pk(:,:)
real(rstd),pointer :: p_layer(:,:)
real(rstd),pointer :: theta(:,:)
real(rstd),pointer :: phi(:,:)
real(rstd),pointer :: temp(:,:)
real(rstd),pointer :: ulon(:,:)
real(rstd),pointer :: ulat(:,:)
real(rstd),pointer :: dulon(:,:)
real(rstd),pointer :: dulat(:,:)
real(rstd),pointer :: dtemp(:,:)
real(rstd),pointer :: dq(:,:,:)
real(rstd),pointer :: dps(:)
real(rstd),pointer :: duc(:,:,:)
integer :: ind
real(rstd),allocatable,save :: ps_phy(:)
real(rstd),allocatable,save :: p_phy(:,:)
real(rstd),allocatable,save :: p_layer_phy(:,:)
real(rstd),allocatable,save :: temp_phy(:,:)
real(rstd),allocatable,save :: phis_phy(:)
real(rstd),allocatable,save :: phi_phy(:,:)
real(rstd),allocatable,save :: ulon_phy(:,:)
real(rstd),allocatable,save :: ulat_phy(:,:)
real(rstd),allocatable,save :: q_phy(:,:,:)
real(rstd),allocatable,save :: wflux_phy(:,:)
real(rstd),allocatable,save :: dulon_phy(:,:)
real(rstd),allocatable,save :: dulat_phy(:,:)
real(rstd),allocatable,save :: dtemp_phy(:,:)
real(rstd),allocatable,save :: dq_phy(:,:,:)
real(rstd),allocatable,save :: dps_phy(:)
real(rstd) :: dtphy
real(rstd) :: time
real(rstd) :: day
real(rstd) :: real_time
integer    :: offset
logical :: lafin=.false.
logical,save :: first=.true.
subroutine grid_physics_to_icosa
use theta2theta_rhodz_mod
use omp_para
integer :: i,j,ij,l,iq
end subroutine grid_physics_to_icosa
subroutine grid_icosa_to_physics
use pression_mod
use exner_mod
use theta2theta_rhodz_mod
use geopotential_mod
use wind_mod
use omp_para
real(rstd) :: uc(3)
integer :: i,j,ij,l
end subroutine grid_icosa_to_physics
end subroutine physics
end module physics_lmdz_generic_mod
module physics_external_mod
use field_mod
integer,save :: it
type(t_field),pointer,save :: f_phis(:)
type(t_field),pointer,save :: f_ps(:)
type(t_field),pointer,save :: f_theta_rhodz(:)
type(t_field),pointer,save :: f_u(:)
type(t_field),pointer,save :: f_wflux(:)
type(t_field),pointer,save :: f_q(:)
type(t_field),pointer,save :: f_theta_rhodz0(:)
type(t_field),pointer,save :: f_u0(:)
type(t_field),pointer,save :: f_q0(:)
type(t_field),pointer,save :: f_dtheta_rhodz(:)
type(t_field),pointer,save :: f_du(:)
type(t_field),pointer,save :: f_dq(:)
type(t_field),pointer,save :: f_rhodz(:)
type(t_field),pointer,save :: f_rhodz0(:)
logical,save :: phys_smooth_tendency
subroutine init_physics
use icosa
end subroutine init_physics
subroutine physics(it_,f_phis_, f_ps_, f_theta_rhodz_, f_u_, f_wflux_, f_q_)
use icosa
use field_mod
use mpipara
use omp_para
use domain_mod
use time_mod
use disvert_mod
integer,intent(in)    :: it_
type(t_field),pointer :: f_phis_(:)
type(t_field),pointer :: f_ps_(:)
type(t_field),pointer :: f_theta_rhodz_(:)
type(t_field),pointer :: f_u_(:)
type(t_field),pointer :: f_wflux_(:)
type(t_field),pointer :: f_q_(:)
real(rstd),pointer    :: theta_rhodz(:,:,:), theta_rhodz0(:,:,:), dtheta_rhodz(:,:,:)
real(rstd),pointer    :: u(:,:), u0(:,:), du(:,:)
real(rstd),pointer    :: q(:,:,:),q0(:,:,:),dq(:,:,:)
real(rstd),pointer    :: ps(:)
real(rstd),pointer    :: rhodz(:,:)
integer :: ind, iq
end subroutine physics
end module physics_external_mod
module physics_interface_mod
use prec
type t_physics_inout
integer :: ngrid
real(rstd) :: dt_phys
real(rstd), dimension(:), pointer :: ai, lon, lat, phis
real(rstd), dimension(:,:), pointer :: p, pk, temp, ulon, ulat
real(rstd), dimension(:,:,:), pointer :: q
real(rstd), dimension(:,:), pointer :: dtemp, dulon, dulat
real(rstd), dimension(:,:,:), pointer :: dq
end type t_physics_inout
type(t_physics_inout), save :: physics_inout
type t_pack_info
integer :: ngrid, & ! number of non-halo points in that domain
integer, allocatable :: n(:), ij(:), k(:)
end type t_pack_info
type(t_pack_info), allocatable, save :: pack_info(:)
interface pack_field
module procedure pack_2d
module procedure pack_3d
module procedure pack_4d
end interface pack_field
interface unpack_field
module procedure unpack_2d
module procedure unpack_3d
module procedure unpack_4d
end interface unpack_field
interface pack_domain
module procedure pack_domain_2d
module procedure pack_domain_3d
module procedure pack_domain_4d
end interface pack_domain
interface unpack_domain
module procedure unpack_domain_2d
module procedure unpack_domain_3d
module procedure unpack_domain_4d
end interface unpack_domain
subroutine init_pack_before
use icosa
integer :: ind, offset
end subroutine init_pack_before
subroutine count_segments(own, info)
use icosa
logical, dimension(:,:) :: own
type(t_pack_info) :: info
integer, dimension(jjm) :: n
integer :: ngrid, nseg, i, j, jj, k
integer, parameter :: method=4
end select
end subroutine count_segments
subroutine init_pack_after
use icosa
integer :: ind
end subroutine init_pack_after
subroutine pack_2d(f_2d, packed)
use icosa
type(t_field),pointer :: f_2d(:)
real(rstd)            :: packed(:)
real(rstd), pointer   :: loc(:)
integer :: ind
end subroutine pack_2d
subroutine unpack_2d(f_2d, packed)
use icosa
type(t_field),pointer :: f_2d(:)
real(rstd)            :: packed(:)
real(rstd), pointer   :: loc(:)
integer :: ind
end subroutine unpack_2d
subroutine pack_domain_2d(info, loc, glob)
use icosa
type(t_pack_info) :: info
real(rstd), dimension(:) :: loc, glob
integer :: jj,n,k,ij
end subroutine pack_domain_2d
subroutine unpack_domain_2d(info, loc, glob)
type(t_pack_info) :: info
real(rstd), dimension(:) :: loc, glob
integer :: jj,n,k,ij
end subroutine unpack_domain_2d
subroutine pack_3d(f_3d, packed)
use icosa
type(t_field),pointer :: f_3d(:)
real(rstd)            :: packed(:,:)
real(rstd), pointer   :: loc(:,:)
integer :: ind
end subroutine pack_3d
subroutine unpack_3d(f_3d, packed)
use icosa
type(t_field),pointer :: f_3d(:)
real(rstd)            :: packed(:,:)
real(rstd), pointer   :: loc(:,:)
integer :: ind
end subroutine unpack_3d
subroutine pack_domain_3d(info, loc, glob)
type(t_pack_info) :: info
real(rstd), dimension(:,:) :: loc, glob
integer :: jj,n,k,ij
end subroutine pack_domain_3d
subroutine unpack_domain_3d(info, loc, glob)
type(t_pack_info) :: info
real(rstd), dimension(:,:) :: loc, glob
integer :: jj,n,k,ij
end subroutine unpack_domain_3d
subroutine garbage_3d(loc,own)
use icosa
logical :: own(iim,jjm)
real(rstd) :: loc(iim*jjm,llm)
integer :: i,j,ij
end subroutine garbage_3d
subroutine pack_4d(f_4d, packed)
use icosa
type(t_field),pointer :: f_4d(:)
real(rstd)            :: packed(:,:,:)
real(rstd), pointer   :: loc(:,:,:)
integer :: ind
end subroutine pack_4d
subroutine unpack_4d(f_4d, packed)
use icosa
type(t_field),pointer :: f_4d(:)
real(rstd)            :: packed(:,:,:)
real(rstd), pointer   :: loc(:,:,:)
integer :: ind
end subroutine unpack_4d
subroutine pack_domain_4d(info, loc, glob)
type(t_pack_info) :: info
real(rstd), dimension(:,:,:) :: loc, glob
integer :: jj,n,k,ij
end subroutine pack_domain_4d
subroutine unpack_domain_4d(info, loc, glob)
type(t_pack_info) :: info
real(rstd), dimension(:,:,:) :: loc, glob
integer :: jj,n,k,ij
end subroutine unpack_domain_4d
end module physics_interface_mod
module diagflux_mod
use icosa
use omp_para
type(t_field), pointer, public ::         f_masst(:), f_qmasst(:), & ! time-averaged mass, tracer mass,
logical :: diagflux_on
subroutine init_diagflux
use getin_mod
use abort_mod
integer :: ll
end subroutine init_diagflux
subroutine zero_qfluxt
integer :: ind
real(rstd), pointer :: buf2(:,:),buf3(:,:,:)
end subroutine zero_qfluxt
subroutine qflux_centered_lonlat(scale, f_flux, f_flux_lon, f_flux_lat)
real(rstd), intent(in) :: scale
type(t_field),pointer :: f_flux(:), f_flux_lon(:), f_flux_lat(:)
real(rstd), pointer :: flux(:,:,:), flux_lon(:,:,:), flux_lat(:,:,:)
integer :: ind, itrac
end subroutine qflux_centered_lonlat
subroutine flux_centered_lonlat(scale, f_flux, f_flux_lon, f_flux_lat)
real(rstd), intent(in) :: scale
type(t_field),pointer :: f_flux(:), f_flux_lon(:), f_flux_lat(:)
real(rstd), pointer :: flux(:,:), flux_lon(:,:), flux_lat(:,:)
integer :: ind
end subroutine flux_centered_lonlat
subroutine compute_flux_centered_lonlat(scale, flux, flux_lon, flux_lat)
use wind_mod
real(rstd), intent(in) :: scale
real(rstd), intent(in) :: flux(3*iim*jjm,llm)
real(rstd), intent(out) :: flux_lon(iim*jjm,llm), flux_lat(iim*jjm,llm)
real(rstd) :: flux_3d(iim*jjm,llm,3)
end subroutine compute_flux_centered_lonlat
subroutine diagflux_energy(frac, f_phis,f_rhodz,f_theta_rhodz,f_u, f_geopot,f_theta,f_pk, f_hfluxt)
real(rstd), intent(in) :: frac
type(t_field),pointer :: f_phis(:),f_rhodz(:),f_theta_rhodz(:),f_u(:), f_geopot(:), f_theta(:), f_pk(:), f_hfluxt(:)
real(rstd), pointer :: phis(:), rhodz(:,:), theta_rhodz(:,:,:), u(:,:),           geopot(:,:), theta(:,:,:), pk(:,:), hfluxt(:,:),           ulont(:,:), thetat(:,:), epot(:,:), ekin(:,:), enthalpy(:,:),           thetaflux(:,:), ulonflux(:,:), epotflux(:,:), ekinflux(:,:), enthalpyflux(:,:)
integer :: ind
end subroutine diagflux_energy
subroutine compute_diagflux_energy(frac, massflux, phis,rhodz,theta_rhodz,ue, geopot,theta,pk,         ulon, thetat, epot, ekin, enthalpy,         ulon_flux, thetat_flux, epot_flux, ekin_flux, enthalpy_flux)
use disvert_mod, only : ptop
real(rstd), intent(in) :: frac
real(rstd), intent(in) :: massflux(3*iim*jjm,llm), ue(3*iim*jjm,llm),                               phis(iim*jjm), rhodz(iim*jjm,llm), theta_rhodz(iim*jjm,llm,nqtot)
real(rstd), intent(inout) :: geopot(iim*jjm,llm+1), theta(iim*jjm,llm), pk(iim*jjm,llm) ! theta,pk = buffers
real(rstd), intent(inout), dimension(iim*jjm, llm)   ::  ulon, thetat, epot, ekin, enthalpy
real(rstd), intent(inout), dimension(3*iim*jjm, llm) ::  ulon_flux, thetat_flux, epot_flux, ekin_flux, enthalpy_flux
real(rstd) :: energy, p_ik, theta_ik, temp_ik, gv, rd, cx,cy,cz, ux,uy,uz, ue_le,ulon_i
integer :: ij, l, ij_omp_begin_ext, ij_omp_end_ext
end select
end subroutine compute_diagflux_energy
end module diagflux_mod
module kinetic_mod
subroutine kinetic(f_ue,f_ki)
use icosa
type(t_field), pointer :: f_ue(:)
type(t_field), pointer :: f_ki(:)
real(rstd), pointer :: ue(:,:)
real(rstd), pointer :: ki(:,:)
integer :: ind
end subroutine kinetic
subroutine kinetic_new(f_ue,f_ki)
use icosa
type(t_field), pointer :: f_ue(:)
type(t_field), pointer :: f_ki(:)
real(rstd), pointer :: ue(:,:)
real(rstd), pointer :: ki(:,:)
integer :: ind
end subroutine kinetic_new
subroutine kinetic_v(f_ue,f_kv)
use icosa
type(t_field), pointer :: f_ue(:)
type(t_field), pointer :: f_kv(:)
real(rstd), pointer :: ue(:,:)
real(rstd), pointer :: kv(:,:)
integer :: ind
end subroutine kinetic_v
subroutine compute_kinetic(ue, ki)
use icosa
use omp_para
real(rstd),intent(in) :: ue(3*iim*jjm,llm)
real(rstd),intent(out) :: ki(iim*jjm,llm)
integer :: i,j,ij,l
end subroutine compute_kinetic
subroutine compute_kv(ue, kv)
use icosa
use omp_para
real(rstd),intent(in) :: ue(3*iim*jjm,llm)
real(rstd),intent(out) :: kv(2*iim*jjm,llm)
integer :: ij,l, u_up, u_down
end subroutine compute_kv
subroutine compute_ki_new(ue, ki)
use icosa
use omp_para
real(rstd),intent(in) :: ue(3*iim*jjm,llm)
real(rstd),intent(out):: ki(iim*jjm,llm)
real(rstd) :: kv(2*iim*jjm,llm)
integer :: ij,l
end subroutine compute_ki_new
subroutine gradient(f_berni, f_du)
use icosa
type(t_field), pointer :: f_berni(:)
type(t_field), pointer :: f_du(:)
real(rstd), pointer :: du(:,:)
real(rstd), pointer :: berni(:,:)
integer :: ind
end subroutine gradient
subroutine compute_grad(berni, du)
use icosa
use omp_para
real(rstd),intent(in) :: berni(iim*jjm,llm)
real(rstd),intent(out) :: du(3*iim*jjm,llm)
integer :: i,j,ij,l
end subroutine compute_grad
end module kinetic_mod
module check_conserve_mod
use icosa
use abort_mod
integer, parameter, public :: check_basic=1, check_detailed=2,         aam_dissip=1, aam_dyn=2, aam_phys=3
integer, save :: check_type
type(t_field),pointer,save :: f_pk(:), f_pks(:), f_p(:)
type(t_field),pointer,save :: f_vort(:)
type(t_field),pointer,save :: f_rhodz(:)
real(rstd),save :: aam_mass, aam_mass_old, aam_vel, aam_vel_old,         aam_velp, aam_velp_old, aam_velm, aam_velm_old,         aam_mass_source(3), aam_vel_source(3) ! read/written only if is_master
real(rstd),save :: aam_vel_plus_source(3), aam_vel_minus_source(3)
real(rstd),save :: mtot0,mqtot0,ztot0,etot0,angtot0,stot0
subroutine init_check_conserve
use getin_mod
use omp_para, only : is_master
use abort_mod
end select
end subroutine init_check_conserve
subroutine check_conserve(f_ps,f_dps,f_ue,f_theta_rhodz,f_phis,f_q,it)
use pression_mod
use vorticity_mod
use caldyn_gcm_mod
use exner_mod
use omp_para, only : is_master
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_dps(:)
type(t_field),pointer :: f_ue(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_phis(:)
type(t_field),pointer :: f_q(:)
integer, intent(in) :: it
real(rstd),pointer :: p(:,:),rhodz(:,:)
integer :: ind
real(rstd) :: mtot, mqtot, angtot, rmsdpdt
real(rstd) :: etot, stot, ang_mass, ang_vel, ang_velp, ang_velm, rmsvtot, ztot
end subroutine check_conserve
subroutine check_conserve_detailed(it,tag, f_ps,f_dps,f_ue,f_theta_rhodz,f_phis)
use pression_mod
use vorticity_mod
use caldyn_gcm_mod
use exner_mod
use omp_para, only : is_master
integer, intent(in) :: tag
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_dps(:)
type(t_field),pointer :: f_ue(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_phis(:)
integer, intent(in) ::it
real(rstd),pointer :: p(:,:),rhodz(:,:)
integer::ind
real(rstd) ::  etot,stot,rmsv, ang_mass, ang_vel, ang_velp, ang_velm
end subroutine check_conserve_detailed
subroutine global_sum(loc_sum, glob_sum)
use mpi_mod
use mpipara
use transfert_omp_mod
real(rstd), intent(in) :: loc_sum
real(rstd), intent(out) :: glob_sum
real(rstd) :: sum
end subroutine global_sum
subroutine check_mass_conserve(f_ps,f_dps,mtot,rmsdpdt)
use mpi_mod
use mpipara
use transfert_omp_mod
use omp_para
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_dps(:)
real(rstd),pointer :: ps(:),dps(:)
real(rstd), intent(out) :: mtot, rmsdpdt
integer :: ind,i,j,ij
real :: mloc, rmsloc
end subroutine check_mass_conserve
subroutine check_qmass_conserve(f_q,f_rhodz,mqtot)
use mpi_mod
use mpipara
use transfert_omp_mod
use omp_para
type(t_field),pointer :: f_q(:)
type(t_field),pointer :: f_rhodz(:)
real(rstd),pointer :: q(:,:,:)
real(rstd),pointer :: rhodz(:,:)
real(rstd), intent(out) :: mqtot
integer :: ind,i,j,ij,l
real :: mloc
end subroutine check_qmass_conserve
subroutine check_energy(f_ue,f_theta_rhodz,f_phis, etot,                        stot, aam_mass_tot, aam_vel_tot, aam_velp_tot, aam_velm_tot, rmsvtot)
use pression_mod
use vorticity_mod
type(t_field), pointer :: f_ue(:)
type(t_field), pointer :: f_theta_rhodz(:)
type(t_field), pointer :: f_phis(:)
real(rstd),intent(out) :: etot, stot, aam_mass_tot, aam_vel_tot, aam_velp_tot, aam_velm_tot, rmsvtot
real(rstd), pointer :: ue(:,:)
real(rstd), pointer :: p(:,:)
real(rstd), pointer :: theta_rhodz(:,:,:)
real(rstd), pointer :: pk(:,:)
real(rstd), pointer :: phis(:)
real(rstd), pointer :: rhodz(:,:)
real(rstd) :: e, s, aam_mass, aam_vel, aam_velp, aam_velm, rmsv
integer :: ind
end subroutine check_energy
subroutine compute_energy(ind,u,p,rhodz,theta_rhodz,pk,phis, e, s, aam_mass, aam_vel, aam_velp, aam_velm, rmsv)
use disvert_mod
use wind_mod
use omp_para
integer,intent(in)::ind
real(rstd),intent(in) :: u(3*iim*jjm,llm)
real(rstd),intent(in) :: p(iim*jjm,llm+1)
real(rstd),intent(in) :: rhodz(iim*jjm,llm)
real(rstd),intent(in) :: theta_rhodz(iim*jjm,llm)
real(rstd),intent(in) :: pk(iim*jjm,llm)
real(rstd),intent(in) :: phis(iim*jjm)
real(rstd),intent(inout) :: e, s, aam_mass, aam_vel, aam_velp, aam_velm, rmsv
real(rstd) :: ucenter(iim*jjm,llm,3)
real(rstd) :: ulon(iim*jjm,llm)
real(rstd) :: ulat(iim*jjm,llm)
real(rstd) :: mass_ij, theta_ij, ke_ij, rad,radomeg,lat
integer :: i,j,ij,l
end subroutine compute_energy
subroutine check_pv(ztot)
real(rstd),intent(out) :: ztot
real(rstd), pointer :: vort(:,:)
real(rstd), pointer :: rhodz(:,:)
integer :: ind
real(rstd) :: z
end subroutine check_pv
subroutine compute_pv(vort,rhodz,z)
use disvert_mod
use omp_para
real(rstd),intent(in) :: vort(2*iim*jjm,llm)
real(rstd),intent(in) :: rhodz(iim*jjm,llm)
real(rstd),intent(inout) :: z
real(rstd)::qv1,qv2
real(rstd)::hv1,hv2
integer :: i,j,ij,l
end subroutine compute_pv
subroutine compute_rhodz(p,rhodz)
real(rstd),intent(in) :: p(iim*jjm,llm+1)
real(rstd),intent(out):: rhodz(iim*jjm,llm)
real(rstd) ::mass(iim*jjm,llm)
integer :: i,j,ij,l
end subroutine compute_rhodz
end module check_conserve_mod
module pression_mod
subroutine pression(f_ps,f_p)
use icosa
type(t_field), pointer :: f_ps(:)
type(t_field), pointer :: f_p(:)
real(rstd), pointer :: ps(:)
real(rstd), pointer :: p(:,:)
integer :: ind
end subroutine pression
subroutine pression_mid(f_ps,f_pmid)
use icosa
type(t_field), pointer :: f_ps(:)
type(t_field), pointer :: f_pmid(:)
real(rstd), pointer :: ps(:)
real(rstd), pointer :: pmid(:,:)
integer :: ind
end subroutine pression_mid
subroutine compute_pression(ps,p,offset)
use icosa
use disvert_mod
use omp_para
real(rstd),intent(in) :: ps(iim*jjm)
real(rstd),intent(out) :: p(iim*jjm,llm+1)
integer,intent(in) :: offset
integer :: i,j,ij,l
end subroutine compute_pression
subroutine compute_pression_mid(ps,pmid,offset)
use icosa
use disvert_mod
use omp_para
real(rstd),intent(in) :: ps(iim*jjm)
real(rstd),intent(out) :: pmid(iim*jjm,llm)
integer,intent(in) :: offset
integer :: i,j,ij,l
end subroutine compute_pression_mid
end module pression_mod
module observable_mod
use icosa
use diagflux_mod
use output_field_mod
type(t_field),pointer, save :: f_buf_i(:),         f_buf_fel(:), f_buf_uh(:), & ! horizontal velocity, different from prognostic velocity if nh
type(t_field),pointer, save :: f_buf_v(:), f_buf_s(:), f_buf_p(:)
type(t_field),pointer, save :: f_pmid(:)
type(t_field),pointer, save :: f_theta(:)
subroutine init_observable
end subroutine init_observable
subroutine write_output_fields_basic(init, f_phis, f_ps, f_mass, f_geopot, f_theta_rhodz, f_u, f_w, f_q)
use xios_mod
use disvert_mod
use wind_mod
use omp_para
use time_mod
use xios_mod
use earth_const
use pression_mod
use vertical_interp_mod
use theta2theta_rhodz_mod
use omega_mod
logical, intent(in) :: init
integer :: l
real :: scalar(1)
real :: mid_ap(llm)
real :: mid_bp(llm)
type(t_field),pointer :: f_phis(:), f_ps(:), f_mass(:), f_geopot(:), f_theta_rhodz(:), f_u(:), f_w(:), f_q(:)
end subroutine write_output_fields_basic
subroutine output_energyflux(f_energy, f_flux, name_energy, name_fluxlon, name_fluxlat)
type(t_field), pointer :: f_energy(:), f_flux(:)
end subroutine output_energyflux
subroutine progonostic_vel_to_horiz(f_geopot, f_ps, f_rhodz, f_u, f_w, f_uh, f_uz)
use disvert_mod
type(t_field), pointer :: f_geopot(:), f_ps(:), f_rhodz(:),           f_u(:), f_w(:), f_uz(:), &  ! in
real(rstd),pointer :: geopot(:,:), ps(:), rhodz(:,:), u(:,:), w(:,:), uh(:,:), uz(:,:), f_el(:,:)
integer :: ind
end subroutine progonostic_vel_to_horiz
subroutine compute_prognostic_vel_to_horiz(phi, rhodz, u, w, f_el, uh, uz)
use omp_para
real(rstd), intent(in) :: phi(iim*jjm,llm+1)
real(rstd), intent(in) :: rhodz(iim*jjm,llm)
real(rstd), intent(in) :: u(3*iim*jjm,llm)
real(rstd), intent(in) :: w(iim*jjm,llm+1)
real(rstd), intent(out) :: uh(3*iim*jjm,llm)
real(rstd), intent(out) :: uz(iim*jjm,llm)
integer :: ij,l
real(rstd) :: f_el(3*iim*jjm,llm+1)
real(rstd) :: w_el, dephil
end subroutine compute_prognostic_vel_to_horiz
subroutine diagnose_temperature(f_pmid,f_q,f_temp)
use icosa
use pression_mod
type(t_field), pointer :: f_pmid(:)           ! in
type(t_field), pointer :: f_q(:)            ! in
type(t_field), pointer :: f_temp(:)         ! inout
real(rstd), pointer :: pmid(:,:)
real(rstd), pointer :: q(:,:,:)
real(rstd), pointer :: temp(:,:)
integer :: ind
end subroutine diagnose_temperature
subroutine compute_diagnose_temp(pmid,q,temp)
use omp_para
use pression_mod
real(rstd),intent(in)    :: pmid(iim*jjm,llm)
real(rstd),intent(in)    :: q(iim*jjm,llm,nqtot)
real(rstd),intent(inout) :: temp(iim*jjm,llm)
real(rstd) :: rd, p_ik, theta_ik, temp_ik, qv, chi, rmix
integer :: ij,l
end select
end subroutine compute_diagnose_temp
subroutine tv2t(f_tv, f_q, f_t)
type(t_field), pointer :: f_tv(:)
type(t_field), pointer :: f_q(:)
type(t_field), pointer :: f_t(:)
real(rstd),pointer :: tv(:,:), q(:,:,:), t(:,:)
integer :: ind
end select
end subroutine tv2t
subroutine divide_by_mass(iq, f_mass, f_theta_rhodz, f_theta)
integer, intent(in) :: iq
type(t_field), pointer :: f_mass(:), f_theta_rhodz(:), f_theta(:)
real(rstd), pointer :: mass(:,:), theta_rhodz(:,:,:), theta(:,:)
integer :: ind
end subroutine divide_by_mass
end module observable_mod
module exner_mod
integer,save :: caldyn_exner
integer, parameter :: lmdz=3, direct=4
subroutine exner(f_ps,f_p,f_pks,f_pk)
use icosa
type(t_field), pointer :: f_ps(:)  ! in
type(t_field), pointer :: f_p(:)   ! in
type(t_field), pointer :: f_pks(:) ! out
type(t_field), pointer :: f_pk(:)  ! out
real(rstd), pointer :: ps(:)
real(rstd), pointer :: p(:,:)
real(rstd), pointer :: pks(:)
real(rstd), pointer :: pk(:,:)
integer :: ind
end subroutine exner
subroutine compute_exner(ps,p,pks,pk,offset)
use icosa
use disvert_mod
use pression_mod
use omp_para
real(rstd),intent(in) :: ps(iim*jjm)
real(rstd),intent(in) :: p(iim*jjm,llm+1)
real(rstd),intent(out) :: pks(iim*jjm)
real(rstd),intent(out) :: pk(iim*jjm,llm)
integer,intent(in) :: offset
integer :: i,j,ij,l
end subroutine compute_exner
end module exner_mod
module omega_mod
use icosa
subroutine w_omega(f_ps, f_u, f_omega) ! compute omega = dp/dt
type(t_field),pointer :: f_ps(:), f_u(:), f_omega(:)
integer :: ind
real(rstd),pointer :: ps(:), u(:,:), om(:,:)
end subroutine w_omega
subroutine compute_omega(ps,u, w)
use disvert_mod, only : ap,bp
use omp_para
real(rstd),intent(in) :: u(iim*3*jjm,llm), ps(iim*jjm)
real(rstd),intent(out):: w(iim*jjm,llm)
real(rstd):: convm(iim*jjm,llm+1)
real(rstd):: p(iim*jjm,llm+1), rhodz(iim*jjm,llm), fe(iim*3*jjm,llm)
real(rstd):: ugradps
integer :: i,j,l,ij
end subroutine compute_omega
end module omega_mod
module vorticity_mod
subroutine vorticity(f_ue,f_vort)
use icosa
type(t_field), pointer :: f_ue(:)
type(t_field), pointer :: f_vort(:)
real(rstd), pointer :: ue(:,:)
real(rstd), pointer :: vort(:,:)
integer :: ind
end subroutine vorticity
subroutine compute_vorticity(ue,vort)
use icosa
use disvert_mod
use omp_para
real(rstd),intent(in)  :: ue(3*iim*jjm,llm)
real(rstd),intent(out) :: vort(2*iim*jjm,llm)
integer :: i,j,ij,l
end subroutine compute_vorticity
end module vorticity_mod
module theta2theta_rhodz_mod
use field_mod
type(t_field), pointer, save  :: f_p(:)
subroutine init_theta2theta_rhodz
use icosa
use field_mod
end subroutine init_theta2theta_rhodz
subroutine theta_rhodz2theta(f_ps,f_theta_rhodz,f_theta)
use icosa
type(t_field), pointer :: f_ps(:)
type(t_field), pointer :: f_theta_rhodz(:)
type(t_field), pointer :: f_theta(:)
real(rstd), pointer :: ps(:)
real(rstd), pointer :: theta_rhodz(:,:)
real(rstd), pointer :: theta(:,:)
integer :: ind
end subroutine theta_rhodz2theta
subroutine theta_rhodz2temperature(f_ps,f_theta_rhodz,f_temp)
use icosa
use pression_mod
type(t_field), pointer :: f_ps(:)
type(t_field), pointer :: f_theta_rhodz(:)
type(t_field), pointer :: f_temp(:)
real(rstd), pointer :: ps(:)
real(rstd), pointer :: theta_rhodz(:,:,:)
real(rstd), pointer :: temp(:,:)
real(rstd), pointer :: p(:,:)
integer :: ind
end subroutine theta_rhodz2temperature
subroutine temperature2theta_rhodz(f_ps,f_temp,f_theta_rhodz)
use icosa
use pression_mod
use exner_mod
type(t_field), pointer :: f_ps(:)
type(t_field), pointer :: f_theta_rhodz(:)
type(t_field), pointer :: f_temp(:)
real(rstd), pointer :: ps(:)
real(rstd), pointer :: theta_rhodz(:,:,:)
real(rstd), pointer :: temp(:,:)
real(rstd), pointer :: p(:,:)
integer :: ind
end subroutine temperature2theta_rhodz
subroutine theta2theta_rhodz(f_ps,f_theta,f_theta_rhodz)
use icosa
type(t_field), pointer :: f_ps(:)
type(t_field), pointer :: f_theta(:)
type(t_field), pointer :: f_theta_rhodz(:)
real(rstd), pointer :: ps(:)
real(rstd), pointer :: theta(:,:)
real(rstd), pointer :: theta_rhodz(:,:)
integer :: ind
end subroutine theta2theta_rhodz
subroutine compute_theta2theta_rhodz(ps,theta, theta_rhodz,offset)
use icosa
use disvert_mod
use omp_para
real(rstd),intent(in) :: ps(iim*jjm)
real(rstd),intent(in) :: theta(iim*jjm,llm)
real(rstd),intent(out) :: theta_rhodz(iim*jjm,llm)
integer,intent(in) :: offset
real(rstd) :: rhodz
integer :: i,j,ij,l
end subroutine compute_theta2theta_rhodz
subroutine compute_theta_rhodz2theta(ps,theta_rhodz,theta,offset)
use icosa
use disvert_mod
use omp_para
real(rstd),intent(in) :: ps(iim*jjm)
real(rstd),intent(in) :: theta_rhodz(iim*jjm,llm)
real(rstd),intent(out) :: theta(iim*jjm,llm)
integer,intent(in) :: offset
real(rstd) :: rhodz
integer :: i,j,ij,l
end subroutine compute_theta_rhodz2theta
subroutine compute_theta_rhodz2temperature(p,theta_rhodz,temp,offset)
use icosa
use pression_mod
use exner_mod
use omp_para
real(rstd),intent(in) :: p(iim*jjm,llm+1)
real(rstd),intent(in) :: theta_rhodz(iim*jjm,llm)
real(rstd),intent(out) :: temp(iim*jjm,llm)
integer,intent(in) :: offset
real(rstd) :: pk_ij
integer :: i,j,ij,l
end subroutine compute_theta_rhodz2temperature
subroutine compute_temperature2theta_rhodz(p,temp,theta_rhodz,offset)
use icosa
use pression_mod
use exner_mod
use omp_para
real(rstd),intent(in)  :: p(iim*jjm,llm+1)
real(rstd),intent(out) :: theta_rhodz(iim*jjm,llm)
real(rstd),intent(in)  :: temp(iim*jjm,llm)
integer,intent(in) :: offset
real(rstd) :: pk_ij
integer :: i,j,ij,l
end subroutine compute_temperature2theta_rhodz
end module theta2theta_rhodz_mod
module wind_mod
use omp_para
use icosa
subroutine un2ulonlat(f_u, f_ulon, f_ulat, scale_)
type(t_field), pointer :: f_u(:) ! in  : normal velocity components on edges
type(t_field), pointer :: f_ulon(:), f_ulat(:) ! out : velocity reconstructed at hexagons
real(rstd),pointer     :: u(:,:),  ulon(:,:), ulat(:,:)
real(rstd), optional   :: scale_
real(rstd)             :: scale
integer :: ind
end subroutine un2ulonlat
subroutine ulonlat2un(f_ulon, f_ulat,f_u)
type(t_field), pointer :: f_ulon(:), f_ulat(:) ! in : velocity reconstructed at hexagons
type(t_field), pointer :: f_u(:) ! out  : normal velocity components on edges
real(rstd),pointer :: u(:,:),  ulon(:,:), ulat(:,:)
integer :: ind
end subroutine ulonlat2un
subroutine compute_wind_centered(ue,ucenter,scale_)
real(rstd) :: ue(3*iim*jjm,llm)
real(rstd) :: ucenter(iim*jjm,llm,3)
real(rstd), intent(in), optional :: scale_
integer :: ij,l
real(rstd) :: scale,fac, ue_le, cx,cy,cz, ux,uy,uz
end subroutine compute_wind_centered
subroutine compute_flux_centered(scale,ue,ucenter)
real(rstd), intent(in) :: scale
real(rstd) :: ue(3*iim*jjm,llm)
real(rstd) :: ucenter(iim*jjm,llm,3)
integer :: ij,l
real(rstd) :: fac, ue_le, cx,cy,cz, ux,uy,uz
end subroutine compute_flux_centered
subroutine compute_wind_on_edge(ue,uedge)
real(rstd) :: ue(3*iim*jjm,llm)
real(rstd) :: uedge(3*iim*jjm,llm,3)
real(rstd) :: ut(3*iim*jjm,llm)
integer :: i,j,ij,l
end subroutine compute_wind_on_edge
subroutine compute_tangential_compound(ue,ut)
real(rstd) :: ue(3*iim*jjm,llm)
real(rstd) :: ut(3*iim*jjm,llm)
integer :: i,j,l,ij
end subroutine compute_tangential_compound
subroutine compute_wind_from_lonlat_compound(ulon, ulat, u)
real(rstd) :: u(3*iim*jjm,llm,3)
real(rstd) :: ulon(3*iim*jjm,llm)
real(rstd) :: ulat(3*iim*jjm,llm)
integer :: i,j,ij,l
end subroutine compute_wind_from_lonlat_compound
subroutine compute_wind_centered_from_lonlat_compound(ulon, ulat, u)
real(rstd) :: u(iim*jjm,llm,3)
real(rstd) :: ulon(iim*jjm,llm)
real(rstd) :: ulat(iim*jjm,llm)
integer :: i,j,ij,l
end subroutine compute_wind_centered_from_lonlat_compound
subroutine compute_wind2d_from_lonlat_compound(ulon, ulat, u)
real(rstd) :: u(3*iim*jjm,3)
real(rstd) :: ulon(3*iim*jjm)
real(rstd) :: ulat(3*iim*jjm)
integer :: i,j,ij
end subroutine compute_wind2d_from_lonlat_compound
subroutine compute_wind_perp_from_lonlat_compound(ulon, ulat, up)
real(rstd) :: up(3*iim*jjm,llm)
real(rstd) :: ulon(3*iim*jjm,llm)
real(rstd) :: ulat(3*iim*jjm,llm)
real(rstd) :: u(3*iim*jjm,llm,3)
integer :: i,j,ij,l
end subroutine compute_wind_perp_from_lonlat_compound
subroutine compute_wind2d_perp_from_lonlat_compound(ulon, ulat, up)
real(rstd) :: up(3*iim*jjm)
real(rstd) :: ulon(3*iim*jjm)
real(rstd) :: ulat(3*iim*jjm)
real(rstd) :: u(3*iim*jjm,3)
integer :: i,j,ij
end subroutine compute_wind2d_perp_from_lonlat_compound
subroutine compute_wind_centered_lonlat_compound(uc, ulon, ulat)
real(rstd) :: uc(iim*jjm,llm,3)
real(rstd) :: ulon(iim*jjm,llm)
real(rstd) :: ulat(iim*jjm,llm)
integer :: i,j,ij,l
end subroutine compute_wind_centered_lonlat_compound
subroutine compute_wind_centered_from_wind_lonlat_centered(ulon, ulat,uc)
real(rstd) :: ulon(iim*jjm,llm)
real(rstd) :: ulat(iim*jjm,llm)
real(rstd) :: uc(iim*jjm,llm,3)
integer :: i,j,ij,l
end subroutine compute_wind_centered_from_wind_lonlat_centered
subroutine compute_wind_perp_from_wind_centered(uc,un)
real(rstd),intent(in)   :: uc(iim*jjm,llm,3)
real(rstd),intent(out)  :: un(3*iim*jjm,llm)
integer :: i,j,ij,l
end subroutine compute_wind_perp_from_wind_centered
subroutine compute_un2ulonlat(un, ulon, ulat, scale)
real(rstd),intent(in)  :: un(3*iim*jjm,llm)
real(rstd),intent(out) :: ulon(iim*jjm,llm)
real(rstd),intent(out) :: ulat(iim*jjm,llm)
real(rstd)             :: uc(iim*jjm,llm,3)
real(rstd)             :: scale
end subroutine compute_un2ulonlat
subroutine compute_ulonlat2un(ulon, ulat,un)
real(rstd),intent(in) :: ulon(iim*jjm,llm)
real(rstd),intent(in) :: ulat(iim*jjm,llm)
real(rstd),intent(out)  :: un(3*iim*jjm,llm)
real(rstd)             :: uc(iim*jjm,llm,3)
end subroutine compute_ulonlat2un
end module wind_mod
module geopotential_mod
subroutine thetarhodz2geopot(f_ps,f_phis,f_theta_rhodz, f_p,f_theta,f_phi) ! fixme : never called, dry only
use icosa
use omp_para
use pression_mod
use theta2theta_rhodz_mod
type(t_field), pointer :: f_ps(:), f_phis(:), f_theta_rhodz(:), &  ! in
real(rstd),pointer :: p(:,:), theta(:,:,:), theta_rhodz(:,:,:),           phi(:,:), phis(:), ps(:)
integer :: ind
end subroutine thetarhodz2geopot
subroutine compute_geopotential(phis,p,theta,phi,offset)
use icosa
use omp_para
real(rstd),intent(in) :: p(iim*jjm,llm+1)
real(rstd),intent(in) :: phis(iim*jjm)
real(rstd),intent(in) :: theta(iim*jjm,llm,nqdyn)
real(rstd),intent(out) :: phi(iim*jjm,llm)
integer,intent(in) :: offset
integer :: i,j,ij,l
real(rstd) :: mg_ij, p_ij, exner_ij
end subroutine compute_geopotential
end module geopotential_mod
module icosa
use genmod
use getin_mod, only : getin
use grid_param
use metric
use domain_mod
use dimensions
use grid_param
use geometry
use spherical_geom_mod
use vector
use field_mod
use write_field_mod
use transfert_mod
use time_mod
real(rstd) :: ncar_dz, ncar_p0, ncar_t0 ! read from run.def by disvert
end module icosa
program icosa_gcm
use icosa_init_mod, only : icosa_init
end program icosa_gcm
subroutine initialize_external_physics
end subroutine initialize_external_physics
subroutine external_physics
end subroutine external_physics
module dissip_gcm_mod
use icosa
use abort_mod
type(t_field),pointer,save :: f_due_diss_gradiv(:)
type(t_field),pointer,save :: f_due_diss_gradrot(:)
type(t_field),pointer,save :: f_dtheta_diss(:)
type(t_field),pointer,save :: f_dtheta_rhodz_diss(:)
type(t_message),save :: req_due_gradiv, req_due_gradrot, req_dtheta
integer,save :: nitergdiv=1
integer,save :: nitergrot=1
integer,save :: niterdivgrad=1
real,allocatable,save :: tau_graddiv(:)
real,allocatable,save :: tau_gradrot(:)
real,allocatable,save :: tau_divgrad(:)
real,save :: cgraddiv
real,save :: cgradrot
real,save :: cdivgrad
integer, save :: rayleigh_friction_type, rayleigh_shear
real, save    :: rayleigh_tau, rayleigh_limlat
real,save    :: dtdissip
subroutine allocate_dissip
use icosa
end subroutine allocate_dissip
subroutine init_dissip
use icosa
use disvert_mod
use mpi_mod
use mpipara
use transfert_mod
use time_mod
use transfert_omp_mod
use omp_para
use abort_mod
type(t_field),pointer,save  :: f_u(:)
type(t_field),pointer,save  :: f_du(:)
real(rstd),pointer     :: u(:)
real(rstd),pointer     :: du(:)
type(t_field),pointer,save  :: f_theta(:)
type(t_field),pointer ,save :: f_dtheta(:)
real(rstd),pointer    :: theta(:)
real(rstd),pointer    :: dtheta(:)
real(rstd)            :: dumax,dumax1
real(rstd)            :: dthetamax,dthetamax1
real(rstd)            :: r
real(rstd)            :: tau
real(rstd)            :: zz, zvert, fact
integer               :: l
real(rstd)            :: mintau
integer    :: vert_prof_dissip
real(rstd) :: dissip_factz,dissip_deltaz,dissip_zref,pseudoz
integer :: i,j,ij,ind,it,iter,m
end select
end subroutine init_dissip
subroutine dissip(f_ps,f_mass,f_phis,f_geopot,f_theta_rhodz,f_ue, f_dtheta_rhodz,f_due)
use icosa
use theta2theta_rhodz_mod
use pression_mod
use exner_mod
use geopotential_mod
use trace
use time_mod
use omp_para
use abort_mod
type(t_field),pointer :: f_ps(:), f_mass(:), f_phis(:), f_geopot(:)
type(t_field),pointer :: f_theta_rhodz(:), f_dtheta_rhodz(:)
type(t_field),pointer :: f_ue(:), f_due(:)
real(rstd),pointer         :: due(:,:)
real(rstd),pointer         :: phi(:,:), ue(:,:)
real(rstd),pointer         :: due_diss1(:,:)
real(rstd),pointer         :: due_diss2(:,:)
real(rstd),pointer         :: dtheta_rhodz(:,:,:)
real(rstd),pointer         :: dtheta_rhodz_diss(:,:)
integer :: ind, shear
integer :: l,ij,nn
subroutine relax(shift_t, shift_u)
use dcmip_initial_conditions_test_1_2_3
real(rstd) :: z, ulon,ulat, & ! input to test2_schaer_mountain
real(rstd), parameter :: zh=2e4,ztop=3e4  ! dcmip values
logical :: hybrid_eta
integer :: shift_u, shift_t, zcoords, nn
end subroutine relax
subroutine write_dissip_tendencies
use observable_mod, only : f_buf_ulon, f_buf_ulat
use wind_mod
use output_field_mod
end subroutine write_dissip_tendencies
end subroutine dissip
subroutine gradiv(f_ue,f_due)
use icosa
use trace
use omp_para
type(t_field),pointer :: f_ue(:)
type(t_field),pointer :: f_due(:)
real(rstd),pointer    :: ue(:,:)
real(rstd),pointer    :: due(:,:)
integer :: ind
integer :: it,l,ij
end subroutine gradiv
subroutine gradrot(f_ue,f_due)
use icosa
use trace
use omp_para
type(t_field),pointer :: f_ue(:)
type(t_field),pointer :: f_due(:)
real(rstd),pointer    :: ue(:,:)
real(rstd),pointer    :: due(:,:)
integer :: ind
integer :: it,l,ij
end subroutine gradrot
subroutine divgrad(f_theta,f_dtheta)
use icosa
use trace
use omp_para
type(t_field),pointer :: f_theta(:)
type(t_field),pointer :: f_dtheta(:)
real(rstd),pointer    :: theta(:,:)
real(rstd),pointer    :: dtheta(:,:)
integer :: ind, l, ij
integer :: it
end subroutine divgrad
subroutine divgrad_theta_rhodz(f_mass,f_theta_rhodz,f_dtheta_rhodz)
use icosa
use trace
use omp_para
type(t_field),pointer :: f_mass(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_dtheta_rhodz(:)
real(rstd),pointer :: mass(:,:)
real(rstd),pointer :: theta_rhodz(:,:,:)
real(rstd),pointer :: dtheta_rhodz(:,:)
integer :: ind
integer :: it,l,ij
end subroutine divgrad_theta_rhodz
subroutine compute_gradiv(ue,gradivu_e,ai,ne,le,de,llb,lle)
integer,intent(in)     :: llb
integer,intent(in)     :: lle
real(rstd),intent(out) :: gradivu_e(iim*3*jjm,llm)
real(rstd),intent(in)  :: ue(iim*3*jjm,llm)
real(rstd),intent(in)  :: ai(iim*jjm)
integer,intent(in)     :: ne(iim*jjm,6)
real(rstd),intent(in)  :: le(iim*3*jjm)
real(rstd),intent(in)  :: de(iim*3*jjm)
end subroutine compute_gradiv
subroutine compute_gradiv_inplace(ue_gradivu_e,ai,ne,le,de,llb,lle)
integer,intent(in)     :: llb
integer,intent(in)     :: lle
real(rstd),intent(inout) :: ue_gradivu_e(iim*3*jjm,llm)
real(rstd),intent(in)  :: ai(iim*jjm)
integer,intent(in)     :: ne(iim*jjm,6)
real(rstd),intent(in)  :: le(iim*3*jjm)
real(rstd),intent(in)  :: de(iim*3*jjm)
real(rstd) :: divu_i(iim*jjm,llb:lle)
integer :: ij,l
end subroutine compute_gradiv_inplace
subroutine compute_divgrad(theta,divgrad_i,ai,ne,le,de,llb,lle)
integer,intent(in)     :: llb
integer,intent(in)     :: lle
real(rstd),intent(in) :: theta(iim*jjm,1:lle)
real(rstd),intent(out) :: divgrad_i(iim*jjm,1:lle)
real(rstd),intent(in)  :: ai(iim*jjm)
integer,intent(in)     :: ne(iim*jjm,6)
real(rstd),intent(in)  :: le(iim*3*jjm)
real(rstd),intent(in)  :: de(iim*3*jjm)
end subroutine compute_divgrad
subroutine compute_divgrad_inplace(theta_divgrad_i,ai,ne,le,de,llb,lle)
integer,intent(in)     :: llb
integer,intent(in)     :: lle
real(rstd),intent(inout) :: theta_divgrad_i(iim*jjm,1:lle)
real(rstd),intent(in)  :: ai(iim*jjm)
integer,intent(in)     :: ne(iim*jjm,6)
real(rstd),intent(in)  :: le(iim*3*jjm)
real(rstd),intent(in)  :: de(iim*3*jjm)
real(rstd)  :: grad_e(3*iim*jjm,llb:lle)
integer :: ij,l
end subroutine compute_divgrad_inplace
subroutine compute_gradrot(ue,gradrot_e,av,ne,le,de,llb,lle)
integer,intent(in)     :: llb
integer,intent(in)     :: lle
real(rstd),intent(in) :: ue(iim*3*jjm,lle)
real(rstd),intent(out) :: gradrot_e(iim*3*jjm,lle)
real(rstd),intent(in)  :: av(2*iim*jjm)
integer,intent(in)     :: ne(iim*jjm,6)
real(rstd),intent(in)  :: le(iim*3*jjm)
real(rstd),intent(in)  :: de(iim*3*jjm)
end subroutine compute_gradrot
subroutine compute_gradrot_inplace(ue_gradrot_e,av,ne,le,de,llb,lle)
integer,intent(in)     :: llb
integer,intent(in)     :: lle
real(rstd),intent(inout) :: ue_gradrot_e(iim*3*jjm,lle)
real(rstd),intent(in)  :: av(2*iim*jjm)
integer,intent(in)     :: ne(iim*jjm,6)
real(rstd),intent(in)  :: le(iim*3*jjm)
real(rstd),intent(in)  :: de(iim*3*jjm)
real(rstd) :: rot_v(2*iim*jjm,llb:lle)
integer :: ij,l
end subroutine compute_gradrot_inplace
end module dissip_gcm_mod
module sponge_mod
use icosa
real,save :: tau_sponge !inverse of charactericstic relaxation time scale at the topmost layer (hz)
integer,save :: iflag_sponge !0 --> for no sponge
integer,save :: mode_sponge !1 --> u and v relax towards 0
real,allocatable,save :: rdamp(:) ! quenching coefficient
real,allocatable,save:: lambda(:) ! inverse or quenching time scale (hz)
subroutine init_sponge
use icosa
use disvert_mod
use omp_para
use mpipara, only: is_mpi_master
use abort_mod
integer :: l
end subroutine init_sponge
subroutine sponge(f_ue,f_due,f_theta_rhodz,f_dtheta_rhodz)
use icosa
use theta2theta_rhodz_mod
use pression_mod
use exner_mod
use geopotential_mod
use trace
use time_mod
use omp_para
type(t_field),pointer :: f_ue(:)
type(t_field),pointer :: f_due(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_dtheta_rhodz(:)
real(rstd),pointer         :: due(:,:)!,due_sponge(:,:)
real(rstd),pointer         :: ue(:,:)
real(rstd),pointer         :: theta_rhodz(:,:,:)
real(rstd),pointer         :: dtheta_rhodz(:,:,:)!,dtheta_sponge(:,:)
integer :: ind
integer :: l,ij
end subroutine sponge
end module sponge_mod
module guided_mod
subroutine init_guided
use icosa
use guided_ncar_mod, only : init_guided_ncar => init_guided
end select
end subroutine init_guided
subroutine guided(tt, f_ps, f_theta_rhodz, f_u, f_q)
use icosa
use guided_ncar_mod, only : guided_ncar => guided
real(rstd), intent(in):: tt
type(t_field),pointer :: f_ps(:)
type(t_field),pointer :: f_theta_rhodz(:)
type(t_field),pointer :: f_u(:)
type(t_field),pointer :: f_q(:)
end select
end subroutine guided
end module guided_mod
module euler_scheme_mod
use field_mod
use abort_mod
type(t_field),pointer,save,public :: f_geopot(:), f_q(:),         f_rhodz(:), f_mass(:), f_massm1(:), f_massm2(:), f_dmass(:), & ! current and previous time steps + tendency of mass,
integer, parameter, public :: explicit=1, hevi=2, euler=1, rk4=2, mlf=3, rk25=4, ark23=6, ark33=7
integer,save, public :: nb_stage, matsuno_period, scheme, scheme_family
subroutine euler_scheme(with_dps,fluxt_zero)
use icosa
use disvert_mod
use omp_para
use trace
logical :: with_dps
logical, optional :: fluxt_zero(ndomain) ! set to .true. to start accumulating fluxes in time
real(rstd),pointer :: ps(:), dps(:)
real(rstd),pointer :: u(:,:) , du(:,:)
real(rstd),pointer :: mass(:,:), dmass(:,:)
real(rstd),pointer :: theta_rhodz(:,:,:), dtheta_rhodz(:,:,:)
real(rstd),pointer :: hflux(:,:),wflux(:,:),hfluxt(:,:),wfluxt(:,:)
integer :: ind
integer :: ij,l
subroutine compute_euler_scheme(u, du, theta_rhodz, dtheta_rhodz)
real(rstd),intent(inout) :: u(iim*3*jjm,llm)
real(rstd),intent(in)    :: du(iim*3*jjm,llm)
real(rstd),intent(inout) :: theta_rhodz(iim*jjm,llm,nqdyn)
real(rstd),intent(in)    :: dtheta_rhodz(iim*jjm,llm,nqdyn)
end subroutine compute_euler_scheme
end subroutine euler_scheme
subroutine accumulate_fluxes(hflux,wflux, hfluxt,wfluxt, tau,fluxt_zero)
use dimensions
use omp_para
use disvert_mod
real(rstd), intent(in)    :: hflux(3*iim*jjm,llm), wflux(iim*jjm,llm+1)
real(rstd), intent(inout) :: hfluxt(3*iim*jjm,llm), wfluxt(iim*jjm,llm+1)
real(rstd), intent(in) :: tau
logical, intent(inout) :: fluxt_zero
integer :: l,ij
end subroutine accumulate_fluxes
subroutine legacy_to_dec(f_ps, f_u)
use icosa
use disvert_mod
use omp_para
use trace
type(t_field),pointer :: f_ps(:), f_u(:)
real(rstd), pointer :: ps(:), u(:,:)
integer :: ind,ij,l
end subroutine legacy_to_dec
subroutine dec_to_legacy(f_ps, f_u)
use icosa
use disvert_mod
use omp_para
use trace
type(t_field),pointer :: f_ps(:), f_u(:)
real(rstd), pointer :: ps(:), u(:,:)
integer :: ind,ij,l
end subroutine dec_to_legacy
end module euler_scheme_mod
module time_mod
use prec
integer,save :: ncid
integer,save :: time_counter_id
integer,save :: it
integer,save :: itau0=0
real(rstd),save :: dt
real(rstd),save :: write_period
integer,save    :: itau_out, itau_adv, itau_dissip, itau_physics, itaumax
integer,save    :: itau_check_conserv
integer,save :: day_step,ndays
subroutine init_time
use earth_const
use getin_mod
use mpipara
real(rstd) :: run_length
end select
end subroutine init_time
subroutine create_time_counter_header
use netcdf_mod
use prec
use getin_mod
use mpipara
integer :: status
integer :: timeid, dtid
real(rstd) :: dt
end subroutine create_time_counter_header
subroutine update_time_counter(time)
use netcdf_mod
use mpipara
use prec
real(rstd),intent(in) ::time
integer :: status
real(rstd) ::time_array(1)
end subroutine update_time_counter
subroutine close_time_counter
use netcdf_mod
use mpipara
integer :: status
end subroutine  close_time_counter
end module time_mod
module explicit_scheme_mod
use euler_scheme_mod
use prec
use domain_mod
use field_mod
real(rstd), dimension(4), parameter :: coef_rk4 = (/ .25, 1./3., .5, 1. /)
real(rstd), dimension(5), parameter :: coef_rk25 = (/ .25, 1./6., 3./8., .5, 1. /)
subroutine explicit_scheme(it, fluxt_zero)
use time_mod
use omp_para
use caldyn_mod
use trace
use dimensions
use geometry
real(rstd),pointer :: ps(:) ,psm1(:), psm2(:), dps(:)
real(rstd),pointer :: u(:,:) , um1(:,:), um2(:,:), du(:,:)
real(rstd),pointer :: mass(:,:), massm1(:,:), dmass(:,:)
real(rstd),pointer :: theta_rhodz(:,:,:) , theta_rhodzm1(:,:,:), theta_rhodzm2(:,:,:), dtheta_rhodz(:,:,:)
real(rstd),pointer :: hflux(:,:),wflux(:,:),hfluxt(:,:),wfluxt(:,:)
logical :: fluxt_zero(ndomain) ! set to .true. to start accumulating fluxes in time
integer :: it,stage
end select
subroutine rk_scheme(stage,coef)
use disvert_mod
integer :: ind, stage
real(rstd), intent(in) :: coef(:)
real(rstd) :: tau
integer :: ij,l
end subroutine rk_scheme
subroutine leapfrog_matsuno_scheme(stage)
integer :: ind, stage
real :: tau
end subroutine leapfrog_matsuno_scheme
end subroutine explicit_scheme
end module explicit_scheme_mod
module hevi_scheme_mod
use prec
use domain_mod
use field_mod
use euler_scheme_mod
use abort_mod
real(rstd), save :: wj(3), bjl(3,3), cjl(3,3), taujj(3)
real(rstd), parameter, dimension(3) :: zero = (/0.,0.,0./)
subroutine set_coefs_ark23(dt)
real(rstd) :: dt
real(rstd), parameter :: delta=.5/sqrt(2.), gamma=1.-2.*delta
real(rstd), parameter :: alpha=0.7
real(rstd), parameter, dimension(3) :: wj = (/delta,delta,gamma/)
end subroutine set_coefs_ark23
subroutine set_coefs_ark33(dt)
real(rstd) :: dt
end subroutine set_coefs_ark33
subroutine set_coefs_rk(dt, ajl)
real(rstd) :: dt, ajl(3,4)
end subroutine set_coefs_rk
subroutine set_coefs_hevi(dt, ajl_slow, ajl_fast)
real(rstd) :: dt, ajl_slow(3,4), ajl_fast(3,4) ! fast/slow butcher tableaus
integer :: j
end subroutine set_coefs_hevi
subroutine hevi_scheme(it, fluxt_zero)
use time_mod
use disvert_mod
use caldyn_hevi_mod
use omp_para
use checksum_mod
logical :: fluxt_zero(ndomain) ! set to .true. to start accumulating fluxes in time
integer :: it,j,l, ind
real(rstd),pointer :: hflux(:,:),wflux(:,:),hfluxt(:,:),wfluxt(:,:)
end subroutine hevi_scheme
subroutine update_4d(w, f_y, f_dy)
use dimensions
use grid_param, only : nqdyn
real(rstd) :: w
type(t_field) :: f_y(:), f_dy(:)
real(rstd), pointer :: y(:,:,:), dy(:,:,:)
integer :: ind, iq
end subroutine update_4d
subroutine update_3d(w, f_y, f_dy)
use dimensions
real(rstd) :: w
type(t_field) :: f_y(:), f_dy(:)
real(rstd), pointer :: y(:,:), dy(:,:)
integer :: ind
end subroutine update_3d
subroutine compute_update_3d(w, y, dy)
use omp_para
use disvert_mod
real(rstd) :: w
real(rstd) :: y(:,:), dy(:,:)
integer :: l
end subroutine compute_update_3d
subroutine update_2d(w, f_y, f_dy)
use omp_para
real(rstd) :: w
type(t_field) :: f_y(:), f_dy(:)
real(rstd), pointer :: y(:), dy(:)
integer :: ind
end subroutine update_2d
subroutine compute_update_2d(w, y, dy)
real(rstd) :: w, y(:), dy(:)
end subroutine compute_update_2d
end module hevi_scheme_mod
module timeloop_gcm_mod
use profiling_mod
use icosa
use disvert_mod
use trace
use omp_para
use euler_scheme_mod
use explicit_scheme_mod
use hevi_scheme_mod
integer, parameter :: sync_it=10
type(t_message),save :: req_ps0, req_mass0, req_theta_rhodz0, req_u0, req_q0, req_w0, req_geopot0
logical, save :: positive_theta
integer :: itau_prof, id_timeloop, id_dyn, id_phys, id_dissip, id_adv, id_diags
subroutine init_timeloop
use dissip_gcm_mod
use observable_mod
use caldyn_mod
use etat0_mod
use guided_mod
use advect_tracer_mod
use check_conserve_mod
use output_field_mod
use theta2theta_rhodz_mod
use sponge_mod
end select
end select
end select
end subroutine init_timeloop
subroutine timeloop
use abort_mod
use dissip_gcm_mod
use sponge_mod
use observable_mod
use etat0_mod
use guided_mod
use caldyn_mod
use advect_tracer_mod
use diagflux_mod
use physics_mod
use mpipara
use transfert_mod
use check_conserve_mod
use xios_mod
use output_field_mod
use write_etat0_mod
use restart_mod
use checksum_mod
use explicit_scheme_mod
use hevi_scheme_mod
real(rstd),pointer :: rhodz(:,:), mass(:,:), ps(:)
real(rstd) :: adv_over_out ! ratio itau_adv/itau_out
integer :: ind, it,l
logical :: fluxt_zero(ndomain) ! set to .true. to start accumulating mass fluxes in time
logical, parameter :: check_rhodz=.false.
integer(kind=8) :: start_clock, stop_clock, rate_clock
integer :: itau_sync   ! best iteration for synchronisation and ensure 1+1=2
integer :: i
logical,save :: first_physic=.true.
end select
end subroutine timeloop
subroutine print_iteration(it,itau0,itaumax,start_clock,rate_clock)
integer :: it, itau0, itaumax, throughput
integer(kind=8) :: start_clock, stop_clock, rate_clock
real :: per_step,total, elapsed
end subroutine print_iteration
subroutine copy_theta_to_q(f_theta_rhodz,f_rhodz,f_q)
type(t_field),pointer :: f_theta_rhodz(:),f_rhodz(:), f_q(:)
real(rstd), pointer :: theta_rhodz(:,:,:), rhodz(:,:), q(:,:,:)
integer :: ind, iq
end subroutine copy_theta_to_q
subroutine copy_q_to_theta(f_theta_rhodz,f_rhodz,f_q)
type(t_field),pointer :: f_theta_rhodz(:),f_rhodz(:), f_q(:)
real(rstd), pointer :: theta_rhodz(:,:,:), rhodz(:,:), q(:,:,:)
integer :: ind, iq
end subroutine copy_q_to_theta
end module timeloop_gcm_mod
module tracer_mod
integer, parameter   :: advect_none    = 0
integer, parameter   :: advect_vanleer = 1
integer, allocatable,save :: advection_scheme(:)
interface set_advection_scheme
module procedure set_advection_scheme_1, set_advection_scheme_full
end interface
subroutine init_tracer
use grid_param
end subroutine init_tracer
subroutine set_advection_scheme_1(nq,scheme)
integer, intent(in) :: nq
integer, intent(in) :: scheme
end subroutine set_advection_scheme_1
subroutine set_advection_scheme_full(schemes)
use grid_param
integer, intent(in) :: schemes(nqtot)
end subroutine set_advection_scheme_full
end module tracer_mod
module advect_tracer_mod
use icosa
use advect_mod
type(t_field),save,pointer :: f_normal(:)
type(t_field),save,pointer :: f_tangent(:)
type(t_field),save,pointer :: f_gradq3d(:)
type(t_field),save,pointer :: f_cc(:)  ! starting point of backward-trajectory (miura approach)
type(t_field),save,pointer :: f_sqrt_leng(:)
type(t_message),save :: req_u, req_cc, req_wfluxt, req_q, req_rhodz, req_gradq3d
real(rstd), parameter :: pente_max=2.0 ! for vlz
type(t_field),save,pointer :: f_dzqw(:)   ! vertical finite difference of q
type(t_field),save,pointer :: f_adzqw(:)  ! abs(dzqw)
type(t_field),save,pointer :: f_dzq(:)    ! limited slope of q
type(t_field),save,pointer :: f_wq(:)     ! time-integrated flux of q
subroutine init_advect_tracer
use omp_para
real(rstd),pointer :: tangent(:,:)
real(rstd),pointer :: normal(:,:)
real(rstd),pointer :: sqrt_leng(:)
integer :: ind
end subroutine init_advect_tracer
subroutine advect_tracer(f_hfluxt, f_wfluxt,f_u, f_q,f_rhodz,        frac, f_masst,f_qmasst,f_massfluxt,f_qfluxt)
use omp_para
use trace
use write_field_mod
use tracer_mod
use abort_mod
type(t_field),pointer :: f_hfluxt(:)   ! time-integrated horizontal mass flux
type(t_field),pointer :: f_wfluxt(:)   ! time-integrated vertical mass flux
type(t_field),pointer :: f_u(:)        ! velocity (for back-trajectories)
type(t_field),pointer :: f_q(:)        ! tracer
type(t_field),pointer :: f_rhodz(:)    ! mass field at beginning of macro time step
real(rstd), intent(in):: frac          ! ratio itau_adv/itau_out or 0. if not diagflux_on
type(t_field),pointer :: f_masst(:)    ! time-integrated mass
type(t_field),pointer :: f_qmasst(:)   ! time-integrated tracer mass
type(t_field),pointer :: f_massfluxt(:)! time-integrated horizontal mass flux
type(t_field),pointer :: f_qfluxt(:)   ! time-integrated horizontal tracer flux
real(rstd),pointer :: q(:,:,:), normal(:,:), tangent(:,:), sqrt_leng(:), gradq3d(:,:,:), cc(:,:,:)
real(rstd),pointer :: hfluxt(:,:), wfluxt(:,:), masst(:,:), qmasst(:,:,:), massfluxt(:,:), qfluxt(:,:,:)
real(rstd),pointer :: rhodz(:,:), u(:,:)
real(rstd),pointer ::  dzqw(:,:)         ! vertical finite difference of q
real(rstd),pointer ::  adzqw(:,:)        ! abs(dzqw)
real(rstd),pointer ::  dzq(:,:)          ! limited slope of q
real(rstd),pointer ::  wq(:,:)           ! time-integrated flux of q
integer :: ind,k, nq_last
logical,save :: first=.true.
end subroutine advect_tracer
subroutine vlz(update_mass, fac,wfluxt,mass, q, halo, dzqw, adzqw, dzq, wq)
use trace
use omp_para
logical, intent(in)       :: update_mass
real(rstd), intent(in)    :: fac, wfluxt(iim*jjm,llm+1) ! vertical mass flux
real(rstd), intent(inout) :: mass(iim*jjm,llm)
real(rstd), intent(inout) :: q(iim*jjm,llm)
integer, intent(in) :: halo
real(rstd),intent(inout) :: dzqw(iim*jjm,llm),        & ! vertical finite difference of q
real(rstd) :: dzqmax, newmass, sigw, qq, w
integer :: ij,l,ijb,ije
end subroutine vlz
end module advect_tracer_mod
module advect_mod
use icosa
subroutine init_advect(normal,tangent,sqrt_leng)
real(rstd),intent(out) :: normal(3*iim*jjm,3)
real(rstd),intent(out) :: tangent(3*iim*jjm,3)
real(rstd),intent(out) :: sqrt_leng(iim*jjm)
integer :: ij
end subroutine init_advect
subroutine compute_gradq3d(qi,sqrt_leng,gradq3d,xyz_i,xyz_v)
use trace
use omp_para
real(rstd),intent(in)  :: qi(iim*jjm,llm)
real(rstd),intent(in)  :: sqrt_leng(iim*jjm)
real(rstd),intent(in)  :: xyz_i(iim*jjm,3)
real(rstd),intent(in)  :: xyz_v(2*iim*jjm,3)
real(rstd),intent(out) :: gradq3d(iim*jjm,llm,3)
real(rstd) :: maxq,minq,minq_c,maxq_c
real(rstd) :: alphamx,alphami,alpha,maggrd
real(rstd) :: arr(2*iim*jjm)
real(rstd) :: ar(iim*jjm)
real(rstd) :: gradtri(2*iim*jjm,llm,3)
integer :: ij,k,l
real(rstd) :: detx,dety,detz,det
real(rstd) :: a(3,3), a11,a12,a13,a21,a22,a23,a31,a32,a33
real(rstd) :: x1,x2,x3
real(rstd) :: dq(3)
subroutine gradq(n0,l,n1,n2,n3,q,dq1,dq2,dq3,det)
integer, intent(in) :: n0,l,n1,n2,n3
real(rstd), intent(in)     :: q(iim*jjm,llm)
real(rstd), intent(out)    :: dq1,dq2,dq3,det
real(rstd)    :: dq(3)
real(rstd) :: a(3,3)
end subroutine gradq
subroutine determinant(a11,a12,a13,a21,a22,a23,a31,a32,a33,det)
real(rstd), intent(in) :: a11,a12,a13,a21,a22,a23,a31,a32,a33
real(rstd), intent(out) :: det
real(rstd) ::  x1,x2,x3
end subroutine determinant
end subroutine compute_gradq3d
subroutine compute_backward_traj(normal,tangent,ue,tau, cc,                                     xyz_e, de, wee, le         ) ! metrics terms
use trace
use omp_para
real(rstd),intent(in)    :: normal(3*iim*jjm,3)
real(rstd),intent(in)    :: tangent(3*iim*jjm,3)
real(rstd),intent(in)    :: ue(iim*3*jjm,llm)
real(rstd),intent(out)   :: cc(3*iim*jjm,llm,3) ! start of backward trajectory
real(rstd),intent(in)    :: tau
real(rstd),intent(in)    :: xyz_e(iim*3*jjm,3)
real(rstd),intent(in)    :: de(iim*3*jjm)
real(rstd),intent(in)    :: wee(iim*3*jjm,5,2)
real(rstd),intent(in)    :: le(iim*3*jjm)
real(rstd) :: v_e(3), up_e
integer :: ij,l
end subroutine compute_backward_traj
subroutine compute_advect_horiz(update_mass,diagflux_on, hfluxt,cc,gradq3d, mass, qi, qfluxt,                                     ai, xyz_i)   ! metrics terms
use trace
use omp_para
use abort_mod
logical, intent(in)       :: update_mass, diagflux_on
real(rstd), intent(in)    :: gradq3d(iim*jjm,llm,3)
real(rstd), intent(in)    :: hfluxt(3*iim*jjm,llm) ! mass flux
real(rstd), intent(in)    :: cc(3*iim*jjm,llm,3)   ! barycenter of quadrilateral, where q is evaluated (1-point quadrature)
real(rstd), intent(inout) :: mass(iim*jjm,llm)
real(rstd), intent(inout) :: qi(iim*jjm,llm)
real(rstd), intent(inout) :: qfluxt(3*iim*jjm,merge(llm,1,diagflux_on)) ! time-integrated tracer flux
real(rstd), intent(in)    :: ai(iim*jjm)
real(rstd), intent(in)    :: xyz_i(iim*jjm,3)
real(rstd) :: dq,dmass,qe,newmass
real(rstd) :: qflux(3*iim*jjm,llm)
integer :: ij,l,ij_tmp
end subroutine compute_advect_horiz
end module advect_mod
