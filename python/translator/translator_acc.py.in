# local imports
#from translator.translator_f03 import *
#import utils

# clauses

# directives without arguements
#emptyString = ""
#singleDirDict = {
#    'loop': 'parallel do',
#    'gang': emptyString,
#    'independent': emptyString,
#    'parallel': 'target teams distribute',
#    'vector': 'simd',
#    'routine': 'declare target',
#    'seq': emptyString,
#    'data': 'data',
#    'end': 'end',
#    'enter': 'target enter',
#    'exit': 'target exit',
#    'atomic': 'atomic',
#    'serial': 'target',
#    'declare': 'declare target',
#}

#dualDirDict = {}
#
## directives with arguements
#singleDirwargsDict = {
#    'attach': 'map(to:',
#    'detach': 'map(from:',
#    'copy': 'map(tofrom:',
#    'copyin': 'map(to:',
#    'copyout': 'map(from:',
#    'create': 'map(alloc:',
#    'delete': 'map(release:',
#    'async': 'depend(out:',
#    'wait': 'task depend(in:',
#    'collapse': 'collapse(',
#    'private': 'private(',
#    'vector_length': 'simd simdlen(',
#    'num_gangs': 'num_teams(',
#    'present': emptyString,
#}
#
#dualDirwargsDict = {
#    'update host': 'target update from(',
#    'update device': 'target update to(',
#}

class TTAccClauseGang(TTNode):
    def _assignFields(self,tokens):
        self._value = tokens[0]
    def value(self):
        return self._value
class TTAccClauseWorker(TTNode):
    def _assignFields(self,tokens):
        self._value = tokens[0]
    def value(self):
        return self._value
class TTAccClauseVector(TTNode):
    def _assignFields(self,tokens):
        self._value = tokens[0]
    def value(self):
        return self._value
class TTAccClauseNumGangs(TTAccClauseGang):
    pass
class TTAccClauseNumWorkers(TTAccClauseWorker):
    pass
class TTAccClauseVectorLength(TTAccClauseVector):
    pass
class TTAccClauseDeviceType(TTNode):
    def _assignFields(self,tokens):
        self._deviceTypes = tokens
    def deviceTypes(self):
        return self._deviceTypes
class TTAccClauseIf(TTNode):
    def _assignFields(self,tokens):
        self._condition = tokens[0]
    def condition(self):
        return self._condition.fStr()

class TTSimpleMapping(TTNode):
    def _assignFields(self,tokens):
        self._varList = tokens[0].asList()
    def varNames():
        return [ var.varName() for var in self._varList ]
class TTAccClauseCopy(TTSimpleMapping):
    pass
class TTAccClauseCopyin(TTSimpleMapping):
    pass
class TTAccClauseCopyout(TTSimpleMapping):
    pass
class TTAccClauseCreate(TTSimpleMapping):
    pass
class TTAccClauseNoCreate(TTSimpleMapping):
    pass
class TTAccClausePresent(TTSimpleMapping):
    pass
class TTAccClauseDeviceptr(TTSimpleMapping):
    pass
class TTAccClauseAttach(TTSimpleMapping):
    pass
class TTAccClauseDetach(TTSimpleMapping):
    pass
class TTAccClausePrivate(TTSimpleMapping):
    pass
class TTAccClauseFirstprivate(TTSimpleMapping):
    pass
class TTAccClauseUseDevice(TTSimpleMapping):
    pass
class TTAccClauseDevice(TTSimpleMapping):
    pass
class TTAccClauseHost(TTSimpleMapping):
    pass
class TTAccClauseLink(TTSimpleMapping):
    pass
class TTAccClauseDefault(TTNode):
    def _assignFields(self,tokens):
        self._value = tokens
    def value(self):
        return self._value
class TTAccReductionVar(TTNode):
    def _assignFields(self,tokens):
        self._operator, self._var = tokens
        # post-process
        # "+" "*" "max" "min" "iand" "ior" "ieor" ".and." ".or." ".eqv." ".neqv."
        self._operator = self._operator.replace(".","")
        self._operator = self._operator.replace("+","add")
        self._operator = self._operator.replace("*","mult")
class TTAccClauseReduction(TTNode):
    def _assignFields(self,tokens):
        self._reductions = findAll(tokens[0],TTAccClauseReductionVar)
    def reductionVars(self):
        result = {}
        for red in self._reductions:
            varName = makeCStr(red._var)
            result[varName] = makeCStr(red._operator) 
        return result
class TTAccClauseRoutine(TTNode):
    def _assignFields(self,tokens):
        pass
class TTAccClauseBind(TTNode):
    def _assignFields(self,tokens):
        pass
class TTAccClauseDelete(TTNode):
    def _assignFields(self,tokens):
        pass
class TTAccClauseDeviceResident(TTSimpleMapping):
    pass
class TTAccClauseTile(TTNode):
    def _assignFields(self,tokens):
        self._tilesPerDim = tokens[0]
    def values():
        return self._tilesPerDim
class TTAccClauseCollapse(TTNode):
    def _assignFields(self,tokens):
        self._value = tokens[0]
    def value(self):
        return int(self._value._value)
class TTAccClauseWait(TTNode):
    def _assignFields(self,tokens):
        self._expressions = list(tokens[0])
    def expressions(self):
        return self._expressions
class TTAccClauseAsync(TTNode):
    def _assignFields(self,tokens):
        self._expression = tokens[0]
    def expression(self):
        return makeFStr(self._expression)

#
# Directives
#

class TTAccDirectiveBase(TTNode):
    def _assignFields(self,tokens):
       self._clauses = tokens
    def ompFStr(self):
       assert False, "Not implemented"     

class TTAccDataManagementDirectiveBase(TTAccDirectiveBase):
    """
    Abstract class that handles the following clauses
      if( condition )
      copy( var-list )
      copyin( [readonly:]var-list )
      copyout( var-list )
      create( var-list )
      no_create( var-list )
      present( var-list )
      deviceptr( var-list )
      attach( var-list )
      default( none | present )
    which are common to data to parallel, kernels and data directives.
    """
    def __handleSimpleMapping(self,clauseType):
        clause = findFirst(self._clauses,clauseType)
        if not clause is None:
            return clause.varNames()
        else:
            return []
    def devicePtrs(self):
        return self.__handleSimpleMapping(TTAccClauseDeviceptr)
    def createAllocVars(self):
        return self.__handleSimpleMapping(TTAccClauseCreate)
    def no_createVars(self):
        return self.__handleSimpleMapping(TTAccClauseNoCreate)
    def presentVars(self):
        return self.__handleSimpleMapping(TTAccClausePresent)
    def copyMapToFromVars(self):
        return self.__handleSimpleMapping(TTAccClauseCopy)
    def copyinMapToAttachVars(self):
        return self.__handleSimpleMapping(TTAccClauseCopyin) +\
               self.__handleSimpleMapping(TTAccClauseAttach)
    def copyoutMapFromDetachVars(self):
        return self.__handleSimpleMapping(TTAccClauseCopyout) +\
               self.__handleSimpleMapping(TTAccClauseDetach)
    def deleteReleaseVars(self):
        return self.__handleSimpleMapping(TTAccClauseDelete)
    def conditionFStr(self):
        clause = findFirst(self._clauses,TTAccClauseIf)
        if not clause is None:
            return [makeFStr(e) for e in clause.expressions()]
        else:
            return ""
    def conditionCStr(self):
        clause = findFirst(self._clauses,TTAccClauseIf)
        if not clause is None:
            return [makeCStr(e) for e in clause.expressions()]
        else:
            return ""
    def presentByDefault(self):
        clause = findFirst(self._clauses,TTAccClauseDefault)
        if not clause is None:
            return clause.value() == "present"
        else:
            return True
    def ompFStr(self,prefix=""):
        """
        :return: 'prefix' [mapped-clauses]
        
        where the clauses are mapped as follows:
        
        attach:    "map(to: var-list)"
        copyin:    "map(to: var-list)"
        detach:    "map(from: var-list)"
        copyout:   "map(from: var-list)"
        copy:      "map(tofrom: var-list)"
        create:    "map(alloc: var-list)"
        delete:    "map(release: var-list)"
        present:   "" 
        no_create: ""
        """
        result      = prefix
        toList      = self.copyinMapToAttachVars()
        fromList    = self.copyoutMapFromDetachVars()
        tofromList  = self.copyMapToFromVars()
        allocList   = self.createAllocVars()
        releaseList = self.deleteReleaseVars()       
        if len(toList):
            result += " map(to:"+",".join(toList)+")"
        if len(fromList):
            result += " map(from:"+",".join(fromList)+")"
        if len(tofromList):
            result += " map(tofrom:"+",".join(tofromList)+")"
        if len(allocList):
            result += " map(alloc:"+",".join(allocList)+")"
        if len(releaseList):
            result += " map(release:"+",".join(releaseList)+")"
        return result

class TTAccData(TTAccDataManagementDirectiveBase):
    """
    possible clauses
      if( condition )
      copy( var-list )
      copyin( [readonly:]var-list )
      copyout( var-list )
      create( var-list )
      no_create( var-list )
      present( var-list )
      deviceptr( var-list )
      attach( var-list )
      default( none | present )
    """
    
class TTAccData(TTAccDataManagementDirectiveBase):

class TTAccDeclare(TTAccDirectiveBase):
    """ NOTE: In contrast to OMP, '!$acc declare' is only applied to global variables.
    There is '!$acc routine' for routines.
    """
    def __handleSimpleMapping(self,clauseType):
        clause = findFirst(self._clauses,clauseType)
        if not clause is None:
            return clause.varNames()
        else:
            return []
    def ompFStr(self):
        toList =\
          self.__handleSimpleMapping(TTAccClauseCreate) +\
          self.__handleSimpleMapping(TTAccClauseCopy) +\
          self.__handleSimpleMapping(TTAccClauseCopyin) +\
          self.__handleSimpleMapping(TTAccClauseAttach) +\
          self.__handleSimpleMapping(TTAccClauseCopyout) +\
          self.__handleSimpleMapping(TTAccClauseDetach)
    
       # TODO: not sure about this mapping       
       toList += self.__handleSimpleMapping(TTAccClauseDeviceResident)

       linkList = self.__handleSimpleMapping(TTAccClauseLink)
       
       result = "!$omp target declare"
       if len(toList):
           result += " to("+",".join(toList)+")"
       if len(linkList):
           result += " link("+",".join(linkList)+")"
       return result

class TTAccRoutine(TTAccDirectiveBase):
    def _assignFields(self,tokens):
        self._id, self._clauses = tokens
    def ompFStr(self,additions=""):
        """ additions can be used to pass 'notinbranch' 'inbranch'"""
        result = "!$omp target declare"
        #if findFirst(self._clauses,TTAccClauseGang) is not None:
        #    pass
        #elif findFirst(self._clauses,TTAccClauseWorker) is not None:
        #    pass
        if findFirst(self._clauses,TTAccClauseVector) is not None:
            if self._id not None:
                result += " simd("+makeFStr(self._id)+")"
            else:
                result += " simd "
        #if not "device_type" in additions:
        #    result += " device_type(any)"
        result += " "+additions
       return result

class TTAccUpdate(TTAccDirectiveBase):
    def ompFStr(self):
        result = "!$omp target update"
        hostClause   = findFirst(self._clauses,TTAccClauseHost)
        deviceClause = findFirst(self._clauses,TTAccClauseDevice)
        if hostClause not None:
            result += " to("+",".join(hostClause.varNames())+")"
        if deviceClause not None:
            result += " from("+",".join(deviceClause.varNames())+")"
        return result

class TTAccWait(TTAccDirectiveBase):
    def waitArgs(self):
        """ Can be used to deduce task dependencies """
        clause = findFirst(self._clauses,TTAccClauseWait)
        if clause is None:
            return None
        else:
            return clause.expressions()
    def asyncQueue(self):
        assert False, "Not implemented!"
    def ompFStr(self,dependOut=[]):
        result = "!$omp taskwait"
        if len(dependOut):
            result += " depend(out:"+",".join(dependOut)")"
        return result

class TTAccLoop(TTAccDirectiveBase,ILoopAnnotation):
    """
    possible clauses:
      collapse( n )
      gang [( gang-arg-list )]
      worker [( [num:]int-expr )]
      vector [( [length:]int-expr )]
      seq
      auto
      tile( size-expr-list )
      device_type( device-type-list )
      independent
      private( var-list )
      reduction( operator:var-list )
    """
    def __handleSimpleMapping(self,clauseType):
        clause = findFirst(self._clauses,clauseType)
        if not clause is None:
            return clause.varNames()
        else:
            return []
    def numCollapse(self):
        clause = findFirst(self._clauses,TTAccCollapse)
        return 1 if clause is None else clause.value()
    def tileSizes(self):
        assert False, "Not implemented!"
        return [1]
    def numGangsTeamsBlocks(self):
        clauses = findAllMatching(self._clauses,lambda x: isinstance(x,TTAccClauseGang),2)
        return [CLAUSE_NOT_FOUND] if clause is None else [max([c.value() for c in clauses])]
    def numWorkers(self):
        clauses = findAllMatching(self._clauses,lambda x: isinstance(x,TTAccClauseWorker),2)
        return [CLAUSE_NOT_FOUND] if clause is None else [max([c.value() for c in clauses])]
    def simdlenVectorLength(self):
        clauses = findAllMatching(self._clauses,lambda x: isinstance(x,TTAccClauseVector),2)
        return [CLAUSE_NOT_FOUND] if clause is None else [max([c.value() for c in clauses])]
    def numThreadsInBlock(self):
        workers   = self.numWorkers()
        vectorLen = self.lenSimdVector()
        if workers[0] < 1 or vectorLen[0] < 1:
            return [CLAUSE_NOT_FOUND]
        else:
            return [workers[0] * vectorLen[0]]
    def dataIndependentIterations(self):
        """ Always assume data independent if no seq clause is used """
        clause = findFirstMatching(self._clauses,lambda x: x=="seq")
        return True if clause is None else False
    def reductionVars(self):
        clause = findFirst(self._mainDirective,TTAccClauseReduction)
        if not clause is None:
            return clause.reductionVars()
        else:
            return {}
    def privateVars(self):
        return self.__handleSimpleMapping(TTAccClausePrivate)
    def firstprivateVars(self):
        return self.__handleSimpleMapping(TTAccClauseFirstprivate)
    def ompFStr(self,prefix="!$omp",loopType="do",parallelRegion="parallel"):
        result = prefix
        def parallelismClause(clause):
            return type(clause) is TTAccClauseGang or\
                   type(clause) is TTAccClauseWorker or\
                   type(clause) is TTAccClauseVector
        for clause in findAllMatching(self._clauses,parallelismClause):
            if type(clause) is TTAccClauseGang:
                result += " teams distribute"
        result +=  " "+parallelRegion+" "+loopType
        for clause in findAllMatching(self._clauses,parallelismClause):
            if type(clause) is TTAccClauseWorker:
                pass
            elif type(clause) is TTAccClauseVector:
                result += " simd"
                if clause.value() > 0:
                    result += " simd simdlen("+str(clause.value())+")"
        privateVars = self.privateVars() 
        if len():
            result += " private("+",".join(privateVars+")" 
        if len(self.reductionVars()):
            result += " reduction("+",".join(self.firstprivateVars())+")" 
        #if len(self.firstprivateVars()):
        #    result += " firstprivate("+",".join(self.firstprivateVars())+")" 
        #if len(self.sharedVars()):
        #    result += " shared("+",".join(self.sharedVars())+")" 
        return result


class TTAccParallel(TTAccDataManagementDirectiveBase):
    """
    possible clauses:
      async [( int-expr )]
      wait [( int-expr-list )]
      num_gangs( int-expr )
      num_workers( int-expr )
      vector_length( int-expr )
      device_type( device-type-list )
      if( condition )
      self [( condition )]
      reduction( operator:var-list )
      copy( var-list )
      copyin( [readonly:]var-list )
      copyout( var-list )
      create( var-list )
      no_create( var-list )
      present( var-list )
      deviceptr( var-list )
      attach( var-list )
      private( var-list )
      firstprivate( var-list )
      default( none | present )
    """
    def __handleSimpleMapping(self,clauseType):
        clause = findFirst(self._clauses,clauseType)
        if not clause is None:
            return clause.varNames()
        else:
            return []
    def deviceTypes(self): 
        return "*"
    def condition(self): 
        """ OMP,ACC: accelerate only if condition is satisfied. Empty string means condition is satisfied. """
        return ""
    def asyncNowait(): 
        return CLAUSE_NOT_FOUND
    def ompFStr(self,prefix="!$omp target teams distribute"):
        result   = prefix 
        dataPart = " "+TTAccDataManagementDirectiveBase.ompFStr(self,prefix="")
        # TODO add more details
        return result

class TTAccParallelLoop(TTAccParallel,TTAccLoop):
    def ompFStr(self,prefix="!$omp",parallelRegion="",loopType="do"):
        dataPart = " "+TTAccParallel.ompFStr(self,prefix="")
        loopPart = TTAccLoop.ompFStr(self,"")
        result   = "!$omp target"
        if not "teamsdistribute" in loopPart.replace(" ",""):
           result += " teams distribute" 
        return result + " " + loopPart + " " + dataPart

# TODO treat kernels and parallel same way for now
class TTAccKernels(TTAccParallel):
    pass
class TTAccKernelsLoop(TTAccParallelLoop):
    pass

acc_clause_gang.setParseAction(TTAccClauseGang)
acc_clause_worker.setParseAction(TTAccClauseWorker)
acc_clause_vector.setParseAction(TTAccClauseVector)
acc_clause_num_gangs.setParseAction(TTAccClauseNumGangs)
acc_clause_num_workers.setParseAction(TTAccClauseNumWorkers)
acc_clause_vector_length.setParseAction(TTAccClauseVectorLength)

acc_clause_device_type.setParseAction(TTAccClauseDeviceType)
acc_clause_if.setParseAction(TTAccClauseIf)

acc_clause_copy.setParseAction(TTAccClauseCopy)
acc_clause_copyin.setParseAction(TTAccClauseCopyin)
acc_clause_copyout.setParseAction(TTAccClauseCopyout)

acc_clause_create.setParseAction(TTAccClauseCreate)
acc_clause_no_create.setParseAction(TTAccClauseNoCreate)
acc_clause_present.setParseAction(TTAccClausePresent)
acc_clause_deviceptr.setParseAction(TTAccClauseDeviceptr)
acc_clause_attach.setParseAction(TTAccClauseAttach)
acc_clause_detach.setParseAction(TTAccClauseDetach)
acc_clause_default.setParseAction(TTAccClauseDefault)
acc_clause_use_device.setParseAction(TTAccClauseUseDevice)
acc_clause_private.setParseAction(TTAccClausePrivate)
accReductionVar.setParseAction(TTAccReductionVar)
acc_clause_reduction.setParseAction(TTAccClauseReduction)
acc_clause_delete.setParseAction(TTAccClauseDelete)
acc_clause_routine.setParseAction(TTAccClauseRoutine)
acc_clause_private.setParseAction(TTAccClausePrivate)
acc_clause_first_private.setParseAction(TTAccClauseFirstprivate)
acc_clause_collapse.setParseAction(TTAccClauseCollapse)
acc_clause_host.setParseAction(TTAccClauseHost)
acc_clause_self.setParseAction(TTAccClauseHost)
acc_clause_bind.setParseAction(TTAccClauseBind)
acc_clause_device_resident.setParseAction(TTAccClauseDeviceResident)
acc_clause_link.setParseAction(TTAccClauseLink)
acc_clause_tile.setParseAction(TTAccClauseTile)
acc_clause_wait.setParseAction(TTAccClauseWait)
acc_clause_async.setParseAction(TTAccClauseAsync)

acc_loop.setParseAction(TTAccLoop)
acc_parallel_loop.setParseAction(TTAccParallelLoop)
acc_kernels_loop.setParseAction(TTAccKernelsLoop)


# TODO parsing and translation is similar but analysis differs between the different kernel
# types. For example for CUF, the reduction vars must be detected by the parser (lhs scalars)
# while they are specified with ACC,OMP.
recursionsLeft=0
def convertAccLoopKernel2Hip(fortranSnippet,maxRecursions=30):
    """
    Return a csnippet equivalent to the original Fortran code.
    """
    global KEYWORDS 

    def convertAccKernel2HipRecursively(fortranSnippet,recursionsToGo):
        global recursionsLeft
        recursionsLeft = recursionsToGo
        try:
            return lookKernel.parseString(fortranSnippet)[0]
        except ParseBaseException as pbe:
            if recursionsToGo <= 0:
                raise pbe
            else:
                lineno = pbe.__getattr__("lineno")
                lines = fortranSnippet.split("\n")
                lines[lineno-1] = "! TODO could not parse: {}".format(lines[lineno-1])
                modifiedFortranSnippet = "\n".join(lines)
                #print(modifiedFortranSnippet)
                return convertAccKernel2HipRecursively(modifiedFortranSnippet,recursionsToGo-1)
        except Exception as e:
            raise e        
   
    fortranSnippet = prepareFortranSnippet(fortranSnippet)
    try:
        result           = convertAccKernel2HipRecursively(fortranSnippet,maxRecursions)
        cSnippet         = utils.prettifyCCode(result.cStr())
        
        kernelLaunchInfo = result.kernelLaunchInfo()
        identifierNames  = result.allIdentifiers()
        loopVars         = result.loopVars()
        localLvalues     = list(filter(lambda x: x not in loopVars, result.allLocalLvalues())) 
        localLvalues     += result.threadPrivateVars()
        reductionVars    = result.reductionVars()
        problemSize      = result.problemSize()
        #print(recursionsLeft)
        if recursionsLeft < maxRecursions:
            body = "\n".join(fortranSnippet.split("\n")[1:])
            identifierNames = list(set(filter(lambda x: x.lower() not in KEYWORDS,[makeFStr(ident) for ident in identifier.searchString(body)])))
            #print(identifierNames) 
        cSnippet = postprocessCSnippet(cSnippet)
    except Exception as e:
        raise e
        logger = logging.getLogger('') 
        logger.error("failed to convert kernel:\n{}".format(fortranSnippet))
        logger.error(str(e))
        cSnippet = "" 
        pragmaLine = fortranSnippet.split("\n")[0]
        body = "\n".join(fortranSnippet.split("\n")[1:])
        #kernelLaunchInfo = acc.parseString(pragmaLine)[0] 
        kernelLaunchInfo = LaunchInfo()
        #print(body)
        identifierNames = list(set(filter(lambda x: x.lower() not in KEYWORDS,[makeFStr(ident) for ident in identifier.searchString(body)])))
        numOuterLoopsToMap     = int(kernelLaunchInfo._numOuterLoopsToMap)
        loopVars        = []
        localLvalues    = []
        reductionVars   = []
        problemSize     = ["TODO unknown"]*numOuterLoopsToMap
        #print(type(e))
    return cSnippet, problemSize, kernelLaunchInfo, identifierNames, localLvalues, loopVars, reductionVars
