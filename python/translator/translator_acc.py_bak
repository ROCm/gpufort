# local imports
#from translator.translator_f03 import *
#import utils

class TTAccIf(TTNode):
    def assignFields(self,tokens):
        self.condition = tokens[0]
    def cStr(self):
        return makeCStr(self.condition)

class TTAccSelf(TTNode):
    def assignFields(self,tokens):
        self.condition = tokens[0]
    def cStr(self):
        return makeCStr(self.condition)

class TTAccAsync(TTNode):
    def assignFields(self,tokens):
        self.queue = tokens[0]
    def cStr(self):
        return makeCStr(self.queue)

class TTAccWait(TTNode):
    def assignFields(self,tokens):
        self.queues = tokens[0]
    def cStr(self):
        return makeCStr(self.queues)

class TTAccNumGangs(TTNode):
    def assignFields(self,tokens):
        self.gangs = tokens[0]
    def cStr(self):
        return makeCStr(self.gangs)

class TTAccNumWorkers(TTNode):
    def assignFields(self,tokens):
        self.workers = tokens[0]
    def cStr(self):
        return makeCStr(self.workers)

class TTAccVectorLen(TTNode):
    def assignFields(self,tokens):
        self.vectorlen = tokens[0]
    def cStr(self):
        return makeCStr(self.vectorlen)

class TTAccCopy(TTNode):
    def assignFields(self,tokens):
        self.copy = tokens[0]
    def cStr(self):
        return makeCStr(self.copy)

class TTAccCopyIn(TTNode):
    def assignFields(self,tokens):
        self.copyin = tokens[0]
    def cStr(self):
        return makeCStr(self.copyin)

class TTAccCopyOut(TTNode):
    def assignFields(self,tokens):
        self.copyout = tokens[0]
    def cStr(self):
        return makeCStr(self.copyout)

class TTAccCreate(TTNode):
    def assignFields(self,tokens):
        self.create = tokens[0]
    def cStr(self):
        return makeCStr(self.create)

class TTAccPresent(TTNode):
    def assignFields(self,tokens):
        self.present = tokens[0]
    def cStr(self):
        return makeCStr(self.present)

class TTAccDevicePtr(TTNode):
    def assignFields(self,tokens):
        self.deviceptr = tokens[0]
    def cStr(self):
        return makeCStr(self.deviceptr)

class TTAccDefault(TTNode):
    def assignFields(self,tokens):
        self.default = tokens[0]
    def cStr(self):
        return makeCStr(self.default)

class TTAccPrivate(TTNode):
    def assignFields(self,tokens):
        self.private = tokens[0]
    def cStr(self):
        return makeCStr(self.private)

class TTAccFirstPrivate(TTNode):
    def assignFields(self,tokens):
        self.firstprivate = tokens[0]
    def cStr(self):
        return makeCStr(self.firstprivate)

class TTAccNoCreate(TTNode):
    def assignFields(self,tokens):
        self.nocreate = tokens[0]
    def cStr(self):
        return makeCStr(self.nocreate)

class TTAccDelete(TTNode):
    def assignFields(self,tokens):
        self.delete = tokens[0]
    def cStr(self):
        return makeCStr(self.delete)

class TTAccReduceOperator(TTNode):
    def assignFields(self,tokens):
        self.operator = tokens[0]
    def cStr(self):
        return makeCStr(self.operator)

class TTAccReduction(TTNode):
    def assignFields(self,tokens):
        self.operator = tokens[0]
        self.var = tokens[1]
    def cStr(self):
        def processList(var):
            if var == None:
                return var
            temp = []
            iden =  findAll(var,TTIdentifier)
            for i in range(len(iden)):
                temp.append(iden[i].cStr())
            return temp
        return makeCStr(self.operator)+", "+str(processList(self.var))

class TTAccDetach(TTNode):
    def assignFields(self,tokens):
        self.detach=tokens[0]
    def cStr(self):
        return makeCStr(self.detach)

class TTAccUseDevice(TTNode):
    def assignFields(self,tokens):
        self.usedevice=tokens[0]
    def cStr(self):
        return makeCStr(self.usedevice)

class TTAccCollapse(TTNode):
    def assignFields(self,tokens):
        self.collapse=tokens[0]
    def cStr(self):
        return makeCStr(self.collapse)
   
class TTAccDevice(TTNode):
    def assignFields(self,tokens):
        self.device=tokens[0]
    def cStr(self):
        return makeCStr(self.device)

class TTAccBind(TTNode):
    def assignFields(self,tokens):
        self.bind=tokens[0]
    def cStr(self):
        return makeCStr(self.bind)

class TTAccDeviceResident(TTNode):
    def assignFields(self,tokens):
        self.device_resident=tokens[0]
    def cStr(self):
        return makeCStr(self.device_resident)

class TTAccLink(TTNode):
    def assignFields(self,tokens):
        self.link=tokens[0]
    def cStr(self):
        return makeCStr(self.link)

class TTAccTile(TTNode):
    def assignFields(self,tokens):
        self.tile=tokens[0]
    def cStr(self):
        return makeCStr(self.tile)

class TTAccSeq(TTNode):
    def assignFields(self,tokens):
        self.seq=tokens[0]
    def cStr(self):
        return self.seq

class TTAccAuto(TTNode):
    def assignFields(self,tokens):
        self.auto=tokens[0]
    def cStr(self):
        return self.auto

class TTAccIndependent(TTNode):
    def assignFields(self,tokens):
        self.independent=tokens[0]
    def cStr(self):
        return self.independent

class TTAccRead(TTNode):
    def assignFields(self,tokens):
        self.read=tokens[0]
    def cStr(self):
        return self.read

class TTAccWrite(TTNode):
    def assignFields(self,tokens):
        self.write=tokens[0]
    def cStr(self):
        return self.write

class TTAccUpdate(TTNode):
    def assignFields(self,tokens):
        self.update=tokens[0]
    def cStr(self):
        return self.update

class TTAccCapture(TTNode):
    def assignFields(self,tokens):
        self.capture=tokens[0]
    def cStr(self):
        return self.capture

class TTAccGang(TTNode):
    def assignFields(self,tokens):
        self.gang,self.numgang = tokens
    def cStr(self):
        return self.gang + "," + makeCStr(self.numgang)

class TTAccVector(TTNode):
    def assignFields(self,tokens):
        self.vector,self.numvector = tokens
    def cStr(self):
        return self.vector + "," + makeCStr(self.numvector)

class TTAccWorker(TTNode):
    def assignFields(self,tokens):
        self.worker,self.numworker = tokens
    def cStr(self):
        return self.worker + "," + makeCStr(self.numworker)

class TTAccPragma(TTNode):
    def assignFields(self,tokens):
        def findClause(expr):
            temp = findAll(self.clauses,expr)
            if len(temp) > 0:
                return temp
            elif expr == TTAccNumGangs:
                return -1
            elif expr == TTAccNumWorkers:
                return -1
            elif expr == TTAccVectorLen:
                return -1
            elif expr == TTAccCollapse:
                return -1
            else:
                return None
        self.clauses = tokens
        #print(self.clauses)
        self.if_clause = findClause(TTAccIf)
        self.self_clause = findClause(TTAccSelf)
        self.async = findClause(TTAccAsync)
        self.wait = findClause(TTAccWait)
        self.num_gangs = findClause(TTAccNumGangs)
        self.num_workers = findClause(TTAccNumWorkers)
        self.vector_len = findClause(TTAccVectorLen)
        self.copy = findClause(TTAccCopy)
        self.copyin = findClause(TTAccCopyIn)
        self.copyout = findClause(TTAccCopyOut)
        self.create = findClause(TTAccCreate)
        self.present = findClause(TTAccPresent)
        self.device_ptr = findClause(TTAccDevicePtr)
        self.default = findClause(TTAccDefault)
        self.private = findClause(TTAccPrivate)
        self.first_private = findClause(TTAccFirstPrivate)
        self.no_create = findClause(TTAccNoCreate)
        self.delete = findClause(TTAccDelete)
        self.reduction = findClause(TTAccReduction)
        self.detach=findClause(TTAccDetach)
        self.usedevice=findClause(TTAccUseDevice)
        self.collapse=findClause(TTAccCollapse)
        self.device=findClause(TTAccDevice)
        self.bind=findClause(TTAccBind)
        self.device_resident=findClause(TTAccDeviceResident)
        self.link=findClause(TTAccLink)
        self.tile = findClause(TTAccTile)
        self.seq = findClause(TTAccSeq)
        self.auto = findClause(TTAccAuto)
        self.independent = findClause(TTAccIndependent)
        self.read =  findClause(TTAccRead)
        self.write =  findClause(TTAccWrite)
        self.update =  findClause(TTAccUpdate)
        self.capture =  findClause(TTAccCapture)
        self.gang = findClause(TTAccGang)
        self.vector = findClause(TTAccVector)
        self.worker = findClause(TTAccWorker)

    def cStr(self):
        def process(var):
            if var == None or var == -1:
                return var
            temp = ""
            for v in var:
                temp += makeCStr(v)
            return temp
        def processList(var):
            if var == None:
                return var
            elif isinstance(var,TTAccWait) or isinstance(var,TTAccTile):
                temp=[]
                num = findAll(var,TTAccNumber)
                for i in range(len(num)):
                    temp.append(num[i].cStr())
                return temp
            temp = []
            for v in var:
                iden =  findAll(v,TTIdentifier)
                for i in range(len(iden)):
                    temp.append(iden[i].cStr())
            return temp
        def isClausePresent(var):
            if var == None:
                return "No"
            elif isinstance(var[0],TTAccGang) or isinstance(var[0],TTAccVector) or isinstance(var[0],TTAccWorker):
                return var[0].cStr()
            else:
                return "Yes"
        cStr = "// NOTE: The following information was given in the orignal OpenACC kernel pragma:\n"
        cStr += "// - If condition: {}\n".format(process(self.if_clause))
        cStr += "// - Self condition: {} (True if no condition is provided)\n".format(process(self.self_clause))
        cStr += "// - Async Queues: {}\n".format(process(self.async))
        cStr += "// - Wait Queues: {}\n".format(processList(self.wait))
        cStr += "// - Number of gangs: {} ('-1' means not specified)\n".format(process(self.num_gangs))
        cStr += "// - Number of workers: {} ('-1' means not specified)\n".format(process(self.num_workers))
        cStr += "// - Vector length: {} ('-1' means not specified)\n".format(process(self.vector_len))
        cStr += "// - copy variables: {}\n".format(processList(self.copy))
        cStr += "// - copyin variables: {}\n".format(processList(self.copyin))
        cStr += "// - copyout variables: {}\n".format(processList(self.copyout))
        cStr += "// - create variables: {}\n".format(processList(self.create))
        cStr += "// - present variables: {}\n".format(processList(self.present))
        cStr += "// - device pointer variables: {}\n".format(processList(self.device_ptr))
        cStr += "// - default type: {}\n".format(process(self.default))
        cStr += "// - private varibales: {}\n".format(processList(self.private))
        cStr += "// - first private varibales: {}\n".format(processList(self.first_private))
        cStr += "// - no create varibales: {}\n".format(processList(self.no_create))
        cStr += "// - delete varibales: {}\n".format(processList(self.delete))
        cStr += "// - reduce operator, variables: {}\n".format(process(self.reduction))
        cStr += "// - Detach Vars:  {}\n".format(processList(self.detach))  
        cStr += "// - Use_Device Name: {}\n".format(processList(self.usedevice))
        cStr += "// - Collapse Value: {} ('-1' means not specified)\n".format(process(self.collapse))
        cStr += "// - Device Vars: {}\n".format(processList(self.device))
        cStr += "// - Bind name: {}\n".format(process(self.bind))
        cStr += "// - Device Resident Vars: {}\n".format(processList(self.device_resident))
        cStr += "// - Link Objects: {}\n".format(processList(self.link))
        cStr += "// - Tile Dimensions: {}\n".format(processList(self.tile))
        cStr += "// - Seq Clause: {}\n".format(isClausePresent(self.seq))
        cStr += "// - Auto Clause: {}\n".format(isClausePresent(self.auto))
        cStr += "// - Independent Clause: {}\n".format(isClausePresent(self.independent))
        cStr += "// - Read Clause: {}\n".format(isClausePresent(self.read))
        cStr += "// - Write Clause: {}\n".format(isClausePresent(self.write))
        cStr += "// - Update Clause: {}\n".format(isClausePresent(self.update))
        cStr += "// - Capture Clause: {}\n".format(isClausePresent(self.capture))
        cStr += "// - Gang, numgangs: {} ('-1' means not specified)\n".format(isClausePresent(self.gang))
        cStr += "// - Vector, numvector: {} ('-1' means not specified)\n".format(isClausePresent(self.vector))
        cStr += "// - Worker, numworker: {} ('-1' means not specified)\n".format(isClausePresent(self.worker))

        return cStr

class TTAccKernels(TTNode):
    def assignFields(self,tokens):
         #print(tokens)
         self.pragma, self.body  = tokens
    
    def printTokens(self):
        print(self.pragma)
        print(self.body)
        print(flattenBody(self.body))
        print(self.pragma[0].cStr())
    
    def cStr(self):
        doLoops = findAll(self.body,TTDoLoop)
        print(self.body)
        #numLoopsToMap = 1
        numLoopsToMap = min(3,len(doLoops))
        threadIndices = ["x","y","z"]
        for i in range(0,3-numLoopsToMap):
            threadIndices.pop()
        hipThreadIndices    = ""
        hipThreadConditions = []
        for loop in doLoops:
            loop.threadIndex = threadIndices.pop()
            hipThreadIndices   += loop.hipThreadIndexCStr()
            hipThreadConditions.append(loop.hipThreadBoundCStr())
            if not len(threadIndices):
                break
        return "{0}if ({1}) {{\n{2}}}".format(hipThreadIndices,"&&".join(hipThreadConditions),makeCStr(self.body))

class TTAccParallel(TTNode):
    def assignFields(self,tokens):
        self.pragma, self.body = tokens

    def printTokens(self):
        print(self.pragma)
        print(self.pragma[0].cStr())

    def cStr(self):
        doLoops = findAll(self.body,TTDoLoop)
        numLoopsToMap = 1
        threadIndices = ["x","y","z"]
        for i in range(0,3-numLoopsToMap):
            threadIndices.pop()
        hipThreadIndices = ""
        hipThreadConditions = []
        for loop in doLoops:
            loop.threadIndex = threadIndices.pop()
            hipThreadIndices += loop.hipThreadIndexCStr()
            hipThreadConditions.append(loop.hipThreadBoundCStr())
            if not len(threadIndices):
                break
        return "{0}if ({1}) {{\n{2}}}".format(hipThreadIndices,"&&".join(hipThreadConditions),makeCStr(self.body))

class TTAccWait(TTNode):
    def assignFields(self,tokens):
        self.pragma = tokens[0]
    def printTokens(self):
        print(self.pragma)
        print(self.pragma[0].cStr())
    def cStr(self):
        pass

class TTAccHostData(TTNode):
    def assignFields(self,tokens):
        self.pragma,self.body = tokens
    def printTokens(self):
        print(self.pragma)
        print(self.pragma[0].cStr())

    def cStr(self):
        doLoops = findAll(self.body,TTDoLoop)
        #print(self.body)
        #numLoopsToMap = min(3,int(self.pragma.numLoopsToMap))
        numLoopsToMap = 1
        threadIndices = ["x","y","z"]
        for i in range(0,3-numLoopsToMap):
            threadIndices.pop()
        hipThreadIndices    = ""
        hipThreadConditions = []
        for loop in doLoops:
            loop.threadIndex = threadIndices.pop()
            hipThreadIndices   += loop.hipThreadIndexCStr()
            hipThreadConditions.append(loop.hipThreadBoundCStr())
            if not len(threadIndices):
                break
        return "{0}if ({1}) {{\n{2}}}".format(hipThreadIndices,"&&".join(hipThreadConditions),makeCStr(self.body))

class TTAccData(TTNode):
    def assignFields(self,tokens):
        self.pragma,self.body = tokens
    def printTokens(self):
        print(self.pragma)
        print(self.pragma[0].cStr())

    def cStr(self):
        doLoops = findAll(self.body,TTDoLoop)
        #print(self.body)
        #numLoopsToMap = min(3,int(self.pragma.numLoopsToMap))
        numLoopsToMap = 1
        threadIndices = ["x","y","z"]
        for i in range(0,3-numLoopsToMap):
            threadIndices.pop()
        hipThreadIndices    = ""
        hipThreadConditions = []
        for loop in doLoops:
            loop.threadIndex = threadIndices.pop()
            hipThreadIndices   += loop.hipThreadIndexCStr()
            hipThreadConditions.append(loop.hipThreadBoundCStr())
            if not len(threadIndices):
                break
        return "{0}if ({1}) {{\n{2}}}".format(hipThreadIndices,"&&".join(hipThreadConditions),makeCStr(self.body))

class TTAccEnterData(TTNode):
    def assignFields(self,tokens):
        self.pragma = tokens[0]
    def printTokens(self):
        print(self.pragma)
        print(self.pragma[0].cStr())
    def cStr(self):
        pass

class TTAccExitData(TTNode):
    def assignFields(self,tokens):
        self.pragma = tokens[0]
    def printTokens(self):
        print(self.pragma)
        print(self.pragma[0].cStr())
    def cStr(self):
        pass

class TTAccLoop(TTNode):
    def assignFields(self,tokens):
        self.pragma = tokens[0]
    def printTokens(self):
        print(self.pragma[0])
        print(self.pragma[0].cStr())
    def cStr(self):
        return self.pragma[0].cStr() 

class TTAccRoutine(TTNode):
    def assignFields(self,tokens):
        self.name, self.pragma = tokens
    def printTokens(self):
        print(self.name)
        print(self.pragma)
    def cStr(self):
        return makeCStr(self.name)+makeCStr(self.pragma[0])

class TTAccAtomic(TTNode):
    def assignFields(self,tokens):
        self.pragma, self.body = tokens
    def printTokens(self):
        print(self.pragma)
        print(self.body)
    def cStr(self):
        doLoops = findAll(self.body,TTDoLoop)
        print(self.body)
        #numLoopsToMap = 1
        numLoopsToMap = min(3,len(doLoops))
        threadIndices = ["x","y","z"]
        for i in range(0,3-numLoopsToMap):
            threadIndices.pop()
        hipThreadIndices    = ""
        hipThreadConditions = []
        for loop in doLoops:
            loop.threadIndex = threadIndices.pop()
            hipThreadIndices   += loop.hipThreadIndexCStr()
            hipThreadConditions.append(loop.hipThreadBoundCStr())
            if not len(threadIndices):
                break
        return "{0}if ({1}) {{\n{2}}}".format(hipThreadIndices,"&&".join(hipThreadConditions),makeCStr(self.body))

class TTAccUpdate(TTNode):
    def assignFields(self,tokens):
        self.pragma = tokens[0]
    def printTokens(self):
        print(self.pragma)
    def cStr(self):
        pass

class TTAccDeclare(TTNode):
    def assignFields(self,tokens):
        self.pragma = tokens[0]
    def printTokens(self):
        print(self.pragma)
    def cStr(self):
        pass

class TTAccSerial(TTNode):
    def assignFields(self,tokens):
        self.pragma, self.body = tokens
    def printTokens(self):
        print(self.pragma)
        print(self.body)
    def cStr(self):
        doLoops = findAll(self.body,TTDoLoop)
        print(self.body)
        #numLoopsToMap = 1
        numLoopsToMap = min(3,len(doLoops))
        threadIndices = ["x","y","z"]
        for i in range(0,3-numLoopsToMap):
            threadIndices.pop()
        hipThreadIndices    = ""
        hipThreadConditions = []
        for loop in doLoops:
            loop.threadIndex = threadIndices.pop()
            hipThreadIndices   += loop.hipThreadIndexCStr()
            hipThreadConditions.append(loop.hipThreadBoundCStr())
            if not len(threadIndices):
                break
        return "{0}if ({1}) {{\n{2}}}".format(hipThreadIndices,"&&".join(hipThreadConditions),makeCStr(self.body))

class TTAccCache(TTNode):
    def assignFields(self,tokens):
        self.list = tokens[0]
    def printTokens(self):
        print(self.list)
    def cStr(self):
        temp = []
        for var in self.list:
            temp.append(makeCStr(var))
        return temp

class TTAccConstruct(TTNode):
    def assignFields(self,tokens):
        self.construct = tokens[0]
    def printTokens(self):
        print(self.construct)
        self.construct.printTokens()
    def cStr(self):
        print(self.construct)
        return makeCStr(self.construct)
    def kernelLaunchInfo(self):
        pragmaList = findAll(self.construct,TTAccPragma)
        kernelLaunchInfo = ""
        for pragma in pragmaList:
            kernelLaunchInfo += makeCStr(pragma)
        return kernelLaunchInfo
    def allIdentifiers(self):
        identifierNames = []
        myList  = findAll(self.construct,TTFunctionCallOrTensorAccess)
        myList += findAll(self.construct,TTIdentifier) # includes the identifiers of the function calls
        for ident in myList:
            name = makeCStr(ident.name)
            if not name.lower() in KEYWORDS:
               identifierNames.append(name)
        return set(identifierNames)
    def loopVars(self):
        identifierNames = []
        doLoops  = findAll(self.construct,TTDoLoop)
        for loop in doLoops:
             identifierNames.append(loop.loopVarCStr())
        return identifierNames
    def problemSize(self):
        #numLoopsToMap = min(3,int(self.pragma.numLoopsToMap))
        numLoopsToMap = min(3,len(findAll(self.construct,TTDoLoop)))
        result = ["-1"]*numLoopsToMap
        doLoops = findAll(self.construct,TTDoLoop)

        for i,loop in enumerate(doLoops):
            if i < numLoopsToMap:
                result[i] = loop.problemSizeCStr()
        return result
    def allLocalLvalues(self):
        """
        We focus on scalar identifiers here, i.e. the left-hand side must not contain any index operator evaluations
        or be a struct.
        NOTE: The loop variables need to be removed from this result when rendering the corresponding C kernel.
        NOTE: When rendering the kernel, it is best to exclude all variables for which an array declaration has been found,
        from the result list. TTCufKernelDo instances do not know of the type of the variables.
        """
        identifierNames = []
        lvalues = list(filter(lambda x: x.isIdentifier(), findAll(self.construct,TTLvalue))) # excludes array assignments, where brackets are used
        rvalues = list(filter(lambda x: x.isIdentifier(), findAll(self.construct,TTRvalue)))
        for lvalue in lvalues:
             lvName = makeCStr(lvalue.value)
             readBeforeAssignment = False
             for rvalue in rvalues:
                 if lvName == makeCStr(rvalue.value) and\
                    rvalue.location < lvalue.location: # rvalue occurred before
                     readBeforeAssignment = True
             if not readBeforeAssignment:
                identifierNames.append(lvName)
        return set(identifierNames)
    def variables(self,expr):
        Var = []
        variables = findAll(expr,TTIdentifier)
        for variable in variables:
            Var.append(makeCStr(variable))
        return Var
    def inputVars(self):
         invar = self.variables(self.construct.pragma[0].copyin)
         invar += self.variables(self.construct.pragma[0].copy)
         return invar
    def outputVars(self):
        outvar = self.variables(self.construct.pragma[0].copyout)
        outvar +=  self.variables(self.construct.pragma[0].copy)
        return outvar
    def mallocVars(self):
        return self.variables(self.construct.pragma[0].create)

class TTAccSubroutine(TTNode):
    def assignFields(self,tokens):
        self.qualifier = tokens[0]
        self.name      = tokens[1]
        self.args      = tokens[2]
        self.body      = tokens[3]
    def nameCStr(self):
        """
        Returns the name of the subroutine.
        """
        return makeCStr(self.name) 
    def argNamesCStr(self):
        """
        Returns the arguments of the subroutine.
        """
        return [makeCStr(ident) for ident in self.args]
    def bodyCStr(self,ignoreDeclarationsAttributes=False):
        """
        Returns the body of the subroutine.
        """
        declarations = findAll(self.body,TTDeclaration)
        #declarations += findAll(self.body,TTAttributes)
        for node in declarations:
             node.ignore = True
        return makeCStr(self.body)

### Link actions
#acc_if.setParseAction(TTAccIf)
#acc_self.setParseAction(TTAccSelf)
#acc_async.setParseAction(TTAccAsync)
#acc_wait.setParseAction(TTAccWait)
#acc_num_gangs.setParseAction(TTAccNumGangs)
#acc_num_workers.setParseAction(TTAccNumWorkers)
#acc_vector_length.setParseAction(TTAccVectorLen)
#acc_copy.setParseAction(TTAccCopy)
#acc_copyin.setParseAction(TTAccCopyIn)
#acc_copyout.setParseAction(TTAccCopyOut)
#acc_create.setParseAction(TTAccCreate)
#acc_present.setParseAction(TTAccPresent)
#acc_deviceptr.setParseAction(TTAccDevicePtr)
#acc_default.setParseAction(TTAccDefault)
#acc_private.setParseAction(TTAccPrivate)
#acc_first_private.setParseAction(TTAccFirstPrivate)
#acc_no_create.setParseAction(TTAccNoCreate)
#acc_delete.setParseAction(TTAccDelete)
#accReduceOperator.setParseAction(TTAccReduceOperator)
#acc_reduction.setParseAction(TTAccReduction)
#acc_detach.setParseAction(TTAccDetach)
#acc_use_device.setParseAction(TTAccUseDevice)
#acc_collapse.setParseAction(TTAccCollapse)
#acc_device.setParseAction(TTAccDevice)
#acc_bind.setParseAction(TTAccBind)
#acc_device_resident.setParseAction(TTAccDeviceResident)
#acc_link.setParseAction(TTAccLink)
#acc_tile.setParseAction(TTAccTile)
#acc_seq.setParseAction(TTAccSeq)
#acc_auto.setParseAction(TTAccAuto)
#acc_independent.setParseAction(TTAccIndependent)
#acc_read.setParseAction(TTAccRead)
#acc_write.setParseAction(TTAccWrite)
#acc_update.setParseAction(TTAccUpdate)
#acc_capture.setParseAction(TTAccCapture)
#acc_gang.setParseAction(TTAccGang)
#acc_vector.setParseAction(TTAccVector)
#acc_worker.setParseAction(TTAccWorker)

#accClauses.setParseAction(TTAccPragma)
#accKernels.setParseAction(TTAccKernels)
#accParallel.setParseAction(TTAccParallel)
#accWait.setParseAction(TTAccWait)
#accHostData.setParseAction(TTAccHostData)
#accData.setParseAction(TTAccData)
#accEnterData.setParseAction(TTAccEnterData)
#accExitData.setParseAction(TTAccExitData)
#accLoop.setParseAction(TTAccLoop)
#accRoutine.setParseAction(TTAccRoutine)
#accAtomic.setParseAction(TTAccAtomic)
#accUpdate.setParseAction(TTAccUpdate)
#accSerial.setParseAction(TTAccSerial)
#accCache.setParseAction(TTAccCache)
#accDeclare.setParseAction(TTAccDeclare)
#accConstruct.setParseAction(TTAccConstruct)

class TTAccLoopKernel(TTLoopKernel):
    def assignFields(self,tokens):
        self._launchInfo, self._body = tokens
    def cStr(self):
        doLoops = findAll(self._body,TTDoLoop)
        #print(self._body)
        numLoopsToMap = min(3,int(self._pragma._numLoopsToMap))
        
        threadIndices = ["x","y","z"]
        for i in range(0,3-numLoopsToMap):
            threadIndices.pop()
        hipThreadIndices    = ""
        hipThreadConditions = []
        for loop in doLoops:
            loop._threadIndex   = threadIndices.pop()
            hipThreadIndices   += loop.hipThreadIndexCStr()
            hipThreadConditions.append(loop.hipThreadBoundCStr()) 
            if not len(threadIndices):
                break
        return "{0}if ({1}) {{\n{2}}}".format(hipThreadIndices,"&&".join(hipThreadConditions),makeCStr(self._body))
    def kernelLaunchInfo(self) :
        return self._pragma

    def loopVars(self):
        identifierNames = []
        doLoops  = findAll(self._body,TTDoLoop)
        for loop in doLoops:
             identifierNames.append(loop.loopVarCStr())
        return identifierNames

    def allIdentifiers(self):
        identifierNames = []
        myList  = findAll(self._body,TTFunctionCallOrTensorAccess)
        myList += findAll(self._body,TTIdentifier) # includes the identifiers of the function calls
        for ident in myList:
            name = makeCStr(ident._name)
            if not name.lower() in KEYWORDS:
               identifierNames.append(name)
        return set(identifierNames)
    
    def allLocalLvalues(self):
        """
        We focus on scalar identifiers here, i.e. the left-hand side must not contain any index operator evaluations
        or be a struct.
        NOTE: The loop variables need to be removed from this result when rendering the corresponding C kernel.
        NOTE: When rendering the kernel, it is best to exclude all variables for which an array declaration has been found,
        from the result list. TTCufKernelDo instances do not know of the type of the variables.
        """
        identifierNames = []
        lvalues = list(filter(lambda x: x.isIdentifier(), findAll(self._body,TTLvalue))) # excludes array assignments, where brackets are used


recursionsLeft=0
def convertAccLoopKernel(fortranSnippet,maxRecursions=10):
    """
    Return a csnippet equit
    """
    global KEYWORDS 

    def convertAccKernelRecursively(fortranSnippet,recursionsToGo):
        global recursionsLeft
        recursionsLeft = recursionsToGo
        try:
            return accLoopKernel.parseString(fortranSnippet)[0]
        except ParseBaseException as pbe:
            if recursionsToGo <= 0:
                raise pbe
            else:
                lineno = pbe.__getattr__("lineno")
                lines = fortranSnippet.split("\n")
                lines[lineno-1] = "! TODO could not parse: {}".format(lines[lineno-1])
                modifiedFortranSnippet = "\n".join(lines)
                #print(modifiedFortranSnippet)
                return convertAccKernelRecursively(modifiedFortranSnippet,recursionsToGo-1)
        except Exception as e:
            raise e        
   
    fortranSnippet = prepareFortranSnippet(fortranSnippet)
    #print(fortranSnippet)
    try:
        result = convertAccKernelRecursively(fortranSnippet,maxRecursions)
        cSnippet = utils.prettifyCCode(result.cStr())
        kernelLaunchInfo = result.kernelLaunchInfo()
        identifierNames = result.allIdentifiers()
        loopVars = result.loopVars()
        #print(loopVars)
        localLvalues = list(filter(lambda x: x not in loopVars,result.allLocalLvalues())) 
        problemSize = result.problemSize()
        #print(recursionsLeft)
        if recursionsLeft < maxRecursions:
            body = "\n".join(fortranSnippet.split("\n")[1:])
            identifierNames = list(filter(lambda x: x.lower() not in KEYWORDS,[makeFStr(ident) for ident in identifier.searchString(body)]))
            #print(identifierNames) 
    except Exception as e:
        cSnippet = "" 
        pragmaLine = fortranSnippet.split("\n")[0]
        body = "\n".join(fortranSnippet.split("\n")[1:])
        kernelLaunchInfo = cufKernelDo.parseString(pragmaLine)[0] 
        #print(body)
        identifierNames = list(filter(lambda x: x.lower() not in KEYWORDS,[makeFStr(ident) for ident in identifier.searchString(body)]))
        numLoopsToMap = int(kernelLaunchInfo._numLoopsToMap)
        loopVars = []
