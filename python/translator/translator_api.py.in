# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.

# API
def createIndexRecordsFromDeclaration(ttdeclaration):
    """
    Per declared variable in the declaration, creates
    a context dictionary that can be easily piped
    to the (HIP) kernel code generation
    and the Fortran-C interface code generation.
    """
    global LOG_PREFIX

    utils.logging.logEnterFunction(LOG_PREFIX,"createIndexRecordsFromDeclaration")
    
    context = []
    hasDimension = ttdeclaration.hasDimension()
    for ttdeclaredvariable in ttdeclaration._rhs:
        varName    = ttdeclaredvariable.name().lower()
        varContext = {}
        # basic 
        f_type = make_f_str(ttdeclaration._datatype.type())
        kind  = make_f_str(ttdeclaration._datatype.kind())
        bpe   = bytes(f_type,kind,default=None)
        varContext["name"]                       = varName
        varContext["f_type"]                     = f_type
        varContext["kind"]                       = kind
        varContext["bytes_per_element"]          = bpe 
        varContext["c_type"]                     = convertToCType(f_type,kind,"TODO unknown")
        varContext["f_interface_type"]           = varContext["f_type"]
        varContext["f_interface_qualifiers"]     = [ "value" ] # assume pass by value by default
        # TODO pack into single variable
        varContext["qualifiers"]                 = ttdeclaration.getStringQualifiers()
        # ACC/OMP
        varContext["declare_on_target"]          = False
        # arrays
        varContext["rank"]                       = 0
        dimension_qualifier = find_all(ttdeclaration._qualifiers,TTDimensionQualifier)
        if ttdeclaredvariable.hasBounds() or len(dimension_qualifier):
            varContext["f_interface_type"] = "type(c_ptr)"
            if len(dimension_qualifier):
                ttbounds = dimension_qualifier[0]._bounds
            else:
                ttbounds = ttdeclaredvariable.getBounds()
            rank = ttbounds.rank()
            varContext["rank"] = rank
            varContext["unspecified_bounds"] = ttbounds.hasUnspecifiedBounds()
            if varContext["unspecified_bounds"]: # TODO: return a mix of unspecified bounds and specified bounds in the future
                varContext["lbounds"]                       = [ "{0}_lb{1}".format(varName,i) for i in range(1,rank+1) ]
                varContext["counts"]                        = [ "{0}_n{1}".format(varName,i) for i in range(1,rank+1 ) ]
                varContext["index_macro_with_placeholders"] = ttbounds.index_macro_c_str(varName,usePlaceHolders=True)
                varContext["index_macro"]                   = varContext["index_macro_with_placeholders"]
            else:
                varContext["lbounds"]                       = ttbounds.specifiedLowerBounds()
                varContext["counts"]                        = ttbounds.specifiedCounts()
                varContext["index_macro_with_placeholders"] = ttbounds.index_macro_c_str(varName,usePlaceHolders=True) 
                varContext["index_macro"]                   = ttbounds.index_macro_c_str(varName,usePlaceHolders=False)
            varContext["total_count"]   = "*".join(varContext["counts"])
            varContext["total_bytes"]   = None if bpe is None else bpe+"*("+varContext["total_count"]+")"
        # handle parameters
        varContext["value"] = None
        if "parameter" in varContext["qualifiers"]:
            if ttdeclaredvariable.rhsIsNumber():
                varContext["value"] = ttdeclaredvariable.rhsCStr()
            else:
                #varContext["value"] = ttdeclaredvariable.rhsCStr()
                # TODO 
                pass
        context.append(varContext)
    
    utils.logging.logLeaveFunction(LOG_PREFIX,"createIndexRecordsFromDeclaration")
    
    return context

def changeKind(varContext,kind):
    f_type = varContext["f_type"]
    bpe   = bytes(f_type,kind,default=None)
    varContext["kind"]                 = kind
    varContext["bytes_per_element"]      = bpe 
    varContext["c_type"]                = convertToCType(f_type,kind,"TODO unknown")
    if varContext["rank"] == 0:
      varContext["f_interface_type"] = varContext["c_type"]
    #
    varContext["total_bytes"] = None if bpe is None else bpe+"*("+varContext["total_count"]+")"

def convertArithmeticExpression(fortran_snippet):
    return ( matrix_arithmetic_expression | complex_arithmetic_expression | arithmetic_expression ).parseString(fortran_snippet)[0].c_str()

def parseAttributes(ttattributes):
    attribute    = make_f_str(ttattributes._qualifiers[0]).lower()
    modifiedVars = [make_f_str(var).lower() for var in ttattributes._rhs]
    return attribute, modifiedVars 

def create_index_search_tag_for_variable(variableExpression):
    """
    Creates tag from variable expressions such as 'A%b(i)%c' that
    can be used to search the index via the scoper module.
    The example 'A%b(i)%c' is translated to a tag 'a%b%c' (lower case).
    All array indexing expressions are stripped away.
    A single identifer 'a' would be translated to the tag 'a'.

    :param str variableExpression: a simple identifier such as 'a' or 'A_d' or a more complicated derived-type member variable expression such as 'a%b%c' or 'A%b(i)%c'.
    :see: indexer.scoper.searchIndexForVariable
    """
    if not "(" in variableExpression:
        return variableExpression.lower()
    else:
        expr         = derived_type_elem
        parse_result = expr.parseString(variableExpression.lower())[0]
        def traverse(ttderivedtype):
            result = ttderivedtype._type.name().lower() + "%"
            if type(ttderivedtype._element) == TTIdentifier or\
               type(ttderivedtype._element) == TTFunctionCallOrTensorAccess:
                result += ttderivedtype._element.name().lower() # end of recursion
            else: # if type(ttderivedtype._element) == TTDerivedTypeElem:
               result += traverse(ttderivedtype._element)
            return result
        return traverse(parse_result)

# TODO parsing and translation is similar but analysis differs between the different kernel
# types. For example for CUF, the reduction vars must be detected by the parser (lhs scalars)
# while they are specified with ACC,OMP.
def parse_loop_kernel(fortran_statements,scope=[],maxRecursions=30):
    """
    Return a csnippet equivalent to the original Fortran code.
    """
    global LOG_PREFIX

    ttloopkernel = _intrnl_parse_fortran_code(fortran_statements).body[0]
    
    ttloopkernel.scope = scope
    return ttloopkernel

def parse_procedure_body(fortran_statements,scope=[],result_name="",maxRecursions=10):
    """
    Parse a function/subroutine body.
    """
    global KEYWORDS 
    global LOG_PREFIX

    parse_result    = _intrnl_parse_fortran_code(fortran_statements)
    ttprocedurebody = TTProcedureBody("",0,[parse_result.body])
    
    ttprocedurebody.scope      = scope 
    ttprocedurebody.result_name = result_name
    return ttprocedurebody
