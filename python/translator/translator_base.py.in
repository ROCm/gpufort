# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.
def bytes(f_type,kind,default=None):
    assert type(f_type) is str
    assert type(kind) is str
    kind_lower = kind.lower()
    return FORTRAN_TYPE_2_BYTES_MAP.get(f_type.lower(),{ kind_lower : default }).get(kind_lower, "UNKNOWN")

ADDITIONS = "cuf kernel kind amax1 amin1" # TODO
KEYWORDS = " ".join([CUDA_FORTRAN_KEYWORDS_STR, FORTRAN_INTRINSICS_STR, F08_KEYWORDS_STR, ADDITIONS])
KEYWORDS = KEYWORDS.lower().split(" ")

# Ternary state
False3, Unknown3, True3 = -1,0,1

## Define actions
class TTNode(object):
    def __init__(self, s, loc, tokens):
       self._input    = s
       self._location = loc
       self.indent = ""
       self.parent = None
       self._assign_fields(tokens)
    def __str__(self):
       return self.__class__.__name__ + ':' + str(self.__dict__)
    def _assign_fields(self,tokens):
        pass
    def children(self):
        result = []
        for key,value in self.__dict__.items():
            if key != "parent":
                result.append(value)
        return result
    def c_str(self):
        pass
    #__repr__ = __str__

class TTContainer(TTNode):
    """
    Container node for manual parser construction.
    """
    def __init__(self,s="",loc=0,tokens=[]):
        self._input    = s
        self._location = loc
        self.indent = ""
        self.parent = None
        self.body = [] # must come before TTNode.__init__ call
        self._assign_fields(tokens)
    def append(self,node):
        self.body.append(node)
    def children(self):
        return self.body
    def c_str(self):
        result = ""
        for child in self.body:
            result += make_c_str(child).rstrip()+"\n"
        return result.rstrip()

def find_all_matching(body,filter_expr=lambda x: True,N=-1):
    """
    Find all nodes in tree of type 'searched_type'.
    """
    result = []
    def descend_(curr):
        if N > 0 and len(result) > N:
            return
        if filter_expr(curr):
            result.append(curr)
        if isinstance(curr,ParseResults) or\
           isinstance(curr,list):
            for el in curr:
                descend_(el)
        elif isinstance(curr,TTNode):
            for child in curr.children():
                descend_(child)
    descend_(body)       
    return result

def find_first_matching(body,filter_expr=lambda x: True):
    """
    Find first node in tree where the filte returns true.
    """
    result = find_all_matching(body,filter_expr,N=1)
    if len(result):
        return result[0]
    else:
        return None

def find_all(body,searched_type,N=-1):
    """
    Find all nodes in tree of type 'searched_type'.
    """
    result = []
    def descend(curr):
        if N > 0 and len(result) > N:
            return
        if type(curr) is searched_type:
            result.append(curr)
        if isinstance(curr,ParseResults) or\
           isinstance(curr,list):
            for el in curr:
                descend(el)
        elif isinstance(curr,TTNode):
            for child in curr.children():
                descend(child)
    descend(body)       
    return result

def find_first(body,searched_type):
    """
    Find first node in tree of type 'searched_type'.
    """
    result = find_all(body,searched_type,N=1)
    if len(result):
        return result[0]
    else:
        return None

def make_c_str(obj):
    if obj is None:
      return ""
    try:
        return obj.c_str().lower()
    except Exception as e:
        if isinstance(obj,ParseResults) or\
           isinstance(obj,list):
            result = ""
            for child in obj:
                result += make_c_str(child)
            return result
        elif type(obj) in [bool,int,float,str]:
            return str(obj).lower()
        else:
            raise e

def make_f_str(obj):
    if obj is None:
       return ""
    try:
        return obj.f_str()
    except Exception as e:
        if isinstance(obj,ParseResults) or\
           isinstance(obj,list):
            result = ""
            for child in obj:
                result += make_f_str(child)
            return result
        elif type(obj) in [int,float,str]:
            return str(obj)
        else:
            raise e

def flatten_body(body):
    #TODO: Check if this is the same as make_c_str()
    def descend(statement):
        term = ""
        if isinstance(statement,ParseResults) or\
           isinstance(statement,list):
            for el in statement:
                term += descend(el)
            return term
        elif isinstance(statement,TTNode):
           try:
               return statement.c_str() 
           except Exception as e:
               raise e
        else:
           return ""
    return descend(body)       

def convert_to_c_type(f_type,kind,default=None):
    """
    :return: An equivalent C datatype for a given Fortran type, e.g. `double` for a `REAL*8`.
    :param f_type: The original Fortran type, e.g. `REAL` for a `REAL*8`.
    :param kind: The kind of the Fortran type, e.g. `8` for a `REAL*8`.
    :rtype: str
    """
    assert type(f_type) is str
    if kind is None:
        kind = ""
    assert type(kind) is str, "{}, {}".format(kind,type(kind))
    kind_lower = kind.lower()
    return FORTRAN_2_C_TYPE_MAP.get(f_type.lower(),{ kind_lower : default }).get(kind_lower, "UNKNOWN")

def prepare_fortran_snippet(fortran_snippet):
    """
    Converts the Fortran snippet to lower case as
    we convert into a case-sensitive C language (preserves case in comments).
    Furthermore, applies a number of hacks that were necessary to get the parser work.
    """
    result = pIgnore.sub("",fortran_snippet)
    result = p_else_if.sub("else if",result)
    result = power.transform_string(result)
    return result

def postprocess_c_snippet(c_snippet):
    to_hip = GPUFORT_CPP_ROUTINES 
    to_hip.update({
       "threadidx.x" : "(1+threadIdx.x)",
       "threadidx.y" : "(1+threadIdx.y)",
       "threadidx.z" : "(1+threadIdx.z)",
       "blockidx.x"  : "(1+block_idx.x)",
       "blockidx.y"  : "(1+block_idx.y)",
       "blockidx.z"  : "(1+block_idx.z)",
       "blockdim"    : "blockDim",
       "griddim"     : "gridDim",
       "warpsize"    : "warp_size",
       "syncthreads" : "__syncthreads",
       "atomicadd"  : "atomicAdd",
       "atomicsub"  : "atomicSub",
       "atomicmax"  : "atomicMax",
       "atomicmin"  : "atomicMin",
       "atomicand"  : "atomicAnd",
       "atomicor"   : "atomicOr",
       "atomicxor"  : "atomicXor",
       "atomicexch" : "atomicExch",
       "atomicinc"  : "atomicInc",
       "atomicdec"  : "atomicDec",
       "atomiccas"  : "atomicCas",
       "sign"       : "copysign",
    })
    for key,subst in to_hip.items():
        c_snippet = re.sub(r"\b"+key+r"\b",subst,c_snippet)
    return c_snippet
