# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.
#from translator.translator_base import *

#f03
def flatten_arithmetic_expression(expr,converter=make_c_str):
    def descend(element,depth=0):
        term = ""
        if isinstance(element,ParseResults):
           for el in element:
               term += "(" if isinstance(el,ParseResults) else ""
               term += descend(el,depth)
               term += ")" if isinstance(el,ParseResults) else ""
           return term
        else:
           return converter(element)
    return descend(expr)       

class TTSimpleToken(TTNode):
      def _assign_fields(self,tokens):
          self._text = " ".join(tokens)
      def c_str(self):
          return "{};".format(self._text.lower())
      def f_str(self):
          return str(self._text)

class TTReturn(TTNode):
      def _assign_fields(self,tokens):
          self._result_name = ""  
      def c_str(self): 
          if len(self._result_name):
              return "return "+self._result_name+";"
          else:
              return "return;"
      def f_str(self):
          return "return"

class TTCommentedOut(TTNode):
      def _assign_fields(self,tokens):
          self._text = " ".join(tokens)
      def c_str(self):
          return "// {}\n".format(self._text)

class TTIgnore(TTNode):
      def c_str(self):
          return ""

class TTLogical(TTNode):
    def _assign_fields(self,tokens):
        self._value = tokens[0]
    def c_str(self):
        return "true" if self._value.lower() == ".true." else "false"
    def f_str(self):
        return self._value

class TTNumber(TTNode):
    def _assign_fields(self,tokens):
        self._value = tokens[0]
    def c_str(self):
        parts = self._value.replace("d","e").split("_")
        if len(parts) > 1:
            return "{0} /*_{1}*/".format(parts[0],parts[1])
        else:
            return parts[0] 
        return self._value 
    def f_str(self):
        return self._value

class TTDatatype_Comment(TTNode):
    # generates object Datatype{'type' : '...', 'kind' : '...'}
    def _assign_fields(self,tokens):
        self._type   = tokens[0]
        self._kind   = tokens[1][0]
        self._length = tokens[1][1]
    def type(self):
        """
        Fortran basetype of the datatype.
        """
        return self._type
    def kind(self):
        return self._kind
    def len(self):
        return self._length
    def is_derived_type(self):
        return self._type.lower() == "type"
    def bytes(self):
        return "TODO unknown size"  
    def c_str(self):
        f_type  = make_f_str(self._type)
        kind   = make_f_str(self._kind)
        length = make_f_str(self._length)
        return "// {}\n// {}(kind={},len={})".format(UNCONVERTED,f_type,kind,length)
    def f_str(self):
        # comment only when generating c string
        result = make_f_str(self._type)
        kind   = make_f_str(self._kind)
        length = make_f_str(self._length)
        args = []
        if len(kind):
            args.append("kind={}".format(kind))
        if len(length):
            args.append("len={}".format(len))
        if len(args):
            result += "({0})".format(",".join(args))
        return result

class TTDatatype_Convert(TTNode):
    # generates object Datatype{'type' : '...', 'kind' : '...'}
    def _assign_fields(self,tokens):
        self._type   = tokens[0]
        self._kind   = tokens[1][0]
        self._length = tokens[1][1]
    def type(self):
        return self._type
    def is_derived_type(self):
        return self._type.lower() == "type"
    def kind(self):
        return self._kind
    def len(self):
        return self._length
    def bytes(self):
        return bytes(make_f_str(self._type),make_f_str(self._kind))  
    def c_str(self):
        f_type = make_f_str(self._type)
        kind = make_f_str(self._kind)
        c_type = convert_to_c_type(f_type,kind)
        if c_type == None:
            return "// {}\n// {}".format(UNCONVERTED,f_type,kind)
        return c_type
    def f_str(self):
        result = str(self._type)
        have_kind = not self._kind is None 
        have_len  = not self._length is None
        have_param = have_kind or have_len
        if have_param:
            result += "("
        if have_kind:
            result += "kind={}".format(make_f_str(self._kind))
            if have_len:
                result += ", "
        if have_len:
            result += "len={}".format(make_f_str(self._len))
        if have_param:
            result += ")"
        return result            

class TTIdentifier(TTNode):
    def _assign_fields(self,tokens):
        self._name = tokens[0]
    def f_str(self):
        return str(self._name)
    def c_str(self):
        return self.f_str()

class TTFunctionCallOrTensorAccess(TTNode):
    def _assign_fields(self,tokens):
        self._name = tokens[0]
        self._args = tokens[1]
        self._is_tensor_access = Unknown3
    def matrix_range_args(self):
        """
        Returns all matrix range args in the order of their appeareance.
        """
        return find_all(self._args,searched_type=TTMatrixRange)
    def has_matrix_range_args(self):
        """
        If any matrix range args are present in the argument list.
        """
        return not find_first(self._args,searched_type=TTMatrixRange) is None
    def __guess_it_is_function(self): 
        """ 
        Tries to determine if the whole expression
        is function or not if no other hints are given
        """
        name = make_c_str(self._name).lower()
        return len(self._args) == 0 or\
          name in GPUFORT_CPP_ROUTINES or\
          name in ALL_HOST_ROUTINES or\
          name in ALL_DEVICE_ROUTINES
    def is_tensor(self):
        if self._is_tensor_access == True3:
            return True
        elif self._is_tensor_access == False3:
            return False
        else:
            return self.has_matrix_range_args() or\
                   not self.__guess_it_is_function()
    def c_str(self):
        name = make_c_str(self._name).lower()
        if self.is_tensor():
            return "{0}[_idx_{0}({1})]".format(name,",".join([make_c_str(s) for s in self._args])) # Fortran identifiers cannot start with "_"
        else:
            return "{}({})".format(name,",".join([make_c_str(s) for s in self._args]))
    def f_str(self):
        name = make_f_str(self._name)
        return "{0}({1})".format(name,",".join([make_f_str(s) for s in self._args]))

class IValue:
    def is_identifier(self):
        return type(self._value) is TTIdentifier      
    def name(self):
        if type(self._value) is TTFunctionCallOrTensorAccess:
            return self._value.name(False)
        elif type(self._value) is TTDerivedTypeMember:
            return self._value.name(False)
        else:
            return self._value.name(False)
    def has_matrix_range_args(self):
        """
        Functionality for scanner.
        """
        if type(self._value) is TTFunctionCallOrTensorAccess:
            return self._value.has_matrix_range_args()
        elif type(self._value) is TTDerivedTypeMember:
            return self._value.last_element_has_matrix_range_args()
        else:
            return False
    def matrix_range_args(self):
        if type(self._value) is TTFunctionCallOrTensorAccess:
            return self._value.matrix_range_args()
        elif type(self._value) is TTDerivedTypeMember:
            return self._value.last_element_matrix_range_args()
        else:
            return []
class TTRValue(TTNode,IValue):
    def _assign_fields(self,tokens):
        self._sign           = tokens[0]
        self._value          = tokens[1]
        self._reduction_index = ""
        #print("{0}: {1}".format(self.c_str(),self.location))
    def f_str(self):
        return self._sign + make_f_str(self._value)
    def c_str(self):
        result = self._sign + make_c_str(self._value)
        if len(self._reduction_index):
            result += "[{idx}]".format(idx=self._reduction_index) 
        return result.lower()

class TTLValue(TTNode,IValue):
    def _assign_fields(self,tokens):
        self._value          = tokens[0]
        self._reduction_index = ""
        #print("{0}: {1}".format(self.c_str(),self.location))
    def f_str(self):
        return make_f_str(self._value)
    def c_str(self):
        result = make_c_str(self._value)
        if len(self._reduction_index):
            result += "[{idx}]".format(idx=self._reduction_index) 
        return result

class TTSizeInquiry(TTNode):
    """
    Translator tree node for size inquiry function.
    """
    def _assign_fields(self,tokens):
        self._ref, self._dim, self._kind = tokens
    def c_str(self):
        """
        :return: number of elements per array dimension, if the dimension
                 is specified as argument.
                 Utilizes the <array>_n<dim> and <array>_lb<dim> arguments that
                 are passed as argument of the extracted kernels.
        :note: only the case where <dim> is specified as integer literal is handled by this function.
        """
        if type(self._dim) is TTNumber:
            return make_c_str(self._ref) + "_n" + make_c_str(self._dim) 
        else:
            prefix = "size"
            return "/* "+prefix+"("+make_f_str(self._ref)+") */"
    def f_str(self):
        prefix = "size"
        result = prefix + "("+make_f_str(self._ref)
        if self._dim != None:
            result += "," + make_f_str(self._dim)
        if self._kind != None:
            result += "," + make_f_str(self._kind)
        return result + ")"

class TTLboundInquiry(TTNode):
    """
    Translator tree node for lbound inquiry function.
    """
    def _assign_fields(self,tokens):
        self._ref, self._dim, self._kind = tokens
    def c_str(self):
        """
        :return: lower bound per array dimension, if the dimension argument is specified as integer literal.
                 Utilizes the <array>_n<dim> and <array>_lb<dim> arguments that
                 are passed as argument of the extracted kernels.
        :note:   only the case where <dim> is specified as integer literal is handled by this function.
        """
        if type(self._dim) is TTNumber:
            return make_c_str(self._ref) + "_lb" + make_c_str(self._dim) 
        else:
            prefix = "lbound"
            return "/* "+prefix+"("+make_f_str(self._ref)+") */"
    def f_str(self):
        prefix = "lbound"
        result = prefix + "("+make_f_str(self._ref)
        if self._dim != None:
            result += "," + make_f_str(self._dim)
        if self._kind != None:
            result += "," + make_f_str(self._kind)
        return result + ")"

class TTUboundInquiry(TTNode):
    """
    Translator tree node for ubound inquiry function.
    """
    def _assign_fields(self,tokens):
        self._ref, self._dim, self._kind = tokens
    def c_str(self):
        """
        :return: upper bound per array dimension, if the dimension argument is specified as integer literal.
                 Utilizes the <array>_n<dim> and <array>_lb<dim> arguments that
                 are passed as argument of the extracted kernels.
        :note:   only the case where <dim> is specified as integer literal is handled by this function.
        """
        if type(self._dim) is TTNumber:
            return "({0}_lb{1} + {0}_n{1} - 1)".format(
                make_c_str(self._ref),
                make_c_str(self._dim))
        else:
            prefix = "ubound"
            return "/* "+prefix+"("+make_f_str(self._ref)+") */"
    def f_str(self):
        prefix = "ubound"
        result = prefix + "("+make_f_str(self._ref)
        if self._dim != None:
            result += "," + make_f_str(self._dim)
        if self._kind != None:
            result += "," + make_f_str(self._kind)
        return result + ")"

class TTConvertToExtractReal (TTNode):
    def _assign_fields(self,tokens):
        self._ref, self._kind = tokens
    def c_str(self):
        c_type = convert_to_c_type("real",self._kind).replace(" ","_") # TODO check if his anything else than double or float
        return "make_{1}({0})".format(make_c_str(self._ref),c_type) # rely on C++ compiler to make the correct type conversion
    def f_str(self):
        result ="REAL({0}".format(make_f_str(self._ref))
        if not self._kind is None:
            result += ",kind={0}".format(make_f_str(self._kind))
        return result + ")"

class TTConvertToDouble(TTNode):
    def _assign_fields(self,tokens):
        self._ref, self._kind = tokens
    def c_str(self):
        return "make_double({0})".format(make_c_str(self._ref)) # rely on C++ compiler to make the correct type conversion
    def f_str(self):
        return "DBLE({0})".format(make_f_str(self._ref)) # rely on C++ compiler to make the correct type conversion

class TTConvertToComplex(TTNode):
    def _assign_fields(self,tokens):
        self._x, self._y, self._kind = tokens
    def c_str(self):
        c_type = convert_to_c_type("complex",self._kind,default=None,float_complex="float_complex",double_complex="double_complex")
        return "make_{2}({0}, {1})".format(make_c_str(self._x),make_c_str(self._y),c_type)
    def f_str(self):
        result ="CMPLX({0},{1}".format(make_f_str(self._x),make_f_str(self._y))
        if not self._kind is None:
            result += ",kind={0}".format(make_f_str(self._kind))
        return result + ")"

class TTConvertToDoubleComplex(TTNode):
    def _assign_fields(self,tokens):
        self._x, self._y, self._kind = tokens
    def c_str(self):
        c_type="double_complex"
        return "make_{2}({0}, {1})".format(make_c_str(self._x),make_c_str(self._y),c_type)
    def f_str(self):
        result ="DCMPLX({0},{1}".format(make_f_str(self._x),make_f_str(self._y))
        return result + ")"

class TTExtractImag(TTNode):
    def _assign_fields(self,tokens):
        self._ref, self._kind = tokens
    def c_str(self):
        return "{0}._y".format(make_c_str(self._ref))

class TTConjugate(TTNode):
    def _assign_fields(self,tokens):
        self._ref, self._kind = tokens
    def c_str(self):
        return "conj({0})".format(make_c_str(self._ref))

class TTDerivedTypeMember(TTNode):
    def _assign_fields(self,tokens):
        self._type, self._element = tokens
        #print(self._type)
    def last_element_matrix_range_args(self):
        """
        Returns all matrix range args in the order of their appeareance.
        """
        result = []
        current = self._element
        while type(current) is TTDerivedTypeMember:
            current = current._element
        if type(current) is TTFunctionCallOrTensorAccess:
            return current.matrix_range_args()
        else:
            return []
    def last_element_has_matrix_range_args(self):
        """
        If any matrix range args are present in the argument list.
        """
        result = []
        current = self._element
        while type(current) is TTDerivedTypeMember:
            current = current._element
        if type(current) is TTFunctionCallOrTensorAccess:
            return current.has_matrix_range_args()
        else:
            return False
    def c_str(self):
        return make_c_str(self._type) + "." + make_c_str(self._element)
    def f_str(self):
        return make_f_str(self._type) + "%" + make_f_str(self._element)

class TTSubroutineCall(TTNode):
    def _assign_fields(self,tokens):
        self._subroutine=tokens[0]
    def c_str(self):
        self._subroutine._is_tensor_access = False3
        return self.indent+self._subroutine.c_str()+";"

class TTOperator(TTNode):
    def _assign_fields(self,tokens):
        self._name = tokens[0]
    def c_str(self):
        f2c = {
          ".eq."   : "==",
          "/="     : "!=",
          ".ne."   : "!=",
          ".neqv." : "!=",
          ".lt."   : "<",
          ".gt."   : ">",
          ".le."   : "<=",
          ".ge."   : ">=",
          ".and."  : "&",
          ".or."   : "|",
          ".xor."  : "^",
          ".not."  : "!",
          ".eqv."  : "==",
        }
        return f2c.get(self._name.lower(),self._name)
    def f_str(self):
        return str(self._name)

class TTArithmeticExpression(TTNode):
    def _assign_fields(self,tokens):
        self._expr = tokens
    def c_str(self):
        return flatten_arithmetic_expression(self._expr)
    def f_str(self):
        return flatten_arithmetic_expression(self._expr,make_f_str)

class TTComplexArithmeticExpression(TTNode):
    def _assign_fields(self,tokens):
        self._real, self._imag = tokens[0]
    def c_str(self):
        return "make_hip_complex({real},{imag})".format(\
                real=flatten_arithmetic_expression(self._real,make_c_str),\
                imag=flatten_arithmetic_expression(self._imag,make_c_str))
    def f_str(self):
        return "({real},{imag})".format(\
                real=flatten_arithmetic_expression(self._real,make_f_str),\
                imag=flatten_arithmetic_expression(self._imag,make_f_str))

class TTPower(TTNode):
    def _assign_fields(self,tokens):
        self._base, self._exp = tokens
    def gpufort_f_str(self,scope=[]):
        sign = ""
        base = self._base
        if type(self._base) is TTRValue:
            base = self._base._value
            sign = self._base._sign
        return "{sign}_intrnl_pow({base},{exp})".format(\
            sign=make_f_str(sign),base=make_f_str(base),
            exp=make_f_str(self._exp))
    
    __str__ = gpufort_f_str
    
    def f_str(self):
        return "({base})**({exp})".format(\
            base=make_c_str(self._base),exp=make_c_str(self._exp))

class TTAssignment(TTNode):
    def _assign_fields(self,tokens):
        self._lhs, self._rhs = tokens
    def convert_to_do_loop_nest_if_necessary(self):
        """
        - step through bounds
        - if type is range
          - get upper bound
	    - not found: use a_lb<i>+a_n<i>-1
	  - get lower bound
	     - not found: use a_lb<i>
        """
        name = self._lhs.name()
        loop_nest_start = ""
        loop_nest_end   = ""
        original_f_str = self.f_str()
        # TODO fix should be moved into parser preprocessing stage
        for i,matrix_range in enumerate(self._lhs.matrix_range_args()):
            loop_var_name = "_"+chr(ord('a')+i) # Fortran names cannot start with "_"
            matrix_range.set_loop_var(loop_var_name)
            lbound = matrix_range.lBound()
            if not len(lbound):
                lbound = "{name}_lb{i}".format(name=name,i=i+1)
            ubound = matrix_range.uBound()
            if not len(ubound):
                ubound = "({lbound} + {name}_n{i} - 1)".format(lbound=lbound,name=name,i=i+1)
            stride = matrix_range.stride()
            if not len(stride):
                stride="1"
            loop_nest_start = "do {var}={lb},{ub},{step}\n".format(var=loop_var_name,lb=lbound,ub=ubound,step=stride) + loop_nest_start
            loop_nest_end   = "end do\n" + loop_nest_end 
        if len(loop_nest_start):
            # TODO put into options
            for rvalue in find_all(self._rhs,searched_type=TTRValue):
                for i,matrix_range in enumerate(rvalue.matrix_range_args()):
                 loop_var_name = "_"+chr(ord('a')+i) # Fortran names cannot start with "_"
                 matrix_range.set_loop_var(loop_var_name)
            loop_nest_start += "! TODO(gpufort) please check if this conversion was done correctly\n"
            loop_nest_start += "! original: {}\n".format(original_f_str)
            result = loop_nest_start + self.f_str()+"\n" + loop_nest_end
            return annotated_do_loop.parseString(result)[0]
        else:
            return self
    def c_str(self,unpack=False):
        """
        :param unpack: Converts this assignment to a do loop nest if any
        matrix ranges ([...]:[...]) are found.
        """
        if unpack:
           return self.indent+self.convert_to_do_loop_nest_if_necessary().c_str()
        else:
           return self.indent + self._lhs.c_str() + "=" + flatten_arithmetic_expression(self._rhs) + ";\n"
    def f_str(self,unpack=False):
        """
        """
        if unpack:
           return self.convert_to_do_loop_nest_if_necessary().f_str()
        else:
           return self._lhs.f_str() + "=" + flatten_arithmetic_expression(self._rhs,converter=make_f_str) + ";\n"

class TTRange(TTNode):
    def _assign_fields(self,tokens):
        self._begin, self._end = tokens
        del self._tokens
    def f_str(self):
        return self._begin.f_str() + ":" + self._end.f_str()
    def c_str(self):
        return self.f_str()

class TTComplexAssignment(TTNode):
    def _assign_fields(self,tokens):
        self._lhs, self._rhs = tokens
        
    def c_str(self):
        """
        Expand the complex assignment.
        """
        result = ""
        result += "{}.x = {};\n".format(make_c_str(self._lhs),make_c_str(self._rhs._real))
        result += "{}.y = {};\n".format(make_c_str(self._lhs),make_c_str(self._rhs._imag))
        return result

class TTMatrixAssignment(TTNode):
    def _assign_fields(self,tokens):
        self._lhs, self._rhs = tokens
        
    def c_str(self):
        """
        Expand the matrix assignment.
        User still has to fix the ranges manually. 
        """
        result = "// TODO: fix ranges"
        for expression in self._rhs: 
            result += make_c_str(self._lhs) + argument + "=" + flatten_arithmetic_expression(expression) + ";\n"
        return result

class TTIntentQualifier(TTNode):
    def _assign_fields(self,tokens):
        #print("found intent_qualifier")
        #print(tokens[0])
        self._intent = tokens[0][0]
    def c_str(self):
        #print(self._intent)
        return "const" if self._intent.lower() == "in" else ""
    def f_str(self):
        return "intent({0})".format(self._intent)

class TTMatrixRange(TTNode):
    def _assign_fields(self,tokens):
        self._lbound, self._ubound, self._stride = tokens 
        self._loop_var = ""
    def set_loop_var(self,name):
        self._loop_var = name
    def lBound(self,converter=make_c_str):
        return converter(self._lbound)
    def uBound(self,converter=make_c_str):
        return converter(self._ubound)
    def unspecified_l_bound(self):
        return not len(self.lBound())
    def unspecified_u_bound(self):
        return not len(self.uBound())
    def stride(self,converter=make_c_str):
        return converter(self._stride)
    def size(self,converter=make_c_str):
        result =  "{1} - ({0}) + 1".format(converter(self._lbound),converter(self._ubound))
        try:
           result = str(ast.literal_eval(result))
        except:
           try:
              result =  " - ({0}) + 1".format(converter(self._lbound))
              result = str(ast.literal_eval(result))
              if result == "0":
                  result = converter(self._ubound)
              else:
                  result = "{1}{0}".format(result,converter(self._ubound))
           except:
              pass
        return result
    def c_str(self):
        #return self.size(make_c_str)
        if len(self._loop_var):
            return self._loop_var # if a do loop is wrapped around this range
        else:
            return "/*TODO fix this BEGIN*/{0}/*fix END*/".format(self.f_str())
    def f_str(self):
        if len(self._loop_var):
            return self._loop_var # if a do loop is wrapped around this range
        else:
            result = ""
            if not self._lbound is None:
                result += make_f_str(self._lbound)
            result += ":"
            if not self._ubound is None:
                result += make_f_str(self._ubound)
            if not self._stride is None:
                result += ":" + make_f_str(self._stride)
            return result

class TTBounds(TTNode):
    """
    Spawned from grammar:
    
    ```python
    dimension_list  = delimitedList(dimension_value)
    ```
 
    where
    
    ```python 
    dimension_value = ( matrix_range | arithmetic_expression | Literal("*"))
    ```
    """
    def _assign_fields(self,tokens):
        self._bounds = []
        if tokens != None:
            self._bounds = tokens[0]
    def has_unspecified_bounds(self,converter=make_c_str):
        """
        Typically the case if the declaration variable has
        a ALLOCATABLE or POINTER qualifier.
        """
        result = False
        for dim in self._bounds:
            result |= type(dim) is str and dim == "*"
            result |= type(dim) in [TTMatrixRange] and (dim.unspecified_l_bound() or dim.unspecified_u_bound())
        return result
    def rank(self):
        """
        :return: the rank, i.e. the number of dimensions.
        """
        return len(self._bounds)
    def specified_bounds(self,converter=make_c_str):
        """
        :return: list that contains a list [lower, upper] per specified dimension of the array.

        Note that in Fortran the fastest running ("stride(1)")
        index is on the left in expressions `(i0,i1,..,in)`, while in C the fastest
        running index is on the right in expressions `[in][in-1]...[i0]`.
        """
        result = []
        for el in self._bounds:
            if type(el) is TTArithmeticExpression:
                result.append(["1",converter(el)])
            elif type(el) is TTMatrixRange:
                result.append([el.lBound(converter),el.uBound(converter)])
            elif el in [":","*"]:
                pass
        return result
    def specified_counts(self,converter=make_c_str):
        """
        Used for mallocs. These are just the counts.
        (Number of bytes requires knowledge of datatype too.)
        """
        result = ["{0}".format(el[1]) if el[0]=="1" else "{1} - ({0}) + 1".format(el[0],el[1]) for el in self.specified_bounds(converter)]
        for i,el in enumerate(result):
            try:
               result[i] = str(ast.literal_eval(el))
            except:
               result[i] = el
        return result
    def specified_lower_bounds(self,converter=make_c_str):
        """
        Used for mallocs. These are just the counts.
        (Number of bytes requires knowledge of datatype too.)
        """
        result = [el[0] for el in self.specified_bounds(converter)]
        return result
    def size(self,bytes_per_element="1",converter=make_c_str):
        """
        Used for mallocs. These are just the counts.
        (Number of bytes requires knowledge of datatype too.)
        """
        result = "*".join(["({0})".format(dim) for dim in self.specified_counts(converter)])
        if bytes_per_element != "1":
            result = "("+bytes_per_element+")*" + result
        if converter is make_f_str:
            result = "1_8*" + result
        return result
    def bound_variable_names(self,variable_name,converter=make_c_str):
        """
        Used for function arguments and declarations
        """
        result  = ["{0}_n{1}".format(variable_name,i+1) for i in range(0,len(self._bounds))]
        result += ["{0}_lb{1}".format(variable_name,i+1) for i in range(0,len(self._bounds))]
        return result
    def bound_variable_assignments(self,variable_name,converter=make_c_str):
        """
        Used for assigning values to the bound variables. Can in general not be put in
        declaration as rhs may not be constant.
        """
        counts      = self.specified_counts(converter)
        lower_bounds = self.specified_lower_bounds(converter)
        result  = ["{0}_n{1} = {2}".format(variable_name,i+1,val) for i,val in enumerate(counts)]
        result += ["{0}_lb{1} = {2}".format(variable_name,i+1,val) for i,val in enumerate(lower_bounds)]
        return result
    def index_str(self,variable_name,use_place_holders=False,macro_args=[]):
        """
        Linearises the multivariate index required to access the original Fortran array.
        :param variable_name: Name of the array this bound is associated with.
        :type variable_name: str
        :return: an expression for the index (as string) or None if no bounds were specified.
        """
        bounds_specified = not self.has_unspecified_bounds()
        bounds          = self.specified_bounds(make_c_str) if bounds_specified else self._bounds
        lower_bounds     = self.specified_lower_bounds(make_c_str) if bounds_specified else ["1"]*len(self._bounds) # TODO
        if bounds_specified:
            counts = self.specified_counts()
        if len(bounds):
            if not len(macro_args):
                macro_args = [chr(ord('a')+i) for i in range(0,len(bounds))]
            assert len(macro_args) == len(bounds)
            if not bounds_specified or use_place_holders:
                bound_args      = ["{0}_n{1}".format(variable_name,i+1) for i in range(0,len(bounds))]
                lower_bound_args = ["{0}_lb{1}".format(variable_name,i+1) for i in range(0,len(bounds))]
            else:
                bound_args      = counts
                lower_bound_args = lower_bounds
            stride = ""
            prod = ""
            index = ""
            for i,mvar in enumerate(macro_args):
                 index += "{0}({1}-({2}))".format(stride,mvar,lower_bound_args[i])
                 prod = "{}{}*".format(prod,bound_args[i])
                 stride = "+{0}".format(prod)
            return index
        else:
            return None
    def index_macro_str(self,variable_name,converter=make_c_str,use_place_holders=False):
        """
        Linearizes the multivariate index required to access the original Fortran array.
        :param variable_name: Name of the array this bound is associated with.
        :type variable_name: str
        :return: an expression for the index (as string) or None if no bounds were specified.
        """
        bounds_specified = not self.has_unspecified_bounds()
        bounds = list(self.specified_bounds(make_c_str)) if bounds_specified else self._bounds
        macro_args = [chr(ord('a')+i) for i in range(0,len(bounds))]
        index     = self.index_str(variable_name,use_place_holders)
        if converter is make_f_str:
            return "#undef {0}\n#define {0}({1}) inc_c_ptr({0}, {2})".format(variable_name,",".join(macro_args),index)
        else:
            return "#undef _idx_{0}\n#define _idx_{0}({1}) ({2})".format(variable_name,",".join(macro_args),index)
    def index_macro_f_str(self,variable_name,use_place_holders=False):
        return self.index_macro_str(variable_name,make_f_str,use_place_holders)
    def index_macro_c_str(self,variable_name,use_place_holders=False):
        return self.index_macro_str(variable_name,make_c_str,use_place_holders)
    def c_str(self):
        """
        Returns '[size(n)][size(n-1)]...[size1]' for all n sizes corresponding to specified bounds
        """
        #print("{0}".format(self._bounds))
        #print("{0}".format(self.specified_counts(make_c_str)))
        return "".join(["[{0}]".format(make_c_str(el)) for el in self._bounds])
    def f_str(self):
        """
        Returns '(<bound1.f_str()>,<bound2.f_str()>,...,<bound(n).f_str()>)' for all n sizes corresponding to specified bounds
        """
        return "({0})".format(",".join(make_f_str(el) for el in self._bounds)) 

class TTDimensionQualifier(TTNode):
    def _assign_fields(self,tokens):
        self._bounds = tokens[0][0]
    def c_str(self):
        return make_c_str(self._bounds) 
    def f_str(self):
        return "dimension{0}".format(make_f_str(self._bounds))

class TTDeclaredVariable(TTNode):
    """
    Spawned from grammar:
    
    ```python
    declaration_variable = Group( identifier + Optional(LPAR + dimension_list + RPAR,default=[]) + Optional(EQ + ( matrix_arithmetic_expression | complex_arithmetic_expression | arithmetic_expression ), default=None)) # ! emits [*,[*],*]
    ```
    """
    def _assign_fields(self,tokens):
        self._name   = tokens[0][0]
        self._bounds = tokens[0][1]
        self._rhs    = tokens[0][2]
    def name(self,converter=make_c_str):
        return converter(self._name)
    def has_bounds(self):
        return self._bounds != None
    def get_bounds(self):
        return self._bounds
    def to_str(self,converter,include_bounds=True,include_rhs=True):
        result = converter(self._name)
        if include_bounds and self.has_bounds():
            #print(converter(self._bounds))
            result += converter(self._bounds)
        if include_rhs and converter(self._rhs) != "":
            result += " = " + converter(self._rhs)      
        return result
    def rhs_is_number(self):
        try:
           ast.literal_eval(self.rhs_c_str())
           return True;
        except:
            return False;
    def rhs_c_str(self):
        return"("+ make_f_str(self._rhs)+")"
    def c_str(self,include_bounds=True,include_rhs=True):
        return self.to_str(make_c_str,include_bounds,include_rhs)
    def f_str(self,include_bounds=True,include_rhs=True):
        return self.to_str(make_f_str,include_bounds,include_rhs)

class Attributed():
    def get_string_qualifiers(self):
        """
        :param name: lower case string qualifier, i.e. no more complex qualifier such as 'dimension' or 'intent'.
        """
        return [q.lower() for q in self._qualifiers if type(q) is str]
    def has_string_qualifier(self,name):
        """
        :param name: lower case string qualifier, i.e. no more complex qualifier such as 'dimension' or 'intent'.
        """
        result = False
        for q in self._qualifiers:
            result |= type(q) is str and q.lower() == name.lower()
        return result
    def has_dimension(self):
        return len(find_all(self._qualifiers,TTDimensionQualifier))

class TTDeclaration(TTNode,Attributed):
    """ 
    Spawned from grammar:

    ```python
    declaration = datatype + Optional(COMMA + qualifier_list,default=[]) + COLONS + Group(delimitedList(declaration_variable))   # ! emits *,[*],[*]
    ```
    """
    def _assign_fields(self,tokens):
        #declaration = datatype + Optional(COMMA + attribute_list,default=[]) + COLONS + Group(delimitedList(declaration_variable))   # ! emits *,[*],[*]
        self._datatype, self._qualifiers, self._rhs = tokens
        self.ignore_list = []
    def f_type(self):
        """
        Fortran basetype of the datatype.
        """
        return make_f_str(self._datatype.type())
    def is_derived_type(self):
        return self._datatype.is_derived_type()
    def kind(self):
        """
        Kind of the datatype.
        :note: Stores the derived type name if the datatype is a derived type.
        """
        return make_f_str(self._datatype.kind())
    def bytes_per_element(self):
        """
        The bytes required to store one element of the datatype of the
        ttdeclaredvariable variables.
        """
        return self._datatype.bytes() 
    def variable_names(self):
        """
        The names of any variables defined by this ttdeclaredvariable.
        Use on the result to check if any array variables are present.
        """
        #for ttdeclaredvariable in self._rhs:
        #     #print(ttdeclaredvariable)
        return [ttdeclaredvariable.name() for ttdeclaredvariable in self._rhs]
    def array_variable_names(self):
        """
        The names of any array variables defined by this ttdeclaredvariable.
        Use `len` on the result to check if any array variables are present.
        """
        result = []
        for ttdeclaredvariable in self._rhs:
            if self.has_dimension() or ttdeclaredvariable.has_bounds():
                result.append(ttdeclaredvariable.name())
        return result

    def num_elements(self,name):
        """
        :return: number of elements of the (multi-dimensional) array 'name' (per dimension).
        :rtype: list of str
        """
        dimension_qualifier = find_all(self._qualifiers,TTDimensionQualifier)
        if len(dimension_qualifier):
            return dimension_qualifier[0]._bounds.specified_counts()
        else:
            for ttdeclaredvariable in self._rhs:
                 if ttdeclaredvariable.name().lower() == name.lower():
                     return ttdeclaredvariable._bounds.specified_counts()
        return []
    def array_bound_variable_names_f_str(self,name):
        """
        If the ttdeclaredvariable has a `dimension(...)` token,
        derive bound variable names from bounds stated in there.
        Otherwise, check if the variable ttdeclaredvariables has some array brackets
        and derive bound variable names from there.

        :see: TTBounds.bound_variable_names, array_variable_names
        :rtype: list
        """
        dimension_qualifier = find_all(self._qualifiers,TTDimensionQualifier)
        if len(dimension_qualifier):
            return dimension_qualifier[0]._bounds.bound_variable_names(name,make_f_str)
        else:
            for ttdeclaredvariable in self._rhs:
                 if ttdeclaredvariable.name().lower() == name.lower():
                     return ttdeclaredvariable._bounds.bound_variable_names(name,make_f_str)
        return []
    def array_bound_variable_assignments_f_str(self,name):
        """
        If the ttdeclaredvariable has a `dimension(...)` token with fixed bounds,
        derive bound variable assignments from bounds stated in there.
        Otherwise, check if the variable ttdeclaredvariables has some array brackets
        and dervice bound variable assignments from there.

        :see: TTBounds.bound_variable_names, array_variable_names
        :rtype: list
        """
        dimension_qualifier = find_all(self._qualifiers,TTDimensionQualifier)
        if len(dimension_qualifier):
            return dimension_qualifier[0]._bounds.bound_variable_assignments(name,make_f_str)
        else:
            for ttdeclaredvariable in self._rhs:
                 if ttdeclaredvariable.name().lower() == name.lower():
                     return ttdeclaredvariable._bounds.bound_variable_assignments(name,make_f_str)
        return []
    def array_variable_index_str(self,name):
        """
        If the ttdeclaredvariable has a `dimension(...)` token,
        derive index from bounds stated in there.
        Otherwise, check if the variable ttdeclaredvariables has some array brackets
        and derive macro string from there.

        :see: TTBounds.index_str(), array_variable_names
        """
        dimension_qualifier = find_all(self._qualifiers,TTDimensionQualifier)
        if len(dimension_qualifier):
            return dimension_qualifier[0]._bounds.index_str(name)
        else:
            for ttdeclaredvariable in self._rhs:
                 if ttdeclaredvariable.name().lower() == name.lower():
                     return ttdeclaredvariable._bounds.index_str(name)
        return None
    def array_variable_index_macro_str(self,name,converter=make_c_str,use_place_holders=False):
        """
        If the ttdeclaredvariable has a `dimension(...)` token,
        derive index from bounds stated in there.
        Otherwise, use

        :see: TTBounds.index_str(), array_variable_names
        """
        dimension_qualifier = find_all(self._qualifiers,TTDimensionQualifier)
        if len(dimension_qualifier):
            return dimension_qualifier[0]._bounds.index_macro_str(name,converter,use_place_holders)
        else:
            for ttdeclaredvariable in self._rhs:
                 if ttdeclaredvariable.name().lower() == name.lower():
                     #print(">"+str(ttdeclaredvariable._bounds))
                     return ttdeclaredvariable._bounds.index_macro_str(name,converter,use_place_holders)
        return None
    def array_variable_index_macro_f_str(self,name,use_place_holders=False):
        return self.array_variable_index_macro_str(name,make_f_str,use_place_holders)
    def array_variable_index_macro_c_str(self,name,use_place_holders=False):
        return self.array_variable_index_macro_str(name,make_c_str,use_place_holders)
    def rhs_c_str(self,name):
        """
        :return: C expression of the right-hand side of the variable with name `name`. Returns empty string in case there is no right-hand side.
        :rtype: str
        :param name: identi
        """
        result = ""
        for ttdeclaredvariable in self._rhs:
            if ttdeclaredvariable.name().lower() == name.lower():
                result = make_c_str(ttdeclaredvariable._rhs)
        return result
    def f_str(self,extra_ignore_list=[],include_bounds=True,include_rhs=True):
        """
        The ignore list can be used to filter out some
        variables
        """
        ignore_list = map(str.lower, self.ignore_list + extra_ignore_list)
        qualifiers_str = ", " if len(self._qualifiers) else ""
        qualifiers_str += ", ".join([make_f_str(q) for q in self._qualifiers])
        result = "{0}{1} :: ".format(make_f_str(self._datatype),qualifiers_str)
        ignored_vars = 0
        for ttdeclaredvariable in self._rhs:
            if not ttdeclaredvariable.name(make_f_str).lower() in ignore_list:
                ignored_vars += 1
                result += "{0},".format(ttdeclaredvariable.f_str(include_bounds,include_rhs))
        if ignored_vars == len(self._rhs):
            return ""
        else:
            return result.rstrip(",")
    def c_str(self,extra_ignore_list=[],is_function_argument=False,include_bounds=True,include_rhs=True):
        """
        The ignore list can be used to filter out some
        variables, e._g. if these are parameters of a subroutine
        that we want to convert.
        """
        # TODO do we still need this if we have the full index at hand?
        ignore_list      = [make_c_str(var) for var in (self.ignore_list + extra_ignore_list)]
        result          = ""
        comment         = ""
        dimension_bounds = ""
        if len(self._qualifiers):
           dimension_qualifier = find_all(self._qualifiers,TTDimensionQualifier)
           if len(dimension_qualifier):
                dimension_bounds = make_c_str(dimension_qualifier[0])
           comment = " /* Fortran qualifiers: {0} */".format(",".join([make_f_str(el) for el in self._qualifiers]))
        for ttdeclaredvariable in self._rhs:
            if not ttdeclaredvariable.name(make_c_str) in ignore_list: 
                if is_function_argument:
                    result += "{{indent}}{0} {1},".format(make_c_str(self._datatype),ttdeclaredvariable.c_str(include_bounds,include_rhs),comment)
                else:
                    datatype = make_c_str(self._datatype)
                    if self.has_string_qualifier("shared"): # never a function argument
                        datatype = "__shared__ " + datatype
                    result += "{{indent}}{0} {1}{2};{3}\n".format(datatype,ttdeclaredvariable.c_str(include_bounds,include_rhs),dimension_bounds,comment) 
        result = result.format(indent=self.indent) 
        if is_function_argument:
            return result
        else:
            return result.rstrip(",")

class TTStatement(TTNode):
    """
    Mainly used for searching expressions and replacing them in the translator AST.
    One example is converting to colon operations to do loops.
    """
    def _assign_fields(self,tokens):
        self._statement = tokens
    def c_str(self):
        return make_c_str(self._statement)
    def f_str(self):
        return make_f_str(self._statement)

class TTSingleLineIf(TTNode):
    def _assign_fields(self,tokens):
        self._condition, self.body, self._semicolon= tokens
    def c_str(self):
        body_content = flatten_body(self.body) 
        return "if ({0}) {{\n  {1}\n}}".format(make_c_str(self._condition), body_content)
    def f_str(self):
        return "if ({0}) {1}{2}".format(make_f_str(self._condition), make_f_str(self.body), self._semicolon)
    def multiline_if_f_str(self):
        return "if ({0}) then\n{1}\nendif\n".format(make_f_str(self._condition).strip("\n"), make_f_str(self.body).strip())
    def __str__(self):
        """
        Makes it possible to use it with pyparsing's transform_string method
        """
        return self.multiline_if_f_str()

class TTIfElseBlock(TTContainer):
    pass
class TTIfElseIf(TTContainer):
    def _assign_fields(self,tokens):
        print(tokens)
        self._else, self._condition, self.body = tokens
    def c_str(self):
        body_content = flatten_body(self.body) 
        return "{0}{1}if ({2}) {{\n{3}\n{0}}}".format(\
            self.indent,self._else,make_c_str(self._condition),body_content) 
class TTElse(TTContainer):
    def c_str(self):
        body_content = TTContainer.c_str(self) 
        return "{0}else {{\n{1}\n{0}}}".format(\
            self.indent,body_content)

class TTWhile(TTContainer):
    def _assign_fields(self,tokens):
        self._condition, self.body = tokens
    def c_str(self):    
        body_content = TTContainer.c_str(self) 
        condition_content = make_c_str(self._condition)
        c_str = "while ({0}) {{\n  {1}\n}}".format(condition_content,body_content) 
        return c_str

## Link actions
#print_statement.setParseAction(TTCommentedOut)
comment.setParseAction(TTCommentedOut)

logical.setParseAction(TTLogical)
integer.setParseAction(TTNumber)
number.setParseAction(TTNumber)
l_arith_operator.setParseAction(TTOperator)
#r_arith_operator.setParseAction(TTOperator)
condition_op.setParseAction(TTOperator)
identifier.setParseAction(TTIdentifier)
rvalue.setParseAction(TTRValue)
lvalue.setParseAction(TTLValue)
simple_derived_type_member.setParseAction(TTDerivedTypeMember)
derived_type_elem.setParseAction(TTDerivedTypeMember)
func_call.setParseAction(TTFunctionCallOrTensorAccess)

convert_to_extract_real.setParseAction(TTConvertToExtractReal)
convert_to_double.setParseAction(TTConvertToDouble)
convert_to_complex.setParseAction(TTConvertToComplex)
convert_to_double_complex.setParseAction(TTConvertToDoubleComplex)
extract_imag.setParseAction(TTExtractImag)
conjugate.setParseAction(TTConjugate)
conjugate_double_complex.setParseAction(TTConjugate) # same action

size_inquiry.setParseAction(TTSizeInquiry)
lbound_inquiry.setParseAction(TTLboundInquiry)
ubound_inquiry.setParseAction(TTUboundInquiry)

datatype_comment.setParseAction(TTDatatype_Comment)
datatype_convert.setParseAction(TTDatatype_Convert)

matrix_range.setParseAction(TTMatrixRange)
bounds.setParseAction(TTBounds)
matrix_ranges.setParseAction(TTBounds)
dimension_qualifier.setParseAction(TTDimensionQualifier)
intent_qualifier.setParseAction(TTIntentQualifier)

declared_variable.setParseAction(TTDeclaredVariable)
arithmetic_expression.setParseAction(TTArithmeticExpression)
arithmetic_logical_expression.setParseAction(TTArithmeticExpression)
complex_arithmetic_expression.setParseAction(TTComplexArithmeticExpression)
power_value1.setParseAction(TTRValue)
power.setParseAction(TTPower)
assignment.setParseAction(TTAssignment)
matrix_assignment.setParseAction(TTMatrixAssignment)
complex_assignment.setParseAction(TTComplexAssignment)

# statements
return_statement.setParseAction(TTReturn)
fortran_subroutine_call.setParseAction(TTSubroutineCall)
fortran_declaration.setParseAction(TTDeclaration)
