# SPDX-License-Identifier: MIT                                                
# Copyright (c) 2021 GPUFORT Advanced Micro Devices, Inc. All rights reserved.
#from translator.translator_base import *

#f03
def flattenArithmeticExpression(expr,converter=make_c_str):
    def descend(element,depth=0):
        term = ""
        if isinstance(element,ParseResults):
           for el in element:
               term += "(" if isinstance(el,ParseResults) else ""
               term += descend(el,depth)
               term += ")" if isinstance(el,ParseResults) else ""
           return term
        else:
           return converter(element)
    return descend(expr)       

class TTSimpleToken(TTNode):
      def _assign_fields(self,tokens):
          self._text = " ".join(tokens)
      def c_str(self):
          return "{};".format(self._text.lower())
      def f_str(self):
          return str(self._text)

class TTReturn(TTNode):
      def _assign_fields(self,tokens):
          self._resultName = ""  
      def c_str(self): 
          if len(self._resultName):
              return "return "+self._resultName+";"
          else:
              return "return;"
      def f_str(self):
          return "return"

class TTCommentedOut(TTNode):
      def _assign_fields(self,tokens):
          self._text = " ".join(tokens)
      def c_str(self):
          return "// {}\n".format(self._text)

class TTIgnore(TTNode):
      def c_str(self):
          return ""

class TTLogical(TTNode):
    def _assign_fields(self,tokens):
        self._value = tokens[0]
    def c_str(self):
        return "true" if self._value.lower() == ".true." else "false"
    def f_str(self):
        return self._value

class TTNumber(TTNode):
    def _assign_fields(self,tokens):
        self._value = tokens[0]
    def c_str(self):
        parts = self._value.replace("d","e").split("_")
        if len(parts) > 1:
            return "{0} /*_{1}*/".format(parts[0],parts[1])
        else:
            return parts[0] 
        return self._value 
    def f_str(self):
        return self._value

class TTDatatype_Comment(TTNode):
    # generates object Datatype{'type' : '...', 'kind' : '...'}
    def _assign_fields(self,tokens):
        self._type   = tokens[0]
        self._kind   = tokens[1][0]
        self._length = tokens[1][1]
    def type(self):
        """
        Fortran basetype of the datatype.
        """
        return self._type
    def kind(self):
        return self._kind
    def len(self):
        return self._length
    def isDerivedType(self):
        return self._type.lower() == "type"
    def bytes(self):
        return "TODO unknown size"  
    def c_str(self):
        fType  = make_f_str(self._type)
        kind   = make_f_str(self._kind)
        length = make_f_str(self._length)
        return "// {}\n// {}(kind={},len={})".format(UNCONVERTED,fType,kind,length)
    def f_str(self):
        # comment only when generating c string
        result = make_f_str(self._type)
        kind   = make_f_str(self._kind)
        length = make_f_str(self._length)
        args = []
        if len(kind):
            args.append("kind={}".format(kind))
        if len(length):
            args.append("len={}".format(len))
        if len(args):
            result += "({0})".format(",".join(args))
        return result

class TTDatatype_Convert(TTNode):
    # generates object Datatype{'type' : '...', 'kind' : '...'}
    def _assign_fields(self,tokens):
        self._type   = tokens[0]
        self._kind   = tokens[1][0]
        self._length = tokens[1][1]
    def type(self):
        return self._type
    def isDerivedType(self):
        return self._type.lower() == "type"
    def kind(self):
        return self._kind
    def len(self):
        return self._length
    def bytes(self):
        return bytes(make_f_str(self._type),make_f_str(self._kind))  
    def c_str(self):
        fType = make_f_str(self._type)
        kind = make_f_str(self._kind)
        cType = convertToCType(fType,kind)
        if cType == None:
            return "// {}\n// {}".format(UNCONVERTED,fType,kind)
        return cType
    def f_str(self):
        result = str(self._type)
        haveKind = not self._kind is None 
        haveLen  = not self._length is None
        haveParam = haveKind or haveLen
        if haveParam:
            result += "("
        if haveKind:
            result += "kind={}".format(make_f_str(self._kind))
            if haveLen:
                result += ", "
        if haveLen:
            result += "len={}".format(make_f_str(self._len))
        if haveParam:
            result += ")"
        return result            

class TTIdentifier(TTNode):
    def _assign_fields(self,tokens):
        self._name = tokens[0]
    def f_str(self):
        return str(self._name)
    def c_str(self):
        return self.f_str()
    def name(self,mangleName=False): # argument is never used as we have already an identifier
        return self.f_str()

class TTFunctionCallOrTensorAccess(TTNode):
    def _assign_fields(self,tokens):
        self._name = tokens[0]
        self._args = tokens[1]
        self._isTensorAccess = Unknown3
    def matrix_rangeArgs(self):
        """
        Returns all matrix range args in the order of their appeareance.
        """
        return find_all(self._args,searchedType=TTMatrixRange)
    def hasMatrixRangeArgs(self):
        """
        If any matrix range args are present in the argument list.
        """
        return not find_first(self._args,searchedType=TTMatrixRange) is None
    def __guessItIsFunction(self): 
        """ 
        Tries to determine if the whole expression
        is function or not if no other hints are given
        """
        name = make_c_str(self._name).lower()
        return len(self._args) == 0 or\
          name in GPUFORT_CPP_ROUTINES or\
          name in ALL_HOST_ROUTINES or\
          name in ALL_DEVICE_ROUTINES
    def isTensor(self):
        if self._isTensorAccess == True3:
            return True
        elif self._isTensorAccess == False3:
            return False
        else:
            return self.hasMatrixRangeArgs() or\
                   not self.__guessItIsFunction()
    def name(self,mangleArgs=False):
        if mangleArgs:
            result = self.f_str().replace("(","_")
            result = result.replace(",","_")
            result = ''.join(e for e in result if e.isalnum() or e == "_" )
            return result
        else:
            return make_f_str(self._name)
    def c_str(self):
        name = make_c_str(self._name).lower()
        if self.isTensor():
            return "{0}[_idx_{0}({1})]".format(name,",".join([make_c_str(s) for s in self._args])) # Fortran identifiers cannot start with "_"
        else:
            return "{}({})".format(name,",".join([make_c_str(s) for s in self._args]))
    def f_str(self):
        name = make_f_str(self._name)
        return "{0}({1})".format(name,",".join([make_f_str(s) for s in self._args]))

class IValue:
    def isIdentifier(self):
        return type(self._value) is TTIdentifier      
    def name(self):
        if type(self._value) is TTFunctionCallOrTensorAccess:
            return self._value.name(False)
        elif type(self._value) is TTDerivedTypeMember:
            return self._value.name(False)
        else:
            return self._value.name(False)
    def hasMatrixRangeArgs(self):
        """
        Functionality for scanner.
        """
        if type(self._value) is TTFunctionCallOrTensorAccess:
            return self._value.hasMatrixRangeArgs()
        elif type(self._value) is TTDerivedTypeMember:
            return self._value.lastElementHasMatrixRangeArgs()
        else:
            return False
    def matrix_rangeArgs(self):
        if type(self._value) is TTFunctionCallOrTensorAccess:
            return self._value.matrix_rangeArgs()
        elif type(self._value) is TTDerivedTypeMember:
            return self._value.lastElementMatrixRangeArgs()
        else:
            return []
class TTRValue(TTNode,IValue):
    def _assign_fields(self,tokens):
        self._sign           = tokens[0]
        self._value          = tokens[1]
        self._reductionIndex = ""
        #print("{0}: {1}".format(self.c_str(),self.location))
    def f_str(self):
        return self._sign + make_f_str(self._value)
    def c_str(self):
        result = self._sign + make_c_str(self._value)
        if len(self._reductionIndex):
            result += "[{idx}]".format(idx=self._reductionIndex) 
        return result.lower()

class TTLValue(TTNode,IValue):
    def _assign_fields(self,tokens):
        self._value          = tokens[0]
        self._reductionIndex = ""
        #print("{0}: {1}".format(self.c_str(),self.location))
    def f_str(self):
        return make_f_str(self._value)
    def c_str(self):
        result = make_c_str(self._value)
        if len(self._reductionIndex):
            result += "[{idx}]".format(idx=self._reductionIndex) 
        return result

class TTSizeInquiry(TTNode):
    """
    Translator tree node for size inquiry function.
    """
    def _assign_fields(self,tokens):
        self._ref, self._dim, self._kind = tokens
    def c_str(self):
        """
        :return: number of elements per array dimension, if the dimension
                 is specified as argument.
                 Utilizes the <array>_n<dim> and <array>_lb<dim> arguments that
                 are passed as argument of the extracted kernels.
        :note: only the case where <dim> is specified as integer literal is handled by this function.
        """
        if type(self._dim) is TTNumber:
            return make_c_str(self._ref) + "_n" + make_c_str(self._dim) 
        else:
            prefix = "size"
            return "/* "+prefix+"("+make_f_str(self._ref)+") */"
    def f_str(self):
        prefix = "size"
        result = prefix + "("+make_f_str(self._ref)
        if self._dim != None:
            result += "," + make_f_str(self._dim)
        if self._kind != None:
            result += "," + make_f_str(self._kind)
        return result + ")"

class TTLboundInquiry(TTNode):
    """
    Translator tree node for lbound inquiry function.
    """
    def _assign_fields(self,tokens):
        self._ref, self._dim, self._kind = tokens
    def c_str(self):
        """
        :return: lower bound per array dimension, if the dimension argument is specified as integer literal.
                 Utilizes the <array>_n<dim> and <array>_lb<dim> arguments that
                 are passed as argument of the extracted kernels.
        :note:   only the case where <dim> is specified as integer literal is handled by this function.
        """
        if type(self._dim) is TTNumber:
            return make_c_str(self._ref) + "_lb" + make_c_str(self._dim) 
        else:
            prefix = "lbound"
            return "/* "+prefix+"("+make_f_str(self._ref)+") */"
    def f_str(self):
        prefix = "lbound"
        result = prefix + "("+make_f_str(self._ref)
        if self._dim != None:
            result += "," + make_f_str(self._dim)
        if self._kind != None:
            result += "," + make_f_str(self._kind)
        return result + ")"

class TTUboundInquiry(TTNode):
    """
    Translator tree node for ubound inquiry function.
    """
    def _assign_fields(self,tokens):
        self._ref, self._dim, self._kind = tokens
    def c_str(self):
        """
        :return: upper bound per array dimension, if the dimension argument is specified as integer literal.
                 Utilizes the <array>_n<dim> and <array>_lb<dim> arguments that
                 are passed as argument of the extracted kernels.
        :note:   only the case where <dim> is specified as integer literal is handled by this function.
        """
        if type(self._dim) is TTNumber:
            return "({0}_lb{1} + {0}_n{1} - 1)".format(
                make_c_str(self._ref),
                make_c_str(self._dim))
        else:
            prefix = "ubound"
            return "/* "+prefix+"("+make_f_str(self._ref)+") */"
    def f_str(self):
        prefix = "ubound"
        result = prefix + "("+make_f_str(self._ref)
        if self._dim != None:
            result += "," + make_f_str(self._dim)
        if self._kind != None:
            result += "," + make_f_str(self._kind)
        return result + ")"

class TTConvertToExtractReal (TTNode):
    def _assign_fields(self,tokens):
        self._ref, self._kind = tokens
    def c_str(self):
        cType = convertToCType("real",self._kind).replace(" ","_") # TODO check if his anything else than double or float
        return "make_{1}({0})".format(make_c_str(self._ref),cType) # rely on C++ compiler to make the correct type conversion
    def f_str(self):
        result ="REAL({0}".format(make_f_str(self._ref))
        if not self._kind is None:
            result += ",kind={0}".format(make_f_str(self._kind))
        return result + ")"

class TTConvertToDouble(TTNode):
    def _assign_fields(self,tokens):
        self._ref, self._kind = tokens
    def c_str(self):
        return "make_double({0})".format(make_c_str(self._ref)) # rely on C++ compiler to make the correct type conversion
    def f_str(self):
        return "DBLE({0})".format(make_f_str(self._ref)) # rely on C++ compiler to make the correct type conversion

class TTConvertToComplex(TTNode):
    def _assign_fields(self,tokens):
        self._x, self._y, self._kind = tokens
    def c_str(self):
        cType = convertToCType("complex",self._kind,default=None,floatComplex="floatComplex",doubleComplex="doubleComplex")
        return "make_{2}({0}, {1})".format(make_c_str(self._x),make_c_str(self._y),cType)
    def f_str(self):
        result ="CMPLX({0},{1}".format(make_f_str(self._x),make_f_str(self._y))
        if not self._kind is None:
            result += ",kind={0}".format(make_f_str(self._kind))
        return result + ")"

class TTConvertToDoubleComplex(TTNode):
    def _assign_fields(self,tokens):
        self._x, self._y, self._kind = tokens
    def c_str(self):
        cType="doubleComplex"
        return "make_{2}({0}, {1})".format(make_c_str(self._x),make_c_str(self._y),cType)
    def f_str(self):
        result ="DCMPLX({0},{1}".format(make_f_str(self._x),make_f_str(self._y))
        return result + ")"

class TTExtractImag(TTNode):
    def _assign_fields(self,tokens):
        self._ref, self._kind = tokens
    def c_str(self):
        return "{0}._y".format(make_c_str(self._ref))

class TTConjugate(TTNode):
    def _assign_fields(self,tokens):
        self._ref, self._kind = tokens
    def c_str(self):
        return "conj({0})".format(make_c_str(self._ref))

class TTDerivedTypeMember(TTNode):
    def _assign_fields(self,tokens):
        self._type, self._element = tokens
        #print(self._type)
    def lastElementMatrixRangeArgs(self):
        """
        Returns all matrix range args in the order of their appeareance.
        """
        result = []
        current = self._element
        while type(current) is TTDerivedTypeMember:
            current = current._element
        if type(current) is TTFunctionCallOrTensorAccess:
            return current.matrix_rangeArgs()
        else:
            return []
    def lastElementHasMatrixRangeArgs(self):
        """
        If any matrix range args are present in the argument list.
        """
        result = []
        current = self._element
        while type(current) is TTDerivedTypeMember:
            current = current._element
        if type(current) is TTFunctionCallOrTensorAccess:
            return current.hasMatrixRangeArgs()
        else:
            return False
    def name(self,mangleName=False):
        return self._type.name(mangleName) + "_" + self._element.name(mangleName)
    def c_str(self,):
        return make_c_str(self._type) + "." + make_c_str(self._element)
    def f_str(self):
        return make_f_str(self._type) + "%" + make_f_str(self._element)

class TTSubroutineCall(TTNode):
    def _assign_fields(self,tokens):
        self._subroutine=tokens[0]
    def c_str(self):
        self._subroutine._isTensorAccess = False3
        return self._subroutine.c_str()+";"

class TTOperator(TTNode):
    def _assign_fields(self,tokens):
        self._name = tokens[0]
    def c_str(self):
        f2c = {
          ".eq."   : "==",
          "/="     : "!=",
          ".ne."   : "!=",
          ".neqv." : "!=",
          ".lt."   : "<",
          ".gt."   : ">",
          ".le."   : "<=",
          ".ge."   : ">=",
          ".and."  : "&",
          ".or."   : "|",
          ".xor."  : "^",
          ".not."  : "!",
          ".eqv."  : "==",
        }
        return f2c.get(self._name.lower(),self._name)
    def f_str(self):
        return str(self._name)

class TTArithmeticExpression(TTNode):
    def _assign_fields(self,tokens):
        self._expr = tokens
    def c_str(self):
        return flattenArithmeticExpression(self._expr)
    def f_str(self):
        return flattenArithmeticExpression(self._expr,make_f_str)

class TTComplexArithmeticExpression(TTNode):
    def _assign_fields(self,tokens):
        self._real, self._imag = tokens[0]
    def c_str(self):
        return "make_hipComplex({real},{imag})".format(\
                real=flattenArithmeticExpression(self._real,make_c_str),\
                imag=flattenArithmeticExpression(self._imag,make_c_str))
    def f_str(self):
        return "({real},{imag})".format(\
                real=flattenArithmeticExpression(self._real,make_f_str),\
                imag=flattenArithmeticExpression(self._imag,make_f_str))

class TTPower(TTNode):
    def _assign_fields(self,tokens):
        self._base, self._exp = tokens
    def gpufortFStr(self,scope=[]):
        sign = ""
        base = self._base
        if type(self._base) is TTRValue:
            base = self._base._value
            sign = self._base._sign
        return "{sign}__pow({base},{exp})".format(\
            sign=make_f_str(sign),base=make_f_str(base),
            exp=make_f_str(self._exp))
    
    __str__ = gpufortFStr
    
    def f_str(self):
        return "({base})**({exp})".format(\
            base=make_c_str(self._base),exp=make_c_str(self._exp))

class TTAssignment(TTNode):
    def _assign_fields(self,tokens):
        self._lhs, self._rhs = tokens
    def convertToDoLoopNestIfNecessary(self):
        """
        - step through bounds
        - if type is range
          - get upper bound
	    - not found: use a_lb<i>+a_n<i>-1
	  - get lower bound
	     - not found: use a_lb<i>
        """
        name = self._lhs.name()
        loopNestStart = ""
        loopNestEnd   = ""
        originalFStr = self.f_str()
        for i,matrix_range in enumerate(self._lhs.matrix_rangeArgs()):
            loopVarName = "_"+chr(ord('a')+i) # Fortran names cannot start with "_"
            matrix_range.setLoopVar(loopVarName)
            lbound = matrix_range.lBound()
            if not len(lbound):
                lbound = "{name}_lb{i}".format(name=name,i=i+1)
            ubound = matrix_range.uBound()
            if not len(ubound):
                ubound = "({lbound} + {name}_n{i} - 1)".format(lbound=lbound,name=name,i=i+1)
            stride = matrix_range.stride()
            if not len(stride):
                stride="1"
            loopNestStart = "do {var}={lb},{ub},{step}\n".format(var=loopVarName,lb=lbound,ub=ubound,step=stride) + loopNestStart
            loopNestEnd   = "end do\n" + loopNestEnd 
        if len(loopNestStart):
            # TODO put into options
            for rvalue in find_all(self._rhs,searchedType=TTRValue):
                for i,matrix_range in enumerate(rvalue.matrix_rangeArgs()):
                 loopVarName = "_"+chr(ord('a')+i) # Fortran names cannot start with "_"
                 matrix_range.setLoopVar(loopVarName)
            loopNestStart += "! TODO(gpufort) please check if this conversion was done correctly\n"
            loopNestStart += "! original: {}\n".format(originalFStr)
            result = loopNestStart + self.f_str()+"\n" + loopNestEnd
            return annotated_do_loop.parseString(result)[0]
        else:
            return self
    def c_str(self,unpack=False):
        """
        :param unpack: Converts this assignment to a do loop nest if any
        matrix ranges ([...]:[...]) are found.
        """
        if unpack:
           return self.convertToDoLoopNestIfNecessary().c_str()
        else:
           return self._lhs.c_str() + "=" + flattenArithmeticExpression(self._rhs) + ";\n"
    def f_str(self,unpack=False):
        """
        """
        if unpack:
           return self.convertToDoLoopNestIfNecessary().f_str()
        else:
           return self._lhs.f_str() + "=" + flattenArithmeticExpression(self._rhs,converter=make_f_str) + ";\n"

class TTRange(TTNode):
    def _assign_fields(self,tokens):
        self._begin, self._end = tokens
        del self._tokens
    def f_str(self):
        return self._begin.f_str() + ":" + self._end.f_str()
    def c_str(self):
        return self.f_str()

class TTComplexAssignment(TTNode):
    def _assign_fields(self,tokens):
        self._lhs, self._rhs = tokens
        
    def c_str(self):
        """
        Expand the complex assignment.
        """
        result = ""
        result += "{}.x = {};\n".format(make_c_str(self._lhs),make_c_str(self._rhs._real))
        result += "{}.y = {};\n".format(make_c_str(self._lhs),make_c_str(self._rhs._imag))
        return result

class TTMatrixAssignment(TTNode):
    def _assign_fields(self,tokens):
        self._lhs, self._rhs = tokens
        
    def c_str(self):
        """
        Expand the matrix assignment.
        User still has to fix the ranges manually. 
        """
        result = "// TODO: fix ranges"
        for expression in self._rhs: 
            result += make_c_str(self._lhs) + argument + "=" + flattenArithmeticExpression(expression) + ";\n"
        return result

class TTIntentQualifier(TTNode):
    def _assign_fields(self,tokens):
        #print("found intent_qualifier")
        #print(tokens[0])
        self._intent = tokens[0][0]
    def c_str(self):
        #print(self._intent)
        return "const" if self._intent.lower() == "in" else ""
    def f_str(self):
        return "intent({0})".format(self._intent)

class TTMatrixRange(TTNode):
    def _assign_fields(self,tokens):
        self._lbound, self._ubound, self._stride = tokens 
        self._loopVar = ""
    def setLoopVar(self,name):
        self._loopVar = name
    def lBound(self,converter=make_c_str):
        return converter(self._lbound)
    def uBound(self,converter=make_c_str):
        return converter(self._ubound)
    def unspecifiedLBound(self):
        return not len(self.lBound())
    def unspecifiedUBound(self):
        return not len(self.uBound())
    def stride(self,converter=make_c_str):
        return converter(self._stride)
    def size(self,converter=make_c_str):
        result =  "{1} - ({0}) + 1".format(converter(self._lbound),converter(self._ubound))
        try:
           result = str(ast.literal_eval(result))
        except:
           try:
              result =  " - ({0}) + 1".format(converter(self._lbound))
              result = str(ast.literal_eval(result))
              if result == "0":
                  result = converter(self._ubound)
              else:
                  result = "{1}{0}".format(result,converter(self._ubound))
           except:
              pass
        return result
    def c_str(self):
        #return self.size(make_c_str)
        if len(self._loopVar):
            return self._loopVar # if a do loop is wrapped around this range
        else:
            return "/*TODO fix this BEGIN*/{0}/*fix END*/".format(self.f_str())
    def f_str(self):
        if len(self._loopVar):
            return self._loopVar # if a do loop is wrapped around this range
        else:
            result = ""
            if not self._lbound is None:
                result += make_f_str(self._lbound)
            result += ":"
            if not self._ubound is None:
                result += make_f_str(self._ubound)
            if not self._stride is None:
                result += ":" + make_f_str(self._stride)
            return result

class TTBounds(TTNode):
    """
    Spawned from grammar:
    
    ```python
    dimensionList  = delimitedList(dimension_value)
    ```
 
    where
    
    ```python 
    dimension_value = ( matrix_range | arithmetic_expression | Literal("*"))
    ```
    """
    def _assign_fields(self,tokens):
        self._bounds = []
        if tokens != None:
            self._bounds = tokens[0]
    def hasUnspecifiedBounds(self,converter=make_c_str):
        """
        Typically the case if the declaration variable has
        a ALLOCATABLE or POINTER qualifier.
        """
        result = False
        for dim in self._bounds:
            result |= type(dim) is str and dim == "*"
            result |= type(dim) in [TTMatrixRange] and (dim.unspecifiedLBound() or dim.unspecifiedUBound())
        return result
    def rank(self):
        """
        :return: the rank, i.e. the number of dimensions.
        """
        return len(self._bounds)
    def specifiedBounds(self,converter=make_c_str):
        """
        :return: list that contains a list [lower, upper] per specified dimension of the array.

        Note that in Fortran the fastest running ("stride(1)")
        index is on the left in expressions `(i0,i1,..,in)`, while in C the fastest
        running index is on the right in expressions `[in][in-1]...[i0]`.
        """
        result = []
        for el in self._bounds:
            if type(el) is TTArithmeticExpression:
                result.append(["1",converter(el)])
            elif type(el) is TTMatrixRange:
                result.append([el.lBound(converter),el.uBound(converter)])
            elif el in [":","*"]:
                pass
        return result
    def specifiedCounts(self,converter=make_c_str):
        """
        Used for mallocs. These are just the counts.
        (Number of bytes requires knowledge of datatype too.)
        """
        result = ["{0}".format(el[1]) if el[0]=="1" else "{1} - ({0}) + 1".format(el[0],el[1]) for el in self.specifiedBounds(converter)]
        for i,el in enumerate(result):
            try:
               result[i] = str(ast.literal_eval(el))
            except:
               result[i] = el
        return result
    def specifiedLowerBounds(self,converter=make_c_str):
        """
        Used for mallocs. These are just the counts.
        (Number of bytes requires knowledge of datatype too.)
        """
        result = [el[0] for el in self.specifiedBounds(converter)]
        return result
    def size(self,bytesPerElement="1",converter=make_c_str):
        """
        Used for mallocs. These are just the counts.
        (Number of bytes requires knowledge of datatype too.)
        """
        result = "*".join(["({0})".format(dim) for dim in self.specifiedCounts(converter)])
        if bytesPerElement != "1":
            result = "("+bytesPerElement+")*" + result
        if converter is make_f_str:
            result = "1_8*" + result
        return result
    def boundVariableNames(self,variableName,converter=make_c_str):
        """
        Used for function arguments and declarations
        """
        result  = ["{0}_n{1}".format(variableName,i+1) for i in range(0,len(self._bounds))]
        result += ["{0}_lb{1}".format(variableName,i+1) for i in range(0,len(self._bounds))]
        return result
    def boundVariableAssignments(self,variableName,converter=make_c_str):
        """
        Used for assigning values to the bound variables. Can in general not be put in
        declaration as rhs may not be constant.
        """
        counts      = self.specifiedCounts(converter)
        lowerBounds = self.specifiedLowerBounds(converter)
        result  = ["{0}_n{1} = {2}".format(variableName,i+1,val) for i,val in enumerate(counts)]
        result += ["{0}_lb{1} = {2}".format(variableName,i+1,val) for i,val in enumerate(lowerBounds)]
        return result
    def indexStr(self,variableName,usePlaceHolders=False,macroArgs=[]):
        """
        Linearises the multivariate index required to access the original Fortran array.
        :param variableName: Name of the array this bound is associated with.
        :type variableName: str
        :return: an expression for the index (as string) or None if no bounds were specified.
        """
        boundsSpecified = not self.hasUnspecifiedBounds()
        bounds          = self.specifiedBounds(make_c_str) if boundsSpecified else self._bounds
        lowerBounds     = self.specifiedLowerBounds(make_c_str) if boundsSpecified else ["1"]*len(self._bounds) # TODO
        if boundsSpecified:
            counts = self.specifiedCounts()
        if len(bounds):
            if not len(macroArgs):
                macroArgs = [chr(ord('a')+i) for i in range(0,len(bounds))]
            assert len(macroArgs) == len(bounds)
            if not boundsSpecified or usePlaceHolders:
                boundArgs      = ["{0}_n{1}".format(variableName,i+1) for i in range(0,len(bounds))]
                lowerBoundArgs = ["{0}_lb{1}".format(variableName,i+1) for i in range(0,len(bounds))]
            else:
                boundArgs      = counts
                lowerBoundArgs = lowerBounds
            stride = ""
            prod = ""
            index = ""
            for i,mvar in enumerate(macroArgs):
                 index += "{0}({1}-({2}))".format(stride,mvar,lowerBoundArgs[i])
                 prod = "{}{}*".format(prod,boundArgs[i])
                 stride = "+{0}".format(prod)
            return index
        else:
            return None
    def indexMacroStr(self,variableName,converter=make_c_str,usePlaceHolders=False):
        """
        Linearizes the multivariate index required to access the original Fortran array.
        :param variableName: Name of the array this bound is associated with.
        :type variableName: str
        :return: an expression for the index (as string) or None if no bounds were specified.
        """
        boundsSpecified = not self.hasUnspecifiedBounds()
        bounds = list(self.specifiedBounds(make_c_str)) if boundsSpecified else self._bounds
        macroArgs = [chr(ord('a')+i) for i in range(0,len(bounds))]
        index     = self.indexStr(variableName,usePlaceHolders)
        if converter is make_f_str:
            return "#undef {0}\n#define {0}({1}) inc_c_ptr({0}, {2})".format(variableName,",".join(macroArgs),index)
        else:
            return "#undef _idx_{0}\n#define _idx_{0}({1}) ({2})".format(variableName,",".join(macroArgs),index)
    def indexMacroFStr(self,variableName,usePlaceHolders=False):
        return self.indexMacroStr(variableName,make_f_str,usePlaceHolders)
    def indexMacroCStr(self,variableName,usePlaceHolders=False):
        return self.indexMacroStr(variableName,make_c_str,usePlaceHolders)
    def c_str(self):
        """
        Returns '[size(n)][size(n-1)]...[size1]' for all n sizes corresponding to specified bounds
        """
        #print("{0}".format(self._bounds))
        #print("{0}".format(self.specifiedCounts(make_c_str)))
        return "".join(["[{0}]".format(make_c_str(el)) for el in self._bounds])
    def f_str(self):
        """
        Returns '(<bound1.f_str()>,<bound2.f_str()>,...,<bound(n).f_str()>)' for all n sizes corresponding to specified bounds
        """
        return "({0})".format(",".join(make_f_str(el) for el in self._bounds)) 

class TTDimensionQualifier(TTNode):
    def _assign_fields(self,tokens):
        self._bounds = tokens[0][0]
    def c_str(self):
        return make_c_str(self._bounds) 
    def f_str(self):
        return "dimension{0}".format(make_f_str(self._bounds))

class TTDeclaredVariable(TTNode):
    """
    Spawned from grammar:
    
    ```python
    declarationVariable = Group( identifier + Optional(LPAR + dimensionList + RPAR,default=[]) + Optional(EQ + ( matrix_arithmetic_expression | complex_arithmetic_expression | arithmetic_expression ), default=None)) # ! emits [*,[*],*]
    ```
    """
    def _assign_fields(self,tokens):
        self._name   = tokens[0][0]
        self._bounds = tokens[0][1]
        self._rhs    = tokens[0][2]
    def name(self,converter=make_c_str):
        return converter(self._name)
    def hasBounds(self):
        return self._bounds != None
    def getBounds(self):
        return self._bounds
    def toStr(self,converter,includeBounds=True,includeRhs=True):
        result = converter(self._name)
        if includeBounds and self.hasBounds():
            #print(converter(self._bounds))
            result += converter(self._bounds)
        if includeRhs and converter(self._rhs) != "":
            result += " = " + converter(self._rhs)      
        return result
    def rhsIsNumber(self):
        try:
           ast.literal_eval(self.rhsCStr())
           return True;
        except:
            return False;
    def rhsCStr(self):
        return"("+ make_f_str(self._rhs)+")"
    def c_str(self,includeBounds=True,includeRhs=True):
        return self.toStr(make_c_str,includeBounds,includeRhs)
    def f_str(self,includeBounds=True,includeRhs=True):
        return self.toStr(make_f_str,includeBounds,includeRhs)

class Attributed():
    def hasStringQualifier(self,name):
        """
        :param name: lower case string qualifier, i.e. no more complex qualifier such as 'dimension' or 'intent'.
        """
        result = False
        for q in self._qualifiers:
            result |= type(q) is str and q.lower() == name.lower()
        return result
    def isDevicePointer(self):
        return self.hasStringQualifier("device") and\
               self.hasStringQualifier("pointer")
    def isPinnedPointer(self):
        return self.hasStringQualifier("pinned") and\
               self.hasStringQualifier("pointer")
    def isAllocatable(self):
        return self.hasStringQualifier("allocatable")
    def hasParameter(self):
        return self.hasStringQualifier("parameter")
    def hasDimension(self):
        return len(find_all(self._qualifiers,TTDimensionQualifier))

class TTDeclaration(TTNode,Attributed):
    """ 
    Spawned from grammar:

    ```python
    declaration = datatype + Optional(COMMA + qualifier_list,default=[]) + COLONS + Group(delimitedList(declarationVariable))   # ! emits *,[*],[*]
    ```
    """
    def _assign_fields(self,tokens):
        #declaration = datatype + Optional(COMMA + attributeList,default=[]) + COLONS + Group(delimitedList(declarationVariable))   # ! emits *,[*],[*]
        self._datatype, self._qualifiers, self._rhs = tokens
        self._ignoreList = []
    def fType(self):
        """
        Fortran basetype of the datatype.
        """
        return make_f_str(self._datatype.type())
    def isDerivedType(self):
        return self._datatype.isDerivedType()
    def kind(self):
        """
        Kind of the datatype.
        :note: Stores the derived type name if the datatype is a derived type.
        """
        return make_f_str(self._datatype.kind())
    def bytesPerElement(self):
        """
        The bytes required to store one element of the datatype of the
        ttdeclaredvariable variables.
        """
        return self._datatype.bytes() 
    def variableNames(self):
        """
        The names of any variables defined by this ttdeclaredvariable.
        Use on the result to check if any array variables are present.
        """
        #for ttdeclaredvariable in self._rhs:
        #     #print(ttdeclaredvariable)
        return [ttdeclaredvariable.name() for ttdeclaredvariable in self._rhs]
    def arrayVariableNames(self):
        """
        The names of any array variables defined by this ttdeclaredvariable.
        Use `len` on the result to check if any array variables are present.
        """
        result = []
        for ttdeclaredvariable in self._rhs:
            if self.hasDimension() or ttdeclaredvariable.hasBounds():
                result.append(ttdeclaredvariable.name())
        return result

    def numElements(self,name):
        """
        :return: number of elements of the (multi-dimensional) array 'name' (per dimension).
        :rtype: list of str
        """
        dimension_qualifier = find_all(self._qualifiers,TTdimension_qualifier)
        if len(dimension_qualifier):
            return dimension_qualifier[0]._bounds.specifiedCounts()
        else:
            for ttdeclaredvariable in self._rhs:
                 if ttdeclaredvariable.name().lower() == name.lower():
                     return ttdeclaredvariable._bounds.specifiedCounts()
        return []
    def arrayBoundVariableNamesFStr(self,name):
        """
        If the ttdeclaredvariable has a `dimension(...)` token,
        derive bound variable names from bounds stated in there.
        Otherwise, check if the variable ttdeclaredvariables has some array brackets
        and derive bound variable names from there.

        :see: TTBounds.boundVariableNames, arrayVariableNames
        :rtype: list
        """
        dimension_qualifier = find_all(self._qualifiers,TTdimension_qualifier)
        if len(dimension_qualifier):
            return dimension_qualifier[0]._bounds.boundVariableNames(name,make_f_str)
        else:
            for ttdeclaredvariable in self._rhs:
                 if ttdeclaredvariable.name().lower() == name.lower():
                     return ttdeclaredvariable._bounds.boundVariableNames(name,make_f_str)
        return []
    def arrayBoundVariableAssignmentsFStr(self,name):
        """
        If the ttdeclaredvariable has a `dimension(...)` token with fixed bounds,
        derive bound variable assignments from bounds stated in there.
        Otherwise, check if the variable ttdeclaredvariables has some array brackets
        and dervice bound variable assignments from there.

        :see: TTBounds.boundVariableNames, arrayVariableNames
        :rtype: list
        """
        dimension_qualifier = find_all(self._qualifiers,TTdimension_qualifier)
        if len(dimension_qualifier):
            return dimension_qualifier[0]._bounds.boundVariableAssignments(name,make_f_str)
        else:
            for ttdeclaredvariable in self._rhs:
                 if ttdeclaredvariable.name().lower() == name.lower():
                     return ttdeclaredvariable._bounds.boundVariableAssignments(name,make_f_str)
        return []
    def arrayVariableIndexStr(self,name):
        """
        If the ttdeclaredvariable has a `dimension(...)` token,
        derive index from bounds stated in there.
        Otherwise, check if the variable ttdeclaredvariables has some array brackets
        and derive macro string from there.

        :see: TTBounds.indexStr(), arrayVariableNames
        """
        dimension_qualifier = find_all(self._qualifiers,TTdimension_qualifier)
        if len(dimension_qualifier):
            return dimension_qualifier[0]._bounds.indexStr(name)
        else:
            for ttdeclaredvariable in self._rhs:
                 if ttdeclaredvariable.name().lower() == name.lower():
                     return ttdeclaredvariable._bounds.indexStr(name)
        return None
    def arrayVariableIndexMacroStr(self,name,converter=make_c_str,usePlaceHolders=False):
        """
        If the ttdeclaredvariable has a `dimension(...)` token,
        derive index from bounds stated in there.
        Otherwise, use

        :see: TTBounds.indexStr(), arrayVariableNames
        """
        dimension_qualifier = find_all(self._qualifiers,TTdimension_qualifier)
        if len(dimension_qualifier):
            return dimension_qualifier[0]._bounds.indexMacroStr(name,converter,usePlaceHolders)
        else:
            for ttdeclaredvariable in self._rhs:
                 if ttdeclaredvariable.name().lower() == name.lower():
                     #print(">"+str(ttdeclaredvariable._bounds))
                     return ttdeclaredvariable._bounds.indexMacroStr(name,converter,usePlaceHolders)
        return None
    def arrayVariableIndexMacroFStr(self,name,usePlaceHolders=False):
        return self.arrayVariableIndexMacroStr(name,make_f_str,usePlaceHolders)
    def arrayVariableIndexMacroCStr(self,name,usePlaceHolders=False):
        return self.arrayVariableIndexMacroStr(name,make_c_str,usePlaceHolders)
    def rhsCStr(self,name):
        """
        :return: C expression of the right-hand side of the variable with name `name`. Returns empty string in case there is no right-hand side.
        :rtype: str
        :param name: identi
        """
        result = ""
        for ttdeclaredvariable in self._rhs:
            if ttdeclaredvariable.name().lower() == name.lower():
                result = make_c_str(ttdeclaredvariable._rhs)
        return result
    def f_str(self,extraIgnoreList=[],includeBounds=True,includeRhs=True):
        """
        The ignore list can be used to filter out some
        variables
        """
        ignoreList = map(str.lower, self._ignoreList + extraIgnoreList)
        qualifiersStr = ", " if len(self._qualifiers) else ""
        qualifiersStr += ", ".join([make_f_str(q) for q in self._qualifiers])
        result = "{0}{1} :: ".format(make_f_str(self._datatype),qualifiersStr)
        ignoredVars = 0
        for ttdeclaredvariable in self._rhs:
            if not ttdeclaredvariable.name(make_f_str).lower() in ignoreList:
                ignoredVars += 1
                result += "{0},".format(ttdeclaredvariable.f_str(includeBounds,includeRhs))
        if ignoredVars == len(self._rhs):
            return ""
        else:
            return result.rstrip(",")
    def c_str(self,extraIgnoreList=[],isFunctionArgument=False,includeBounds=True,includeRhs=True):
        """
        The ignore list can be used to filter out some
        variables, e._g. if these are parameters of a subroutine
        that we want to convert.
        """
        ignoreList      = [make_c_str(var) for var in (self._ignoreList + extraIgnoreList)]
        result          = ""
        comment         = ""
        dimensionBounds = ""
        ignoredVars     = 0
        if len(self._qualifiers):
           dimension_qualifier = find_all(self._qualifiers,TTdimension_qualifier)
           if len(dimension_qualifier):
                dimensionBounds = make_c_str(dimension_qualifier[0])
           comment = " /* Fortran qualifiers: {0} */".format(",".join([make_f_str(el) for el in self._qualifiers]))
        for ttdeclaredvariable in self._rhs:
            if not ttdeclaredvariable.name(make_c_str) in ignoreList: 
                ignoredVars += 1
                if isFunctionArgument:
                    result += "{0} {1},".format(make_c_str(self._datatype),ttdeclaredvariable.c_str(includeBounds,includeRhs),comment)
                else:
                    datatype = make_c_str(self._datatype)
                    if self.hasStringQualifier("shared"):
                        datatype = "__shared__ " + datatype
                    result += "{0} {1}{2};{3}\n".format(datatype,ttdeclaredvariable.c_str(includeBounds,includeRhs),dimensionBounds,comment) 
        if ignoredVars < len(self._rhs):
            if isFunctionArgument:
                return result
            else:
                return result.rstrip(",")
        else:
            return ""

class TTStatement(TTNode):
    """
    Mainly used for searching expressions and replacing them in the translator AST.
    One example is converting to colon operations to do loops.
    """
    def _assign_fields(self,tokens):
        self._statement = tokens
    def c_str(self):
        return make_c_str(self._statement)
    def f_str(self):
        return make_f_str(self._statement)

class TTSingleLineIf(TTNode):
    def _assign_fields(self,tokens):
        self._condition, self.body, self._semicolon= tokens
    def c_str(self):
        bodyContent = flattenBody(self.body) 
        return "if ({0}) {{\n  {1}\n}}".format(make_c_str(self._condition), bodyContent)
    def f_str(self):
        return "if ({0}) {1}{2}".format(make_f_str(self._condition), make_f_str(self.body), self._semicolon)
    def multilineIfFStr(self):
        return "if ({0}) then\n{1}\nendif\n".format(make_f_str(self._condition).strip("\n"), make_f_str(self.body).strip())
    def __str__(self):
        """
        Makes it possible to use it with pyparsing's transformString method
        """
        return self.multilineIfFStr()

class TTIfElseBlock(TTContainer):
    pass
class TTIfElseIf(TTContainer):
    def _assign_fields(self,tokens):
        self._else, self.condition = tokens
    def c_str(self):
        bodyContent = flattenBody(self.body) 
        return "{0}{1}if ({2}) {{\n{3}\n{0}}}".format(\
            self.indent,self._else,make_c_str(condition),bodyContent) 
class TTElse(TTContainer):
    def c_str(self):
        bodyContent = flattenBody(self.body) 
        return "{0}else {{\n{1}\n{0}}}".format(\
            self.indent,bodyContent)

class TTWhile(TTContainer):
    def _assign_fields(self,tokens):
        self._condition, self.body = tokens
    def c_str(self):    
        bodyContent = flattenBody(self.body)
        conditionContent = make_c_str(self._condition)
        c_str = "while ({0}) {{\n  {1}\n}}".format(conditionContent,bodyContent) 
        return c_str

class TTProcedureBody(TTContainer):
    def _assign_fields(self,tokens):
        self.body    = tokens[0]
        self.scope  = []
        self.ignoredVars = []
        self.resultName  = ""
    def c_str(self):
        """
        :return: body of a procedure as C/C++ code.
        
        When converting declarations, all declared variables with a name in the
        _ignoredVars member are ignored. All declared variables that store a precision
        kind are ignored too.

        Moreover, non-empty result names will be propagated to
        all return statements.
        """
        # 0. Clarify types of function calls / tensor access that are not 
        # members of a struct
        if len(self.scope):
            for expr in find_all_matching(self.body,filterExpr=lambda x: isinstance(x,IValue)):
                 if type(expr._value) is TTFunctionCallOrTensorAccess:
                     _, discovered = scoper.searchScopeForVariable(self.scope,createIndexSearchTagForVariable(expr.name()))
                     if discovered:
                         expr._value._isTensorAccess = True3
        # 1. Remove function argument definitions and precision definitions
        # from body before converting body to C code.

        # TODO Potentially simpler/more transparent to generate local variables from index and ignore in code.

        declarations = find_all(self.body,TTDeclaration)
        for ttdeclaration in declarations:
            ttdeclaration._ignoreList = list(self.ignoredVars)
            for name in ttdeclaration.variableNames():
                if "selected_real_kind" in ttdeclaration.rhsCStr(name).lower():
                    ttdeclaration._ignoreList.append(name)
        # 2. Propagate result variable name to return statements
        if len(self.resultName):
            for expr in find_all(self.body,TTReturn):
                 expr._resultName = resultName  
        cBody = make_c_str(self.body)
        if len(self.resultName):
             cBody += "\nreturn "+resultName+";"
        return postprocessCSnippet(cBody)

## Link actions
#print_statement.setParseAction(TTCommentedOut)
comment.setParseAction(TTCommentedOut)

logical.setParseAction(TTLogical)
integer.setParseAction(TTNumber)
number.setParseAction(TTNumber)
l_arith_operator.setParseAction(TTOperator)
#r_arith_operator.setParseAction(TTOperator)
conditionOp.setParseAction(TTOperator)
identifier.setParseAction(TTIdentifier)
rvalue.setParseAction(TTRValue)
lvalue.setParseAction(TTLValue)
simple_derived_type_member.setParseAction(TTDerivedTypeMember)
derived_type_elem.setParseAction(TTDerivedTypeMember)
func_call.setParseAction(TTFunctionCallOrTensorAccess)

convert_to_extract_real.setParseAction(TTConvertToExtractReal)
convert_to_double.setParseAction(TTConvertToDouble)
convert_to_complex.setParseAction(TTConvertToComplex)
convert_to_double_complex.setParseAction(TTConvertToDoubleComplex)
extract_imag.setParseAction(TTExtractImag)
conjugate.setParseAction(TTConjugate)
conjugate_double_complex.setParseAction(TTConjugate) # same action

size_inquiry.setParseAction(TTSizeInquiry)
lbound_inquiry.setParseAction(TTLboundInquiry)
ubound_inquiry.setParseAction(TTUboundInquiry)

datatype_comment.setParseAction(TTDatatype_Comment)
datatype_convert.setParseAction(TTDatatype_Convert)

matrix_range.setParseAction(TTMatrixRange)
bounds.setParseAction(TTBounds)
matrix_ranges.setParseAction(TTBounds)
dimension_qualifier.setParseAction(TTDimensionQualifier)
intent_qualifier.setParseAction(TTIntentQualifier)

declared_variable.setParseAction(TTDeclaredVariable)
arithmetic_expression.setParseAction(TTArithmeticExpression)
arithmetic_logical_expression.setParseAction(TTArithmeticExpression)
complex_arithmetic_expression.setParseAction(TTComplexArithmeticExpression)
power_value1.setParseAction(TTRValue)
power.setParseAction(TTPower)
assignment.setParseAction(TTAssignment)
matrix_assignment.setParseAction(TTMatrixAssignment)
complex_assignment.setParseAction(TTComplexAssignment)

# statements
return_statement.setParseAction(TTReturn)
fortran_subroutine_call.setParseAction(TTSubroutineCall)
fortran_declaration.setParseAction(TTDeclaration)