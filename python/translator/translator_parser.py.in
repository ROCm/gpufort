def __preprocess_fortran_statement(statement):
    """Performs the following operations:
    - replace power (**) expression by func call expression
    # TODO handle directly via arithmetic expression grammar
    """
    result = statement
    if "**" in result1:
        result = power.transformString(result)
    return result

def __parse_fortran_code(statements,scope=[]):
    """
    :param list for
    
    requirements:
    
    - input is statements:
      - all lower case
      - & multiline statement/directives have been converted to single-line statement
      - single-line multi-statement has been converted to multiple single statements
      - lines may contain comments and directives appended to actual code
        - comments must be preserved
  
    behavior:

    - recursively?
    - treat do, do while, if, elseif, else, select and end statements explicitly
    - parse other statements
    - consider comments
    - every call returns a subtree
    - if
    """
    global LOG_PREFIX

    # tree node flagging
    def is_ignored_statement_(tokens):
        """All statements beginning with the tokens below are ignored.
        """
        return tokens[0] in ["write","print","character","use","implicit"]
    def is_blank_line_(statement):
        return not len(statement.strip())
    def is_comment_(tokens,statement):
        cond1 = tokens[0]=="!"
        cond2 = statement[0] in ["c","*"] and\
                statement[1]!="$"
        return cond1 or cond2
    def is_cpp_directive_(statement):
        return statement[0] == "#" 
    def is_fortran_directive_(tokens,statement):
        return tokens[0] in ["!$","*$","c$"]
    def is_ignored_fortran_directive_(tokens,statement):
        return tokens[1:2+1] == ["acc","end"] and\
               tokens[3] in ["kernels","parallel","loop"]
    def is_fortran_offload_region_directive_(tokens):
        return\
            tokens[1:2+1] == ["acc","parallel"] or\
            tokens[1:2+1] == ["acc","kernels"]
    def is_fortran_offload_region_plus_loop_directive_(tokens):
        return\
            tokens[1:3+1] == ["cuf","kernel","do"]  or\
            tokens[1:3+1] == ["acc","parallel","loop"] or\
            tokens[1:3+1] == ["acc","kernels","loop"] or\
            tokens[1:3+1] == ["acc","kernels","loop"]
    def is_fortran_offload_loop_directive_(tokens):
        return\
            tokens[1:2+1] == ["acc","loop"]
    def is_declaration_(tokens):
        return\
            tokens[0] in ["type","integer","real","complex","logical","character"] or\
            tokens[0:1+1] == ["double","precision"]
        return cond1 or cond2
    def is_assignment_(tokens):
        #assert not is_declaration_(tokens)
        #assert not is_do_(tokens)
        return "=" in tokens
    def is_pointer_assignment_(tokens):
        #assert not is_ignored_statement_(tokens)
        #assert not is_declaration_(tokens)
        return "=>" in tokens
    def is_subroutine_call_(tokens):
        return tokens[0] == "call" and tokens[1].isidentifier()
    def is_select_case_(tokens):
        cond1 = tokens[0:1+1] == ["select","case"]
        cond2 = tokens[0].isidentifier() and tokens[1] == ":" and\
                tokens[2:3+1] == ["select","case"]
        return cond1 or cond2
    def is_case_(tokens):
        return tokens[0:1+1] == ["case","("]
    def is_case_default_(tokens):
        return tokens[0:1+1] == ["case","default"]
    def is_if_then_(tokens):
        """:note: we assume single-line if have been
        transformed in preprocessing step."""
        return tokens[0:1+1] == ["if","("]
    def is_if_then_(tokens):
        """:note: we assume single-line if have been
        transformed in preprocessing step."""
        return tokens[0:1+1] == ["if","("]
    def is_else_if_then_(tokens):
        return tokens[0:2+1] == ["else","if","("]
    def is_else_(tokens):
        #assert not is_else_if_then_(tokens)
        return tokens[0] == "else"
    def is_do_while_(tokens):
        cond1 = tokens_p[0:1+1] == ["do","while"]
        cond2 = tokens_p[0].isidentifier() and tokens_p[1] == ":" and\
                tokens_p[2:3+1] == ["do","while"]
        return cond1 or cond2
    def is_do_(tokens):
        cond1 = tokens[0] == "do"
        cond2 = tokens[0].isidentifier() and tokens[1] == ":" and\
                tokens[2] == "do"
        return cond1 or cond2
    def is_end_(tokens,kinds=[]):
        cond1 = tokens[0] == "end"
        cond2 = not len(kinds) or tokens[1] in kinds
        return cond1 and cond2

    # tree creation ops
    def append_(node):
        nonlocal curr
        node.parent = curr
        curr.body.append(node)
    def descend_(node,kind):
        nonlocal curr
        nonlocal stmt
        append_(node)
        curr = node
        utils.logging.logDebug(LOG_PREFIX,"__parse_fortran_code.append_","enter {} in statement '{}'".format(kind,stmt))
    def ascend_(kind):
        nonlocal curr
        nonlocal stmt
        curr = node.parent
        utils.logging.logDebug(LOG_PREFIX,"__parse_fortran_code.append_","leave {} in statement '{}'".format(kind,stmt))
    
    # error handling
    def error_(expr,exception=None):
        nonlocal stmt1
        utils.logging.logError(LOG_PREFIX,"__parse_fortran_code","failed to parse {} expression '{}'".format(expr,stmt))
        if exception != None:
            utils.logging.logDebug(LOG_PREFIX,"__parse_fortran_code",str(exception))
        sys.exit(2) # TODO error code
    def warn_(expr,exception=None):
        nonlocal stmt1
        utils.logging.logWarn(LOG_PREFIX,"__parse_fortran_code","ignored {} expression '{}'".format(expr,stmt))
        if exception != None:
            utils.logging.logDebug(LOG_PREFIX,"__parse_fortran_code",str(exception))
        sys.exit(2) # TODO error code
    def ignore_(expr):
        nonlocal stmt1
        utils.logging.logDebug3(LOG_PREFIX,"__parse_fortran_code","ignored {} '{}'".format(expr,stmt))

    # parser loop
    ttree               = TTContainer()
    curr                = ttree
    curr_offload_region = None 
    curr_offload_loop   = None
    for stmt1 in statements:
        # TODO move somewhere else
        # replace power (**) expression by func call expression
        stmt    = __preprocess_fortran_statement(stmt1)
        tokens  = utils.pyparsingutils.tokenize(stmt.lower(),padded_size=6)
        # strip of ! from tokens.index("!")
        if "!" in stmt:
            stmt_no_comment = stmt.split("!")[0]
        else:
            stmt_no_comment = stmt
        utils.logging.logDebug2(LOG_PREFIX,"__parse_fortran_code","process statement '{}' (preprocessed: '{}')".format(stmt1,stmt))
        if len(tokens):
            utils.logging.logDebug3(LOG_PREFIX,"__parse_fortran_code","tokens=['{}']".format("','".join(tokens)))
        # tree construction 
        if is_ignored_statement_(tokens):
            ignore_("statement")
        elif is_comment_(tokens,stmt):
            comment = re.split("!|c|\*",stmt,1,re.IGNORECASE)[1]
            append_("// "+comment+"\n","comment")
        elif is_blank_line_(stmt):
            append_(stmt,"blank line")
        elif is_fortran_directive_(tokens,stmt):
            try:
                if is_ignored_fortran_directive_(tokens):
                    ignore_("directive")
                elif is_fortran_offload_region_directive_(tokens):
                    parse_result = parallel_region_start.parseString(stmt,parseAll=True)
                    curr_offload_region = parse_result[0]
                elif is_fortran_offload_region_plus_loop_directive_(tokens):
                    parse_result = loop_annotation.parseString(stmt,parseAll=True)
                    curr_offload_region = parse_result[0]
                    curr_offload_loop   = parse_result[0] 
                elif is_fortran_offload_loop_directive_(tokens):
                    parse_result = loop_annotation.parseString(stmt,parseAll=True)
                    curr_offload_loop = parse_result[0] 
                else:
                    warn_("directive",e)
            except Exception as e:
                error_("directive",e)
                pass
        # do/while
        elif is_do_while_(tokens):
            try: 
                parse_result = fortan_do_while.parseString(stmt_no_comment,parseAll=True)
                descend_(TTWhileLoop(stmt,0,parse_result.asList()+[[]]),"do-while loop")
            except Exception as e:
                error_("do-while loop",e)
        elif is_do_(tokens):
            try: 
                parse_result   = fortran_do_loop.parseString(stmt_no_comment,parseAll=True)
                do_loop_tokens = [ curr_offload_loop ] + parse_result.asList() + [[]]
                do_loop = TTDoLoop(stmt,0,do_loop_tokens)
                if curr_offload_region != None:
                    append_(TTLoopKernel(stmt_no_comment,"", [curr_offload_region, do_loop]))
                    curr_offload_region = None
                descend_(do_loop,"do loop")
                curr_offload_loop   = None
            except Exception as e:
                error_("do loop",e)
        # if-then-else
        elif is_if_then_(tokens):
            try: 
                descend_(TTIfElseBlock(),"if block")
                parse_result = fortran_if_else_if.parseString(stmt_no_comment,parseAll=True)
                descend_(TTIfElseIf(stmt_no_comment,0,parse_result.asList()+[[]]),"if branch")
            except Exception as e:
                error_("if",e)
        elif is_else_if_then_(tokens):
            assert type(curr) is TTIfElseIf
            ascend_()
            try: 
                parse_result = fortran_if_else_if.parseString(stmt_no_comment,parseAll=True)
                descend_(TTIfElseIf(stmt_no_comment,0,parse_result.asList()+[[]]),"else-if branch")
            except Exception as e:
                error_("else-if",e)
        elif is_else_(tokens):
            assert type(curr) is TTIfElseIf
            ascend_()
            descend_(TTElse(stmt_no_comment,0,[]),"else branch")
        # select-case
        elif is_select_case_(tokens):
            try: 
                parse_result = fortran_select_case.parseString(stmt_no_comment,parseAll=True)
                descend_(TTSelectCase(stmt_no_comment,0,parse_result.asList()+[[]]),"select-case")
            except Exception as e:
                error_("select-case",e)
        elif is_case_(tokens):
            if type(curr) is TTCase:
                ascend_()
            try: 
                parse_result = fortran_case.parseString(stmt_no_comment,parseAll=True)
                descend_(TTCase(stmt_no_comment,0,parse_result.asList()+[[]]),"case")
            except Exception as e:
                error_("else-if",e)
        elif is_case_default_(tokens):
            if type(curr) is TTCase:
                ascend_()
            descend_(TTCase(stmt_no_comment,0,[[]]),"case default")
        # end
        elif is_end_(tokens,["do","if","select"]):
            ascend_()
        # decl
        elif is_declaration_(tokens): 
            parse_result = fortran_declaration.parseString(stmt_no_comment,parseAll=True)
            append_(parse_result[0],"declaration")
        # assignment
        elif is_pointer_assignment_(tokens):
            error_("pointer assignment")
        # assignment
        elif is_assignment_(tokens):
            parse_result = fortran_assignment.parseString(stmt_no_comment,parseAll=True)
            append(parse_result[0],"assignment")
        elif is_subroutine_call_(tokens):
            parse_result = fortran_subroutine_call.parseString(stmt_no_comment,parseAll=True)
            append_(parse_result[0],"subroutine call")
        else:
            error_("unknown and not ignored")
    return ttree
